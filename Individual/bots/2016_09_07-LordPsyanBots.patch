From 800b2afb13a782ce223bb7c0ad74ac6a0d2e096a Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Wed, 7 Sep 2016 12:12:14 -0500
Subject: [PATCH] 2016-09-07_LordPsyanBots

---
 .gitignore                                         |    2 +
 cmake/options.cmake                                |    1 +
 cmake/options.cmake.orig                           |   53 +
 sql/ai_playerbot_guild_names.sql                   |  652 ++++
 sql/characters_ai_playerbot.sql                    |   34 +
 sql/characters_ai_playerbot_custom_strategy.sql    |   22 +
 sql/characters_ai_playerbot_speech.sql             |  241 ++
 sql/characters_auctionhousebot.sql                 |   37 +
 src/CMakeLists.txt                                 |    5 +
 src/common/Configuration/Config.h                  |    2 +
 src/plugins/CMakeLists.txt                         |  204 ++
 src/plugins/ahbot/AhBot.cpp                        |  984 ++++++
 src/plugins/ahbot/AhBot.h                          |   93 +
 src/plugins/ahbot/AhBotConfig.cpp                  |   59 +
 src/plugins/ahbot/AhBotConfig.h                    |   93 +
 src/plugins/ahbot/Category.cpp                     |   76 +
 src/plugins/ahbot/Category.h                       |  354 ++
 src/plugins/ahbot/ConsumableCategory.cpp           |    5 +
 src/plugins/ahbot/ConsumableCategory.h             |   86 +
 src/plugins/ahbot/ItemBag.cpp                      |  184 ++
 src/plugins/ahbot/ItemBag.h                        |   82 +
 src/plugins/ahbot/PricingStrategy.cpp              |  220 ++
 src/plugins/ahbot/PricingStrategy.h                |   55 +
 src/plugins/ahbot/TradeCategory.cpp                |    4 +
 src/plugins/ahbot/TradeCategory.h                  |  183 ++
 src/plugins/ahbot/ahbot.conf.dist.in               |  209 ++
 src/plugins/pch/pch.cpp                            |    1 +
 src/plugins/pch/pch.h                              |   10 +
 src/plugins/pchdef.h                               |    4 +
 src/plugins/playerbot/AiFactory.cpp                |  229 ++
 src/plugins/playerbot/AiFactory.h                  |   20 +
 src/plugins/playerbot/ChatFilter.cpp               |  257 ++
 src/plugins/playerbot/ChatFilter.h                 |   24 +
 src/plugins/playerbot/ChatHelper.cpp               |  450 +++
 src/plugins/playerbot/ChatHelper.h                 |   52 +
 src/plugins/playerbot/FleeManager.cpp              |  174 +
 src/plugins/playerbot/FleeManager.h                |   82 +
 src/plugins/playerbot/GuildTaskMgr.cpp             |  726 ++++
 src/plugins/playerbot/GuildTaskMgr.h               |   45 +
 src/plugins/playerbot/Helpers.cpp                  |   90 +
 src/plugins/playerbot/LazyCalculatedValue.h        |   42 +
 src/plugins/playerbot/LootObjectStack.cpp          |  234 ++
 src/plugins/playerbot/LootObjectStack.h            |   76 +
 src/plugins/playerbot/PlayerbotAI.cpp              | 1424 ++++++++
 src/plugins/playerbot/PlayerbotAI.h                |  187 ++
 src/plugins/playerbot/PlayerbotAIAware.h           |   13 +
 src/plugins/playerbot/PlayerbotAIBase.cpp          |   51 +
 src/plugins/playerbot/PlayerbotAIBase.h            |   24 +
 src/plugins/playerbot/PlayerbotAIConfig.cpp        |  230 ++
 src/plugins/playerbot/PlayerbotAIConfig.h          |   82 +
 src/plugins/playerbot/PlayerbotCommandServer.cpp   |   94 +
 src/plugins/playerbot/PlayerbotCommandServer.h     |   26 +
 src/plugins/playerbot/PlayerbotFactory.cpp         | 1737 ++++++++++
 src/plugins/playerbot/PlayerbotFactory.h           |   68 +
 src/plugins/playerbot/PlayerbotMgr.cpp             |  472 +++
 src/plugins/playerbot/PlayerbotMgr.h               |   69 +
 src/plugins/playerbot/PlayerbotSecurity.cpp        |  187 ++
 src/plugins/playerbot/PlayerbotSecurity.h          |   42 +
 src/plugins/playerbot/RandomItemMgr.cpp            |  154 +
 src/plugins/playerbot/RandomItemMgr.h              |   50 +
 src/plugins/playerbot/RandomPlayerbotFactory.cpp   |  382 +++
 src/plugins/playerbot/RandomPlayerbotFactory.h     |   35 +
 src/plugins/playerbot/RandomPlayerbotMgr.cpp       |  912 ++++++
 src/plugins/playerbot/RandomPlayerbotMgr.h         |   74 +
 src/plugins/playerbot/aiplayerbot.conf.dist.in     |  183 ++
 src/plugins/playerbot/playerbot.h                  |   31 +
 src/plugins/playerbot/playerbotDefs.h              |    2 +
 src/plugins/playerbot/strategy/Action.cpp          |   93 +
 src/plugins/playerbot/strategy/Action.h            |  138 +
 src/plugins/playerbot/strategy/ActionBasket.cpp    |    4 +
 src/plugins/playerbot/strategy/ActionBasket.h      |    5 +
 src/plugins/playerbot/strategy/AiObject.cpp        |   16 +
 src/plugins/playerbot/strategy/AiObject.h          |   33 +
 src/plugins/playerbot/strategy/AiObjectContext.cpp |   48 +
 src/plugins/playerbot/strategy/AiObjectContext.h   |   81 +
 src/plugins/playerbot/strategy/CustomStrategy.cpp  |   86 +
 src/plugins/playerbot/strategy/CustomStrategy.h    |   21 +
 src/plugins/playerbot/strategy/Engine.cpp          |  546 ++++
 src/plugins/playerbot/strategy/Engine.h            |  123 +
 src/plugins/playerbot/strategy/Event.cpp           |   20 +
 src/plugins/playerbot/strategy/Event.h             |   36 +
 .../playerbot/strategy/ExternalEventHelper.h       |   69 +
 src/plugins/playerbot/strategy/ItemVisitors.h      |  258 ++
 src/plugins/playerbot/strategy/Multiplier.cpp      |    5 +
 src/plugins/playerbot/strategy/Multiplier.h        |   16 +
 .../playerbot/strategy/NamedObjectContext.h        |  249 ++
 .../playerbot/strategy/PassiveMultiplier.cpp       |   47 +
 src/plugins/playerbot/strategy/PassiveMultiplier.h |   20 +
 src/plugins/playerbot/strategy/Queue.cpp           |   81 +
 src/plugins/playerbot/strategy/Queue.h             |   21 +
 src/plugins/playerbot/strategy/Strategy.cpp        |  117 +
 src/plugins/playerbot/strategy/Strategy.h          |   55 +
 src/plugins/playerbot/strategy/StrategyContext.h   |  149 +
 src/plugins/playerbot/strategy/Trigger.cpp         |   27 +
 src/plugins/playerbot/strategy/Trigger.h           |   84 +
 src/plugins/playerbot/strategy/Value.cpp           |    5 +
 src/plugins/playerbot/strategy/Value.h             |  177 +
 .../playerbot/strategy/actions/AcceptDuelAction.h  |   31 +
 .../strategy/actions/AcceptInvitationAction.h      |   47 +
 .../strategy/actions/AcceptQuestAction.cpp         |  102 +
 .../playerbot/strategy/actions/AcceptQuestAction.h |   27 +
 .../strategy/actions/AcceptResurrectAction.h       |   31 +
 .../playerbot/strategy/actions/ActionContext.h     |  113 +
 .../playerbot/strategy/actions/AddLootAction.cpp   |   62 +
 .../playerbot/strategy/actions/AddLootAction.h     |   32 +
 .../strategy/actions/AreaTriggerAction.cpp         |   73 +
 .../playerbot/strategy/actions/AreaTriggerAction.h |   23 +
 .../playerbot/strategy/actions/AttackAction.cpp    |  104 +
 .../playerbot/strategy/actions/AttackAction.h      |   38 +
 .../playerbot/strategy/actions/BankAction.cpp      |  168 +
 .../playerbot/strategy/actions/BankAction.h        |   21 +
 .../playerbot/strategy/actions/BuffAction.cpp      |  118 +
 .../playerbot/strategy/actions/BuffAction.h        |   17 +
 .../playerbot/strategy/actions/BuyAction.cpp       |   53 +
 src/plugins/playerbot/strategy/actions/BuyAction.h |   19 +
 .../strategy/actions/CastCustomSpellAction.cpp     |   48 +
 .../strategy/actions/CastCustomSpellAction.h       |   14 +
 .../strategy/actions/ChangeChatAction.cpp          |   26 +
 .../playerbot/strategy/actions/ChangeChatAction.h  |   14 +
 .../strategy/actions/ChangeStrategyAction.cpp      |   38 +
 .../strategy/actions/ChangeStrategyAction.h        |   30 +
 .../strategy/actions/ChangeTalentsAction.cpp       |   37 +
 .../strategy/actions/ChangeTalentsAction.h         |   16 +
 .../playerbot/strategy/actions/ChatActionContext.h |  184 ++
 .../strategy/actions/ChatShortcutActions.cpp       |  108 +
 .../strategy/actions/ChatShortcutActions.h         |   57 +
 .../playerbot/strategy/actions/CheckMailAction.cpp |   66 +
 .../playerbot/strategy/actions/CheckMailAction.h   |   17 +
 .../strategy/actions/CheckMountStateAction.cpp     |   79 +
 .../strategy/actions/CheckMountStateAction.h       |   19 +
 .../strategy/actions/ChooseTargetActions.h         |   80 +
 .../strategy/actions/DestroyItemAction.cpp         |   34 +
 .../playerbot/strategy/actions/DestroyItemAction.h |   17 +
 .../playerbot/strategy/actions/DropQuestAction.cpp |   47 +
 .../playerbot/strategy/actions/DropQuestAction.h   |   13 +
 .../playerbot/strategy/actions/EmoteAction.cpp     |  366 +++
 .../playerbot/strategy/actions/EmoteAction.h       |   20 +
 .../playerbot/strategy/actions/EquipAction.cpp     |  105 +
 .../playerbot/strategy/actions/EquipAction.h       |   21 +
 .../playerbot/strategy/actions/FollowActions.cpp   |   49 +
 .../playerbot/strategy/actions/FollowActions.h     |   14 +
 .../playerbot/strategy/actions/GenericActions.cpp  |    5 +
 .../playerbot/strategy/actions/GenericActions.h    |   19 +
 .../strategy/actions/GenericSpellActions.cpp       |   55 +
 .../strategy/actions/GenericSpellActions.h         |  271 ++
 .../strategy/actions/GossipHelloAction.cpp         |   71 +
 .../playerbot/strategy/actions/GossipHelloAction.h |   13 +
 .../strategy/actions/GuildAcceptAction.cpp         |   42 +
 .../playerbot/strategy/actions/GuildAcceptAction.h |   14 +
 .../playerbot/strategy/actions/GuildBankAction.cpp |   61 +
 .../playerbot/strategy/actions/GuildBankAction.h   |   18 +
 .../playerbot/strategy/actions/HelpAction.cpp      |   54 +
 .../playerbot/strategy/actions/HelpAction.h        |   22 +
 .../playerbot/strategy/actions/InventoryAction.cpp |  288 ++
 .../playerbot/strategy/actions/InventoryAction.h   |   24 +
 .../actions/InventoryChangeFailureAction.cpp       |   55 +
 .../actions/InventoryChangeFailureAction.h         |   12 +
 .../strategy/actions/InviteToGroupAction.h         |   28 +
 .../playerbot/strategy/actions/LeaveGroupAction.h  |   79 +
 .../playerbot/strategy/actions/LfgActions.cpp      |  250 ++
 .../playerbot/strategy/actions/LfgActions.h        |   48 +
 .../strategy/actions/ListQuestsActions.cpp         |   71 +
 .../playerbot/strategy/actions/ListQuestsActions.h |   25 +
 .../strategy/actions/ListSpellsAction.cpp          |   65 +
 .../playerbot/strategy/actions/ListSpellsAction.h  |   16 +
 .../playerbot/strategy/actions/LogLevelAction.cpp  |   43 +
 .../playerbot/strategy/actions/LogLevelAction.h    |   17 +
 .../playerbot/strategy/actions/LootAction.cpp      |  338 ++
 .../playerbot/strategy/actions/LootAction.h        |   39 +
 .../playerbot/strategy/actions/LootRollAction.cpp  |   66 +
 .../playerbot/strategy/actions/LootRollAction.h    |   15 +
 .../strategy/actions/LootStrategyAction.cpp        |  100 +
 .../strategy/actions/LootStrategyAction.h          |   19 +
 .../playerbot/strategy/actions/MovementActions.cpp |  376 +++
 .../playerbot/strategy/actions/MovementActions.h   |   92 +
 .../strategy/actions/NonCombatActions.cpp          |    6 +
 .../playerbot/strategy/actions/NonCombatActions.h  |   47 +
 .../actions/PassLeadershipToMasterAction.h         |   26 +
 .../playerbot/strategy/actions/PositionAction.cpp  |   38 +
 .../playerbot/strategy/actions/PositionAction.h    |   37 +
 .../strategy/actions/QueryItemUsageAction.cpp      |  172 +
 .../strategy/actions/QueryItemUsageAction.h        |   24 +
 .../strategy/actions/QueryQuestAction.cpp          |   89 +
 .../playerbot/strategy/actions/QueryQuestAction.h  |   16 +
 .../playerbot/strategy/actions/QuestAction.cpp     |  137 +
 .../playerbot/strategy/actions/QuestAction.h       |   33 +
 .../strategy/actions/ReachTargetActions.h          |   57 +
 .../strategy/actions/ReadyCheckAction.cpp          |   84 +
 .../playerbot/strategy/actions/ReadyCheckAction.h  |   26 +
 .../strategy/actions/ReleaseSpiritAction.h         |   29 +
 .../strategy/actions/RememberTaxiAction.cpp        |   46 +
 .../strategy/actions/RememberTaxiAction.h          |   13 +
 .../playerbot/strategy/actions/RepairAllAction.cpp |   30 +
 .../playerbot/strategy/actions/RepairAllAction.h   |   13 +
 .../playerbot/strategy/actions/ResetAiAction.cpp   |   12 +
 .../playerbot/strategy/actions/ResetAiAction.h     |   14 +
 .../strategy/actions/ReviveFromCorpseAction.cpp    |   51 +
 .../strategy/actions/ReviveFromCorpseAction.h      |   21 +
 .../playerbot/strategy/actions/RewardAction.cpp    |   75 +
 .../playerbot/strategy/actions/RewardAction.h      |   17 +
 src/plugins/playerbot/strategy/actions/RtiAction.h |   44 +
 .../playerbot/strategy/actions/SaveManaAction.cpp  |   73 +
 .../playerbot/strategy/actions/SaveManaAction.h    |   20 +
 .../playerbot/strategy/actions/SayAction.cpp       |  102 +
 src/plugins/playerbot/strategy/actions/SayAction.h |   20 +
 .../strategy/actions/SecurityCheckAction.cpp       |   31 +
 .../strategy/actions/SecurityCheckAction.h         |   14 +
 .../playerbot/strategy/actions/SellAction.cpp      |   95 +
 .../playerbot/strategy/actions/SellAction.h        |   18 +
 .../playerbot/strategy/actions/SetHomeAction.cpp   |   42 +
 .../playerbot/strategy/actions/SetHomeAction.h     |   12 +
 .../playerbot/strategy/actions/StatsAction.cpp     |  145 +
 .../playerbot/strategy/actions/StatsAction.h       |   22 +
 .../playerbot/strategy/actions/StayActions.cpp     |   34 +
 .../playerbot/strategy/actions/StayActions.h       |   23 +
 .../strategy/actions/SuggestWhatToDoAction.cpp     |  255 ++
 .../strategy/actions/SuggestWhatToDoAction.h       |   34 +
 .../strategy/actions/TalkToQuestGiverAction.cpp    |   90 +
 .../strategy/actions/TalkToQuestGiverAction.h      |   22 +
 .../playerbot/strategy/actions/TaxiAction.cpp      |   51 +
 .../playerbot/strategy/actions/TaxiAction.h        |   13 +
 .../playerbot/strategy/actions/TeleportAction.cpp  |   54 +
 .../playerbot/strategy/actions/TeleportAction.h    |   16 +
 .../strategy/actions/TellCastFailedAction.cpp      |   75 +
 .../strategy/actions/TellCastFailedAction.h        |   22 +
 .../strategy/actions/TellItemCountAction.cpp       |   16 +
 .../strategy/actions/TellItemCountAction.h         |   14 +
 .../playerbot/strategy/actions/TellLosAction.cpp   |   61 +
 .../playerbot/strategy/actions/TellLosAction.h     |   17 +
 .../playerbot/strategy/actions/TellMasterAction.h  |   38 +
 .../strategy/actions/TellReputationAction.cpp      |   68 +
 .../strategy/actions/TellReputationAction.h        |   16 +
 .../strategy/actions/TellTargetAction.cpp          |   53 +
 .../playerbot/strategy/actions/TellTargetAction.h  |   21 +
 .../playerbot/strategy/actions/TradeAction.cpp     |   83 +
 .../playerbot/strategy/actions/TradeAction.h       |   19 +
 .../strategy/actions/TradeStatusAction.cpp         |  216 ++
 .../playerbot/strategy/actions/TradeStatusAction.h |   20 +
 .../playerbot/strategy/actions/TrainerAction.cpp   |  114 +
 .../playerbot/strategy/actions/TrainerAction.h     |   22 +
 .../playerbot/strategy/actions/UnequipAction.cpp   |   45 +
 .../playerbot/strategy/actions/UnequipAction.h     |   18 +
 .../playerbot/strategy/actions/UseItemAction.cpp   |  302 ++
 .../playerbot/strategy/actions/UseItemAction.h     |   47 +
 .../strategy/actions/UseMeetingStoneAction.cpp     |   86 +
 .../strategy/actions/UseMeetingStoneAction.h       |   26 +
 .../playerbot/strategy/actions/WhoAction.cpp       |  160 +
 src/plugins/playerbot/strategy/actions/WhoAction.h |   23 +
 .../strategy/actions/WorldPacketActionContext.h    |  108 +
 .../strategy/druid/BearTankDruidStrategy.cpp       |  172 +
 .../strategy/druid/BearTankDruidStrategy.h         |   18 +
 .../strategy/druid/CasterDruidStrategy.cpp         |  177 +
 .../playerbot/strategy/druid/CasterDruidStrategy.h |   39 +
 .../strategy/druid/CatDpsDruidStrategy.cpp         |  139 +
 .../playerbot/strategy/druid/CatDpsDruidStrategy.h |   29 +
 .../playerbot/strategy/druid/DruidActions.cpp      |   31 +
 .../playerbot/strategy/druid/DruidActions.h        |  205 ++
 .../strategy/druid/DruidAiObjectContext.cpp        |  258 ++
 .../strategy/druid/DruidAiObjectContext.h          |   12 +
 .../playerbot/strategy/druid/DruidBearActions.h    |   64 +
 .../playerbot/strategy/druid/DruidCatActions.h     |   64 +
 .../playerbot/strategy/druid/DruidMultipliers.cpp  |    6 +
 .../playerbot/strategy/druid/DruidMultipliers.h    |    6 +
 .../strategy/druid/DruidShapeshiftActions.h        |   53 +
 .../playerbot/strategy/druid/DruidTriggers.cpp     |    7 +
 .../playerbot/strategy/druid/DruidTriggers.h       |  127 +
 .../strategy/druid/FeralDruidStrategy.cpp          |   90 +
 .../playerbot/strategy/druid/FeralDruidStrategy.h  |   75 +
 .../druid/GenericDruidNonCombatStrategy.cpp        |   73 +
 .../strategy/druid/GenericDruidNonCombatStrategy.h |   16 +
 .../strategy/druid/GenericDruidStrategy.cpp        |  132 +
 .../strategy/druid/GenericDruidStrategy.h          |   18 +
 .../playerbot/strategy/druid/HealDruidStrategy.cpp |   57 +
 .../playerbot/strategy/druid/HealDruidStrategy.h   |   18 +
 .../generic/AttackEnemyPlayersStrategy.cpp         |   13 +
 .../strategy/generic/AttackEnemyPlayersStrategy.h  |   16 +
 .../strategy/generic/AttackRtiStrategy.cpp         |   14 +
 .../playerbot/strategy/generic/AttackRtiStrategy.h |   16 +
 .../strategy/generic/AttackWeakStrategy.cpp        |   13 +
 .../strategy/generic/AttackWeakStrategy.h          |   16 +
 .../strategy/generic/CastTimeStrategy.cpp          |   42 +
 .../playerbot/strategy/generic/CastTimeStrategy.h  |   26 +
 .../generic/ChatCommandHandlerStrategy.cpp         |  177 +
 .../strategy/generic/ChatCommandHandlerStrategy.h  |   15 +
 .../playerbot/strategy/generic/CombatStrategy.cpp  |   12 +
 .../playerbot/strategy/generic/CombatStrategy.h    |   13 +
 .../strategy/generic/ConserveManaStrategy.cpp      |   88 +
 .../strategy/generic/ConserveManaStrategy.h        |   32 +
 .../playerbot/strategy/generic/DeadStrategy.cpp    |   23 +
 .../playerbot/strategy/generic/DeadStrategy.h      |   15 +
 .../playerbot/strategy/generic/DpsAoeStrategy.cpp  |   12 +
 .../playerbot/strategy/generic/DpsAoeStrategy.h    |   18 +
 .../strategy/generic/DpsAssistStrategy.cpp         |   15 +
 .../playerbot/strategy/generic/DpsAssistStrategy.h |   16 +
 .../playerbot/strategy/generic/DuelStrategy.cpp    |   24 +
 .../playerbot/strategy/generic/DuelStrategy.h      |   15 +
 .../playerbot/strategy/generic/EmoteStrategy.cpp   |   17 +
 .../playerbot/strategy/generic/EmoteStrategy.h     |   16 +
 .../playerbot/strategy/generic/FleeStrategy.cpp    |   26 +
 .../playerbot/strategy/generic/FleeStrategy.h      |   21 +
 .../strategy/generic/FollowMasterStrategy.cpp      |   17 +
 .../strategy/generic/FollowMasterStrategy.h        |   16 +
 .../strategy/generic/GrindingStrategy.cpp          |   20 +
 .../playerbot/strategy/generic/GrindingStrategy.h  |   20 +
 .../playerbot/strategy/generic/GuardStrategy.cpp   |   16 +
 .../playerbot/strategy/generic/GuardStrategy.h     |   19 +
 .../playerbot/strategy/generic/KiteStrategy.cpp    |   16 +
 .../playerbot/strategy/generic/KiteStrategy.h      |   15 +
 .../strategy/generic/LootNonCombatStrategy.cpp     |   29 +
 .../strategy/generic/LootNonCombatStrategy.h       |   24 +
 .../strategy/generic/MeleeCombatStrategy.cpp       |   23 +
 .../strategy/generic/MeleeCombatStrategy.h         |   16 +
 .../strategy/generic/MoveRandomStrategy.cpp        |   13 +
 .../strategy/generic/MoveRandomStrategy.h          |   16 +
 .../strategy/generic/NonCombatStrategy.cpp         |   28 +
 .../playerbot/strategy/generic/NonCombatStrategy.h |   21 +
 .../strategy/generic/PassTroughStrategy.h          |   26 +
 .../playerbot/strategy/generic/PassiveStrategy.cpp |   13 +
 .../playerbot/strategy/generic/PassiveStrategy.h   |   16 +
 .../playerbot/strategy/generic/PullStrategy.cpp    |   52 +
 .../playerbot/strategy/generic/PullStrategy.h      |   24 +
 .../playerbot/strategy/generic/QuestStrategies.cpp |   69 +
 .../playerbot/strategy/generic/QuestStrategies.h   |   34 +
 .../playerbot/strategy/generic/RacialsStrategy.cpp |   39 +
 .../playerbot/strategy/generic/RacialsStrategy.h   |   15 +
 .../strategy/generic/RangedCombatStrategy.cpp      |   15 +
 .../strategy/generic/RangedCombatStrategy.h        |   15 +
 .../playerbot/strategy/generic/RunawayStrategy.cpp |   18 +
 .../playerbot/strategy/generic/RunawayStrategy.h   |   16 +
 .../playerbot/strategy/generic/SayStrategy.cpp     |   29 +
 .../playerbot/strategy/generic/SayStrategy.h       |   16 +
 .../playerbot/strategy/generic/StayStrategy.cpp    |   11 +
 .../playerbot/strategy/generic/StayStrategy.h      |   14 +
 .../playerbot/strategy/generic/TankAoeStrategy.cpp |   12 +
 .../playerbot/strategy/generic/TankAoeStrategy.h   |   18 +
 .../strategy/generic/TankAssistStrategy.cpp        |   13 +
 .../strategy/generic/TankAssistStrategy.h          |   17 +
 .../strategy/generic/TellTargetStrategy.cpp        |   13 +
 .../strategy/generic/TellTargetStrategy.h          |   16 +
 .../playerbot/strategy/generic/ThreatStrategy.cpp  |   32 +
 .../playerbot/strategy/generic/ThreatStrategy.h    |   25 +
 .../playerbot/strategy/generic/UseFoodStrategy.cpp |   18 +
 .../playerbot/strategy/generic/UseFoodStrategy.h   |   15 +
 .../strategy/generic/UsePotionsStrategy.cpp        |   18 +
 .../strategy/generic/UsePotionsStrategy.h          |   15 +
 .../generic/WorldPacketHandlerStrategy.cpp         |  106 +
 .../strategy/generic/WorldPacketHandlerStrategy.h  |   25 +
 .../strategy/hunter/DpsHunterStrategy.cpp          |  118 +
 .../playerbot/strategy/hunter/DpsHunterStrategy.h  |   39 +
 .../hunter/GenericHunterNonCombatStrategy.cpp      |   58 +
 .../hunter/GenericHunterNonCombatStrategy.h        |   17 +
 .../strategy/hunter/GenericHunterStrategy.cpp      |   66 +
 .../strategy/hunter/GenericHunterStrategy.h        |   20 +
 .../playerbot/strategy/hunter/HunterActions.cpp    |   26 +
 .../playerbot/strategy/hunter/HunterActions.h      |  158 +
 .../strategy/hunter/HunterAiObjectContext.cpp      |  191 ++
 .../strategy/hunter/HunterAiObjectContext.h        |   12 +
 .../strategy/hunter/HunterBuffStrategies.cpp       |   35 +
 .../strategy/hunter/HunterBuffStrategies.h         |   47 +
 .../strategy/hunter/HunterMultipliers.cpp          |    5 +
 .../playerbot/strategy/hunter/HunterMultipliers.h  |    6 +
 .../playerbot/strategy/hunter/HunterTriggers.cpp   |   29 +
 .../playerbot/strategy/hunter/HunterTriggers.h     |   86 +
 .../playerbot/strategy/mage/ArcaneMageStrategy.cpp |   64 +
 .../playerbot/strategy/mage/ArcaneMageStrategy.h   |   18 +
 .../playerbot/strategy/mage/FireMageStrategy.cpp   |   44 +
 .../playerbot/strategy/mage/FireMageStrategy.h     |   28 +
 .../playerbot/strategy/mage/FrostMageStrategy.cpp  |   32 +
 .../playerbot/strategy/mage/FrostMageStrategy.h    |   28 +
 .../strategy/mage/GenericMageNonCombatStrategy.cpp |   87 +
 .../strategy/mage/GenericMageNonCombatStrategy.h   |   37 +
 .../strategy/mage/GenericMageStrategy.cpp          |  137 +
 .../playerbot/strategy/mage/GenericMageStrategy.h  |   17 +
 .../playerbot/strategy/mage/MageActions.cpp        |   10 +
 src/plugins/playerbot/strategy/mage/MageActions.h  |  205 ++
 .../strategy/mage/MageAiObjectContext.cpp          |  221 ++
 .../playerbot/strategy/mage/MageAiObjectContext.h  |   12 +
 .../playerbot/strategy/mage/MageMultipliers.cpp    |    6 +
 .../playerbot/strategy/mage/MageMultipliers.h      |    6 +
 .../playerbot/strategy/mage/MageTriggers.cpp       |   15 +
 src/plugins/playerbot/strategy/mage/MageTriggers.h |   92 +
 .../strategy/paladin/DpsPaladinStrategy.cpp        |   83 +
 .../strategy/paladin/DpsPaladinStrategy.h          |   18 +
 .../paladin/GenericPaladinNonCombatStrategy.cpp    |   65 +
 .../paladin/GenericPaladinNonCombatStrategy.h      |   16 +
 .../strategy/paladin/GenericPaladinStrategy.cpp    |   77 +
 .../strategy/paladin/GenericPaladinStrategy.h      |   18 +
 .../GenericPaladinStrategyActionNodeFactory.h      |  150 +
 .../playerbot/strategy/paladin/PaladinActions.cpp  |    6 +
 .../playerbot/strategy/paladin/PaladinActions.h    |  365 +++
 .../strategy/paladin/PaladinAiObjectContext.cpp    |  279 ++
 .../strategy/paladin/PaladinAiObjectContext.h      |   12 +
 .../strategy/paladin/PaladinBuffStrategies.cpp     |   72 +
 .../strategy/paladin/PaladinBuffStrategies.h       |   86 +
 .../strategy/paladin/PaladinMultipliers.cpp        |    6 +
 .../strategy/paladin/PaladinMultipliers.h          |    6 +
 .../playerbot/strategy/paladin/PaladinTriggers.cpp |   23 +
 .../playerbot/strategy/paladin/PaladinTriggers.h   |  114 +
 .../strategy/paladin/TankPaladinStrategy.cpp       |   70 +
 .../strategy/paladin/TankPaladinStrategy.h         |   18 +
 .../strategy/priest/GenericPriestStrategy.cpp      |   67 +
 .../strategy/priest/GenericPriestStrategy.h        |   17 +
 .../GenericPriestStrategyActionNodeFactory.h       |  173 +
 .../strategy/priest/HealPriestStrategy.cpp         |   36 +
 .../playerbot/strategy/priest/HealPriestStrategy.h |   18 +
 .../strategy/priest/HolyPriestStrategy.cpp         |   46 +
 .../playerbot/strategy/priest/HolyPriestStrategy.h |   18 +
 .../playerbot/strategy/priest/PriestActions.cpp    |   17 +
 .../playerbot/strategy/priest/PriestActions.h      |  246 ++
 .../strategy/priest/PriestAiObjectContext.cpp      |  217 ++
 .../strategy/priest/PriestAiObjectContext.h        |   12 +
 .../strategy/priest/PriestMultipliers.cpp          |    6 +
 .../playerbot/strategy/priest/PriestMultipliers.h  |    6 +
 .../strategy/priest/PriestNonCombatStrategy.cpp    |   82 +
 .../strategy/priest/PriestNonCombatStrategy.h      |   17 +
 .../PriestNonCombatStrategyActionNodeFactory.h     |  126 +
 .../playerbot/strategy/priest/PriestTriggers.cpp   |    7 +
 .../playerbot/strategy/priest/PriestTriggers.h     |   54 +
 .../strategy/priest/ShadowPriestStrategy.cpp       |   60 +
 .../strategy/priest/ShadowPriestStrategy.h         |   38 +
 .../priest/ShadowPriestStrategyActionNodeFactory.h |   37 +
 .../playerbot/strategy/rogue/DpsRogueStrategy.cpp  |  110 +
 .../playerbot/strategy/rogue/DpsRogueStrategy.h    |   18 +
 .../rogue/GenericRogueNonCombatStrategy.cpp        |   14 +
 .../strategy/rogue/GenericRogueNonCombatStrategy.h |   16 +
 .../playerbot/strategy/rogue/RogueActions.cpp      |    5 +
 .../playerbot/strategy/rogue/RogueActions.h        |   82 +
 .../strategy/rogue/RogueAiObjectContext.cpp        |  119 +
 .../strategy/rogue/RogueAiObjectContext.h          |   12 +
 .../playerbot/strategy/rogue/RogueComboActions.h   |   45 +
 .../strategy/rogue/RogueFinishingActions.h         |   35 +
 .../playerbot/strategy/rogue/RogueMultipliers.cpp  |    6 +
 .../playerbot/strategy/rogue/RogueMultipliers.h    |    6 +
 .../playerbot/strategy/rogue/RogueOpeningActions.h |   24 +
 .../playerbot/strategy/rogue/RogueTriggers.cpp     |    7 +
 .../playerbot/strategy/rogue/RogueTriggers.h       |   36 +
 .../strategy/shaman/CasterShamanStrategy.cpp       |   75 +
 .../strategy/shaman/CasterShamanStrategy.h         |   29 +
 .../strategy/shaman/GenericShamanStrategy.cpp      |  159 +
 .../strategy/shaman/GenericShamanStrategy.h        |   39 +
 .../strategy/shaman/HealShamanStrategy.cpp         |   82 +
 .../playerbot/strategy/shaman/HealShamanStrategy.h |   17 +
 .../strategy/shaman/MeleeShamanStrategy.cpp        |   93 +
 .../strategy/shaman/MeleeShamanStrategy.h          |   28 +
 .../playerbot/strategy/shaman/ShamanActions.cpp    |    6 +
 .../playerbot/strategy/shaman/ShamanActions.h      |  304 ++
 .../strategy/shaman/ShamanAiObjectContext.cpp      |  268 ++
 .../strategy/shaman/ShamanAiObjectContext.h        |   12 +
 .../strategy/shaman/ShamanMultipliers.cpp          |    6 +
 .../playerbot/strategy/shaman/ShamanMultipliers.h  |    6 +
 .../strategy/shaman/ShamanNonCombatStrategy.cpp    |   49 +
 .../strategy/shaman/ShamanNonCombatStrategy.h      |   19 +
 .../playerbot/strategy/shaman/ShamanTriggers.cpp   |   38 +
 .../playerbot/strategy/shaman/ShamanTriggers.h     |  197 ++
 .../strategy/shaman/TotemsShamanStrategy.cpp       |   31 +
 .../strategy/shaman/TotemsShamanStrategy.h         |   17 +
 .../strategy/triggers/ChatCommandTrigger.h         |   36 +
 .../strategy/triggers/ChatTriggerContext.h         |  140 +
 .../playerbot/strategy/triggers/CureTriggers.cpp   |   17 +
 .../playerbot/strategy/triggers/CureTriggers.h     |   35 +
 .../strategy/triggers/GenericTriggers.cpp          |  242 ++
 .../playerbot/strategy/triggers/GenericTriggers.h  |  540 +++
 .../playerbot/strategy/triggers/HealthTriggers.cpp |   26 +
 .../playerbot/strategy/triggers/HealthTriggers.h   |  139 +
 .../playerbot/strategy/triggers/LfgTriggers.h      |   17 +
 .../playerbot/strategy/triggers/LootTriggers.cpp   |   20 +
 .../playerbot/strategy/triggers/LootTriggers.h     |   30 +
 .../playerbot/strategy/triggers/RangeTriggers.h    |   81 +
 .../playerbot/strategy/triggers/TriggerContext.h   |  158 +
 .../strategy/triggers/WithinAreaTrigger.h          |   76 +
 .../strategy/triggers/WorldPacketTrigger.h         |   36 +
 .../strategy/triggers/WorldPacketTriggerContext.h  |   85 +
 .../strategy/values/AlwaysLootListValue.h          |   14 +
 .../playerbot/strategy/values/AoeHealValues.cpp    |   37 +
 .../playerbot/strategy/values/AoeHealValues.h      |   14 +
 .../strategy/values/AttackerCountValues.cpp        |  107 +
 .../strategy/values/AttackerCountValues.h          |   59 +
 .../values/AttackerWithoutAuraTargetValue.cpp      |   26 +
 .../values/AttackerWithoutAuraTargetValue.h        |   15 +
 .../playerbot/strategy/values/AttackersValue.cpp   |   94 +
 .../playerbot/strategy/values/AttackersValue.h     |   20 +
 .../playerbot/strategy/values/AvailableLootValue.h |   40 +
 .../playerbot/strategy/values/CcTargetValue.cpp    |   88 +
 .../playerbot/strategy/values/CcTargetValue.h      |   16 +
 src/plugins/playerbot/strategy/values/ChatValue.h  |   11 +
 .../strategy/values/CurrentCcTargetValue.cpp       |   31 +
 .../strategy/values/CurrentCcTargetValue.h         |   16 +
 .../strategy/values/CurrentTargetValue.cpp         |   22 +
 .../playerbot/strategy/values/CurrentTargetValue.h |   17 +
 .../playerbot/strategy/values/DistanceValue.h      |   35 +
 .../playerbot/strategy/values/DpsTargetValue.cpp   |   45 +
 .../playerbot/strategy/values/DpsTargetValue.h     |   16 +
 .../playerbot/strategy/values/DuelTargetValue.cpp  |   10 +
 .../playerbot/strategy/values/DuelTargetValue.h    |   15 +
 .../strategy/values/EnemyHealerTargetValue.cpp     |   36 +
 .../strategy/values/EnemyHealerTargetValue.h       |   15 +
 .../playerbot/strategy/values/EnemyPlayerValue.cpp |   34 +
 .../playerbot/strategy/values/EnemyPlayerValue.h   |   15 +
 .../playerbot/strategy/values/Formations.cpp       |  377 +++
 src/plugins/playerbot/strategy/values/Formations.h |   52 +
 .../playerbot/strategy/values/GrindTargetValue.cpp |  126 +
 .../playerbot/strategy/values/GrindTargetValue.h   |   20 +
 .../strategy/values/HasAvailableLootValue.h        |   20 +
 .../playerbot/strategy/values/HasTotemValue.h      |   34 +
 .../strategy/values/InvalidTargetValue.cpp         |   26 +
 .../playerbot/strategy/values/InvalidTargetValue.h |   14 +
 .../playerbot/strategy/values/IsBehindValue.h      |   25 +
 .../playerbot/strategy/values/IsFacingValue.h      |   20 +
 .../playerbot/strategy/values/IsMovingValue.h      |   42 +
 .../playerbot/strategy/values/ItemCountValue.cpp   |   37 +
 .../playerbot/strategy/values/ItemCountValue.h     |   35 +
 .../strategy/values/ItemForSpellValue.cpp          |   70 +
 .../playerbot/strategy/values/ItemForSpellValue.h  |   20 +
 .../playerbot/strategy/values/ItemUsageValue.cpp   |  146 +
 .../playerbot/strategy/values/ItemUsageValue.h     |   28 +
 .../playerbot/strategy/values/LastMovementValue.h  |   61 +
 .../playerbot/strategy/values/LastSaidValue.h      |   17 +
 .../strategy/values/LastSpellCastTimeValue.h       |   11 +
 .../playerbot/strategy/values/LastSpellCastValue.h |   39 +
 .../strategy/values/LeastHpTargetValue.cpp         |   33 +
 .../playerbot/strategy/values/LeastHpTargetValue.h |   15 +
 src/plugins/playerbot/strategy/values/LfgValues.h  |   12 +
 .../playerbot/strategy/values/LineTargetValue.cpp  |   33 +
 .../playerbot/strategy/values/LineTargetValue.h    |   14 +
 .../playerbot/strategy/values/LogLevelValue.h      |   12 +
 .../playerbot/strategy/values/LootStrategyValue.h  |   11 +
 .../playerbot/strategy/values/ManaSaveLevelValue.h |   11 +
 .../playerbot/strategy/values/MasterTargetValue.h  |   13 +
 .../playerbot/strategy/values/NearestAdsValue.cpp  |   11 +
 .../playerbot/strategy/values/NearestAdsValue.h    |   18 +
 .../strategy/values/NearestCorpsesValue.cpp        |   36 +
 .../strategy/values/NearestCorpsesValue.h          |   19 +
 .../strategy/values/NearestGameObjects.cpp         |   47 +
 .../playerbot/strategy/values/NearestGameObjects.h |   19 +
 .../playerbot/strategy/values/NearestNpcsValue.cpp |   23 +
 .../playerbot/strategy/values/NearestNpcsValue.h   |   18 +
 .../playerbot/strategy/values/NearestUnitsValue.h  |   36 +
 .../strategy/values/PartyMemberToDispel.cpp        |   37 +
 .../strategy/values/PartyMemberToDispel.h          |   16 +
 .../strategy/values/PartyMemberToHeal.cpp          |   60 +
 .../playerbot/strategy/values/PartyMemberToHeal.h  |   17 +
 .../strategy/values/PartyMemberToResurrect.cpp     |   44 +
 .../strategy/values/PartyMemberToResurrect.h       |   16 +
 .../playerbot/strategy/values/PartyMemberValue.cpp |  111 +
 .../playerbot/strategy/values/PartyMemberValue.h   |   31 +
 .../values/PartyMemberWithoutAuraValue.cpp         |   35 +
 .../strategy/values/PartyMemberWithoutAuraValue.h  |   17 +
 .../playerbot/strategy/values/PetTargetValue.h     |   13 +
 .../playerbot/strategy/values/PositionValue.cpp    |   10 +
 .../playerbot/strategy/values/PositionValue.h      |   26 +
 .../strategy/values/PossibleTargetsValue.cpp       |   23 +
 .../strategy/values/PossibleTargetsValue.h         |   19 +
 .../playerbot/strategy/values/RtiTargetValue.h     |   51 +
 src/plugins/playerbot/strategy/values/RtiValue.cpp |   36 +
 src/plugins/playerbot/strategy/values/RtiValue.h   |   11 +
 .../playerbot/strategy/values/SelfTargetValue.h    |   13 +
 .../strategy/values/SpellCastUsefulValue.cpp       |   52 +
 .../strategy/values/SpellCastUsefulValue.h         |   17 +
 .../playerbot/strategy/values/SpellIdValue.cpp     |   90 +
 .../playerbot/strategy/values/SpellIdValue.h       |   17 +
 .../playerbot/strategy/values/StatsValues.cpp      |  120 +
 .../playerbot/strategy/values/StatsValues.h        |  146 +
 .../playerbot/strategy/values/TankTargetValue.cpp  |   47 +
 .../playerbot/strategy/values/TankTargetValue.h    |   16 +
 .../playerbot/strategy/values/TargetValue.cpp      |   54 +
 .../playerbot/strategy/values/TargetValue.h        |   39 +
 .../playerbot/strategy/values/ThreatValues.cpp     |   62 +
 .../playerbot/strategy/values/ThreatValues.h       |   17 +
 .../playerbot/strategy/values/ValueContext.h       |  232 ++
 .../playerbot/strategy/values/formations/Arrow.cpp |  162 +
 .../playerbot/strategy/values/formations/Arrow.h   |  109 +
 .../strategy/warlock/DpsWarlockStrategy.cpp        |   76 +
 .../strategy/warlock/DpsWarlockStrategy.h          |   39 +
 .../warlock/GenericWarlockNonCombatStrategy.cpp    |   65 +
 .../warlock/GenericWarlockNonCombatStrategy.h      |   16 +
 .../strategy/warlock/GenericWarlockStrategy.cpp    |   74 +
 .../strategy/warlock/GenericWarlockStrategy.h      |   18 +
 .../strategy/warlock/TankWarlockStrategy.cpp       |   51 +
 .../strategy/warlock/TankWarlockStrategy.h         |   17 +
 .../playerbot/strategy/warlock/WarlockActions.cpp  |    5 +
 .../playerbot/strategy/warlock/WarlockActions.h    |  176 +
 .../strategy/warlock/WarlockAiObjectContext.cpp    |  183 ++
 .../strategy/warlock/WarlockAiObjectContext.h      |   12 +
 .../strategy/warlock/WarlockMultipliers.cpp        |    6 +
 .../strategy/warlock/WarlockMultipliers.h          |    6 +
 .../playerbot/strategy/warlock/WarlockTriggers.cpp |   19 +
 .../playerbot/strategy/warlock/WarlockTriggers.h   |   81 +
 .../strategy/warrior/DpsWarriorStrategy.cpp        |  130 +
 .../strategy/warrior/DpsWarriorStrategy.h          |   28 +
 .../warrior/GenericWarriorNonCombatStrategy.cpp    |    7 +
 .../warrior/GenericWarriorNonCombatStrategy.h      |   13 +
 .../strategy/warrior/GenericWarriorStrategy.cpp    |   73 +
 .../strategy/warrior/GenericWarriorStrategy.h      |   19 +
 .../strategy/warrior/TankWarriorStrategy.cpp       |  126 +
 .../strategy/warrior/TankWarriorStrategy.h         |   18 +
 .../playerbot/strategy/warrior/WarriorActions.cpp  |   15 +
 .../playerbot/strategy/warrior/WarriorActions.h    |  207 ++
 .../strategy/warrior/WarriorAiObjectContext.cpp    |  192 ++
 .../strategy/warrior/WarriorAiObjectContext.h      |   12 +
 .../strategy/warrior/WarriorMultipliers.cpp        |    6 +
 .../strategy/warrior/WarriorMultipliers.h          |    6 +
 .../playerbot/strategy/warrior/WarriorTriggers.cpp |    7 +
 .../playerbot/strategy/warrior/WarriorTriggers.h   |   78 +
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |    8 +
 src/server/game/CMakeLists.txt                     |    1 +
 src/server/game/DungeonFinding/LFGQueue.cpp        |   18 +
 src/server/game/Entities/Player/Player.cpp         |   21 +-
 src/server/game/Entities/Player/Player.h           |   19 +-
 src/server/game/Groups/Group.h                     |    5 +
 src/server/game/Handlers/CharacterHandler.cpp      |   81 +
 src/server/game/Handlers/CharacterHandler.cpp.orig | 2188 +++++++++++++
 src/server/game/Handlers/ChatHandler.cpp           |   88 +-
 src/server/game/Server/WorldSession.cpp            |   43 +-
 src/server/game/Server/WorldSession.h              |    7 +-
 src/server/game/World/World.cpp                    |   32 +-
 src/server/game/World/World.cpp.orig               | 3456 ++++++++++++++++++++
 src/server/scripts/Commands/cs_ahbot.cpp           |    3 +-
 src/server/scripts/Commands/cs_misc.cpp            |    9 +
 src/server/worldserver/CMakeLists.txt              |    1 +
 src/test/AcceptAllQuestStrategyTestCase.cpp        |   68 +
 src/test/AiObjectContextWrapper.h                  |  289 ++
 src/test/ArcaneMageTestCase.cpp                    |   55 +
 src/test/BearTankDruidTestCase.cpp                 |  223 ++
 src/test/CMakeLists.txt                            |  177 +
 src/test/CasterDruidTestCase.cpp                   |  166 +
 src/test/CasterShamanTestCase.cpp                  |   86 +
 src/test/CatDpsDruidTestCase.cpp                   |  140 +
 src/test/ChatCommandTestCase.cpp                   |  454 +++
 src/test/ChatFilterTestCase.cpp                    |   32 +
 src/test/DpsHunterEngineTestCase.cpp               |  166 +
 src/test/DpsPaladinTestCase.cpp                    |   79 +
 src/test/DpsPriestTestCase.cpp                     |   95 +
 src/test/DpsRogueTestCase.cpp                      |   80 +
 src/test/DpsWarlockTestCase.cpp                    |   99 +
 src/test/DpsWarriorTestCase.cpp                    |  133 +
 src/test/DruidNonCombatTestCase.cpp                |   70 +
 src/test/DuelTestCase.cpp                          |   44 +
 src/test/EngineTestBase.cpp                        |  557 ++++
 src/test/EngineTestBase.h                          |   90 +
 src/test/EngineTestCase.cpp                        |  321 ++
 src/test/EventTestCase.cpp                         |   59 +
 src/test/EverythingUnavailableAiManagerRegistry.h  |   15 +
 src/test/ExternalEventHelperTestCase.cpp           |   81 +
 src/test/FireMageTestCase.cpp                      |  109 +
 src/test/FrostMageTestCase.cpp                     |  150 +
 src/test/GenericTestCase.cpp                       |  139 +
 src/test/HealDruidTestCase.cpp                     |   91 +
 src/test/HealPriestTestCase.cpp                    |  201 ++
 src/test/HealShamanTestCase.cpp                    |  137 +
 src/test/HolyPriestTestCase.cpp                    |   62 +
 src/test/HunterNonCombatTestCase.cpp               |   74 +
 src/test/KiteTestCase.cpp                          |   39 +
 src/test/LootObjectStackTestCase.cpp               |   52 +
 src/test/MageNonCombatTestCase.cpp                 |   87 +
 src/test/MeleeShamanTestCase.cpp                   |  109 +
 src/test/MockAiObjectContext.cpp                   |  114 +
 src/test/MockAiObjectContext.h                     |   31 +
 src/test/MockPlayerbotAIBase.cpp                   |   79 +
 src/test/MockPlayerbotAIBase.h                     |   41 +
 src/test/MockedAiObjectContextTestCase.h           |   54 +
 src/test/MockedTargets.h                           |   65 +
 src/test/NextActionTestCase.cpp                    |   82 +
 src/test/NonCombatEngineTestCase.cpp               |  290 ++
 src/test/NonCombatEngineTestCase2.cpp              |   42 +
 src/test/PaladinNonCombatTestCase.cpp              |   97 +
 src/test/PerformanceTestCase.cpp                   |  177 +
 src/test/PriestNonCombatTestCase.cpp               |  112 +
 src/test/QualifiedValueTestCase.cpp                |   84 +
 src/test/QuestStrategyTestCase.cpp                 |   73 +
 src/test/QueueTestCase.cpp                         |   40 +
 src/test/RacialsTestCase.cpp                       |   41 +
 src/test/RandomItemMgrTestCase.cpp                 |   84 +
 src/test/SayStrategyTestCase.cpp                   |   85 +
 src/test/ShamanNonCombatTestCase.cpp               |   69 +
 src/test/TankPaladinTestCase.cpp                   |  230 ++
 src/test/TankWarlockTestCase.cpp                   |   57 +
 src/test/TankWarriorTestCase.cpp                   |  174 +
 src/test/ValueTestCase.cpp                         |  121 +
 src/test/WarlockNonCombatTestCase.cpp              |   50 +
 src/test/WarrirorNonCombatTestCase.cpp             |   40 +
 src/test/WorldPacketHandlerTestCase.cpp            |  278 ++
 src/test/aitest.h                                  |   14 +
 src/test/cppunit/AdditionalMessage.cpp             |   41 +
 src/test/cppunit/AdditionalMessage.h               |   76 +
 src/test/cppunit/Asserter.cpp                      |  101 +
 src/test/cppunit/Asserter.h                        |  143 +
 src/test/cppunit/BeOsDynamicLibraryManager.cpp     |   49 +
 src/test/cppunit/BriefTestProgressListener.cpp     |   49 +
 src/test/cppunit/BriefTestProgressListener.h       |   43 +
 src/test/cppunit/CompilerOutputter.cpp             |  216 ++
 src/test/cppunit/CompilerOutputter.h               |  146 +
 src/test/cppunit/DefaultProtector.cpp              |   42 +
 src/test/cppunit/DefaultProtector.h                |   27 +
 src/test/cppunit/DllMain.cpp                       |   16 +
 src/test/cppunit/DynamicLibraryManager.cpp         |   77 +
 .../cppunit/DynamicLibraryManagerException.cpp     |   41 +
 src/test/cppunit/Exception.cpp                     |  126 +
 src/test/cppunit/Exception.h                       |   90 +
 src/test/cppunit/Makefile.am                       |   67 +
 src/test/cppunit/Makefile.in                       |  632 ++++
 src/test/cppunit/Message.cpp                       |  170 +
 src/test/cppunit/Message.h                         |  156 +
 src/test/cppunit/Outputter.h                       |   26 +
 src/test/cppunit/PlugInManager.cpp                 |  110 +
 src/test/cppunit/PlugInParameters.cpp              |   28 +
 src/test/cppunit/Portability.h                     |  177 +
 src/test/cppunit/Protector.cpp                     |   86 +
 src/test/cppunit/Protector.h                       |   94 +
 src/test/cppunit/ProtectorChain.cpp                |   86 +
 src/test/cppunit/ProtectorChain.h                  |   51 +
 src/test/cppunit/ProtectorContext.h                |   38 +
 src/test/cppunit/RepeatedTest.cpp                  |   29 +
 src/test/cppunit/ShlDynamicLibraryManager.cpp      |   53 +
 src/test/cppunit/SourceLine.cpp                    |   81 +
 src/test/cppunit/SourceLine.h                      |   63 +
 src/test/cppunit/StringTools.cpp                   |   80 +
 src/test/cppunit/SynchronizedObject.cpp            |   32 +
 src/test/cppunit/SynchronizedObject.h              |   80 +
 src/test/cppunit/Test.cpp                          |   97 +
 src/test/cppunit/Test.h                            |  117 +
 src/test/cppunit/TestAssert.cpp                    |   46 +
 src/test/cppunit/TestAssert.h                      |  428 +++
 src/test/cppunit/TestCaller.h                      |  204 ++
 src/test/cppunit/TestCase.cpp                      |  137 +
 src/test/cppunit/TestCase.h                        |   55 +
 src/test/cppunit/TestCaseDecorator.cpp             |   47 +
 src/test/cppunit/TestComposite.cpp                 |   77 +
 src/test/cppunit/TestComposite.h                   |   45 +
 src/test/cppunit/TestDecorator.cpp                 |   53 +
 src/test/cppunit/TestFactoryRegistry.cpp           |  161 +
 src/test/cppunit/TestFailure.cpp                   |   71 +
 src/test/cppunit/TestFailure.h                     |   58 +
 src/test/cppunit/TestFixture.h                     |   99 +
 src/test/cppunit/TestLeaf.cpp                      |   28 +
 src/test/cppunit/TestLeaf.h                        |   44 +
 src/test/cppunit/TestListener.h                    |  148 +
 src/test/cppunit/TestNamer.cpp                     |   44 +
 src/test/cppunit/TestPath.cpp                      |  254 ++
 src/test/cppunit/TestPath.h                        |  211 ++
 src/test/cppunit/TestPlugInDefaultImpl.cpp         |   63 +
 src/test/cppunit/TestResult.cpp                    |  196 ++
 src/test/cppunit/TestResult.h                      |  156 +
 src/test/cppunit/TestResultCollector.cpp           |  117 +
 src/test/cppunit/TestResultCollector.h             |   87 +
 src/test/cppunit/TestRunner.cpp                    |  101 +
 src/test/cppunit/TestRunner.h                      |  135 +
 src/test/cppunit/TestSetUp.cpp                     |   32 +
 src/test/cppunit/TestSuccessListener.cpp           |   44 +
 src/test/cppunit/TestSuccessListener.h             |   39 +
 src/test/cppunit/TestSuite.cpp                     |   64 +
 src/test/cppunit/TestSuite.h                       |   80 +
 src/test/cppunit/TestSuiteBuilderContext.cpp       |   85 +
 src/test/cppunit/TextOutputter.cpp                 |  140 +
 src/test/cppunit/TextOutputter.h                   |   59 +
 src/test/cppunit/TextTestProgressListener.cpp      |   43 +
 src/test/cppunit/TextTestProgressListener.h        |   44 +
 src/test/cppunit/TextTestResult.cpp                |   50 +
 src/test/cppunit/TextTestResult.h                  |   39 +
 src/test/cppunit/TextTestRunner.cpp                |  144 +
 src/test/cppunit/TextTestRunner.h                  |    6 +
 src/test/cppunit/TypeInfoHelper.cpp                |   53 +
 src/test/cppunit/UnixDynamicLibraryManager.cpp     |   44 +
 src/test/cppunit/Win32DynamicLibraryManager.cpp    |   73 +
 src/test/cppunit/XmlDocument.cpp                   |  106 +
 src/test/cppunit/XmlElement.cpp                    |  226 ++
 src/test/cppunit/XmlOutputter.cpp                  |  205 ++
 src/test/cppunit/XmlOutputter.h                    |  167 +
 src/test/cppunit/XmlOutputterHook.cpp              |   44 +
 src/test/cppunit/XmlOutputterHook.h                |  163 +
 src/test/cppunit/config/CppUnitApi.h               |   33 +
 src/test/cppunit/config/Makefile.am                |   10 +
 src/test/cppunit/config/Makefile.in                |  438 +++
 src/test/cppunit/config/SelectDllLoader.h          |   76 +
 src/test/cppunit/config/SourcePrefix.h             |   14 +
 src/test/cppunit/config/config-bcb5.h              |   47 +
 src/test/cppunit/config/config-evc4.h              |   78 +
 src/test/cppunit/config/config-mac.h               |   58 +
 src/test/cppunit/config/config-msvc6.h             |   83 +
 src/test/cppunit/cppunit.dsp                       |  707 ++++
 src/test/cppunit/cppunit_dll.dsp                   |  682 ++++
 src/test/cppunit/extensions/AutoRegisterSuite.h    |   83 +
 .../extensions/ExceptionTestCaseDecorator.h        |  104 +
 src/test/cppunit/extensions/HelperMacros.h         |  541 +++
 src/test/cppunit/extensions/Makefile.am            |   19 +
 src/test/cppunit/extensions/Makefile.in            |  446 +++
 src/test/cppunit/extensions/Orthodox.h             |   95 +
 src/test/cppunit/extensions/RepeatedTest.h         |   43 +
 src/test/cppunit/extensions/TestCaseDecorator.h    |   40 +
 src/test/cppunit/extensions/TestDecorator.h        |   49 +
 src/test/cppunit/extensions/TestFactory.h          |   27 +
 src/test/cppunit/extensions/TestFactoryRegistry.h  |  182 ++
 src/test/cppunit/extensions/TestFixtureFactory.h   |   50 +
 src/test/cppunit/extensions/TestNamer.h            |   89 +
 src/test/cppunit/extensions/TestSetUp.h            |   34 +
 .../cppunit/extensions/TestSuiteBuilderContext.h   |  131 +
 src/test/cppunit/extensions/TestSuiteFactory.h     |   27 +
 src/test/cppunit/extensions/TypeInfoHelper.h       |   33 +
 src/test/cppunit/plugin/DynamicLibraryManager.h    |  121 +
 .../plugin/DynamicLibraryManagerException.h        |   53 +
 src/test/cppunit/plugin/Makefile.am                |    9 +
 src/test/cppunit/plugin/Makefile.in                |  437 +++
 src/test/cppunit/plugin/PlugInManager.h            |  113 +
 src/test/cppunit/plugin/PlugInParameters.h         |   36 +
 src/test/cppunit/plugin/TestPlugIn.h               |  200 ++
 src/test/cppunit/plugin/TestPlugInDefaultImpl.h    |   52 +
 src/test/cppunit/portability/CppUnitDeque.h        |   25 +
 src/test/cppunit/portability/CppUnitMap.h          |   29 +
 src/test/cppunit/portability/CppUnitSet.h          |   28 +
 src/test/cppunit/portability/CppUnitStack.h        |   26 +
 src/test/cppunit/portability/CppUnitVector.h       |   25 +
 src/test/cppunit/portability/FloatingPoint.h       |   54 +
 src/test/cppunit/portability/Makefile.am           |   10 +
 src/test/cppunit/portability/Makefile.in           |  438 +++
 src/test/cppunit/portability/Stream.h              |  347 ++
 src/test/cppunit/tools/Algorithm.h                 |   23 +
 src/test/cppunit/tools/Makefile.am                 |    7 +
 src/test/cppunit/tools/Makefile.in                 |  435 +++
 src/test/cppunit/tools/StringTools.h               |   34 +
 src/test/cppunit/tools/XmlDocument.h               |   86 +
 src/test/cppunit/tools/XmlElement.h                |  149 +
 src/test/cppunit/ui/Makefile.am                    |    1 +
 src/test/cppunit/ui/Makefile.in                    |  511 +++
 src/test/cppunit/ui/mfc/Makefile.am                |    5 +
 src/test/cppunit/ui/mfc/Makefile.in                |  433 +++
 src/test/cppunit/ui/mfc/MfcTestRunner.h            |   76 +
 src/test/cppunit/ui/mfc/TestRunner.h               |   21 +
 src/test/cppunit/ui/qt/Config.h                    |   21 +
 src/test/cppunit/ui/qt/Makefile.am                 |    6 +
 src/test/cppunit/ui/qt/Makefile.in                 |  434 +++
 src/test/cppunit/ui/qt/QtTestRunner.h              |   85 +
 src/test/cppunit/ui/qt/TestRunner.h                |   11 +
 src/test/cppunit/ui/text/Makefile.am               |    5 +
 src/test/cppunit/ui/text/Makefile.in               |  433 +++
 src/test/cppunit/ui/text/TestRunner.h              |   24 +
 src/test/cppunit/ui/text/TextTestRunner.h          |   97 +
 src/test/efficiency/AbstractEfficiencyTestCase.h   |   40 +
 src/test/efficiency/DruidEfficiencyTestCase.cpp    |   39 +
 .../EfficiencyActionExecutionListener.cpp          |   88 +
 .../efficiency/EfficiencyActionExecutionListener.h |   52 +
 src/test/efficiency/MageEfficiencyTestCase.cpp     |   55 +
 src/test/efficiency/PriestEfficiencyTestCase.cpp   |   43 +
 src/test/efficiency/ShamanEfficiencyTestCase.cpp   |   46 +
 src/test/efficiency/WarlockEfficiencyTestCase.cpp  |   43 +
 src/test/main.cpp                                  |   98 +
 src/test/pch.cpp                                   |    1 +
 src/test/pch.h                                     |   38 +
 846 files changed, 74798 insertions(+), 16 deletions(-)
 create mode 100644 cmake/options.cmake.orig
 create mode 100644 sql/ai_playerbot_guild_names.sql
 create mode 100644 sql/characters_ai_playerbot.sql
 create mode 100644 sql/characters_ai_playerbot_custom_strategy.sql
 create mode 100644 sql/characters_ai_playerbot_speech.sql
 create mode 100644 sql/characters_auctionhousebot.sql
 create mode 100644 src/plugins/CMakeLists.txt
 create mode 100644 src/plugins/ahbot/AhBot.cpp
 create mode 100644 src/plugins/ahbot/AhBot.h
 create mode 100644 src/plugins/ahbot/AhBotConfig.cpp
 create mode 100644 src/plugins/ahbot/AhBotConfig.h
 create mode 100644 src/plugins/ahbot/Category.cpp
 create mode 100644 src/plugins/ahbot/Category.h
 create mode 100644 src/plugins/ahbot/ConsumableCategory.cpp
 create mode 100644 src/plugins/ahbot/ConsumableCategory.h
 create mode 100644 src/plugins/ahbot/ItemBag.cpp
 create mode 100644 src/plugins/ahbot/ItemBag.h
 create mode 100644 src/plugins/ahbot/PricingStrategy.cpp
 create mode 100644 src/plugins/ahbot/PricingStrategy.h
 create mode 100644 src/plugins/ahbot/TradeCategory.cpp
 create mode 100644 src/plugins/ahbot/TradeCategory.h
 create mode 100644 src/plugins/ahbot/ahbot.conf.dist.in
 create mode 100644 src/plugins/pch/pch.cpp
 create mode 100644 src/plugins/pch/pch.h
 create mode 100644 src/plugins/pchdef.h
 create mode 100644 src/plugins/playerbot/AiFactory.cpp
 create mode 100644 src/plugins/playerbot/AiFactory.h
 create mode 100644 src/plugins/playerbot/ChatFilter.cpp
 create mode 100644 src/plugins/playerbot/ChatFilter.h
 create mode 100644 src/plugins/playerbot/ChatHelper.cpp
 create mode 100644 src/plugins/playerbot/ChatHelper.h
 create mode 100644 src/plugins/playerbot/FleeManager.cpp
 create mode 100644 src/plugins/playerbot/FleeManager.h
 create mode 100644 src/plugins/playerbot/GuildTaskMgr.cpp
 create mode 100644 src/plugins/playerbot/GuildTaskMgr.h
 create mode 100644 src/plugins/playerbot/Helpers.cpp
 create mode 100644 src/plugins/playerbot/LazyCalculatedValue.h
 create mode 100644 src/plugins/playerbot/LootObjectStack.cpp
 create mode 100644 src/plugins/playerbot/LootObjectStack.h
 create mode 100644 src/plugins/playerbot/PlayerbotAI.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAI.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIAware.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIBase.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAIBase.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIConfig.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAIConfig.h
 create mode 100644 src/plugins/playerbot/PlayerbotCommandServer.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotCommandServer.h
 create mode 100644 src/plugins/playerbot/PlayerbotFactory.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotFactory.h
 create mode 100644 src/plugins/playerbot/PlayerbotMgr.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotMgr.h
 create mode 100644 src/plugins/playerbot/PlayerbotSecurity.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotSecurity.h
 create mode 100644 src/plugins/playerbot/RandomItemMgr.cpp
 create mode 100644 src/plugins/playerbot/RandomItemMgr.h
 create mode 100644 src/plugins/playerbot/RandomPlayerbotFactory.cpp
 create mode 100644 src/plugins/playerbot/RandomPlayerbotFactory.h
 create mode 100644 src/plugins/playerbot/RandomPlayerbotMgr.cpp
 create mode 100644 src/plugins/playerbot/RandomPlayerbotMgr.h
 create mode 100644 src/plugins/playerbot/aiplayerbot.conf.dist.in
 create mode 100644 src/plugins/playerbot/playerbot.h
 create mode 100644 src/plugins/playerbot/playerbotDefs.h
 create mode 100644 src/plugins/playerbot/strategy/Action.cpp
 create mode 100644 src/plugins/playerbot/strategy/Action.h
 create mode 100644 src/plugins/playerbot/strategy/ActionBasket.cpp
 create mode 100644 src/plugins/playerbot/strategy/ActionBasket.h
 create mode 100644 src/plugins/playerbot/strategy/AiObject.cpp
 create mode 100644 src/plugins/playerbot/strategy/AiObject.h
 create mode 100644 src/plugins/playerbot/strategy/AiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/AiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/CustomStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/CustomStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/Engine.cpp
 create mode 100644 src/plugins/playerbot/strategy/Engine.h
 create mode 100644 src/plugins/playerbot/strategy/Event.cpp
 create mode 100644 src/plugins/playerbot/strategy/Event.h
 create mode 100644 src/plugins/playerbot/strategy/ExternalEventHelper.h
 create mode 100644 src/plugins/playerbot/strategy/ItemVisitors.h
 create mode 100644 src/plugins/playerbot/strategy/Multiplier.cpp
 create mode 100644 src/plugins/playerbot/strategy/Multiplier.h
 create mode 100644 src/plugins/playerbot/strategy/NamedObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/PassiveMultiplier.cpp
 create mode 100644 src/plugins/playerbot/strategy/PassiveMultiplier.h
 create mode 100644 src/plugins/playerbot/strategy/Queue.cpp
 create mode 100644 src/plugins/playerbot/strategy/Queue.h
 create mode 100644 src/plugins/playerbot/strategy/Strategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/Strategy.h
 create mode 100644 src/plugins/playerbot/strategy/StrategyContext.h
 create mode 100644 src/plugins/playerbot/strategy/Trigger.cpp
 create mode 100644 src/plugins/playerbot/strategy/Trigger.h
 create mode 100644 src/plugins/playerbot/strategy/Value.cpp
 create mode 100644 src/plugins/playerbot/strategy/Value.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AddLootAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AddLootAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AttackAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AttackAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BankAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BankAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BuffAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BuffAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BuyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BuyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeChatAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMailAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/DestroyItemAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/DropQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/EmoteAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/EmoteAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/EquipAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/EquipAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/FollowActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/FollowActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericSpellActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GossipHelloAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildBankAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/HelpAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/HelpAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LfgActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LfgActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ListQuestsActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ListSpellsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LogLevelAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootRollAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootRollAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootStrategyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/MovementActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/MovementActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/NonCombatActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/PositionAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/PositionAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReachTargetActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RepairAllAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ResetAiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RewardAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RewardAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RtiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SaveManaAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SayAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SayAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SellAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SellAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SetHomeAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/StatsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/StatsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/StayActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/StayActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TaxiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TaxiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TeleportAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TeleportAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellItemCountAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellLosAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellLosAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellMasterAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellReputationAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellTargetAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeStatusAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TrainerAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TrainerAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UnequipAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UnequipAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UseItemAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UseItemAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/WhoAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/WhoAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidBearActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidCatActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/CombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DeadStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DuelStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/EmoteStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/FleeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/GrindingStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/GuardStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/KiteStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/PassiveStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PullStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/PullStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/QuestStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RacialsStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RunawayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/SayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/SayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/StayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/StayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ThreatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterActions.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/FireMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageActions.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinActions.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestActions.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueComboActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanActions.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/CureTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/GenericTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/HealthTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/LfgTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/LootTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/RangeTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/TriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AoeHealValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AoeHealValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerCountValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackersValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackersValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AvailableLootValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CcTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CcTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ChatValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DistanceValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/DpsTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/DuelTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/Formations.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/Formations.h
 create mode 100644 src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/GrindTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/HasTotemValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/InvalidTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsBehindValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsFacingValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsMovingValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemCountValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemCountValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemForSpellValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemUsageValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastMovementValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSaidValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSpellCastValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LfgValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/LineTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/LineTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LogLevelValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LootStrategyValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/MasterTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestAdsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestGameObjects.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestNpcsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestUnitsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PetTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PositionValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PositionValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/RtiTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/RtiValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/RtiValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SelfTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SpellIdValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/SpellIdValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/StatsValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/StatsValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/TankTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/TankTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/TargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/TargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ThreatValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ThreatValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/ValueContext.h
 create mode 100644 src/plugins/playerbot/strategy/values/formations/Arrow.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/formations/Arrow.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockActions.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorActions.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
 create mode 100644 src/server/game/Handlers/CharacterHandler.cpp.orig
 create mode 100644 src/server/game/World/World.cpp.orig
 create mode 100644 src/test/AcceptAllQuestStrategyTestCase.cpp
 create mode 100644 src/test/AiObjectContextWrapper.h
 create mode 100644 src/test/ArcaneMageTestCase.cpp
 create mode 100644 src/test/BearTankDruidTestCase.cpp
 create mode 100644 src/test/CMakeLists.txt
 create mode 100644 src/test/CasterDruidTestCase.cpp
 create mode 100644 src/test/CasterShamanTestCase.cpp
 create mode 100644 src/test/CatDpsDruidTestCase.cpp
 create mode 100644 src/test/ChatCommandTestCase.cpp
 create mode 100644 src/test/ChatFilterTestCase.cpp
 create mode 100644 src/test/DpsHunterEngineTestCase.cpp
 create mode 100644 src/test/DpsPaladinTestCase.cpp
 create mode 100644 src/test/DpsPriestTestCase.cpp
 create mode 100644 src/test/DpsRogueTestCase.cpp
 create mode 100644 src/test/DpsWarlockTestCase.cpp
 create mode 100644 src/test/DpsWarriorTestCase.cpp
 create mode 100644 src/test/DruidNonCombatTestCase.cpp
 create mode 100644 src/test/DuelTestCase.cpp
 create mode 100644 src/test/EngineTestBase.cpp
 create mode 100644 src/test/EngineTestBase.h
 create mode 100644 src/test/EngineTestCase.cpp
 create mode 100644 src/test/EventTestCase.cpp
 create mode 100644 src/test/EverythingUnavailableAiManagerRegistry.h
 create mode 100644 src/test/ExternalEventHelperTestCase.cpp
 create mode 100644 src/test/FireMageTestCase.cpp
 create mode 100644 src/test/FrostMageTestCase.cpp
 create mode 100644 src/test/GenericTestCase.cpp
 create mode 100644 src/test/HealDruidTestCase.cpp
 create mode 100644 src/test/HealPriestTestCase.cpp
 create mode 100644 src/test/HealShamanTestCase.cpp
 create mode 100644 src/test/HolyPriestTestCase.cpp
 create mode 100644 src/test/HunterNonCombatTestCase.cpp
 create mode 100644 src/test/KiteTestCase.cpp
 create mode 100644 src/test/LootObjectStackTestCase.cpp
 create mode 100644 src/test/MageNonCombatTestCase.cpp
 create mode 100644 src/test/MeleeShamanTestCase.cpp
 create mode 100644 src/test/MockAiObjectContext.cpp
 create mode 100644 src/test/MockAiObjectContext.h
 create mode 100644 src/test/MockPlayerbotAIBase.cpp
 create mode 100644 src/test/MockPlayerbotAIBase.h
 create mode 100644 src/test/MockedAiObjectContextTestCase.h
 create mode 100644 src/test/MockedTargets.h
 create mode 100644 src/test/NextActionTestCase.cpp
 create mode 100644 src/test/NonCombatEngineTestCase.cpp
 create mode 100644 src/test/NonCombatEngineTestCase2.cpp
 create mode 100644 src/test/PaladinNonCombatTestCase.cpp
 create mode 100644 src/test/PerformanceTestCase.cpp
 create mode 100644 src/test/PriestNonCombatTestCase.cpp
 create mode 100644 src/test/QualifiedValueTestCase.cpp
 create mode 100644 src/test/QuestStrategyTestCase.cpp
 create mode 100644 src/test/QueueTestCase.cpp
 create mode 100644 src/test/RacialsTestCase.cpp
 create mode 100644 src/test/RandomItemMgrTestCase.cpp
 create mode 100644 src/test/SayStrategyTestCase.cpp
 create mode 100644 src/test/ShamanNonCombatTestCase.cpp
 create mode 100644 src/test/TankPaladinTestCase.cpp
 create mode 100644 src/test/TankWarlockTestCase.cpp
 create mode 100644 src/test/TankWarriorTestCase.cpp
 create mode 100644 src/test/ValueTestCase.cpp
 create mode 100644 src/test/WarlockNonCombatTestCase.cpp
 create mode 100644 src/test/WarrirorNonCombatTestCase.cpp
 create mode 100644 src/test/WorldPacketHandlerTestCase.cpp
 create mode 100644 src/test/aitest.h
 create mode 100644 src/test/cppunit/AdditionalMessage.cpp
 create mode 100644 src/test/cppunit/AdditionalMessage.h
 create mode 100644 src/test/cppunit/Asserter.cpp
 create mode 100644 src/test/cppunit/Asserter.h
 create mode 100644 src/test/cppunit/BeOsDynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/BriefTestProgressListener.cpp
 create mode 100644 src/test/cppunit/BriefTestProgressListener.h
 create mode 100644 src/test/cppunit/CompilerOutputter.cpp
 create mode 100644 src/test/cppunit/CompilerOutputter.h
 create mode 100644 src/test/cppunit/DefaultProtector.cpp
 create mode 100644 src/test/cppunit/DefaultProtector.h
 create mode 100644 src/test/cppunit/DllMain.cpp
 create mode 100644 src/test/cppunit/DynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/DynamicLibraryManagerException.cpp
 create mode 100644 src/test/cppunit/Exception.cpp
 create mode 100644 src/test/cppunit/Exception.h
 create mode 100644 src/test/cppunit/Makefile.am
 create mode 100644 src/test/cppunit/Makefile.in
 create mode 100644 src/test/cppunit/Message.cpp
 create mode 100644 src/test/cppunit/Message.h
 create mode 100644 src/test/cppunit/Outputter.h
 create mode 100644 src/test/cppunit/PlugInManager.cpp
 create mode 100644 src/test/cppunit/PlugInParameters.cpp
 create mode 100644 src/test/cppunit/Portability.h
 create mode 100644 src/test/cppunit/Protector.cpp
 create mode 100644 src/test/cppunit/Protector.h
 create mode 100644 src/test/cppunit/ProtectorChain.cpp
 create mode 100644 src/test/cppunit/ProtectorChain.h
 create mode 100644 src/test/cppunit/ProtectorContext.h
 create mode 100644 src/test/cppunit/RepeatedTest.cpp
 create mode 100644 src/test/cppunit/ShlDynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/SourceLine.cpp
 create mode 100644 src/test/cppunit/SourceLine.h
 create mode 100644 src/test/cppunit/StringTools.cpp
 create mode 100644 src/test/cppunit/SynchronizedObject.cpp
 create mode 100644 src/test/cppunit/SynchronizedObject.h
 create mode 100644 src/test/cppunit/Test.cpp
 create mode 100644 src/test/cppunit/Test.h
 create mode 100644 src/test/cppunit/TestAssert.cpp
 create mode 100644 src/test/cppunit/TestAssert.h
 create mode 100644 src/test/cppunit/TestCaller.h
 create mode 100644 src/test/cppunit/TestCase.cpp
 create mode 100644 src/test/cppunit/TestCase.h
 create mode 100644 src/test/cppunit/TestCaseDecorator.cpp
 create mode 100644 src/test/cppunit/TestComposite.cpp
 create mode 100644 src/test/cppunit/TestComposite.h
 create mode 100644 src/test/cppunit/TestDecorator.cpp
 create mode 100644 src/test/cppunit/TestFactoryRegistry.cpp
 create mode 100644 src/test/cppunit/TestFailure.cpp
 create mode 100644 src/test/cppunit/TestFailure.h
 create mode 100644 src/test/cppunit/TestFixture.h
 create mode 100644 src/test/cppunit/TestLeaf.cpp
 create mode 100644 src/test/cppunit/TestLeaf.h
 create mode 100644 src/test/cppunit/TestListener.h
 create mode 100644 src/test/cppunit/TestNamer.cpp
 create mode 100644 src/test/cppunit/TestPath.cpp
 create mode 100644 src/test/cppunit/TestPath.h
 create mode 100644 src/test/cppunit/TestPlugInDefaultImpl.cpp
 create mode 100644 src/test/cppunit/TestResult.cpp
 create mode 100644 src/test/cppunit/TestResult.h
 create mode 100644 src/test/cppunit/TestResultCollector.cpp
 create mode 100644 src/test/cppunit/TestResultCollector.h
 create mode 100644 src/test/cppunit/TestRunner.cpp
 create mode 100644 src/test/cppunit/TestRunner.h
 create mode 100644 src/test/cppunit/TestSetUp.cpp
 create mode 100644 src/test/cppunit/TestSuccessListener.cpp
 create mode 100644 src/test/cppunit/TestSuccessListener.h
 create mode 100644 src/test/cppunit/TestSuite.cpp
 create mode 100644 src/test/cppunit/TestSuite.h
 create mode 100644 src/test/cppunit/TestSuiteBuilderContext.cpp
 create mode 100644 src/test/cppunit/TextOutputter.cpp
 create mode 100644 src/test/cppunit/TextOutputter.h
 create mode 100644 src/test/cppunit/TextTestProgressListener.cpp
 create mode 100644 src/test/cppunit/TextTestProgressListener.h
 create mode 100644 src/test/cppunit/TextTestResult.cpp
 create mode 100644 src/test/cppunit/TextTestResult.h
 create mode 100644 src/test/cppunit/TextTestRunner.cpp
 create mode 100644 src/test/cppunit/TextTestRunner.h
 create mode 100644 src/test/cppunit/TypeInfoHelper.cpp
 create mode 100644 src/test/cppunit/UnixDynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/Win32DynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/XmlDocument.cpp
 create mode 100644 src/test/cppunit/XmlElement.cpp
 create mode 100644 src/test/cppunit/XmlOutputter.cpp
 create mode 100644 src/test/cppunit/XmlOutputter.h
 create mode 100644 src/test/cppunit/XmlOutputterHook.cpp
 create mode 100644 src/test/cppunit/XmlOutputterHook.h
 create mode 100644 src/test/cppunit/config/CppUnitApi.h
 create mode 100644 src/test/cppunit/config/Makefile.am
 create mode 100644 src/test/cppunit/config/Makefile.in
 create mode 100644 src/test/cppunit/config/SelectDllLoader.h
 create mode 100644 src/test/cppunit/config/SourcePrefix.h
 create mode 100644 src/test/cppunit/config/config-bcb5.h
 create mode 100644 src/test/cppunit/config/config-evc4.h
 create mode 100644 src/test/cppunit/config/config-mac.h
 create mode 100644 src/test/cppunit/config/config-msvc6.h
 create mode 100644 src/test/cppunit/cppunit.dsp
 create mode 100644 src/test/cppunit/cppunit_dll.dsp
 create mode 100644 src/test/cppunit/extensions/AutoRegisterSuite.h
 create mode 100644 src/test/cppunit/extensions/ExceptionTestCaseDecorator.h
 create mode 100644 src/test/cppunit/extensions/HelperMacros.h
 create mode 100644 src/test/cppunit/extensions/Makefile.am
 create mode 100644 src/test/cppunit/extensions/Makefile.in
 create mode 100644 src/test/cppunit/extensions/Orthodox.h
 create mode 100644 src/test/cppunit/extensions/RepeatedTest.h
 create mode 100644 src/test/cppunit/extensions/TestCaseDecorator.h
 create mode 100644 src/test/cppunit/extensions/TestDecorator.h
 create mode 100644 src/test/cppunit/extensions/TestFactory.h
 create mode 100644 src/test/cppunit/extensions/TestFactoryRegistry.h
 create mode 100644 src/test/cppunit/extensions/TestFixtureFactory.h
 create mode 100644 src/test/cppunit/extensions/TestNamer.h
 create mode 100644 src/test/cppunit/extensions/TestSetUp.h
 create mode 100644 src/test/cppunit/extensions/TestSuiteBuilderContext.h
 create mode 100644 src/test/cppunit/extensions/TestSuiteFactory.h
 create mode 100644 src/test/cppunit/extensions/TypeInfoHelper.h
 create mode 100644 src/test/cppunit/plugin/DynamicLibraryManager.h
 create mode 100644 src/test/cppunit/plugin/DynamicLibraryManagerException.h
 create mode 100644 src/test/cppunit/plugin/Makefile.am
 create mode 100644 src/test/cppunit/plugin/Makefile.in
 create mode 100644 src/test/cppunit/plugin/PlugInManager.h
 create mode 100644 src/test/cppunit/plugin/PlugInParameters.h
 create mode 100644 src/test/cppunit/plugin/TestPlugIn.h
 create mode 100644 src/test/cppunit/plugin/TestPlugInDefaultImpl.h
 create mode 100644 src/test/cppunit/portability/CppUnitDeque.h
 create mode 100644 src/test/cppunit/portability/CppUnitMap.h
 create mode 100644 src/test/cppunit/portability/CppUnitSet.h
 create mode 100644 src/test/cppunit/portability/CppUnitStack.h
 create mode 100644 src/test/cppunit/portability/CppUnitVector.h
 create mode 100644 src/test/cppunit/portability/FloatingPoint.h
 create mode 100644 src/test/cppunit/portability/Makefile.am
 create mode 100644 src/test/cppunit/portability/Makefile.in
 create mode 100644 src/test/cppunit/portability/Stream.h
 create mode 100644 src/test/cppunit/tools/Algorithm.h
 create mode 100644 src/test/cppunit/tools/Makefile.am
 create mode 100644 src/test/cppunit/tools/Makefile.in
 create mode 100644 src/test/cppunit/tools/StringTools.h
 create mode 100644 src/test/cppunit/tools/XmlDocument.h
 create mode 100644 src/test/cppunit/tools/XmlElement.h
 create mode 100644 src/test/cppunit/ui/Makefile.am
 create mode 100644 src/test/cppunit/ui/Makefile.in
 create mode 100644 src/test/cppunit/ui/mfc/Makefile.am
 create mode 100644 src/test/cppunit/ui/mfc/Makefile.in
 create mode 100644 src/test/cppunit/ui/mfc/MfcTestRunner.h
 create mode 100644 src/test/cppunit/ui/mfc/TestRunner.h
 create mode 100644 src/test/cppunit/ui/qt/Config.h
 create mode 100644 src/test/cppunit/ui/qt/Makefile.am
 create mode 100644 src/test/cppunit/ui/qt/Makefile.in
 create mode 100644 src/test/cppunit/ui/qt/QtTestRunner.h
 create mode 100644 src/test/cppunit/ui/qt/TestRunner.h
 create mode 100644 src/test/cppunit/ui/text/Makefile.am
 create mode 100644 src/test/cppunit/ui/text/Makefile.in
 create mode 100644 src/test/cppunit/ui/text/TestRunner.h
 create mode 100644 src/test/cppunit/ui/text/TextTestRunner.h
 create mode 100644 src/test/efficiency/AbstractEfficiencyTestCase.h
 create mode 100644 src/test/efficiency/DruidEfficiencyTestCase.cpp
 create mode 100644 src/test/efficiency/EfficiencyActionExecutionListener.cpp
 create mode 100644 src/test/efficiency/EfficiencyActionExecutionListener.h
 create mode 100644 src/test/efficiency/MageEfficiencyTestCase.cpp
 create mode 100644 src/test/efficiency/PriestEfficiencyTestCase.cpp
 create mode 100644 src/test/efficiency/ShamanEfficiencyTestCase.cpp
 create mode 100644 src/test/efficiency/WarlockEfficiencyTestCase.cpp
 create mode 100644 src/test/main.cpp
 create mode 100644 src/test/pch.cpp
 create mode 100644 src/test/pch.h

diff --git a/.gitignore b/.gitignore
index 0fb3980..fed272f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -16,7 +16,9 @@ CMakeLists.txt.user
 *.BACKUP.*
 *.BASE.*
 *.LOCAL.*
+/cmake/
 nbproject/*
+workspace
 .idea/*
 .browse.VC*
 .vscode
diff --git a/cmake/options.cmake b/cmake/options.cmake
index 80f07b1..f1cb2ea 100644
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -51,3 +51,4 @@ option(WITH_COREDEBUG   "Include additional debug-code in core"
 set(WITH_SOURCE_TREE    "hierarchical" CACHE STRING "Build the source tree for IDE's.")
 set_property(CACHE WITH_SOURCE_TREE PROPERTY STRINGS no flat hierarchical hierarchical-folders)
 option(WITHOUT_GIT      "Disable the GIT testing routines"                            0)
+option(TESTS            "Build cppunit tests"                                         0)
diff --git a/cmake/options.cmake.orig b/cmake/options.cmake.orig
new file mode 100644
index 0000000..80f07b1
--- /dev/null
+++ b/cmake/options.cmake.orig
@@ -0,0 +1,53 @@
+# Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+option(SERVERS          "Build worldserver and authserver"                            1)
+
+set(SCRIPTS_AVAILABLE_OPTIONS none static dynamic minimal-static minimal-dynamic)
+
+# Log a fatal error when the value of the SCRIPTS variable isn't a valid option.
+if (SCRIPTS)
+  list (FIND SCRIPTS_AVAILABLE_OPTIONS "${SCRIPTS}" SCRIPTS_INDEX)
+  if (${SCRIPTS_INDEX} EQUAL -1)
+    message(FATAL_ERROR "The value (${SCRIPTS}) of your SCRIPTS variable is invalid! "
+                        "Allowed values are: ${SCRIPTS_AVAILABLE_OPTIONS} if you still "
+                        "have problems search on forum for TCE00019.")
+  endif()
+endif()
+
+set(SCRIPTS "static" CACHE STRING "Build core with scripts")
+set_property(CACHE SCRIPTS PROPERTY STRINGS ${SCRIPTS_AVAILABLE_OPTIONS})
+
+# Build a list of all script modules when -DSCRIPT="custom" is selected
+GetScriptModuleList(SCRIPT_MODULE_LIST)
+foreach(SCRIPT_MODULE ${SCRIPT_MODULE_LIST})
+  ScriptModuleNameToVariable(${SCRIPT_MODULE} SCRIPT_MODULE_VARIABLE)
+  set(${SCRIPT_MODULE_VARIABLE} "default" CACHE STRING "Build type of the ${SCRIPT_MODULE} module.")
+  set_property(CACHE ${SCRIPT_MODULE_VARIABLE} PROPERTY STRINGS default disabled static dynamic)
+endforeach()
+
+option(TOOLS            "Build map/vmap/mmap extraction/assembler tools"              0)
+option(USE_SCRIPTPCH    "Use precompiled headers when compiling scripts"              1)
+option(USE_COREPCH      "Use precompiled headers when compiling servers"              1)
+option(WITH_DYNAMIC_LINKING "Enable dynamic library linking."                         0)
+IsDynamicLinkingRequired(WITH_DYNAMIC_LINKING_FORCED)
+if (WITH_DYNAMIC_LINKING AND WITH_DYNAMIC_LINKING_FORCED)
+  set(WITH_DYNAMIC_LINKING_FORCED OFF)
+endif()
+if (WITH_DYNAMIC_LINKING OR WITH_DYNAMIC_LINKING_FORCED)
+  set(BUILD_SHARED_LIBS ON)
+else()
+  set(BUILD_SHARED_LIBS OFF)
+endif()
+option(WITH_WARNINGS    "Show all warnings during compile"                            0)
+option(WITH_COREDEBUG   "Include additional debug-code in core"                       0)
+set(WITH_SOURCE_TREE    "hierarchical" CACHE STRING "Build the source tree for IDE's.")
+set_property(CACHE WITH_SOURCE_TREE PROPERTY STRINGS no flat hierarchical hierarchical-folders)
+option(WITHOUT_GIT      "Disable the GIT testing routines"                            0)
diff --git a/sql/ai_playerbot_guild_names.sql b/sql/ai_playerbot_guild_names.sql
new file mode 100644
index 0000000..8ea74de
--- /dev/null
+++ b/sql/ai_playerbot_guild_names.sql
@@ -0,0 +1,652 @@
+DROP TABLE IF EXISTS `ai_playerbot_guild_names`;
+CREATE TABLE `ai_playerbot_guild_names` (
+  `name_id` mediumint(8) NOT NULL AUTO_INCREMENT UNIQUE,
+  `name` varchar(24) NOT NULL UNIQUE,
+  PRIMARY KEY (`name_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='PlayerbotAI guild names';
+
+
+
+LOCK TABLES `ai_playerbot_guild_names` WRITE;
+INSERT INTO `ai_playerbot_guild_names` VALUES
+(NULL, 'Black Guard'),
+(NULL, 'Abyssal Kingdoms'),
+(NULL, 'Acid Evil'),
+(NULL, 'Addicts Muskateers'),
+(NULL, 'Adventurers War'),
+(NULL, 'Age of Red Water Clan'),
+(NULL, 'Alivso Reason'),
+(NULL, 'All Knights'),
+(NULL, 'Allegiance of the Vile'),
+(NULL, 'Alliance Clan'),
+(NULL, 'Alliance of Defectives'),
+(NULL, 'Alti Legions'),
+(NULL, 'Anarchie Shi'),
+(NULL, 'Anchors of the Nominal'),
+(NULL, 'Ancients of Part Times'),
+(NULL, 'Angelus Gods'),
+(NULL, 'Angry Party'),
+(NULL, 'Apocalyptic Lamont'),
+(NULL, 'Architects of Green'),
+(NULL, 'Army of Black Widows'),
+(NULL, 'Army of Orgrimmar Minds'),
+(NULL, 'Army of Three Horses'),
+(NULL, 'Arrows of Midlight'),
+(NULL, 'Artisans of Best Guild'),
+(NULL, 'Assasins of the Pyrewood'),
+(NULL, 'Assassins Bane'),
+(NULL, 'Avatars of Warsong Stuff'),
+(NULL, 'Axis of the Funky Night'),
+(NULL, 'Azeroth Souls'),
+(NULL, 'Azeroths Rabbits'),
+(NULL, 'Bad Sentinels'),
+(NULL, 'Banana Song'),
+(NULL, 'Band of Tarantula Attack'),
+(NULL, 'Band of the Dark Reveren'),
+(NULL, 'Barcode Praised'),
+(NULL, 'Basher Goats'),
+(NULL, 'Basic Order'),
+(NULL, 'Batman of Banished'),
+(NULL, 'Betrayers of Lucky Child'),
+(NULL, 'Blackwater Committee'),
+(NULL, 'Blades of Lich Kings'),
+(NULL, 'Blades of the Hive'),
+(NULL, 'Blades of the Total'),
+(NULL, 'Bleeding War'),
+(NULL, 'Blessed Lair'),
+(NULL, 'Blizzards of the Iron'),
+(NULL, 'Blood Chaos'),
+(NULL, 'Blood Intrigue'),
+(NULL, 'Blood Samurai'),
+(NULL, 'Bloodlust Good'),
+(NULL, 'Bonds of Reported Ignore'),
+(NULL, 'Booty Cry'),
+(NULL, 'Border Knights'),
+(NULL, 'Bossmans Targaryen'),
+(NULL, 'Braveheart Heaven'),
+(NULL, 'Brotherhood of Twilight'),
+(NULL, 'Bruised Pain'),
+(NULL, 'Burning Control'),
+(NULL, 'Burning Oblivion'),
+(NULL, 'Cabal of Kalimdor'),
+(NULL, 'Cake Crusade'),
+(NULL, 'Call of the Ironforge'),
+(NULL, 'Carebears Thunder'),
+(NULL, 'Carpe Heaven'),
+(NULL, 'Carpe Regiment'),
+(NULL, 'Children of Order'),
+(NULL, 'Children of the Gods'),
+(NULL, 'Circle of Amor E Bobby'),
+(NULL, 'Clan of the Elven Toys'),
+(NULL, 'Clan of the Strike Light'),
+(NULL, 'Coalition of Super Best'),
+(NULL, 'Collective Pimps'),
+(NULL, 'Companions of the Gnome'),
+(NULL, 'Company of the Vibe'),
+(NULL, 'Conclave of the Triad'),
+(NULL, 'Council of Final Demise'),
+(NULL, 'Council of Hard Core Ord'),
+(NULL, 'Craaweh Thrall'),
+(NULL, 'Cradle Scourge'),
+(NULL, 'Crimson Angels'),
+(NULL, 'Crimson Saints'),
+(NULL, 'Crusade of Oh'),
+(NULL, 'Crusaders of Undead'),
+(NULL, 'Cryptic Serenity'),
+(NULL, 'Csa Rigged'),
+(NULL, 'Cult of the Raging Raid'),
+(NULL, 'Dalaran Fair'),
+(NULL, 'Damage Inc'),
+(NULL, 'Dark Alliance'),
+(NULL, 'Dark Azeroth'),
+(NULL, 'Dark Damage'),
+(NULL, 'Dark Resistus'),
+(NULL, 'Dark Samurai'),
+(NULL, 'Dark Turtles'),
+(NULL, 'Darken Mercenaries'),
+(NULL, 'Darkened Malevolence'),
+(NULL, 'Darkness of Sword Coast'),
+(NULL, 'Dawn of Knights Society'),
+(NULL, 'Dawn of Mad Sentry'),
+(NULL, 'Dead Zug'),
+(NULL, 'Death Darkness'),
+(NULL, 'Death Knights'),
+(NULL, 'Deathlike Goods'),
+(NULL, 'Deaths Venoms'),
+(NULL, 'Decree of the Phumpers'),
+(NULL, 'Defenders of Da Raised'),
+(NULL, 'Defenders of Hyuuga Dark'),
+(NULL, 'Defenders of Sacred Harm'),
+(NULL, 'Deths Lords'),
+(NULL, 'Devil Circl'),
+(NULL, 'Devils Klng'),
+(NULL, 'Dharma Hand'),
+(NULL, 'Dharma Thorn'),
+(NULL, 'Dies Ravager'),
+(NULL, 'Disciples of Dead Panda'),
+(NULL, 'Disciples of the Rot'),
+(NULL, 'Doomsday Youth'),
+(NULL, 'Dorcha Knights'),
+(NULL, 'Dots of Dead Skull'),
+(NULL, 'Dragon Arms'),
+(NULL, 'Dragonhawk Revolution'),
+(NULL, 'Dragons Erythnul'),
+(NULL, 'Dragons of the Black'),
+(NULL, 'Drunken Thunder'),
+(NULL, 'Drunks of Matoskan'),
+(NULL, 'Dwarven Rock'),
+(NULL, 'Dynasty of the Emerald'),
+(NULL, 'Eastern Asylum'),
+(NULL, 'Echo Sanctus'),
+(NULL, 'Echoes of the Muphin'),
+(NULL, 'Effreno Death'),
+(NULL, 'Elite Guild'),
+(NULL, 'Elite Legion'),
+(NULL, 'Elite Veritas'),
+(NULL, 'Elunes Meat'),
+(NULL, 'Emerald Men'),
+(NULL, 'Emerald Mjolnir'),
+(NULL, 'Endless Defense'),
+(NULL, 'Enemies of Bleeding'),
+(NULL, 'Enternal Saber'),
+(NULL, 'Evictors of the Returned'),
+(NULL, 'Evil Guard'),
+(NULL, 'Exalted Effect'),
+(NULL, 'Eyes of a Night Elf'),
+(NULL, 'Eyes of the Elton Souls'),
+(NULL, 'Fallen Clan'),
+(NULL, 'Fallen Milk'),
+(NULL, 'Fenrir Seeker'),
+(NULL, 'Final Army'),
+(NULL, 'Flames of Ale Drinkers'),
+(NULL, 'Flames of Antarian Chaos'),
+(NULL, 'Forestt''s Wrath'),
+(NULL, 'Forgotten Within'),
+(NULL, 'From Synergy'),
+(NULL, 'Frozen Oblivion'),
+(NULL, 'Gashlycrumb Rollers'),
+(NULL, 'Giovannitwos Elune'),
+(NULL, 'Glass Meridian'),
+(NULL, 'Gnome Faction'),
+(NULL, 'Gods Gold'),
+(NULL, 'Gods of the Complete'),
+(NULL, 'Gold Catchers'),
+(NULL, 'Golden Legendz'),
+(NULL, 'Golden Souls'),
+(NULL, 'Goldshire Goats'),
+(NULL, 'Good Azeroth'),
+(NULL, 'Gotz Safety'),
+(NULL, 'Grammaton Alliance'),
+(NULL, 'Great Circle'),
+(NULL, 'Guardians of Honor'),
+(NULL, 'Guards of Frostmane'),
+(NULL, 'Guild of La Mano Dragons'),
+(NULL, 'Guild of the Puppet'),
+(NULL, 'Haggles Brigade'),
+(NULL, 'Hammer of the Moral'),
+(NULL, 'Hand of the Iron'),
+(NULL, 'Hands of Far Con Buddies'),
+(NULL, 'Hearts Knights'),
+(NULL, 'Hell Angels'),
+(NULL, 'Hells Thorn'),
+(NULL, 'Holy Darnassus'),
+(NULL, 'Horde Abh'),
+(NULL, 'Horde Dragons'),
+(NULL, 'Horde Leaders'),
+(NULL, 'Horde Squad'),
+(NULL, 'Horde of Omnia'),
+(NULL, 'Horde of Free Brigade'),
+(NULL, 'Horde of Shadow Flush'),
+(NULL, 'Hordes Buccaneers'),
+(NULL, 'Hordes Marauders'),
+(NULL, 'House Crusaders'),
+(NULL, 'Immortality Honor'),
+(NULL, 'Inside Poof'),
+(NULL, 'Iron Boyz'),
+(NULL, 'Iscariot Ginas'),
+(NULL, 'Island Kimchi'),
+(NULL, 'Jenovas Wild'),
+(NULL, 'Kalimdor Darkness'),
+(NULL, 'Keepers of Golden Misery'),
+(NULL, 'Keggers of Alt Hand Aton'),
+(NULL, 'Kill Mafia'),
+(NULL, 'Killer Durotar'),
+(NULL, 'Killer Force'),
+(NULL, 'Kindred Yardies'),
+(NULL, 'Kindred of King Assassin'),
+(NULL, 'Kingdom of the Ordo Crew'),
+(NULL, 'Kings Boys'),
+(NULL, 'Kings Windstorm'),
+(NULL, 'Kings of Blood Knuckle'),
+(NULL, 'Kings of Dol Aegis'),
+(NULL, 'Knight Combat'),
+(NULL, 'Knight of Fuzzy Night'),
+(NULL, 'Knights of Darkspear'),
+(NULL, 'Knights of Heavens Grave'),
+(NULL, 'Knights of Myrmidon Ivxx'),
+(NULL, 'Knights of the Avenging'),
+(NULL, 'Knights of the Ballpeen'),
+(NULL, 'Knights of the Black'),
+(NULL, 'Knights of the Bloodhoof'),
+(NULL, 'Knights of the Sovereign'),
+(NULL, 'Knights of the Storm'),
+(NULL, 'Knights of the Zulian'),
+(NULL, 'Last Ptesanwi'),
+(NULL, 'League of Hate Crew Seek'),
+(NULL, 'Legacy of Ninth Beard'),
+(NULL, 'Legendary Sons'),
+(NULL, 'Legion of Maple Syrup'),
+(NULL, 'Legion of Public Works'),
+(NULL, 'Legion of Three Course'),
+(NULL, 'Legion of United Souls'),
+(NULL, 'Legion of Westfall Gold'),
+(NULL, 'Legion of the Dark'),
+(NULL, 'Legionnaires of Skull'),
+(NULL, 'Les Warriors'),
+(NULL, 'Lifetakers Inc'),
+(NULL, 'Light of Dark Spire'),
+(NULL, 'Light of Jade Renegade'),
+(NULL, 'Liquid Guild'),
+(NULL, 'Lone Side'),
+(NULL, 'Lords of Fallen Blood'),
+(NULL, 'Los Frum'),
+(NULL, 'Lost Boyz'),
+(NULL, 'Lost Squad'),
+(NULL, 'Mad Daggers'),
+(NULL, 'Malice Fatale'),
+(NULL, 'Mandate of Jade'),
+(NULL, 'Marines of the Butt'),
+(NULL, 'Mercenaries of the Death'),
+(NULL, 'Midget Council'),
+(NULL, 'Midgets of Dark Sexy'),
+(NULL, 'Midnight Norrathians'),
+(NULL, 'Midnight Slayer'),
+(NULL, 'Midnight War'),
+(NULL, 'Minions of the Shadow'),
+(NULL, 'Ministry of the Allince'),
+(NULL, 'Mithril Destiny'),
+(NULL, 'Monarchs of Party Crew'),
+(NULL, 'Money Call'),
+(NULL, 'Moonwood Redeye'),
+(NULL, 'Narrow Patrol'),
+(NULL, 'New Clan'),
+(NULL, 'Night Pack'),
+(NULL, 'Nightmare Guild'),
+(NULL, 'Ninja Pledge'),
+(NULL, 'Nocturne of Totally Dead'),
+(NULL, 'Obsidian Fish'),
+(NULL, 'Old Cosa'),
+(NULL, 'One Valor'),
+(NULL, 'Opus Faithful'),
+(NULL, 'Order of Alts oF Fate'),
+(NULL, 'Order of Nagas Bike Hunt'),
+(NULL, 'Order of Omega Wards'),
+(NULL, 'Order of Pink'),
+(NULL, 'Order of Shield Bed'),
+(NULL, 'Order of the Alt Sheep'),
+(NULL, 'Order of the Honor'),
+(NULL, 'Order of the Divine Lord'),
+(NULL, 'Ordo Force'),
+(NULL, 'Orgrimmar Ones'),
+(NULL, 'Out of Lw Downed Wrynn'),
+(NULL, 'Out of Mithril Avengers'),
+(NULL, 'Oxbloods Medivh'),
+(NULL, 'Pally Guard'),
+(NULL, 'Path of the Brain'),
+(NULL, 'Peddlers of the Hidden'),
+(NULL, 'Phantoms of Wicked'),
+(NULL, 'Phoenix Keepers'),
+(NULL, 'Pillowcase Azeroth'),
+(NULL, 'Pillowcase Cats'),
+(NULL, 'Pius Tribe'),
+(NULL, 'Plague of Human Slayer'),
+(NULL, 'Plan Hand'),
+(NULL, 'Power of Tuatha De Blood'),
+(NULL, 'Priest Guild'),
+(NULL, 'Prophets of Fatima War'),
+(NULL, 'Prophets of Outlaw'),
+(NULL, 'Prophets of the Red Mean'),
+(NULL, 'Protectors of Black Hand'),
+(NULL, 'Pure Aequitas'),
+(NULL, 'Question Thrall'),
+(NULL, 'Quintessential Sister'),
+(NULL, 'Rage of Prairie Black'),
+(NULL, 'Rage of the Flame'),
+(NULL, 'Raiders of Candy Heart'),
+(NULL, 'Raiders of the Purple'),
+(NULL, 'Raiders of the Sil'),
+(NULL, 'Ram Runners'),
+(NULL, 'Rangers Vengeance'),
+(NULL, 'Rangers of Interitus'),
+(NULL, 'Raven Clan'),
+(NULL, 'Razzle Guardian'),
+(NULL, 'Reapers of the Shadow'),
+(NULL, 'Reckless Knights'),
+(NULL, 'Red Byam'),
+(NULL, 'Red Death'),
+(NULL, 'Reign of Alliance Task'),
+(NULL, 'Reign of Blazing Frell'),
+(NULL, 'Reign of Pure Conway'),
+(NULL, 'Restoration of Illegal'),
+(NULL, 'Resurrection of Tenui'),
+(NULL, 'Ronin Kalimdor'),
+(NULL, 'Rotting Tears'),
+(NULL, 'Ruins of Dark Azeroth'),
+(NULL, 'Rulers of Devils'),
+(NULL, 'Sacred Parts'),
+(NULL, 'Sacred Society'),
+(NULL, 'Sacrificial Brotherhood'),
+(NULL, 'Sanguine Council'),
+(NULL, 'Sapphic Exiles'),
+(NULL, 'Savage Kalimdor'),
+(NULL, 'Scourge of Eight Inches'),
+(NULL, 'Scourge of Wow Knights'),
+(NULL, 'Scythe Sauce'),
+(NULL, 'Secret Clan'),
+(NULL, 'Seki Council'),
+(NULL, 'Seraph Legends'),
+(NULL, 'Shaded Judgement'),
+(NULL, 'Shadow America'),
+(NULL, 'Shadow Boys'),
+(NULL, 'Shadow Knights'),
+(NULL, 'Shadowed Ghosts'),
+(NULL, 'Shadowed Goat'),
+(NULL, 'Shadows of Cole Trainz'),
+(NULL, 'Shadows of Los Banditos'),
+(NULL, 'Shattered Stormrage'),
+(NULL, 'Silent Night'),
+(NULL, 'Silver Fools'),
+(NULL, 'Silversky Sun'),
+(NULL, 'Sisters of Kalimdor'),
+(NULL, 'Skulled Ironforge'),
+(NULL, 'Slayers of the Primals'),
+(NULL, 'Sleepy Steel'),
+(NULL, 'Soldiers of Azeroth'),
+(NULL, 'Soldiers of Stalker'),
+(NULL, 'Sons of Lambent Virtue'),
+(NULL, 'Sons of the Top Truth'),
+(NULL, 'Soul Wish'),
+(NULL, 'Souls of Elite Gnome'),
+(NULL, 'Spanaway Metalheadz'),
+(NULL, 'Spoony Demise'),
+(NULL, 'Squires of Sacred Tribe'),
+(NULL, 'Stagnant Jesters'),
+(NULL, 'Stars of Gear Farming'),
+(NULL, 'Stupid Crusaders'),
+(NULL, 'Stop Guides'),
+(NULL, 'Storm of the Mope''s'),
+(NULL, 'Stormrage Ferguson'),
+(NULL, 'Stormtroopers of Fatima '),
+(NULL, 'Stormwind Crew'),
+(NULL, 'Straight Caedes'),
+(NULL, 'Stronghold Angels'),
+(NULL, 'Sturgeon Empire'),
+(NULL, 'Survivors of Devil Club'),
+(NULL, 'Sweet Bear'),
+(NULL, 'Sword of Lost Evil'),
+(NULL, 'Tainted Bunnies'),
+(NULL, 'Talon of the Eclectic'),
+(NULL, 'Team Kingdom'),
+(NULL, 'Team United'),
+(NULL, 'Tears of Eternal Kitties'),
+(NULL, 'Tears of Phantom Druids'),
+(NULL, 'Templar of Raid Dodgers'),
+(NULL, 'Templars of Plagueware'),
+(NULL, 'Terra Totem'),
+(NULL, 'Terra War'),
+(NULL, 'The Abiem'),
+(NULL, 'The Aceofchaos'),
+(NULL, 'The Afterlife'),
+(NULL, 'The Aggression'),
+(NULL, 'The Alliance of Dark'),
+(NULL, 'The Altimate'),
+(NULL, 'The Ancona Fire'),
+(NULL, 'The Apocalypse'),
+(NULL, 'The Arcane Monkey'),
+(NULL, 'The Army of Spartans'),
+(NULL, 'The Avalon'),
+(NULL, 'The Avengers of Shining'),
+(NULL, 'The Azure Gangstaz'),
+(NULL, 'The Battlegnome'),
+(NULL, 'The Black Hand Haven'),
+(NULL, 'The Blackdraygon'),
+(NULL, 'The Blackout'),
+(NULL, 'The Blade'),
+(NULL, 'The Blades of Caer Eel'),
+(NULL, 'The Blades of Onyxia'),
+(NULL, 'The Blood Red Violence'),
+(NULL, 'The Blood of Red Powers'),
+(NULL, 'The Bloodycrusaders'),
+(NULL, 'The Blues Azeroth'),
+(NULL, 'The Blues Grimfang'),
+(NULL, 'The Bluethunder'),
+(NULL, 'The Bonds of Arcane'),
+(NULL, 'The Brimstone'),
+(NULL, 'The Broken Chaos'),
+(NULL, 'The Brood of Unknown'),
+(NULL, 'The Burning Dog Firewall'),
+(NULL, 'The Cabal'),
+(NULL, 'The Cake Gankers'),
+(NULL, 'The Cannabuddies'),
+(NULL, 'The Circle of Shadow'),
+(NULL, 'The Clan Blackwatch Few'),
+(NULL, 'The Clan Cats'),
+(NULL, 'The Clan Knights'),
+(NULL, 'The Clean Combinations'),
+(NULL, 'The Clean Up Guard'),
+(NULL, 'The Council of Dark'),
+(NULL, 'The Covenant'),
+(NULL, 'The Crimson Guild'),
+(NULL, 'The Crimson Marbock'),
+(NULL, 'The Crusaders of Horde'),
+(NULL, 'The Crusaders of Seksoni'),
+(NULL, 'The Cult of Clan Brigade'),
+(NULL, 'The Cult of the Pink'),
+(NULL, 'The Daggers of the Vile'),
+(NULL, 'The Dark'),
+(NULL, 'The Dark Dogs'),
+(NULL, 'The Dark Pain'),
+(NULL, 'The Darkfall'),
+(NULL, 'The Darkside Vanguard'),
+(NULL, 'The Darkside of Initium'),
+(NULL, 'The Daughters of the Elite'),
+(NULL, 'The Daytripper'),
+(NULL, 'The Deadfriends'),
+(NULL, 'The Defiant'),
+(NULL, 'The Dont Overwhelming'),
+(NULL, 'The Doom Pasta'),
+(NULL, 'The Dragon Redeye'),
+(NULL, 'The Dragons Flame'),
+(NULL, 'The Dreadlords'),
+(NULL, 'The Dublainn Crown'),
+(NULL, 'The Durban Protecters'),
+(NULL, 'The Echoes of Goldshire'),
+(NULL, 'The Elit of Dark Elune'),
+(NULL, 'The Emissaries of Furiou'),
+(NULL, 'The Eternal Chaos'),
+(NULL, 'The Eternus'),
+(NULL, 'The Exiie'),
+(NULL, 'The Expendable Shadow'),
+(NULL, 'The Faith of Desert'),
+(NULL, 'The Family Misfits'),
+(NULL, 'The Fere Darkness'),
+(NULL, 'The Final Tears'),
+(NULL, 'The Forsaken Boochies'),
+(NULL, 'The Gates of the Bloody'),
+(NULL, 'The Gnomes Lordaero'),
+(NULL, 'The Gods of Blackscar'),
+(NULL, 'The Gods of Twilight'),
+(NULL, 'The Gold Fighters'),
+(NULL, 'The Guardian Thieves'),
+(NULL, 'The Guardians of Gnome'),
+(NULL, 'The Hands of Redridge'),
+(NULL, 'The Hawk'),
+(NULL, 'The Hearts Images'),
+(NULL, 'The Hellborn Die'),
+(NULL, 'The Heroes Plague'),
+(NULL, 'The Horde Farmer'),
+(NULL, 'The Horde Honor'),
+(NULL, 'The Hotpocket'),
+(NULL, 'The Ignis Prophecy'),
+(NULL, 'The Illuminatie'),
+(NULL, 'The Immortal League'),
+(NULL, 'The Independant'),
+(NULL, 'The Infragilis Legion'),
+(NULL, 'The Jag'),
+(NULL, 'The Jookmaster'),
+(NULL, 'The Kataclysm'),
+(NULL, 'The Knight'),
+(NULL, 'The Knightelf'),
+(NULL, 'The Knights Thorn'),
+(NULL, 'The Knights of Gods Fury'),
+(NULL, 'The Knights of Lost Peon'),
+(NULL, 'The Knights of Mortal'),
+(NULL, 'The Knights of Samurai'),
+(NULL, 'The Kobra'),
+(NULL, 'The Leaders of Evil'),
+(NULL, 'The Leaders of Life'),
+(NULL, 'The League of Red Knight'),
+(NULL, 'The Legacy Meathooks'),
+(NULL, 'The Legion of the Blue'),
+(NULL, 'The Legion of Death'),
+(NULL, 'The Lemmings of Flaming'),
+(NULL, 'The Let Blood Gamer'),
+(NULL, 'The Light'),
+(NULL, 'The Little Hunters'),
+(NULL, 'The Lords of Vae Knight'),
+(NULL, 'The Mercenaries'),
+(NULL, 'The Midieval Vanguard'),
+(NULL, 'The Might of Dark Tong'),
+(NULL, 'The Mithril Justice'),
+(NULL, 'The Mithril Pepsi'),
+(NULL, 'The Mjollnir'),
+(NULL, 'The Moo Licht'),
+(NULL, 'The Morgantis'),
+(NULL, 'The Mulletmen'),
+(NULL, 'The Necrontyr of Eternal'),
+(NULL, 'The Nedrage Kills'),
+(NULL, 'The Night'),
+(NULL, 'The Nightfall'),
+(NULL, 'The Ninja Heroes'),
+(NULL, 'The Order of Gold'),
+(NULL, 'The Order of Warcraft'),
+(NULL, 'The Order of Warsong'),
+(NULL, 'The Over Louder'),
+(NULL, 'The Overlord'),
+(NULL, 'The Pants'),
+(NULL, 'The Pie'),
+(NULL, 'The Pretectors'),
+(NULL, 'The Project Disease'),
+(NULL, 'The Psychotics'),
+(NULL, 'The Puggers'),
+(NULL, 'The Pyreborne'),
+(NULL, 'The Queen of Meow'),
+(NULL, 'The Red Hood Thunder'),
+(NULL, 'The Reign of Uber Enigma'),
+(NULL, 'The Resurrection'),
+(NULL, 'The Ring of Honor'),
+(NULL, 'The Ropetown'),
+(NULL, 'The Royal Militia Blanco'),
+(NULL, 'The Samurai Banda'),
+(NULL, 'The Sanity'),
+(NULL, 'The Sauce'),
+(NULL, 'The Schoolyard Reapers'),
+(NULL, 'The Secrets of Hehog'),
+(NULL, 'The Seers'),
+(NULL, 'The Servants of Cyclone'),
+(NULL, 'The Seven'),
+(NULL, 'The Shadow Gate'),
+(NULL, 'The Shadow Misfits'),
+(NULL, 'The Shadow of Ninja Pain'),
+(NULL, 'The Shadowborn'),
+(NULL, 'The Shizam'),
+(NULL, 'The Shockers'),
+(NULL, 'The Shriek of Nightmare'),
+(NULL, 'The Silent Grunts'),
+(NULL, 'The Silent Legion'),
+(NULL, 'The Skunkdesigns'),
+(NULL, 'The Sorrow'),
+(NULL, 'The Souls of Azeroth Old'),
+(NULL, 'The Spazler'),
+(NULL, 'The Squirrels'),
+(NULL, 'The Stringville'),
+(NULL, 'The Stronghold of Reds'),
+(NULL, 'The Tha Handlers'),
+(NULL, 'The Thieves of Moral'),
+(NULL, 'The Thorium Claw'),
+(NULL, 'The Thread'),
+(NULL, 'The Thule'),
+(NULL, 'The Thunderslayers'),
+(NULL, 'The True Wow'),
+(NULL, 'The Trusted Minions'),
+(NULL, 'The Twilight Rangers'),
+(NULL, 'The Tyraels Aggression'),
+(NULL, 'The Ultimates'),
+(NULL, 'The Unforgiven Heresy'),
+(NULL, 'The Unholy Bards'),
+(NULL, 'The Unsung Efficiency'),
+(NULL, 'The Valley of the Demon'),
+(NULL, 'The Valor'),
+(NULL, 'The Violent Chaos'),
+(NULL, 'The Virus Eternal'),
+(NULL, 'The War'),
+(NULL, 'The Warsong Gnomeregan'),
+(NULL, 'The Westcoast'),
+(NULL, 'The Wicked'),
+(NULL, 'The Will of Chronicles'),
+(NULL, 'The Windsword Nightmare'),
+(NULL, 'The Wings of Oxy Claw'),
+(NULL, 'The Wrath of Elton'),
+(NULL, 'The Wut'),
+(NULL, 'The Yoricks Assassins'),
+(NULL, 'The Zeksonic Thieves'),
+(NULL, 'Theramore Azeroth'),
+(NULL, 'Thirstquencher Chaos'),
+(NULL, 'Thralls Caribous'),
+(NULL, 'Three Alive'),
+(NULL, 'Titans of Blood Sun'),
+(NULL, 'Torvus Dragons'),
+(NULL, 'Tower of the Little'),
+(NULL, 'True Team'),
+(NULL, 'Tul Inc'),
+(NULL, 'Twinks of Cold Club'),
+(NULL, 'Twinks of Hidden Venture'),
+(NULL, 'Ultimate Rules'),
+(NULL, 'Undead Kingdom'),
+(NULL, 'Unforgiven Destiny'),
+(NULL, 'Unguilded War'),
+(NULL, 'Unholy Cats'),
+(NULL, 'Unholy Teeth'),
+(NULL, 'Union of Burning Prz'),
+(NULL, 'Unusual Guard'),
+(NULL, 'Valiant Riderz'),
+(NULL, 'Vanguard Omen'),
+(NULL, 'Vanguard Redeemers'),
+(NULL, 'Vanguard of Teutonic'),
+(NULL, 'Vengeful Mayhem'),
+(NULL, 'Verata Blackflame'),
+(NULL, 'Vicious Renegade'),
+(NULL, 'Vile Dead'),
+(NULL, 'Voodoo Hearth'),
+(NULL, 'War Legion'),
+(NULL, 'Warlockian Tree'),
+(NULL, 'Warlords of Kungfu Army'),
+(NULL, 'Warriors of Happy Death'),
+(NULL, 'Warriors of the Tundra'),
+(NULL, 'Warsong Insanity'),
+(NULL, 'Waste of Grey Death'),
+(NULL, 'Wayfarers of Maple Leaf'),
+(NULL, 'Wayward Agenda'),
+(NULL, 'Web of Forgoten Warfare'),
+(NULL, 'Wet Guard'),
+(NULL, 'Wild Fire'),
+(NULL, 'Will of the Forgotten'),
+(NULL, 'Winds of Steve Irwin'),
+(NULL, 'Wings of Emerald Minions'),
+(NULL, 'Wintermane Good'),
+(NULL, 'Witchhunters of Chaos'),
+(NULL, 'With Sea'),
+(NULL, 'Wrath of the Horde Troop'),
+(NULL, 'Wtf Losers'),
+(NULL, 'Xcalibur of Shogunz Depo'),
+(NULL, 'Xelium Determination');
diff --git a/sql/characters_ai_playerbot.sql b/sql/characters_ai_playerbot.sql
new file mode 100644
index 0000000..fdf3535
--- /dev/null
+++ b/sql/characters_ai_playerbot.sql
@@ -0,0 +1,34 @@
+DROP TABLE IF EXISTS `ai_playerbot_random_bots`;
+
+CREATE TABLE `ai_playerbot_random_bots` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `owner` bigint(20) NOT NULL,
+  `bot` bigint(20) NOT NULL,
+  `time` bigint(20) NOT NULL,
+  `validIn` bigint(20) DEFAULT NULL,
+  `event` varchar(45) DEFAULT NULL,
+  `value` bigint(20) DEFAULT NULL,
+  `data` varchar(255) DEFAULT NULL,
+  PRIMARY KEY (`id`),
+  KEY `owner` (`owner`),
+  KEY `bot` (`bot`),
+  KEY `event` (`event`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
+DROP TABLE IF EXISTS `ai_playerbot_guild_tasks`;
+
+CREATE TABLE `ai_playerbot_guild_tasks` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `owner` bigint(20) NOT NULL,
+  `guildid` bigint(20) NOT NULL,
+  `time` bigint(20) NOT NULL,
+  `validIn` bigint(20) DEFAULT NULL,
+  `type` varchar(45) DEFAULT NULL,
+  `value` bigint(20) DEFAULT NULL,
+  `data` varchar(255) DEFAULT NULL,
+  PRIMARY KEY (`id`),
+  KEY `owner` (`owner`),
+  KEY `guildid` (`guildid`),
+  KEY `type` (`type`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/characters_ai_playerbot_custom_strategy.sql b/sql/characters_ai_playerbot_custom_strategy.sql
new file mode 100644
index 0000000..3f8cb7b
--- /dev/null
+++ b/sql/characters_ai_playerbot_custom_strategy.sql
@@ -0,0 +1,22 @@
+DROP TABLE IF EXISTS `ai_playerbot_custom_strategy`;
+
+CREATE TABLE `ai_playerbot_custom_strategy` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `name` varchar(255) NOT NULL,
+  `action_line` varchar(1024) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `name` (`name`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+DELETE FROM `ai_playerbot_custom_strategy`;
+
+-- say
+
+INSERT INTO `ai_playerbot_custom_strategy` VALUES
+(NULL, 'say', 'critical health>emote::helpme|99,say::critical health|98'),
+(NULL, 'say', 'low health>emote::healme|99,say::low health|98'),
+(NULL, 'say', 'low mana>emote::oom|99,say::low mana|98'),
+(NULL, 'say', 'tank aoe>charge|99,say::taunt|98'),
+(NULL, 'say', 'medium aoe>say::aoe|99'),
+(NULL, 'say', 'can loot>say::loot|99')
+;
diff --git a/sql/characters_ai_playerbot_speech.sql b/sql/characters_ai_playerbot_speech.sql
new file mode 100644
index 0000000..31a8095
--- /dev/null
+++ b/sql/characters_ai_playerbot_speech.sql
@@ -0,0 +1,241 @@
+DROP TABLE IF EXISTS `ai_playerbot_speech`;
+
+CREATE TABLE `ai_playerbot_speech` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `name` varchar(255) NOT NULL,
+  `text` varchar(1024) NOT NULL,
+  `type` varchar(10) NOT NULL,
+  PRIMARY KEY (`id`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `ai_playerbot_speech_probability`;
+
+CREATE TABLE `ai_playerbot_speech_probability` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `name` varchar(255) NOT NULL,
+  `probability` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+INSERT INTO `ai_playerbot_speech_probability` VALUES
+(NULL, 'taunt', 30),
+(NULL, 'aoe', 75),
+(NULL, 'loot', 20);
+
+INSERT INTO `ai_playerbot_speech` VALUES
+(NULL, 'taunt', 'I have puppies under my armor!', 'say'),
+(NULL, 'taunt', 'Bite me, <target>!', 'say'),
+(NULL, 'taunt', 'Hey <target>! Guess what your mom said last night!', 'say'),
+(NULL, 'taunt', '<target>, you''re so ugly you couldn''t score in a monkey whorehouse with a bag of bananas!', 'say'),
+(NULL, 'taunt', 'Shut up <target>, you''ll never be the man your mother is!!', 'say'),
+(NULL, 'taunt', 'Your mother was a hampster and your father smelt of elderberries!!!!', 'say'),
+(NULL, 'taunt', 'I don''t want to talk to you no more, you empty headed animal food trough wiper!!!', 'say'),
+(NULL, 'taunt', 'I fart in your general direction!!!', 'say'),
+(NULL, 'taunt', 'Go and boil your bottom, you son of a silly person!!!', 'say'),
+(NULL, 'taunt', 'What are you going to do <target>, bleed on me? HAVE AT YOU!', 'say'),
+(NULL, 'taunt', 'M-O-O-N! That spells aggro!', 'say'),
+(NULL, 'taunt', 'You''re about as useful as a one-legged man in an ass kicking contest.', 'say'),
+(NULL, 'taunt', 'Hey <target>! Stop hitting on them, they''re not your type. They aren''t inflatable.', 'say'),
+(NULL, 'taunt', '<target> you''re so far outta your league, you''re playing a different sport.', 'say'),
+(NULL, 'taunt', 'You made a big mistake today <target>, you got out of bed.', 'say'),
+(NULL, 'taunt', 'I wanna try turning into a horse, but I need help. I''ll be the front, you be yourself.', 'say'),
+(NULL, 'taunt', 'Can I borrow your face for a few days? My ass is going on holiday....', 'say'),
+(NULL, 'taunt', 'I''d like to give you a going away present... First you do your part.', 'say'),
+(NULL, 'taunt', 'Before you came along we were hungry, Now we''re just fed up.', 'say'),
+(NULL, 'taunt', 'I like you. People say I have no taste, but I like you.', 'say'),
+(NULL, 'taunt', 'I think you have an inferiority complex, but that''s okay, it''s justified.', 'say'),
+(NULL, 'taunt', 'Hence rotten thing! Or I shall shake thy bones out of thy garments.', 'say'),
+(NULL, 'taunt', 'I can''t believe I''m wasting my time with you!', 'say'),
+(NULL, 'taunt', 'I love it when someone insults me, it means I don''t have to be nice anymore.', 'say'),
+(NULL, 'taunt', 'Thou leathern-jerkin, crystal-button, knot-pated, agatering, puke-stocking, caddis-garter, smooth-tongue, Spanish pouch!', 'say'),
+(NULL, 'taunt', 'Thou qualling bat-fowling malt-worm!', 'say'),
+(NULL, 'taunt', 'Thou art truely an idol of idiot-worshippers!', 'say'),
+(NULL, 'taunt', 'Thou misbegotten knotty-pated wagtail!', 'say'),
+(NULL, 'taunt', 'Thou whoreson mandrake, thou art fitter to be worn in my cap than to wait at my heels!', 'say'),
+(NULL, 'taunt', 'You! You scullion! You rampallian! You fustilarian! I''ll tickle your catastrophe!', 'say'),
+(NULL, 'taunt', 'Oh <target>! Thou infectious ill-nurtured flax-wench!', 'say'),
+(NULL, 'taunt', 'We leak in your chimney, <target>!', 'say'),
+(NULL, 'taunt', 'Oh thou bootless fen-sucked canker-blossom!', 'say'),
+(NULL, 'taunt', 'Were I like thee I''d throw away myself!', 'say'),
+(NULL, 'taunt', 'O teach me <target>, how I should forget to think!', 'say'),
+(NULL, 'taunt', 'Truly thou art damned, like an ill-roasted egg, all on one side!', 'say'),
+(NULL, 'taunt', 'You starvelling, you eel-skin, you dried neat''s-tongue, you bull''s-pizzle, you stock-fish- O for breath to utter what is like thee!! -you tailor''s-yard, you sheath, you bow-case, you vile standing tuck!', 'say'),
+(NULL, 'taunt', 'Fie! Drop thee into the rotten mouth of Death!', 'say'),
+(NULL, 'taunt', '<target>, you are a fishmonger!', 'say'),
+(NULL, 'taunt', 'I shall live to knock thy brains out!', 'say'),
+(NULL, 'taunt', 'Most shallow are you, <target>!! Thou art worms-meat in respect of a good piece of flesh, indeed!!', 'say'),
+(NULL, 'taunt', 'Vile wretch! O <target>, thou odiferous hell-hated pignut!', 'say'),
+(NULL, 'taunt', '<target>! Thy kiss is as comfortless as frozen water to a starved snake!', 'say'),
+(NULL, 'taunt', 'I scorn you, scurvy companion. What, you poor, base, rascally, cheating, lack-linen mate! Away, you moldy rogue, away!', 'say'),
+(NULL, 'taunt', 'Out of my sight! Thou dost infect my eyes <target>!', 'say'),
+(NULL, 'taunt', 'PLAY TIME!!!!', 'say'),
+(NULL, 'taunt', 'None shall pass!', 'say'),
+(NULL, 'taunt', 'We''re under attack! A vast, ye swabs! Repel the invaders!', 'say'),
+(NULL, 'taunt', 'None may challenge the Brotherhood!', 'say'),
+(NULL, 'taunt', 'Foolsss...Kill the one in the dress!', 'say'),
+(NULL, 'taunt', 'I''ll feed your soul to Hakkar himself! ', 'say'),
+(NULL, 'taunt', 'Pride heralds the end of your world! Come, mortals! Face the wrath of the <randomfaction>!', 'say'),
+(NULL, 'taunt', 'All my plans have led to this!', 'say'),
+(NULL, 'taunt', 'Ahh! More lambs to the slaughter!', 'say'),
+(NULL, 'taunt', 'Another day, another glorious battle!', 'say'),
+(NULL, 'taunt', 'So, business... or pleasure?', 'say'),
+(NULL, 'taunt', 'You are not prepared!', 'say'),
+(NULL, 'taunt', 'The <randomfaction>''s final conquest has begun! Once again the subjugation of this world is within our grasp. Let none survive! ', 'say'),
+(NULL, 'taunt', 'Your death will be a painful one. ', 'say'),
+(NULL, 'taunt', 'Cry for mercy! Your meaningless lives will soon be forfeit. ', 'say'),
+(NULL, 'taunt', 'Abandon all hope! The <randomfaction> has returned to finish what was begun so many years ago. This time there will be no escape! ', 'say'),
+(NULL, 'taunt', 'Alert! You are marked for Extermination! ', 'say'),
+(NULL, 'taunt', 'The <subzone> is for guests only...', 'say'),
+(NULL, 'taunt', 'Ha ha ha! You are hopelessly outmatched!', 'say'),
+(NULL, 'taunt', 'I will crush your delusions of grandeur! ', 'say'),
+(NULL, 'taunt', 'Forgive me, for you are about to lose the game.', 'say'),
+(NULL, 'taunt', 'Struggling only makes it worse.', 'say'),
+(NULL, 'taunt', 'Vermin! Leeches! Take my blood and choke on it!', 'say'),
+(NULL, 'taunt', 'Not again... NOT AGAIN!', 'say'),
+(NULL, 'taunt', 'My blood will be the end of you!', 'say'),
+(NULL, 'taunt', 'Good, now you fight me!', 'say'),
+(NULL, 'taunt', 'Get da move on, guards! It be killin'' time!', 'say'),
+(NULL, 'taunt', 'Don''t be delayin'' your fate. Come to me now. I make your sacrifice quick.', 'say'),
+(NULL, 'taunt', 'You be dead soon enough!', 'say'),
+(NULL, 'taunt', 'Mua-ha-ha!', 'say'),
+(NULL, 'taunt', 'I be da predator! You da prey...', 'say'),
+(NULL, 'taunt', 'You gonna leave in pieces!', 'say'),
+(NULL, 'taunt', 'Death comes. Will your conscience be clear? ', 'say'),
+(NULL, 'taunt', 'Your behavior will not be tolerated.', 'say'),
+(NULL, 'taunt', 'The Menagerie is for guests only.', 'say'),
+(NULL, 'taunt', 'Hmm, unannounced visitors, Preparations must be made... ', 'say'),
+(NULL, 'taunt', 'Hostile entities detected. Threat assessment protocol active. Primary target engaged. Time minus thirty seconds to re-evaluation.', 'say'),
+(NULL, 'taunt', 'New toys? For me? I promise I won''t break them this time!', 'say'),
+(NULL, 'taunt', 'I''m ready to play!', 'say'),
+(NULL, 'taunt', 'Shhh... it will all be over soon.', 'say'),
+(NULL, 'taunt', 'Aaaaaughibbrgubugbugrguburgle!', 'say'),
+(NULL, 'taunt', 'RwlRwlRwlRwl!', 'say'),
+(NULL, 'taunt', 'You too, shall serve!', 'say'),
+(NULL, 'taunt', 'Tell me... tell me everything!  Naughty secrets! I''ll rip the secrets from your flesh!', 'say'),
+(NULL, 'taunt', 'Prepare yourselves, the bells have tolled! Shelter your weak, your young and your old! Each of you shall pay the final sum! Cry for mercy; the reckoning has come!', 'say'),
+(NULL, 'taunt', 'Where in Bonzo''s brass buttons am I?', 'say'),
+(NULL, 'taunt', 'I can bear it no longer! Goblin King! Goblin King! Wherever you may be! Take this <target> far away from me!', 'say'),
+(NULL, 'taunt', 'You have thirteen hours in which to solve the labyrinth, before your baby brother becomes one of us... forever.', 'say'),
+(NULL, 'taunt', 'So, the <subzone> is a piece of cake, is it? Well, let''s see how you deal with this little slice... ', 'say'),
+(NULL, 'taunt', 'Back off, I''ll take you on, headstrong to take on anyone, I know that you are wrong, and this is not where you belong', 'say'),
+(NULL, 'taunt', 'Show me whatcha got!', 'say'),
+(NULL, 'taunt', 'To the death!', 'say'),
+(NULL, 'taunt', 'Twin blade action, for a clean close shave every time.', 'say'),
+(NULL, 'taunt', 'Bring it on!', 'say'),
+(NULL, 'taunt', 'You''re goin'' down!', 'say'),
+(NULL, 'taunt', 'Stabby stab stab!', 'say'),
+(NULL, 'taunt', 'Let''s get this over quick; time is mana.', 'say'),
+(NULL, 'taunt', 'I do not think you realise the gravity of your situation.', 'say'),
+(NULL, 'taunt', 'I will bring honor to my family and my kingdom!', 'say'),
+(NULL, 'taunt', 'Light, give me strength!', 'say'),
+(NULL, 'taunt', 'My church is the field of battle - time to worship...', 'say'),
+(NULL, 'taunt', 'I hold you in contempt...', 'say'),
+(NULL, 'taunt', 'Face the hammer of justice!', 'say'),
+(NULL, 'taunt', 'Prove your worth in the test of arms under the Light!', 'say'),
+(NULL, 'taunt', 'All must fall before the might and right of my cause, you shall be next!', 'say'),
+(NULL, 'taunt', 'Prepare to die!', 'say'),
+(NULL, 'taunt', 'The beast with me is nothing compared to the beast within...', 'say'),
+(NULL, 'taunt', 'Witness the firepower of this fully armed huntsman!', 'say');
+
+
+INSERT INTO `ai_playerbot_speech` VALUES
+(NULL, 'critical health', 'Heal me! Quick!', 'yell'),
+(NULL, 'critical health', 'Almost dead! Heal me!', 'yell'),
+(NULL, 'critical health', 'Help! Heal me!', 'yell'),
+(NULL, 'critical health', 'Somebody! Heal me!', 'yell'),
+(NULL, 'critical health', 'Heal! Heal! Heal!', 'yell'),
+(NULL, 'critical health', 'I am dying! Heal! Aaaaarhg!', 'yell'),
+(NULL, 'critical health', 'Heal me!', 'yell'),
+(NULL, 'critical health', 'I will die. I will die. I will die. Heal!', 'yell'),
+(NULL, 'critical health', 'Healers, where are you? I am dying!', 'yell'),
+(NULL, 'critical health', 'Oh the pain. Heal me quick!', 'yell');
+
+
+INSERT INTO `ai_playerbot_speech` VALUES
+(NULL, 'low health', 'Need heal', 'say'),
+(NULL, 'low health', 'Low health', 'say'),
+(NULL, 'low health', 'Drop a heal. Please.', 'say'),
+(NULL, 'low health', 'Could somebody drop a heal on me?', 'say'),
+(NULL, 'low health', 'Hey! Better heal me now than rez later', 'say'),
+(NULL, 'low health', 'I am sorry. Need another heal', 'say'),
+(NULL, 'low health', 'Damn mobs. Heal me please', 'say'),
+(NULL, 'low health', 'One more hit and I am done for. Heal please', 'say'),
+(NULL, 'low health', 'Are there any healers?', 'say'),
+(NULL, 'low health', 'Why do they always punch me in the face? Need heal', 'say'),
+(NULL, 'low health', 'Can anybody heal me a bit?', 'say');
+
+
+INSERT INTO `ai_playerbot_speech` VALUES
+(NULL, 'low mana', 'OOM', 'say'),
+(NULL, 'low mana', 'I am out of mana', 'say'),
+(NULL, 'low mana', 'Damn I wasted all my mana on this', 'say'),
+(NULL, 'low mana', 'You should wait until I drink or regenerate my mana', 'say'),
+(NULL, 'low mana', 'Low mana', 'say'),
+(NULL, 'low mana', 'No mana. Again?', 'say'),
+(NULL, 'low mana', 'Low mana. Wanna drink', 'say'),
+(NULL, 'low mana', 'Do we have a vending machine? Out of mana again', 'say'),
+(NULL, 'low mana', 'My mana is history', 'say'),
+(NULL, 'low mana', 'I''d get some drinks next time. Out of mana', 'say'),
+(NULL, 'low mana', 'Where is my mana?', 'say');
+
+INSERT INTO `ai_playerbot_speech` VALUES
+(NULL, 'aoe', 'Oh god!', 'say'),
+(NULL, 'aoe', 'I am scared', 'say'),
+(NULL, 'aoe', 'We are done for', 'say'),
+(NULL, 'aoe', 'This is over', 'say'),
+(NULL, 'aoe', 'This ends now', 'say'),
+(NULL, 'aoe', 'Could somebody cast blizzard or something?', 'say'),
+(NULL, 'aoe', 'Damn. The tank aggroed all the mobs around', 'say'),
+(NULL, 'aoe', 'We gonna die. We gonna die. We gonna die.', 'say'),
+(NULL, 'aoe', 'Whoa! So many toys to play with', 'say'),
+(NULL, 'aoe', 'I gonna kill them all!', 'say'),
+(NULL, 'aoe', 'If the tank dies we are history', 'say'),
+(NULL, 'aoe', 'Aaaaaargh!', 'yell'),
+(NULL, 'aoe', 'LEEEEERROOOYYYYYYYYYYYY JENNKINNNSSSSSS!!!!!!!', 'yell'),
+(NULL, 'aoe', 'Right. What do we have in AOE?', 'say'),
+(NULL, 'aoe', 'This gets interesting', 'say'),
+(NULL, 'aoe', 'Cool. Get them in one place for a good flamestrike', 'say'),
+(NULL, 'aoe', 'Kill! Kill! Kill!', 'say'),
+(NULL, 'aoe', 'I think my pants are wet', 'say'),
+(NULL, 'aoe', 'We are history', 'say'),
+(NULL, 'aoe', 'I hope healers are ready. Leeeeroy!', 'say'),
+(NULL, 'aoe', 'I hope they won''t come for me', 'say'),
+(NULL, 'aoe', 'Oh no. I can''t see at this slaugther', 'say');
+
+INSERT INTO `ai_playerbot_speech` VALUES
+(NULL, 'loot', 'I hope there will be some money', 'say'),
+(NULL, 'loot', 'Loot! Loot!', 'say'),
+(NULL, 'loot', 'My precious', 'say'),
+(NULL, 'loot', 'I hope there is a shiny epic item waiting for me there', 'say'),
+(NULL, 'loot', 'I have deep pockets and bags', 'say'),
+(NULL, 'loot', 'All is mine!', 'say'),
+(NULL, 'loot', 'Hope no gray shit today', 'say'),
+(NULL, 'loot', 'This loot is MINE!', 'say'),
+(NULL, 'loot', 'Looting is disgusting but I need money', 'say'),
+(NULL, 'loot', 'Gold!', 'say'),
+(NULL, 'loot', 'OK. Let''s see what they''ve got', 'say'),
+(NULL, 'loot', 'Do not worry. I will loot eveything', 'say'),
+(NULL, 'loot', 'I am loot ninja', 'say'),
+(NULL, 'loot', 'Do I neeed to roll?', 'say'),
+(NULL, 'loot', 'Somebody explain me, where they did put all this stuff?', 'say'),
+(NULL, 'loot', 'No, I won''t loot gray shit', 'say'),
+(NULL, 'loot', 'I''m first. I''m first. I''m first.', 'say'),
+(NULL, 'loot', 'Give me your money!', 'say'),
+(NULL, 'loot', 'My pockets are empty, I need to fill them', 'say'),
+(NULL, 'loot', 'I''ve got a new bag for this', 'say'),
+(NULL, 'loot', 'I hope I won''t aggro anybody while looting', 'say'),
+(NULL, 'loot', 'Please don''t watch. I am looting', 'say'),
+(NULL, 'loot', 'Ha! You won''t get any piece of it!', 'say'),
+(NULL, 'loot', 'Looting is cool', 'say'),
+(NULL, 'loot', 'I like new gear', 'say'),
+(NULL, 'loot', 'I''l quit if there is nothing valuable again', 'say'),
+(NULL, 'loot', 'I hope it is be a pretty ring', 'say'),
+(NULL, 'loot', 'I''l rip the loot from you', 'say'),
+(NULL, 'loot', 'Everybody stay off. I''m going to loot', 'say'),
+(NULL, 'loot', 'Sweet loot', 'say'),
+(NULL, 'loot', 'The Roll God! Give me an epic today', 'say'),
+(NULL, 'loot', 'Please give me new toys', 'say'),
+(NULL, 'loot', 'I hope they carry tasties', 'say'),
+(NULL, 'loot', 'The gold is mine. I''l leave everyting, I promise', 'say'),
+(NULL, 'loot', 'No, I can''t resist', 'say'),
+(NULL, 'loot', 'I want more!', 'say');
diff --git a/sql/characters_auctionhousebot.sql b/sql/characters_auctionhousebot.sql
new file mode 100644
index 0000000..c2d8824
--- /dev/null
+++ b/sql/characters_auctionhousebot.sql
@@ -0,0 +1,37 @@
+DROP TABLE IF EXISTS `ahbot_history`;
+DROP TABLE IF EXISTS `ahbot_category`;
+DROP TABLE IF EXISTS `ahbot_price`;
+
+CREATE TABLE `ahbot_history` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `buytime` bigint(20) NOT NULL,
+  `item` bigint(20) NOT NULL,
+  `bid` bigint(20) NOT NULL,
+  `buyout` bigint(20) NOT NULL,
+  `won` bigint(20) NOT NULL,
+  `category` varchar(45) DEFAULT NULL,
+  `auction_house` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `won` (`won`),
+  KEY `category` (`category`),
+  KEY `auction_house` (`auction_house`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+CREATE TABLE `ahbot_category` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `category` varchar(45) DEFAULT NULL,
+  `multiplier` decimal(20, 2) NOT NULL,
+  `max_auction_count` bigint(20) NOT NULL,
+  `expire_time` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `helper` (`category`, `multiplier`, `expire_time`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+CREATE TABLE `ahbot_price` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `item` varchar(45) DEFAULT NULL,
+  `price` decimal(20, 2) NOT NULL,
+  `auction_house` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `ahbot_price_item` (`item`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 619ab33..04644d2 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -13,8 +13,13 @@ add_subdirectory(common)
 
 if(SERVERS)
   add_subdirectory(server)
+  add_subdirectory(plugins)
 endif(SERVERS)
 
 if(TOOLS)
   add_subdirectory(tools)
 endif(TOOLS)
+
+if(TESTS)
+  add_subdirectory(test)
+endif(TESTS)
diff --git a/src/common/Configuration/Config.h b/src/common/Configuration/Config.h
index 573bc7b..e1c7a20 100644
--- a/src/common/Configuration/Config.h
+++ b/src/common/Configuration/Config.h
@@ -29,6 +29,8 @@
 
 class TC_COMMON_API ConfigMgr
 {
+// playerbot mod
+public:
     ConfigMgr() = default;
     ConfigMgr(ConfigMgr const&) = delete;
     ConfigMgr& operator=(ConfigMgr const&) = delete;
diff --git a/src/plugins/CMakeLists.txt b/src/plugins/CMakeLists.txt
new file mode 100644
index 0000000..3b45ec6
--- /dev/null
+++ b/src/plugins/CMakeLists.txt
@@ -0,0 +1,204 @@
+# Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+file(GLOB_RECURSE sources_ahbot ahbot/*.cpp ahbot/*.h)
+file(GLOB_RECURSE sources_playerbot playerbot/*.cpp playerbot/*.h)
+file(GLOB_RECURSE sources_pch pch/*.cpp pch/*.h)
+
+set(plugins_STAT_SRCS
+  ${plugins_STAT_SRCS}
+  ${sources_ahbot}
+  ${sources_playerbot}
+  ${sources_pch}
+)
+
+
+if (USE_COREPCH)
+  set(PRIVATE_PCH_HEADER pch/pch.h)
+  set(PRIVATE_PCH_SOURCE pch/pch.cpp)
+endif()
+
+GroupSources(${CMAKE_CURRENT_SOURCE_DIR})
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour/Include
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast/Include
+  ${CMAKE_SOURCE_DIR}/dep/cppformat
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/src/common
+  ${CMAKE_SOURCE_DIR}/src/common/Collision
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Management
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Models
+  ${CMAKE_SOURCE_DIR}/src/common/Configuration
+  ${CMAKE_SOURCE_DIR}/src/common/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/common/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/common/Debugging
+  ${CMAKE_SOURCE_DIR}/src/common/Logging
+  ${CMAKE_SOURCE_DIR}/src/common/Threading
+  ${CMAKE_SOURCE_DIR}/src/common/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/server/database
+  ${CMAKE_SOURCE_DIR}/src/server/database/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Networking
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_SOURCE_DIR}/src/server/game
+  ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouseBot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/DungeonFinding
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Corpse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/DynamicObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/pluginsObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Totem
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Transport
+  ${CMAKE_SOURCE_DIR}/src/server/game/Events
+  ${CMAKE_SOURCE_DIR}/src/server/game/Globals
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
+  ${CMAKE_SOURCE_DIR}/src/server/game/Guilds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Instances
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Mails
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/MovementGenerators
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/game/Pools
+  ${CMAKE_SOURCE_DIR}/src/server/game/pch
+  ${CMAKE_SOURCE_DIR}/src/server/game/Quests
+  ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
+  ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Skills
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden/Modules
+  ${CMAKE_SOURCE_DIR}/src/server/game/Weather
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/pch
+  ${MYSQL_INCLUDE_DIR}
+  ${OPENSSL_INCLUDE_DIR}
+)
+
+add_library(plugins STATIC
+  ${plugins_STAT_SRCS}
+  ${plugins_STAT_PCH_SRC}
+)
+
+
+# Do NOT add any extra include directory unless it does not create unneeded extra dependencies,
+# and specially, not add any dependency to neither of these: shared, game, scripts
+# This way we ensure that if either a PR does that without modifying this file,
+# a compile error will be generated, either this file will be modified so it
+# is detected more easily.
+# While it is OK to include files from other libs as long as they don't require
+# linkage (enums, defines...) it is discouraged to do so unless necessary, as it will pullute
+# include_directories leading to further unnoticed dependency aditions
+# Linker Depencency requirements: common
+CollectIncludeDirectories(
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  PUBLIC_INCLUDES
+  # Exclude
+  ${CMAKE_CURRENT_SOURCE_DIR}/pch)
+
+target_include_directories(plugins
+  PUBLIC
+    ${PUBLIC_INCLUDES}
+  PRIVATE
+    ${CMAKE_CURRENT_BINARY_DIR})
+
+add_definitions(-DTRINITY_API_EXPORT_plugins)
+
+target_link_libraries(plugins
+  PUBLIC
+    common
+    mysql)
+
+set_target_properties(plugins
+    PROPERTIES
+      FOLDER
+        "server")
+
+if( BUILD_SHARED_LIBS )
+  if( UNIX )
+    install(TARGETS plugins
+      LIBRARY
+        DESTINATION lib)
+  elseif( WIN32 )
+    install(TARGETS plugins
+      RUNTIME
+        DESTINATION "${CMAKE_INSTALL_PREFIX}")
+  endif()
+endif()
+
+# Generate precompiled header
+if (USE_COREPCH)
+  add_cxx_pch(plugins ${PRIVATE_PCH_HEADER} ${PRIVATE_PCH_SOURCE})
+endif ()
diff --git a/src/plugins/ahbot/AhBot.cpp b/src/plugins/ahbot/AhBot.cpp
new file mode 100644
index 0000000..9742c6d
--- /dev/null
+++ b/src/plugins/ahbot/AhBot.cpp
@@ -0,0 +1,984 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBot.h"
+#include "../World/World.h"
+#include "../Chat.h"
+#include "AhBotConfig.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+#include "../WorldSession.h"
+#include "../../game/Entities/Player/Player.h"
+#include "../playerbot/PlayerbotAIConfig.h"
+#include "../playerbot/playerbot.h"
+
+using namespace ahbot;
+
+bool Player::MinimalLoadFromDB( QueryResult result, uint32 guid )
+{
+    if (!result)
+    {
+        //                                        0     1           2           3           4    5          6          7
+        result = CharacterDatabase.PQuery("SELECT name, position_x, position_y, position_z, map, totaltime, leveltime, at_login FROM characters WHERE guid = '%u'",guid);
+        if (!result)
+            return false;
+    }
+
+    Field *fields = result->Fetch();
+
+    m_name = fields[0].GetString();
+
+    Relocate(fields[1].GetFloat(),fields[2].GetFloat(),fields[3].GetFloat());
+    SetLocationMapId(fields[4].GetUInt32());
+
+    m_Played_time[PLAYED_TIME_TOTAL] = fields[5].GetUInt32();
+    m_Played_time[PLAYED_TIME_LEVEL] = fields[6].GetUInt32();
+
+    m_atLoginFlags = fields[7].GetUInt32();
+
+    for (int i = 0; i < PLAYER_SLOTS_COUNT; ++i)
+        m_items[i] = NULL;
+
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+        m_deathState = DEAD;
+
+    return true;
+}
+
+bool AhBot::HandleAhBotCommand(ChatHandler* handler, char const* args)
+{
+    auctionbot.HandleCommand(args);
+    return true;
+}
+
+uint32 AhBot::auctionIds[MAX_AUCTIONS] = {1,6,7};
+uint32 AhBot::auctioneers[MAX_AUCTIONS] = {79707,4656,23442};
+map<uint32, uint32> AhBot::factions;
+
+void AhBot::Init()
+{
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "Initializing AhBot by ike3");
+
+    if (!sAhBotConfig.Initialize())
+        return;
+
+    factions[1] = 1;
+    factions[2] = 1;
+    factions[3] = 1;
+    factions[4] = 2;
+    factions[5] = 2;
+    factions[6] = 2;
+    factions[7] = 3;
+
+    availableItems.Init();
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot configuration loaded");
+}
+
+AhBot::~AhBot()
+{
+}
+
+ObjectGuid AhBot::GetAHBplayerGUID()
+{
+    return ObjectGuid(sAhBotConfig.guid);
+}
+
+void AhBotThread(AhBot* ahbot)
+{
+    ahbot->ForceUpdate();
+}
+
+void AhBot::Update()
+{
+    time_t now = time(0);
+
+    if (now < nextAICheckTime)
+        return;
+
+    if (updating)
+        return;
+
+    nextAICheckTime = time(0) + sAhBotConfig.updateInterval;
+
+    thread ahBotThread(AhBotThread, this);
+    ahBotThread.detach();
+}
+
+void AhBot::ForceUpdate()
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    if (updating)
+        return;
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is now checking auctions");
+    updating = true;
+
+    if (!allBidders.size())
+        LoadRandomBots();
+
+    if (!allBidders.size())
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "Ahbot is disabled but there is no bidders available");
+        return;
+    }
+
+    CheckCategoryMultipliers();
+
+    int answered = 0, added = 0;
+    for (int i = 0; i < MAX_AUCTIONS; i++)
+    {
+        InAuctionItemsBag inAuctionItems(auctionIds[i]);
+        inAuctionItems.Init(true);
+
+        for (int j = 0; j < CategoryList::instance.size(); j++)
+        {
+            Category* category = CategoryList::instance[j];
+            answered += Answer(i, category, &inAuctionItems);
+            added += AddAuctions(i, category, &inAuctionItems);
+        }
+    }
+
+    CleanupHistory();
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot auction check finished. %d auctions answered, %d new auctions added. Next check in %d seconds",
+            answered, added, sAhBotConfig.updateInterval);
+    updating = false;
+}
+
+struct SortByPricePredicate
+{
+    bool operator()(AuctionEntry* const & a, AuctionEntry* const & b) const
+    {
+        if (a->startbid == b->startbid)
+            return a->buyout < b->buyout;
+
+        return a->startbid < b->startbid;
+    }
+};
+
+vector<AuctionEntry*> AhBot::LoadAuctions(AuctionHouseObject* auctionHouse,
+        Category*& category, int& auction)
+{
+    vector<AuctionEntry*> entries;
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+            itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *entry = itr->second;
+        if (IsBotAuction(entry->owner) || IsBotAuction(entry->bidder))
+            continue;
+
+        Item *item = sAuctionMgr->GetAItem(entry->itemGUIDLow);
+        if (!item)
+            continue;
+
+        if (!category->Contains(item->GetTemplate()))
+            continue;
+
+        uint32 price = category->GetPricingStrategy()->GetBuyPrice(item->GetTemplate(), auctionIds[auction]);
+        if (!price || !item->GetCount())
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price cannot be determined",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        entries.push_back(entry);
+    }
+    sort(entries.begin(), entries.end(), SortByPricePredicate());
+    return entries;
+}
+
+void AhBot::FindMinPrice(AuctionHouseObject* auctionHouse, AuctionEntry*& entry, Item*& item, uint32* minBid,
+        uint32* minBuyout)
+{
+    *minBid = 0;
+    *minBuyout = 0;
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+            itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *other = itr->second;
+        if (other->owner == entry->owner)
+            continue;
+
+        Item *otherItem = sAuctionMgr->GetAItem(other->itemGUIDLow);
+        if (!otherItem || !otherItem->GetCount() || otherItem->GetTemplate()->ItemId != item->GetTemplate()->ItemId)
+            continue;
+
+        uint32 startbid = other->startbid / otherItem->GetCount() * item->GetCount();
+        uint32 bid = other->bid / otherItem->GetCount() * item->GetCount();
+        uint32 buyout = other->buyout / otherItem->GetCount() * item->GetCount();
+
+        if (!bid && startbid && (!*minBid || *minBid > startbid))
+            *minBid = startbid;
+
+        if (bid && (*minBid || *minBid > bid))
+            *minBid = bid;
+
+        if (buyout && (!*minBuyout || *minBuyout > buyout))
+            *minBuyout = buyout;
+    }
+}
+
+int AhBot::Answer(int auction, Category* category, ItemBag* inAuctionItems)
+{
+    const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if (!ahEntry)
+        return 0;
+
+    int answered = 0;
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auction);
+    int64 availableMoney = GetAvailableMoney(auctionIds[auction]);
+
+    vector<AuctionEntry*> entries = LoadAuctions(auctionHouse, category, auction);
+    for (vector<AuctionEntry*>::iterator itr = entries.begin(); itr != entries.end(); ++itr)
+    {
+        AuctionEntry *entry = *itr;
+
+        Item *item = sAuctionMgr->GetAItem(entry->itemGUIDLow);
+        if (!item || !item->GetCount())
+            continue;
+
+        const ItemTemplate* proto = item->GetTemplate();
+        vector<uint32> items = availableItems.Get(category);
+        if (find(items.begin(), items.end(), proto->ItemId) == items.end())
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: unavailable item",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 answerCount = GetAnswerCount(proto->ItemId, auctionIds[auction], sAhBotConfig.itemBuyMaxInterval);
+        uint32 maxAnswerCount = category->GetMaxAllowedItemAuctionCount(proto);
+        if (maxAnswerCount && answerCount > maxAnswerCount)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: answer count %d > %d (max)",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction], answerCount, maxAnswerCount);
+            continue;
+        }
+
+        if (proto->RequiredLevel > sAhBotConfig.maxRequiredLevel || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: above max required or item level",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 price = category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+        if (!price)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: cannot determine price",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 bidPrice = item->GetCount() * price;
+        uint32 buyoutPrice = item->GetCount() * urand(price, 4 * price / 3);
+
+        uint32 curPrice = entry->bid;
+        if (!curPrice) curPrice = entry->startbid;
+        if (!curPrice) curPrice = entry->buyout;
+
+        if (curPrice > buyoutPrice)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price %d > %d (buyout price)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], curPrice, buyoutPrice);
+            continue;
+        }
+
+        if (availableMoney < curPrice)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price %d > %d (available money)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], curPrice, availableMoney);
+            continue;
+        }
+
+        uint32 minBid = 0, minBuyout = 0;
+        FindMinPrice(auctionHouse, entry, item, &minBid, &minBuyout);
+
+        if (minBid && entry->bid && minBid < entry->bid)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: %d (bid) > %d (minBid)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->bid, minBid);
+            continue;
+        }
+
+        if (minBid && entry->startbid && minBid < entry->startbid)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: %d (startbid) > %d (minBid)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->startbid, minBid);
+            continue;
+        }
+
+        double priceLevel = (double)curPrice / (double)buyoutPrice;
+        uint32 buytime = GetBuyTime(entry->Id, proto->ItemId, auctionIds[auction], category, priceLevel);
+        if (time(0) < buytime)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: will buy/bid in %d seconds",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], buytime - time(0));
+            continue;
+        }
+
+        uint32 bidder = GetRandomBidder(auctionIds[auction]);
+        if (!bidder)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "No bidders for auction %d", auctionIds[auction]);
+            break;
+        }
+
+        entry->bidder = bidder;
+        entry->bid = curPrice + urand(1, 1 + bidPrice / 10);
+        availableMoney -= curPrice;
+
+        updateMarketPrice(item->GetTemplate()->ItemId, entry->buyout / item->GetCount(), auctionIds[auction]);
+
+        if ((entry->buyout && (entry->bid >= entry->buyout || 100 * (entry->buyout - entry->bid) / price < 25)) &&
+                !(minBuyout && entry->buyout && minBuyout < entry->buyout))
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d won %s (x%d) in auction %d for %d",
+                    bidder, item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->buyout);
+
+            entry->bid = entry->buyout;
+        }
+        else
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d placed bid %d for %s (x%d) in auction %d",
+                    bidder, entry->bid, item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'",
+                entry->bidder, entry->bid, entry->Id);
+            AddToHistory(entry, AHBOT_WON_BID);
+        }
+
+        CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE item = '%u' AND won = 4 AND auction_house = '%u' ",
+                proto->ItemId, factions[auctionIds[auction]]);
+
+        answered++;
+    }
+
+    return answered;
+}
+
+uint32 AhBot::GetTime(string category, uint32 id, uint32 auctionHouse, uint32 type)
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT MAX(buytime) FROM ahbot_history WHERE item = '%u' AND won = '%u' AND auction_house = '%u' AND category = '%s'",
+        id, type, factions[auctionHouse], category.c_str());
+
+    if (!results)
+        return 0;
+
+    Field* fields = results->Fetch();
+    uint32 result = fields[0].GetUInt32();
+
+    return result;
+}
+
+void AhBot::SetTime(string category, uint32 id, uint32 auctionHouse, uint32 type, uint32 value)
+{
+    CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE item = '%u' AND won = '%u' AND auction_house = '%u' AND category = '%s'",
+        id, type, factions[auctionHouse], category.c_str());
+
+    CharacterDatabase.PExecute("INSERT INTO ahbot_history (buytime, item, bid, buyout, category, won, auction_house) "
+        "VALUES ('%u', '%u', '%u', '%u', '%s', '%u', '%u')",
+        value, id, 0, 0,
+        category.c_str(), type, factions[auctionHouse]);
+}
+
+uint32 AhBot::GetBuyTime(uint32 entry, uint32 itemId, uint32 auctionHouse, Category*& category, double priceLevel)
+{
+    uint32 entryTime = GetTime("entry", entry, auctionHouse, AHBOT_WON_DELAY);
+    if (entryTime > time(0))
+        return entryTime;
+
+    uint32 result = entryTime;
+
+    string categoryName = category->GetName();
+    uint32 categoryTime = GetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY);
+    uint32 itemTime = GetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY);
+
+    if (categoryTime < time(0)) categoryTime = time(0);
+    if (itemTime < time(0)) itemTime = time(0);
+
+    double rarity = category->GetPricingStrategy()->GetRarityPriceMultiplier(itemId);
+    categoryTime += urand(sAhBotConfig.itemBuyMinInterval, sAhBotConfig.itemBuyMaxInterval) * priceLevel;
+    itemTime += urand(sAhBotConfig.itemBuyMinInterval, sAhBotConfig.itemBuyMaxInterval) * priceLevel / rarity;
+    entryTime = max(categoryTime, itemTime);
+
+    SetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY, categoryTime);
+    SetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY, itemTime);
+    SetTime("entry", entry, auctionHouse, AHBOT_WON_DELAY, entryTime);
+
+    return result ? result : entryTime;
+}
+
+uint32 AhBot::GetSellTime(uint32 itemId, uint32 auctionHouse, Category*& category)
+{
+    uint32 itemSellTime = GetTime("item", itemId, auctionHouse, AHBOT_SELL_DELAY);
+    uint32 itemBuyTime = GetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY);
+    uint32 itemTime = max(itemSellTime, itemBuyTime);
+
+    if (itemTime > time(0))
+        return itemTime;
+
+    uint32 result = itemTime;
+
+    string categoryName = category->GetName();
+    uint32 categorySellTime = GetTime(categoryName, 0, auctionHouse, AHBOT_SELL_DELAY);
+    uint32 categoryBuyTime = GetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY);
+    uint32 categoryTime = max(categorySellTime, categoryBuyTime);
+
+    if (categoryTime < time(0)) categoryTime = time(0);
+    if (itemTime < time(0)) itemTime = time(0);
+
+    double rarity = category->GetPricingStrategy()->GetRarityPriceMultiplier(itemId);
+    categoryTime += urand(sAhBotConfig.itemSellMinInterval, sAhBotConfig.itemSellMaxInterval);
+    itemTime += urand(sAhBotConfig.itemSellMinInterval, sAhBotConfig.itemSellMaxInterval) * rarity;
+    itemTime = max(itemTime, categoryTime);
+
+    SetTime(categoryName, 0, auctionHouse, AHBOT_SELL_DELAY, categoryTime);
+    SetTime("item", itemId, auctionHouse, AHBOT_SELL_DELAY, itemTime);
+
+    return result ? result : itemTime;
+}
+
+int AhBot::AddAuctions(int auction, Category* category, ItemBag* inAuctionItems)
+{
+    vector<uint32>& inAuction = inAuctionItems->Get(category);
+
+    int32 maxAllowedAuctionCount = categoryMaxAuctionCount[category->GetName()];
+    if (inAuctionItems->GetCount(category) >= maxAllowedAuctionCount)
+        return 0;
+
+    int added = 0;
+    vector<uint32> available = availableItems.Get(category);
+    for (int32 i = 0; i <= maxAllowedAuctionCount && available.size() > 0 && inAuctionItems->GetCount(category) < maxAllowedAuctionCount; ++i)
+    {
+        uint32 index = urand(0, available.size() - 1);
+        uint32 itemId = available[index];
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        int32 maxAllowedItems = category->GetMaxAllowedItemAuctionCount(proto);
+        if (maxAllowedItems && inAuctionItems->GetCount(category, proto->ItemId) >= maxAllowedItems)
+            continue;
+
+        uint32 sellTime = GetSellTime(proto->ItemId, auctionIds[auction], category);
+        if (time(0) < sellTime)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s in auction %d: will add in %d seconds",
+                    proto->Name1.c_str(), auctionIds[auction], sellTime - time(0));
+            continue;
+        }
+        else if (time(0) - sellTime > sAhBotConfig.maxSellInterval)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s in auction %d: too old (%d secs)",
+                    proto->Name1.c_str(), auctionIds[auction], time(0) - sellTime);
+            continue;
+        }
+
+        inAuctionItems->Add(proto);
+        added += AddAuction(auction, category, proto);
+    }
+
+    return added;
+}
+
+int AhBot::AddAuction(int auction, Category* category, ItemTemplate const* proto)
+{
+    uint32 owner = GetRandomBidder(auctionIds[auction]);
+    if (!owner)
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "No bidders for auction %d", auctionIds[auction]);
+        return 0;
+    }
+
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return 0;
+
+    uint32 price = category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction]);
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AddAuction: market price adjust");
+    updateMarketPrice(proto->ItemId, price, auctionIds[auction]);
+
+    price = category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+
+    uint32 stackCount = category->GetStackCount(proto);
+    if (!price || !stackCount)
+        return 0;
+
+    if (urand(0, 100) <= sAhBotConfig.underPriceProbability * 100)
+        price = price * 100 / urand(100, 200);
+
+    uint32 bidPrice = stackCount * price;
+    uint32 buyoutPrice = stackCount * urand(price, 4 * price / 3);
+
+    Item* item = Item::CreateItem(proto->ItemId, stackCount);
+    if (!item)
+        return 0;
+
+    uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(proto->ItemId);
+    if (randomPropertyId)
+        item->SetItemRandomProperties(randomPropertyId);
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return 0;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionIds[auction]);
+
+    AuctionEntry* auctionEntry = new AuctionEntry;
+    auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+    auctionEntry->itemGUIDLow = item->GetGUID().GetCounter();
+    auctionEntry->itemEntry = item->GetEntry();
+    auctionEntry->owner = owner;
+    auctionEntry->startbid = bidPrice;
+    auctionEntry->buyout = buyoutPrice;
+    // TODO: remove?
+    // auctionEntry->auctioneer = auctioneers[auction];
+    auctionEntry->bidder = 0;
+    auctionEntry->bid = 0;
+    auctionEntry->deposit = 0;
+    auctionEntry->expire_time = (time_t) (urand(8, 24) * 60 * 60 + time(NULL));
+    auctionEntry->auctionHouseEntry = ahEntry;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    item->SaveToDB(trans);
+    sAuctionMgr->AddAItem(item);
+    auctionHouse->AddAuction(auctionEntry);
+    auctionEntry->SaveToDB(trans);
+
+    auctionHouse->AddAuction(auctionEntry);
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d added %d of %s to auction %d for %d..%d", owner, stackCount, proto->Name1.c_str(), auctionIds[auction], bidPrice, buyoutPrice);
+    return 1;
+}
+
+void AhBot::HandleCommand(string command)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    if (command == "expire")
+    {
+        for (int i = 0; i < MAX_AUCTIONS; i++)
+            Expire(i);
+
+        return;
+    }
+
+    if (command == "stats")
+    {
+        for (int i = 0; i < MAX_AUCTIONS; i++)
+            PrintStats(i);
+
+        return;
+    }
+
+    if (command == "update")
+    {
+        thread ahBotThread(AhBotThread, this);
+        ahBotThread.detach();
+        return;
+    }
+
+    uint32 itemId = atoi(command.c_str());
+    if (!itemId)
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot stats - show short summary");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot expire - expire all auctions");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot update - update all auctions");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot <itemId> - show item price");
+        return;
+    }
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (category->Contains(proto))
+        {
+            vector<uint32> items = availableItems.Get(category);
+            if (find(items.begin(), items.end(), proto->ItemId) == items.end())
+                continue;
+
+            ostringstream out;
+            out << proto->Name1 << " (" << category->GetDisplayName() << "), "
+                    << category->GetMaxAllowedAuctionCount() << "x" << category->GetMaxAllowedItemAuctionCount(proto)
+                    << "x" << category->GetStackCount(proto) << " max"
+                    << "\n";
+            for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+            {
+                const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+                out << "--- auction house " << auctionIds[auction] << "(faction: " << factions[auctionIds[auction]] << ", money: "
+                    << GetAvailableMoney(auctionIds[auction])
+                    << ") ---\n";
+
+                out << "sell: " << category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction])
+                    << " ("  << category->GetPricingStrategy()->ExplainSellPrice(proto, auctionIds[auction]) << ")"
+                    << "\n";
+
+                out << "buy: " << category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction])
+                    << " ("  << category->GetPricingStrategy()->ExplainBuyPrice(proto, auctionIds[auction]) << ")"
+                    << "\n";
+            }
+            sLog->outMessage("ahbot", LOG_LEVEL_INFO, out.str().c_str());
+            break;
+        }
+    }
+}
+
+void AhBot::Expire(int auction)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionIds[auction]);
+
+    AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+
+    int count = 0;
+    while (itr != auctionHouse->GetAuctionsEnd())
+    {
+        if (IsBotAuction(itr->second->owner))
+        {
+            itr->second->expire_time = sWorld->GetGameTime();
+            count++;
+        }
+
+        ++itr;
+    }
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_category");
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "%d auctions marked as expired in auction %d", count, auctionIds[auction]);
+}
+
+void AhBot::PrintStats(int auction)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auction);
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "%d auctions available on auction house %d", auctionHouse->Getcount(), auctionIds[auction]);
+}
+
+void AhBot::AddToHistory(AuctionEntry* entry, uint32 won)
+{
+    if (!sAhBotConfig.enabled || !entry)
+        return;
+
+    if (!IsBotAuction(entry->owner) && !IsBotAuction(entry->bidder))
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry->itemEntry);
+    if (!proto)
+        return;
+
+    string category = "";
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        if (CategoryList::instance[i]->Contains(proto))
+        {
+            category = CategoryList::instance[i]->GetName();
+            break;
+        }
+    }
+
+    if (!won)
+    {
+        won = AHBOT_WON_PLAYER;
+        if (IsBotAuction(entry->bidder))
+            won = AHBOT_WON_SELF;
+    }
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AddToHistory: market price adjust");
+    int count = entry->itemCount ? entry->itemCount : 1;
+    updateMarketPrice(proto->ItemId, entry->buyout / count, entry->auctionHouseEntry->houseId);
+
+    uint32 now = time(0);
+    CharacterDatabase.PExecute("INSERT INTO ahbot_history (buytime, item, bid, buyout, category, won, auction_house) "
+        "VALUES ('%u', '%u', '%u', '%u', '%s', '%u', '%u')",
+        now, entry->itemEntry, entry->bid ? entry->bid : entry->startbid, entry->buyout,
+        category.c_str(), won, factions[entry->auctionHouseEntry->houseId]);
+}
+
+uint32 AhBot::GetAnswerCount(uint32 itemId, uint32 auctionHouse, uint32 withinTime)
+{
+    uint32 count = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT COUNT(*) FROM ahbot_history WHERE "
+        "item = '%u' AND won in (2, 3) AND auction_house = '%u' AND buytime > '%u'",
+        itemId, factions[auctionHouse], time(0) - withinTime);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            count = fields[0].GetUInt32();
+        } while (results->NextRow());
+    }
+
+    return count;
+}
+
+void AhBot::CleanupHistory()
+{
+    uint32 when = time(0) - 3600 * 24 * sAhBotConfig.historyDays;
+    CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE buytime < '%u'", when);
+}
+
+uint32 AhBot::GetAvailableMoney(uint32 auctionHouse)
+{
+    int64 result = sAhBotConfig.alwaysAvailableMoney;
+
+    map<uint32, uint32> data;
+    data[AHBOT_WON_PLAYER] = 0;
+    data[AHBOT_WON_SELF] = 0;
+
+    const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionHouse);
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT won, SUM(bid) FROM ahbot_history WHERE auction_house = '%u' GROUP BY won HAVING won > 0 ORDER BY won",
+        factions[auctionHouse]);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            data[fields[0].GetUInt32()] = fields[1].GetUInt32();
+
+        } while (results->NextRow());
+    }
+
+    results = CharacterDatabase.PQuery(
+        "SELECT max(buytime) FROM ahbot_history WHERE auction_house = '%u' AND won = '2'",
+        factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 lastBuyTime = fields[0].GetUInt32();
+        uint32 now = time(0);
+        if (lastBuyTime && now > lastBuyTime)
+        result += (now - lastBuyTime) / 3600 / 24 * sAhBotConfig.alwaysAvailableMoney;
+    }
+
+    AuctionHouseObject* auctionHouseObject = sAuctionMgr->GetAuctionsMap(auctionHouse);
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouseObject->GetAuctionsBegin(); itr != auctionHouseObject->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *entry = itr->second;
+        if (!IsBotAuction(entry->bidder))
+            continue;
+
+        result -= entry->bid;
+    }
+
+    result += (data[AHBOT_WON_PLAYER] - data[AHBOT_WON_SELF]);
+    return result < 0 ? 0 : (uint32)result;
+}
+
+void AhBot::CheckCategoryMultipliers()
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT category, multiplier, max_auction_count, expire_time FROM ahbot_category");
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            categoryMultipliers[fields[0].GetString()] = fields[1].GetFloat();
+            categoryMaxAuctionCount[fields[0].GetString()] = fields[2].GetInt32();
+            categoryMultiplierExpireTimes[fields[0].GetString()] = fields[3].GetUInt64();
+
+        } while (results->NextRow());
+    }
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_category");
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        string name = CategoryList::instance[i]->GetName();
+        if (categoryMultiplierExpireTimes[name] <= time(0) || categoryMultipliers[name] <= 0)
+        {
+            categoryMultipliers[name] = (double)urand(20, 100) / 20.0;
+            uint32 maxAllowedAuctionCount = CategoryList::instance[i]->GetMaxAllowedAuctionCount();
+            categoryMaxAuctionCount[name] = urand(maxAllowedAuctionCount / 2, maxAllowedAuctionCount);
+            categoryMultiplierExpireTimes[name] = time(0) + urand(4, 7) * 3600 * 24;
+        }
+
+        CharacterDatabase.PExecute("INSERT INTO ahbot_category (category, multiplier, max_auction_count, expire_time) "
+                "VALUES ('%s', '%f', '%u', '%u')",
+                name.c_str(), categoryMultipliers[name], categoryMaxAuctionCount[name], categoryMultiplierExpireTimes[name]);
+    }
+}
+
+
+void AhBot::updateMarketPrice(uint32 itemId, double price, uint32 auctionHouse)
+{
+    double marketPrice = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT price FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    if (results)
+    {
+        marketPrice = results->Fetch()[0].GetFloat();
+    }
+
+    if (marketPrice > 0)
+        marketPrice = (marketPrice + price) / 2;
+    else
+        marketPrice = price;
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    CharacterDatabase.PExecute("INSERT INTO ahbot_price (item, price, auction_house) VALUES ('%u', '%lf', '%u')", itemId, marketPrice, auctionHouse);
+}
+
+bool AhBot::IsBotAuction(uint32 bidder)
+{
+    return allBidders.find(bidder) != allBidders.end();
+}
+
+uint32 AhBot::GetRandomBidder(uint32 auctionHouse)
+{
+    vector<uint32> guids = bidders[factions[auctionHouse]];
+    if (guids.empty())
+        return 0;
+
+    vector<uint32> online;
+    for (vector<uint32>::iterator i = guids.begin(); i != guids.end(); ++i)
+    {
+        uint32 guid = *i;
+        Player* player = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (!player)
+            continue;
+
+        online.push_back(guid);
+    }
+
+    if (online.empty())
+        return 0;
+
+    int index = urand(0, online.size() - 1);
+    return online[index];
+}
+
+void AhBot::LoadRandomBots()
+{
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint8 race = fields[1].GetUInt8();
+            uint32 auctionHouse = PlayerbotAI::IsOpposing(race, RACE_HUMAN) ? 2 : 1;
+            bidders[auctionHouse].push_back(guid);
+            bidders[3].push_back(guid);
+            allBidders.insert(guid);
+        } while (result->NextRow());
+    }
+
+    if (allBidders.empty() && sAhBotConfig.guid)
+    {
+        uint32 guid = sAhBotConfig.guid;
+        allBidders.insert(guid);
+        for (int i = 1; i <= 3; i++)
+        {
+            bidders[i].push_back(guid);
+        }
+    }
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "{A=%d,H=%d,N=%d} bidders loaded", bidders[1].size(), bidders[2].size(), bidders[3].size());
+}
+
+int32 AhBot::GetSellPrice(ItemTemplate const* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 0;
+
+    int32 maxPrice = 0;
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+        {
+            int32 price = (int32)category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction]);
+            if (!price)
+                price = (int32)category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+
+            if (price > maxPrice)
+                maxPrice = price;
+        }
+    }
+
+    return maxPrice;
+}
+
+int32 AhBot::GetBuyPrice(ItemTemplate const* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 0;
+
+    int32 maxPrice = 0;
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+        {
+            int32 price = (int32)category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+            if (!price)
+                continue;
+
+            if (price > maxPrice)
+                maxPrice = price;
+        }
+    }
+
+    return maxPrice;
+}
+
+double AhBot::GetRarityPriceMultiplier(const ItemTemplate* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 1.0;
+
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        return category->GetPricingStrategy()->GetRarityPriceMultiplier(proto->ItemId);
+    }
+
+    return 1.0;
+
+}
diff --git a/src/plugins/ahbot/AhBot.h b/src/plugins/ahbot/AhBot.h
new file mode 100644
index 0000000..4b704fb
--- /dev/null
+++ b/src/plugins/ahbot/AhBot.h
@@ -0,0 +1,93 @@
+#pragma once
+
+#include "Category.h"
+#include "ItemBag.h"
+#include "../playerbot/PlayerbotAIBase.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+#include "../WorldSession.h"
+#include "../pchdef.h"
+
+#define MAX_AUCTIONS 3
+#define AHBOT_WON_EXPIRE 0
+#define AHBOT_WON_PLAYER 1
+#define AHBOT_WON_SELF 2
+#define AHBOT_WON_BID 3
+#define AHBOT_WON_DELAY 4
+#define AHBOT_SELL_DELAY 5
+
+namespace ahbot
+{
+    using namespace std;
+
+    class AhBot
+    {
+    public:
+        AhBot() : nextAICheckTime(0), updating(false) {}
+        virtual ~AhBot();
+        static AhBot& instance()
+        {
+            static AhBot instance;
+            return instance;
+        }
+
+    public:
+        static bool HandleAhBotCommand(ChatHandler* handler, char const* args);
+        ObjectGuid GetAHBplayerGUID();
+        void Init();
+        void Update();
+        void ForceUpdate();
+        void HandleCommand(string command);
+        void Won(AuctionEntry* entry) { AddToHistory(entry); }
+        void Expired(AuctionEntry* entry) {}
+
+        double GetCategoryMultiplier(string category)
+        {
+            return categoryMultipliers[category];
+        }
+
+        int32 GetSellPrice(const ItemTemplate* proto);
+        int32 GetBuyPrice(const ItemTemplate* proto);
+        double GetRarityPriceMultiplier(const ItemTemplate* proto);
+
+    private:
+        int Answer(int auction, Category* category, ItemBag* inAuctionItems);
+        int AddAuctions(int auction, Category* category, ItemBag* inAuctionItems);
+        int AddAuction(int auction, Category* category, const ItemTemplate* proto);
+        void Expire(int auction);
+        void PrintStats(int auction);
+        void AddToHistory(AuctionEntry* entry, uint32 won = 0);
+        void CleanupHistory();
+        uint32 GetAvailableMoney(uint32 auctionHouse);
+        void CheckCategoryMultipliers();
+        void updateMarketPrice(uint32 itemId, double price, uint32 auctionHouse);
+        bool IsBotAuction(uint32 bidder);
+        uint32 GetRandomBidder(uint32 auctionHouse);
+        void LoadRandomBots();
+        uint32 GetAnswerCount(uint32 itemId, uint32 auctionHouse, uint32 withinTime);
+        vector<AuctionEntry*> LoadAuctions(AuctionHouseObject* auctionHouse, Category*& category,
+                int& auction);
+        void FindMinPrice(AuctionHouseObject* auctionHouse, AuctionEntry*& entry, Item*& item, uint32* minBid,
+                uint32* minBuyout);
+        uint32 GetBuyTime(uint32 entry, uint32 itemId, uint32 auctionHouse, Category*& category, double priceLevel);
+        uint32 GetTime(string category, uint32 id, uint32 auctionHouse, uint32 type);
+        void SetTime(string category, uint32 id, uint32 auctionHouse, uint32 type, uint32 value);
+        uint32 GetSellTime(uint32 itemId, uint32 auctionHouse, Category*& category);
+
+    public:
+        static uint32 auctionIds[MAX_AUCTIONS];
+        static uint32 auctioneers[MAX_AUCTIONS];
+        static map<uint32, uint32> factions;
+
+    private:
+        AvailableItemsBag availableItems;
+        time_t nextAICheckTime;
+        map<string, double> categoryMultipliers;
+        map<string, uint32> categoryMaxAuctionCount;
+        map<string, uint64> categoryMultiplierExpireTimes;
+        map<uint32, vector<uint32> > bidders;
+        set<uint32> allBidders;
+        bool updating;
+    };
+};
+
+#define auctionbot ahbot::AhBot::instance()
diff --git a/src/plugins/ahbot/AhBotConfig.cpp b/src/plugins/ahbot/AhBotConfig.cpp
new file mode 100644
index 0000000..9d52ebd
--- /dev/null
+++ b/src/plugins/ahbot/AhBotConfig.cpp
@@ -0,0 +1,59 @@
+#include "../pchdef.h"
+#include "AhBotConfig.h"
+std::vector<std::string> split(const std::string &s, char delim);
+
+using namespace std;
+
+AhBotConfig::AhBotConfig()
+{
+}
+
+template <class T>
+void LoadSet(string value, T &res)
+{
+    vector<string> ids = split(value, ',');
+    for (vector<string>::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        uint32 id = atoi((*i).c_str());
+        if (!id)
+            continue;
+
+        res.insert(id);
+    }
+}
+
+bool AhBotConfig::Initialize()
+{
+    string error;
+	vector<string> args;
+    if (!config.LoadInitial("ahbot.conf", args, error))
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is Disabled. Unable to open configuration file ahbot.conf");
+        return false;
+    }
+
+    enabled = config.GetBoolDefault("AhBot.Enabled", true);
+
+    if (!enabled)
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is Disabled in ahbot.conf");
+
+    guid = (uint64)config.GetIntDefault("AhBot.GUID", 0);
+    updateInterval = config.GetIntDefault("AhBot.UpdateIntervalInSeconds", 300);
+    historyDays = config.GetIntDefault("AhBot.History.Days", 30);
+    itemBuyMinInterval = config.GetIntDefault("AhBot.ItemBuyMinInterval", 600);
+    itemBuyMaxInterval = config.GetIntDefault("AhBot.ItemBuyMaxInterval", 7200);
+    itemSellMinInterval = config.GetIntDefault("AhBot.ItemSellMinInterval", 600);
+    itemSellMaxInterval = config.GetIntDefault("AhBot.ItemSellMaxInterval", 7200);
+    maxSellInterval = config.GetIntDefault("AhBot.MaxSellInterval", 3600 * 8);
+    alwaysAvailableMoney = config.GetIntDefault("AhBot.AlwaysAvailableMoney", 200000);
+    priceMultiplier = config.GetFloatDefault("AhBot.PriceMultiplier", 1.0f);
+    defaultMinPrice = config.GetIntDefault("AhBot.DefaultMinPrice", 20);
+    maxItemLevel = config.GetIntDefault("AhBot.MaxItemLevel", 199);
+    maxRequiredLevel = config.GetIntDefault("AhBot.MaxRequiredLevel", 80);
+    priceQualityMultiplier = config.GetFloatDefault("AhBot.PriceQualityMultiplier", 1.0f);
+    underPriceProbability = config.GetFloatDefault("AhBot.UnderPriceProbability", 0.05f);
+    LoadSet<set<uint32> >(config.GetStringDefault("AhBot.IgnoreItemIds", "49283,52200,8494,6345,6891,2460,37164,34835"), ignoreItemIds);
+
+
+    return enabled;
+}
diff --git a/src/plugins/ahbot/AhBotConfig.h b/src/plugins/ahbot/AhBotConfig.h
new file mode 100644
index 0000000..1826109
--- /dev/null
+++ b/src/plugins/ahbot/AhBotConfig.h
@@ -0,0 +1,93 @@
+#pragma once
+
+#include "../../common/Configuration/Config.h"
+
+using namespace std;
+
+class AhBotConfig
+{
+public:
+    AhBotConfig();
+    static AhBotConfig& instance()
+    {
+        static AhBotConfig instance;
+        return instance;
+    }
+
+public:
+    bool Initialize();
+
+    bool enabled;
+    uint64 guid;
+    uint32 updateInterval;
+    uint32 historyDays, maxSellInterval;
+    uint32 itemBuyMinInterval, itemBuyMaxInterval;
+    uint32 itemSellMinInterval, itemSellMaxInterval;
+    uint32 alwaysAvailableMoney;
+    float priceMultiplier, priceQualityMultiplier;
+    uint32 defaultMinPrice;
+    uint32 maxItemLevel, maxRequiredLevel;
+    float underPriceProbability;
+    std::set<uint32> ignoreItemIds;
+
+    float GetSellPriceMultiplier(string category)
+    {
+        return GetCategoryParameter(sellPriceMultipliers, "PriceMultiplier.Sell", category, 1.0f);
+    }
+
+    float GetBuyPriceMultiplier(string category)
+    {
+        return GetCategoryParameter(buyPriceMultipliers, "PriceMultiplier.Buy", category, 1.0f);
+    }
+
+    float GetItemPriceMultiplier(string name)
+    {
+        return GetCategoryParameter(itemPriceMultipliers, "PriceMultiplier.Item", name, 1.0f);
+    }
+
+    int32 GetMaxAllowedAuctionCount(string category)
+    {
+        return (int32)GetCategoryParameter(maxAuctionCount, "MaxAuctionCount", category, 5);
+    }
+
+    std::string GetStringDefault(const char* name, const char* def)
+    {
+        return config.GetStringDefault(name, def);
+    }
+
+    bool GetBoolDefault(const char* name, const bool def = false)
+    {
+        return config.GetBoolDefault(name, def);
+    }
+
+    int32 GetIntDefault(const char* name, const int32 def)
+    {
+        return config.GetIntDefault(name, def);
+    }
+
+    float GetFloatDefault(const char* name, const float def)
+    {
+        return config.GetFloatDefault(name, def);
+    }
+
+private:
+    float GetCategoryParameter(map<string, float>& cache, string type, string category, float defaultValue)
+    {
+        if (cache.find(category) == cache.end())
+        {
+            ostringstream out; out << "AhBot."<< type << "." << category;
+            cache[category] = config.GetFloatDefault(out.str().c_str(), defaultValue);
+        }
+
+        return cache[category];
+    }
+
+private:
+    ConfigMgr config;
+    map<string, float> sellPriceMultipliers;
+    map<string, float> buyPriceMultipliers;
+    map<string, float> itemPriceMultipliers;
+    map<string, float> maxAuctionCount;
+};
+
+#define sAhBotConfig AhBotConfig::instance()
diff --git a/src/plugins/ahbot/Category.cpp b/src/plugins/ahbot/Category.cpp
new file mode 100644
index 0000000..1dd0ac5
--- /dev/null
+++ b/src/plugins/ahbot/Category.cpp
@@ -0,0 +1,76 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBotConfig.h"
+#include "PricingStrategy.h"
+
+using namespace ahbot;
+
+uint32 Category::GetStackCount(ItemTemplate const* proto)
+{
+    if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+        return 1;
+
+    return urand(1, proto->GetMaxStackSize());
+}
+
+uint32 Category::GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+{
+    return 0;
+}
+
+uint32 Category::GetMaxAllowedAuctionCount()
+{
+    return sAhBotConfig.GetMaxAllowedAuctionCount(GetName());
+}
+
+PricingStrategy* Category::GetPricingStrategy()
+{
+    if (pricingStrategy)
+        return pricingStrategy;
+
+    ostringstream out; out << "AhBot.PricingStrategy." << GetName();
+    string name = sAhBotConfig.GetStringDefault(out.str().c_str(), "default");
+    return pricingStrategy = PricingStrategyFactory::Create(name, this);
+}
+
+QualityCategoryWrapper::QualityCategoryWrapper(Category* category, uint32 quality) : Category(), quality(quality), category(category)
+{
+    ostringstream out; out << category->GetName() << ".";
+    switch (quality)
+    {
+    case ITEM_QUALITY_POOR:
+        out << "gray";
+        break;
+    case ITEM_QUALITY_NORMAL:
+        out << "white";
+        break;
+    case ITEM_QUALITY_UNCOMMON:
+        out << "green";
+        break;
+    case ITEM_QUALITY_RARE:
+        out << "blue";
+        break;
+    default:
+        out << "epic";
+        break;
+    }
+
+    combinedName = out.str();
+}
+
+bool QualityCategoryWrapper::Contains(ItemTemplate const* proto)
+{
+    return proto->Quality == quality && category->Contains(proto);
+}
+
+uint32 QualityCategoryWrapper::GetMaxAllowedAuctionCount()
+{
+    uint32 count = sAhBotConfig.GetMaxAllowedAuctionCount(combinedName);
+    return count > 0 ? count : category->GetMaxAllowedAuctionCount();
+}
+
+uint32 QualityCategoryWrapper::GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+{
+    return category->GetMaxAllowedItemAuctionCount(proto);
+}
diff --git a/src/plugins/ahbot/Category.h b/src/plugins/ahbot/Category.h
new file mode 100644
index 0000000..ec31b81
--- /dev/null
+++ b/src/plugins/ahbot/Category.h
@@ -0,0 +1,354 @@
+#pragma once
+#include "PricingStrategy.h"
+#include "../Entities/Item/ItemTemplate.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Category
+    {
+    public:
+        Category() : pricingStrategy(NULL) {}
+        virtual ~Category() { if (pricingStrategy) delete pricingStrategy; }
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto) { return false; }
+        virtual string GetName() { return "default"; }
+        virtual string GetDisplayName() { return GetName(); }
+
+        virtual uint32 GetMaxAllowedAuctionCount();
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto);
+        virtual uint32 GetStackCount(ItemTemplate const* proto);
+
+        virtual PricingStrategy* GetPricingStrategy();
+
+    private:
+        PricingStrategy *pricingStrategy;
+    };
+
+    class Consumable : public Category
+    {
+    public:
+        Consumable() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_CONSUMABLE;
+        }
+
+        virtual string GetName() { return "consumable"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 10;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+                return 1;
+
+            uint32 maxStackSize = proto->GetMaxStackSize();
+            if (maxStackSize == 1)
+                return 1;
+
+            if (maxStackSize <= 10)
+                return urand(1, 10);
+
+            return urand(1, 4) * maxStackSize / 5;
+        }
+    };
+
+    class Quest : public Category
+    {
+    public:
+        Quest() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_QUEST;
+        }
+        virtual string GetName() { return "quest"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+                return 1;
+
+            uint32 maxStackSize = proto->GetMaxStackSize();
+            if (proto->Quality == ITEM_QUALITY_UNCOMMON && maxStackSize > 10)
+                maxStackSize = urand(1, 10);
+
+            if (maxStackSize > 20)
+                maxStackSize = urand(1, 20);
+
+            return maxStackSize;
+        }
+    };
+
+    class Trade : public Category
+    {
+    public:
+        Trade() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_TRADE_GOODS;
+        }
+        virtual string GetName() { return "trade"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            uint32 maxStack = proto->GetMaxStackSize();
+            if (maxStack < 2)
+                return maxStack;
+
+            switch (proto->Quality)
+            {
+            case ITEM_QUALITY_NORMAL:
+                return maxStack;
+            case ITEM_QUALITY_UNCOMMON:
+                return urand(1, maxStack);
+            }
+
+            return 1;
+        }
+    };
+
+    class Enchant : public Category
+    {
+    public:
+        Enchant() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_PERMANENT && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "enchant"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Reagent : public Category
+    {
+    public:
+        Reagent() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_REAGENT && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "reagent"; }
+    };
+
+    class Recipe : public Category
+    {
+    public:
+        Recipe() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_RECIPE && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "recipe"; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Equip : public Category
+    {
+    public:
+        Equip() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return (proto->Class == ITEM_CLASS_WEAPON ||
+                proto->Class == ITEM_CLASS_ARMOR) && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "equip"; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Other : public Category
+    {
+    public:
+        Other() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Quality > ITEM_QUALITY_POOR && (
+                proto->Class == ITEM_CLASS_MISC ||
+                proto->Class == ITEM_CLASS_GENERIC ||
+                proto->Class == ITEM_CLASS_MONEY) && proto->ItemLevel > 1 && proto->SubClass != ITEM_SUBCLASS_JUNK_MOUNT;
+        }
+        virtual string GetName() { return "other"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Quiver : public Category
+    {
+    public:
+        Quiver() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_QUIVER && proto->ItemLevel > 1;
+        }
+
+        virtual string GetName() { return "quiver"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Projectile : public Category
+    {
+    public:
+        Projectile() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_PROJECTILE;
+        }
+
+        virtual string GetName() { return "projectile"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return proto->GetMaxStackSize();
+        }
+    };
+
+    class Container : public Category
+    {
+    public:
+        Container() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_CONTAINER && proto->ItemLevel > 1;
+        }
+
+        virtual string GetName() { return "container"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Glyph : public Category
+    {
+    public:
+        Glyph() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GLYPH;
+        }
+
+        virtual string GetName() { return "glyph"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class QualityCategoryWrapper : public Category
+    {
+    public:
+        QualityCategoryWrapper(Category* category, uint32 quality);
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto);
+        virtual uint32 GetMaxAllowedAuctionCount();
+        virtual string GetName() { return category->GetName(); }
+        virtual string GetDisplayName() { return combinedName; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto);
+        virtual uint32 GetStackCount(ItemTemplate const* proto) { return category->GetStackCount(proto); }
+        virtual PricingStrategy* GetPricingStrategy() { return category->GetPricingStrategy(); }
+
+    private:
+        uint32 quality;
+        Category* category;
+        string combinedName;
+    };
+};
diff --git a/src/plugins/ahbot/ConsumableCategory.cpp b/src/plugins/ahbot/ConsumableCategory.cpp
new file mode 100644
index 0000000..2cd06c5
--- /dev/null
+++ b/src/plugins/ahbot/ConsumableCategory.cpp
@@ -0,0 +1,5 @@
+#include "../pchdef.h"
+#include "ConsumableCategory.h"
+#include "ItemBag.h"
+
+using namespace ahbot;
diff --git a/src/plugins/ahbot/ConsumableCategory.h b/src/plugins/ahbot/ConsumableCategory.h
new file mode 100644
index 0000000..6f3051b
--- /dev/null
+++ b/src/plugins/ahbot/ConsumableCategory.h
@@ -0,0 +1,86 @@
+#pragma once
+#include "Category.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Alchemy : public Consumable
+    {
+    public:
+        Alchemy() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_POTION ||
+                    proto->SubClass == ITEM_SUBCLASS_ELIXIR ||
+                    proto->SubClass == ITEM_SUBCLASS_FLASK);
+        }
+
+        virtual string GetName() { return "Alchemy"; }
+    };
+
+    class Scroll : public Consumable
+    {
+    public:
+        Scroll() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_SCROLL ||
+                    proto->SubClass == ITEM_SUBCLASS_ITEM_ENHANCEMENT);
+        }
+
+        virtual string GetName() { return "Scroll"; }
+    };
+
+    class Food : public Consumable
+    {
+    public:
+        Food() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_FOOD;
+        }
+
+        virtual string GetName() { return "Food"; }
+    };
+
+    class Bandage : public Consumable
+    {
+    public:
+        Bandage() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_BANDAGE;
+        }
+
+        virtual string GetName() { return "Bandage"; }
+    };
+
+    class OtherConsumable : public Consumable
+    {
+    public:
+        OtherConsumable() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_CONSUMABLE ||
+                    proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) && (proto->RequiredSkill || proto->Flags & ITEM_FLAG_UNK6);
+        }
+
+        virtual string GetName() { return "OtherConsumable"; }
+    };
+};
diff --git a/src/plugins/ahbot/ItemBag.cpp b/src/plugins/ahbot/ItemBag.cpp
new file mode 100644
index 0000000..8bf4107
--- /dev/null
+++ b/src/plugins/ahbot/ItemBag.cpp
@@ -0,0 +1,184 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "ConsumableCategory.h"
+#include "TradeCategory.h"
+#include "AhBotConfig.h"
+#include "../DataStores/DBCStructure.h"
+#include "../../common/Logging/Log.h"
+#include "../../server/database/Database/QueryResult.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "../../shared/DataStores/DBCStore.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+
+using namespace ahbot;
+char * strstri (const char* str1, const char* str2);
+
+CategoryList CategoryList::instance;
+
+CategoryList::CategoryList()
+{
+    Add(new Equip());
+    Add(new ahbot::Quest());
+    Add(new Quiver());
+    Add(new Projectile());
+
+    Add(new Recipe());
+    Add(new Container());
+
+    Add(new Reagent());
+    Add(new Enchant());
+    Add(new Alchemy());
+    Add(new Scroll());
+    Add(new Food());
+    Add(new Bandage());
+
+    Add(new Cloth());
+    Add(new Leather());
+    Add(new Herb());
+    Add(new Metal());
+    Add(new Disenchants());
+    Add(new Meat());
+    Add(new Engineering());
+    Add(new SimpleGems());
+    Add(new SocketGems());
+    Add(new Elemental());
+
+    Add(new Glyph());
+
+    Add(new OtherConsumable());
+    Add(new OtherTrade());
+    Add(new Other());
+}
+
+void CategoryList::Add(Category* category)
+{
+    for (uint32 quality = ITEM_QUALITY_NORMAL; quality <= ITEM_QUALITY_EPIC; ++quality)
+        categories.push_back(new QualityCategoryWrapper(category, quality));
+}
+
+CategoryList::~CategoryList()
+{
+    for (vector<Category*>::const_iterator i = categories.begin(); i != categories.end(); ++i)
+        delete *i;
+}
+
+ItemBag::ItemBag()
+{
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        content[CategoryList::instance[i]] = vector<uint32>();
+    }
+}
+
+void ItemBag::Init(bool silent)
+{
+    if (silent)
+    {
+        Load();
+        return;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Loading/Scanning %s...", GetName().c_str());
+
+    Load();
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        Shuffle(content[category]);
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "loaded %d %s items", content[category].size(), category->GetDisplayName().c_str());
+    }
+}
+
+int32 ItemBag::GetCount(Category* category, uint32 item)
+{
+    uint32 count = 0;
+
+    vector<uint32>& items = content[category];
+    for (vector<uint32>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        if (*i == item)
+            count++;
+    }
+
+    return count;
+}
+
+bool ItemBag::Add(ItemTemplate const* proto)
+{
+    if (!proto ||
+        proto->Bonding == BIND_WHEN_PICKED_UP ||
+        proto->Bonding == BIND_QUEST_ITEM)
+        return false;
+
+    if (proto->RequiredLevel > sAhBotConfig.maxRequiredLevel || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+        return false;
+
+    if (proto->Duration & 0x80000000)
+        return false;
+
+    if (sAhBotConfig.ignoreItemIds.find(proto->ItemId) != sAhBotConfig.ignoreItemIds.end())
+        return false;
+
+    if (strstri(proto->Name1.c_str(), "qa") || strstri(proto->Name1.c_str(), "test") || strstri(proto->Name1.c_str(), "deprecated"))
+        return false;
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        if (CategoryList::instance[i]->Contains(proto))
+        {
+            content[CategoryList::instance[i]].push_back(proto->ItemId);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void AvailableItemsBag::Load()
+{
+    set<uint32> vendorItems;
+
+      QueryResult results = WorldDatabase.PQuery("SELECT item FROM npc_vendor where maxcount = 0");
+      if (results != NULL)
+      {
+          do
+          {
+              Field* fields = results->Fetch();
+              vendorItems.insert(fields[0].GetUInt32());
+          } while (results->NextRow());
+      }
+
+      ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+      for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+      {
+          ItemTemplate const& itemTemplate = i->second;
+          uint32 itemId = i->first;
+
+          if (vendorItems.find(itemTemplate.ItemId) != vendorItems.end())
+              continue;
+
+        Add(sObjectMgr->GetItemTemplate(itemId));
+    }
+
+}
+
+void InAuctionItemsBag::Load()
+{
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionId);
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itr->second->itemEntry);
+        if (!proto)
+            continue;
+
+        Add(proto);
+    }
+}
+
+string InAuctionItemsBag::GetName()
+{
+    ostringstream out; out << "auction house " << auctionId;
+    return out.str();
+}
diff --git a/src/plugins/ahbot/ItemBag.h b/src/plugins/ahbot/ItemBag.h
new file mode 100644
index 0000000..4d11fd4
--- /dev/null
+++ b/src/plugins/ahbot/ItemBag.h
@@ -0,0 +1,82 @@
+#pragma once
+#include "Category.h"
+
+namespace ahbot
+{
+    using namespace std;
+
+    class CategoryList
+    {
+    public:
+        CategoryList();
+        virtual ~CategoryList();
+
+        Category* operator[](int index) { return categories[index]; }
+        int32 size() { return categories.size(); }
+        static CategoryList instance;
+
+    private:
+        void Add(Category* category);
+
+    private:
+        vector<Category*> categories;
+    };
+
+    template<class T>
+    void Shuffle(vector<T>& items) 
+    {
+        uint32 count = items.size();
+        for (uint32 i = 0; i < count * 5; i++)
+        {
+            int i1 = urand(0, count - 1);
+            int i2 = urand(0, count - 1);
+
+            T item = items[i1];
+            items[i1] = items[i2];
+            items[i2] = item;
+        }
+    }
+
+    class ItemBag 
+    {
+    public:
+        ItemBag();
+
+    public:
+        void Init(bool silent = false);
+        vector<uint32>& Get(Category* category) { return content[category]; }
+        int32 GetCount(Category* category) { return content[category].size(); }
+        int32 GetCount(Category* category, uint32 item);
+        bool Add(ItemTemplate const* proto);
+
+    protected:
+        virtual void Load() = 0;
+        virtual string GetName() = 0;
+
+    protected:
+        map<Category*,vector<uint32> > content;
+    };
+
+    class AvailableItemsBag : public ItemBag
+    {
+    public:
+        AvailableItemsBag() {}
+
+    protected:
+        virtual void Load();
+        virtual string GetName() { return "available"; }
+    };
+
+    class InAuctionItemsBag : public ItemBag
+    {
+    public:
+        InAuctionItemsBag(uint32 auctionId) : auctionId(auctionId) {}
+
+    protected:
+        virtual void Load();
+        virtual string GetName();
+
+    private:
+        uint32 auctionId;
+    };
+};
diff --git a/src/plugins/ahbot/PricingStrategy.cpp b/src/plugins/ahbot/PricingStrategy.cpp
new file mode 100644
index 0000000..e51c00e
--- /dev/null
+++ b/src/plugins/ahbot/PricingStrategy.cpp
@@ -0,0 +1,220 @@
+#include "PricingStrategy.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBotConfig.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "AhBot.h"
+
+using namespace ahbot;
+
+uint32 PricingStrategy::GetSellPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    uint32 now = time(0);
+    double price = sAhBotConfig.GetItemPriceMultiplier(proto->Name1) *
+        auctionbot.GetCategoryMultiplier(category->GetName()) *
+        GetRarityPriceMultiplier(proto->ItemId) *
+        GetCategoryPriceMultiplier(now, auctionHouse) *
+        GetItemPriceMultiplier(proto, now, auctionHouse) *
+        sAhBotConfig.GetSellPriceMultiplier(category->GetName()) *
+        GetDefaultSellPrice(proto);
+    return (uint32)price;
+}
+
+double PricingStrategy::GetMarketPrice(uint32 itemId, uint32 auctionHouse)
+{
+    double marketPrice = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT price FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    if (results)
+    {
+        marketPrice = results->Fetch()[0].GetFloat();
+    }
+
+    return marketPrice;
+}
+
+uint32 PricingStrategy::GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    double marketPrice = GetMarketPrice(proto->ItemId, auctionHouse);
+
+    if (marketPrice > 0)
+        return marketPrice;
+
+    uint32 untilTime = time(0) - 3600 * 12;
+    double price = sAhBotConfig.GetItemPriceMultiplier(proto->Name1) *
+        auctionbot.GetCategoryMultiplier(category->GetName()) *
+        GetRarityPriceMultiplier(proto->ItemId) *
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) *
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) *
+        sAhBotConfig.GetBuyPriceMultiplier(category->GetName()) *
+        GetDefaultBuyPrice(proto);
+    return (uint32)price;
+}
+
+string PricingStrategy::ExplainSellPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    ostringstream out;
+
+    uint32 untilTime = time(0);
+    out << sAhBotConfig.GetItemPriceMultiplier(proto->Name1) << " (item const) * " <<
+        auctionbot.GetCategoryMultiplier(category->GetName()) << " (random) * " <<
+        GetRarityPriceMultiplier(proto->ItemId) << " (rariry) * " <<
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) << " (category) * " <<
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) << " (item) * " <<
+        sAhBotConfig.GetSellPriceMultiplier(category->GetName()) << " (sell) * " <<
+        GetDefaultSellPrice(proto) << " (price)";
+    return out.str();
+}
+
+string PricingStrategy::ExplainBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    ostringstream out;
+
+    double marketPrice = GetMarketPrice(proto->ItemId, auctionHouse);
+    if (marketPrice > 0)
+    {
+        out << marketPrice << " (market)";
+        return out.str();
+    }
+
+    uint32 untilTime = time(0) - 3600 * 12;
+    out << sAhBotConfig.GetItemPriceMultiplier(proto->Name1) << " (item const) * " <<
+        auctionbot.GetCategoryMultiplier(category->GetName()) << " (random) * " <<
+        GetRarityPriceMultiplier(proto->ItemId) << " (rarity) * " <<
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) << " (category) * " <<
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) << " (item) * " <<
+        sAhBotConfig.GetBuyPriceMultiplier(category->GetName()) << " (buy) * " <<
+        GetDefaultBuyPrice(proto) << " (price)";
+    return out.str();
+}
+
+double PricingStrategy::GetRarityPriceMultiplier(uint32 itemId)
+{
+    double result = 1.0;
+
+    QueryResult results = WorldDatabase.PQuery(
+        "select max(Chance) from ( "
+        "select Chance from gameobject_loot_template where item = '%u' "
+        "union select Chance from spell_loot_template where item = '%u' "
+        "union select Chance from disenchant_loot_template where item = '%u' "
+        "union select Chance from fishing_loot_template where item = '%u' "
+        "union select Chance from item_loot_template where item = '%u' "
+        "union select Chance from milling_loot_template where item = '%u' "
+        "union select Chance from pickpocketing_loot_template where item = '%u' "
+        "union select Chance from prospecting_loot_template where item = '%u' "
+        "union select Chance from reference_loot_template where item = '%u' "
+        "union select Chance from skinning_loot_template where item = '%u' "
+        "union select Chance from creature_loot_template where item = '%u' "
+        "union select 0 "
+        ") a",
+        itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        float chance = fields[0].GetFloat();
+
+        if (chance > 0 && chance <= 90.0)
+            result = sqrt((100.0 - chance) / 10.0);
+    }
+
+    return result >= 1.0 ? result : 1.0;
+}
+
+
+double PricingStrategy::GetCategoryPriceMultiplier(uint32 untilTime, uint32 auctionHouse)
+{
+    double result = 1.0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT count(*) FROM (SELECT round(buytime/3600/24/5) as days FROM ahbot_history WHERE category = '%s' AND won = '1' AND buytime <= '%u' AND auction_house = '%u' group by days) q",
+        category->GetName().c_str(), untilTime, AhBot::factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 count = fields[0].GetUInt32();
+
+        if (count)
+            result += count;
+    }
+
+    return result;
+}
+
+double PricingStrategy::GetMultiplier(double count, double firstBuyTime, double lastBuyTime)
+{
+    double k1 = (double)count / (double)((time(0) - firstBuyTime) / 3600 / 24 + 1);
+    double k2 = (double)count / (double)((time(0) - lastBuyTime) / 3600 / 24 + 1);
+    return max(1.0, k1 + k2) * sAhBotConfig.priceMultiplier;
+}
+
+double PricingStrategy::GetItemPriceMultiplier(ItemTemplate const* proto, uint32 untilTime, uint32 auctionHouse)
+{
+    double result = 1.0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT count(*) FROM (SELECT round(buytime/3600/24/5) as days FROM ahbot_history WHERE won = '1' AND item = '%u' AND buytime <= '%u' AND auction_house = '%u' group by days) q",
+        proto->ItemId, untilTime, AhBot::factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 count = fields[0].GetUInt32();
+
+        if (count)
+            result += count;
+    }
+
+    return result;
+}
+
+uint32 PricingStrategy::ApplyQualityMultiplier(ItemTemplate const* proto, uint32 price)
+{
+    if (proto->Quality == ITEM_QUALITY_POOR)
+        return price;
+
+    return (uint32)(price * sqrt((double)proto->Quality) * sAhBotConfig.priceQualityMultiplier);
+}
+
+uint32 PricingStrategy::GetDefaultBuyPrice(ItemTemplate const* proto)
+{
+    uint32 price = 0;
+
+    if (proto->SellPrice)
+        price = proto->SellPrice;
+    if (proto->BuyPrice)
+        price = max(price, (uint32)(proto->BuyPrice / 4));
+
+    uint32 level = max(proto->ItemLevel, proto->RequiredLevel);
+    if (proto->Class == ITEM_CLASS_QUEST)
+    {
+        double result = 1.0;
+
+        QueryResult results = WorldDatabase.PQuery(
+            "select max(QuestLevel), max(MinLevel) from quest_template where RequiredItemId1 = %u or RequiredItemId2 = %u or RequiredItemId3 = %u or RequiredItemId4 = %u or RequiredItemId5 = %u or RequiredItemId6 = %u",
+            proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId);
+        if (results)
+        {
+            Field* fields = results->Fetch();
+            level = max(fields[0].GetUInt32(), fields[1].GetUInt32());
+        }
+    }
+    price = max(price, sAhBotConfig.defaultMinPrice * level * level / 10);
+    price = max(price, (uint32)100);
+
+    return ApplyQualityMultiplier(proto, price) * sAhBotConfig.priceMultiplier;
+}
+
+uint32 PricingStrategy::GetDefaultSellPrice(ItemTemplate const* proto)
+{
+    return GetDefaultBuyPrice(proto);
+}
+
+
+uint32 BuyOnlyRarePricingStrategy::GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    if (proto->Quality < ITEM_QUALITY_RARE)
+        return 0;
+
+    return PricingStrategy::GetBuyPrice(proto, auctionHouse);
+}
+
diff --git a/src/plugins/ahbot/PricingStrategy.h b/src/plugins/ahbot/PricingStrategy.h
new file mode 100644
index 0000000..2bbcf41
--- /dev/null
+++ b/src/plugins/ahbot/PricingStrategy.h
@@ -0,0 +1,55 @@
+#pragma once
+#include "../../game/Entities/Item/ItemTemplate.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Category;
+
+    class PricingStrategy
+    {
+    public:
+        PricingStrategy(Category* category) : category(category) {}
+
+    public:
+        virtual uint32 GetSellPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        virtual uint32 GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        string ExplainSellPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        string ExplainBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        virtual double GetRarityPriceMultiplier(uint32 itemId);
+
+    protected:
+        virtual uint32 GetDefaultBuyPrice(ItemTemplate const* proto);
+        virtual uint32 GetDefaultSellPrice(ItemTemplate const* proto);
+        virtual uint32 ApplyQualityMultiplier(ItemTemplate const* proto, uint32 price);
+        virtual double GetCategoryPriceMultiplier(uint32 untilTime, uint32 auctionHouse);
+        virtual double GetItemPriceMultiplier(ItemTemplate const* proto, uint32 untilTime, uint32 auctionHouse);
+        double GetMultiplier(double count, double firstBuyTime, double lastBuyTime);
+        double GetMarketPrice(uint32 itemId, uint32 auctionHouse);
+
+    protected:
+        Category* category;
+    };
+
+    class BuyOnlyRarePricingStrategy : public PricingStrategy
+    {
+    public:
+        BuyOnlyRarePricingStrategy(Category* category) : PricingStrategy(category) {}
+
+    public:
+        virtual uint32 GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+    };
+
+    class PricingStrategyFactory
+    {
+    public:
+        static PricingStrategy* Create(string name, Category* category)
+        {
+            if (name == "buyOnlyRare")
+                return new BuyOnlyRarePricingStrategy(category);
+
+            return new PricingStrategy(category);
+        }
+    };
+};
diff --git a/src/plugins/ahbot/TradeCategory.cpp b/src/plugins/ahbot/TradeCategory.cpp
new file mode 100644
index 0000000..082ee56
--- /dev/null
+++ b/src/plugins/ahbot/TradeCategory.cpp
@@ -0,0 +1,4 @@
+#include "TradeCategory.h"
+#include "ItemBag.h"
+
+using namespace ahbot;
diff --git a/src/plugins/ahbot/TradeCategory.h b/src/plugins/ahbot/TradeCategory.h
new file mode 100644
index 0000000..1d987ba
--- /dev/null
+++ b/src/plugins/ahbot/TradeCategory.h
@@ -0,0 +1,183 @@
+#pragma once
+#include "Category.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Cloth : public Trade
+    {
+    public:
+        Cloth() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_CLOTH;
+        }
+
+        virtual string GetName() { return "Cloth"; }
+    };
+
+    class Leather : public Trade
+    {
+    public:
+        Leather() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_LEATHER;
+        }
+
+        virtual string GetName() { return "Leather"; }
+    };
+
+    class Elemental : public Trade
+    {
+    public:
+        Elemental() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                proto->SubClass == ITEM_SUBCLASS_ELEMENTAL;
+        }
+
+        virtual string GetName() { return "Elemental"; }
+    };
+
+    class Herb : public Trade
+    {
+    public:
+        Herb() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_HERB;
+        }
+
+        virtual string GetName() { return "Herb"; }
+    };
+
+    class Meat : public Trade
+    {
+    public:
+        Meat() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_MEAT;
+        }
+
+        virtual string GetName() { return "Meat"; }
+    };
+
+    class Metal : public Trade
+    {
+    public:
+        Metal() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_METAL_STONE;
+        }
+
+        virtual string GetName() { return "Metal"; }
+    };
+
+    class Disenchants : public Trade
+    {
+    public:
+        Disenchants() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_ENCHANTING;
+        }
+
+        virtual string GetName() { return "Disenchants"; }
+    };
+
+    class SimpleGems : public Trade
+    {
+    public:
+        SimpleGems() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GEM && proto->SubClass == ITEM_SUBCLASS_GEM_SIMPLE;
+        }
+
+        virtual string GetName() { return "SimpleGems"; }
+    };
+
+    class SocketGems : public Trade
+    {
+    public:
+        SocketGems() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GEM && proto->SubClass != ITEM_SUBCLASS_GEM_SIMPLE;
+        }
+
+        virtual string GetName() { return "SocketGems"; }
+    };
+
+    class Engineering : public Trade
+    {
+    public:
+        Engineering() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_PARTS ||
+                    proto->SubClass == ITEM_SUBCLASS_DEVICES ||
+                    proto->SubClass == ITEM_SUBCLASS_MATERIAL ||
+                    proto->SubClass == ITEM_SUBCLASS_EXPLOSIVES);
+        }
+
+        virtual string GetName() { return "Engineering"; }
+    };
+
+    class OtherTrade : public Trade
+    {
+    public:
+        OtherTrade() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass != ITEM_SUBCLASS_PARTS &&
+                    proto->SubClass != ITEM_SUBCLASS_DEVICES &&
+                    proto->SubClass != ITEM_SUBCLASS_MATERIAL &&
+                    proto->SubClass != ITEM_SUBCLASS_EXPLOSIVES &&
+                    proto->SubClass != ITEM_SUBCLASS_ENCHANTING &&
+                    proto->SubClass != ITEM_SUBCLASS_JEWELCRAFTING &&
+                    proto->SubClass != ITEM_SUBCLASS_METAL_STONE &&
+                    proto->SubClass != ITEM_SUBCLASS_MEAT &&
+                    proto->SubClass != ITEM_SUBCLASS_HERB &&
+                    proto->SubClass != ITEM_SUBCLASS_LEATHER &&
+                    proto->SubClass != ITEM_SUBCLASS_CLOTH;
+        }
+
+        virtual string GetName() { return "OtherTrade"; }
+    };
+};
diff --git a/src/plugins/ahbot/ahbot.conf.dist.in b/src/plugins/ahbot/ahbot.conf.dist.in
new file mode 100644
index 0000000..f50ffc2
--- /dev/null
+++ b/src/plugins/ahbot/ahbot.conf.dist.in
@@ -0,0 +1,209 @@
+################################################
+# MANGOS Auction House Bot Configuration file  #
+################################################
+
+[AhbotConf]
+ConfVersion=2010102201
+
+###################################################################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+###################################################################################################################
+
+# Disable original AuctionHouseBot
+AuctionHouseBot.Seller.Enabled = 0
+AuctionHouseBot.Buyer.Enabled = 0
+
+# Replace with the new AhBot
+AhBot.Enabled = 1
+
+# Should be used only if random bots are disabled
+# AhBot.GUID = 0
+
+# 199 for 80, 80 for 70, 70 for 60, ..., 25 for 20
+AhBot.MaxItemLevel = 199
+# Same as level cap
+AhBot.MaxRequiredLevel = 80
+
+# Ignore items by ID
+AhBot.IgnoreItemIds = 49283,52200,8494,6345,6891,2460
+
+AhBot.PriceMultiplier = 1.0
+AhBot.DefaultMinPrice = 20
+AhBot.PriceQualityMultiplier = 1.0
+AhBot.AlwaysAvailableMoney = 2000000
+
+# Buy/sell delays
+AhBot.ItemBuyMinInterval = 7200
+AhBot.ItemBuyMaxInterval = 28800
+AhBot.ItemSellMinInterval = 7200
+AhBot.ItemSellMaxInterval = 28800
+
+#
+# Items
+#
+
+AhBot.MaxAuctionCount.equip.green = 0
+AhBot.MaxAuctionCount.equip.blue = 40
+AhBot.MaxAuctionCount.equip.epic = 20
+AhBot.PriceMultiplier.Sell.equip = 1.0
+AhBot.PriceMultiplier.Buy.equip = 1.0
+AhBot.PricingStrategy.equip = buyOnlyRare
+
+AhBot.MaxAuctionCount.reagent.white = 6
+AhBot.MaxAuctionCount.reagent.green = 2
+AhBot.PriceMultiplier.Sell.reagent = 1.0
+AhBot.PriceMultiplier.Buy.reagent = 1.0
+AhBot.PricingStrategy.reagent = buyOnlyRare
+
+AhBot.MaxAuctionCount.other.white = 20
+AhBot.MaxAuctionCount.other.green = 10
+AhBot.MaxAuctionCount.other.blue = 6
+AhBot.PriceMultiplier.Sell.other = 1.0
+AhBot.PriceMultiplier.Buy.other = 1.0
+AhBot.PricingStrategy.other = buyOnlyRare
+
+#
+# Container
+#
+
+AhBot.MaxAuctionCount.quiver.white = 2
+AhBot.PriceMultiplier.Sell.quiver = 1.0
+AhBot.PriceMultiplier.Buy.quiver = 1.0
+AhBot.PricingStrategy.quiver = buyOnlyRare
+
+AhBot.MaxAuctionCount.container.white = 6
+AhBot.MaxAuctionCount.container.green = 2
+AhBot.MaxAuctionCount.container.blue = 2
+AhBot.PriceMultiplier.Sell.container = 1.0
+AhBot.PriceMultiplier.Buy.container = 1.0
+
+#
+# Glyph
+#
+
+AhBot.MaxAuctionCount.glyph.white = 50
+AhBot.MaxAuctionCount.glyph.green = 20
+AhBot.MaxAuctionCount.glyph.blue = 10
+AhBot.PriceMultiplier.Sell.glyph = 1.0
+AhBot.PriceMultiplier.Buy.glyph = 1.0
+
+#
+# Quest
+#
+
+AhBot.MaxAuctionCount.quest.white = 14
+AhBot.MaxAuctionCount.quest.green = 2
+AhBot.MaxAuctionCount.quest.blue = 2
+AhBot.PriceMultiplier.Sell.quest = 1.0
+AhBot.PriceMultiplier.Buy.quest = 1.0
+
+#
+# Consumables
+#
+
+AhBot.MaxAuctionCount.alchemy.white = 50
+AhBot.MaxAuctionCount.alchemy.green = 20
+AhBot.MaxAuctionCount.alchemy.blue = 10
+AhBot.PriceMultiplier.Sell.alchemy = 1.0
+AhBot.PriceMultiplier.Buy.alchemy = 1.0
+
+AhBot.MaxAuctionCount.scroll.white = 40
+AhBot.MaxAuctionCount.scroll.green = 6
+AhBot.MaxAuctionCount.scroll.blue = 4
+AhBot.PriceMultiplier.Sell.scroll = 1.0
+AhBot.PriceMultiplier.Buy.scroll = 1.0
+
+AhBot.MaxAuctionCount.Food.white = 40
+AhBot.PriceMultiplier.Sell.Food = 1.0
+AhBot.PriceMultiplier.Buy.Food = 1.0
+
+AhBot.MaxAuctionCount.bandage.white = 10
+AhBot.PriceMultiplier.Sell.bandage = 1.0
+AhBot.PriceMultiplier.Buy.bandage = 1.0
+
+AhBot.MaxAuctionCount.OtherConsumable.white = 20
+AhBot.MaxAuctionCount.OtherConsumable.green = 10
+AhBot.MaxAuctionCount.OtherConsumable.blue = 5
+AhBot.PriceMultiplier.Sell.OtherConsumable = 1.0
+AhBot.PriceMultiplier.Buy.OtherConsumable = 1.0
+
+#
+# Recipe
+#
+
+AhBot.MaxAuctionCount.recipe.white = 8
+AhBot.MaxAuctionCount.recipe.green = 4
+AhBot.MaxAuctionCount.recipe.blue = 2
+AhBot.MaxAuctionCount.recipe.epic = 2
+AhBot.PriceMultiplier.Sell.recipe = 1.0
+AhBot.PriceMultiplier.Buy.recipe = 1.0
+
+#
+# Trade
+#
+
+AhBot.MaxAuctionCount.Elemental.white = 30
+AhBot.MaxAuctionCount.Elemental.green = 20
+AhBot.MaxAuctionCount.Elemental.blue = 6
+AhBot.PriceMultiplier.Sell.Elemental = 1.0
+AhBot.PriceMultiplier.Buy.Elemental = 1.0
+
+AhBot.MaxAuctionCount.Cloth.white = 50
+AhBot.MaxAuctionCount.Cloth.green = 14
+AhBot.MaxAuctionCount.Cloth.blue = 6
+AhBot.PriceMultiplier.Sell.Cloth = 1.0
+AhBot.PriceMultiplier.Buy.Cloth = 1.0
+
+AhBot.MaxAuctionCount.Leather.white = 50
+AhBot.MaxAuctionCount.Leather.green = 14
+AhBot.MaxAuctionCount.Leather.blue = 6
+AhBot.PriceMultiplier.Sell.Leather = 1.0
+AhBot.PriceMultiplier.Buy.Leather = 1.0
+
+AhBot.MaxAuctionCount.Herb.white = 50
+AhBot.MaxAuctionCount.Herb.green = 14
+AhBot.PriceMultiplier.Sell.Herb = 1.0
+AhBot.PriceMultiplier.Buy.Herb = 1.0
+
+AhBot.MaxAuctionCount.Meat.white = 50
+AhBot.PriceMultiplier.Sell.Meat = 1.0
+AhBot.PriceMultiplier.Buy.Meat = 1.0
+
+AhBot.MaxAuctionCount.Metal.white = 50
+AhBot.MaxAuctionCount.Metal.green = 14
+AhBot.MaxAuctionCount.Metal.blue = 6
+AhBot.PriceMultiplier.Sell.Metal = 1.0
+AhBot.PriceMultiplier.Buy.Metal = 1.0
+
+AhBot.MaxAuctionCount.Engineering.white = 20
+AhBot.MaxAuctionCount.Engineering.green = 10
+AhBot.MaxAuctionCount.Engineering.blue = 4
+AhBot.PriceMultiplier.Sell.Engineering = 1.0
+AhBot.PriceMultiplier.Buy.Engineering = 1.0
+
+AhBot.MaxAuctionCount.Disenchants.white = 40
+AhBot.MaxAuctionCount.Disenchants.green = 20
+AhBot.MaxAuctionCount.Disenchants.blue = 20
+AhBot.PriceMultiplier.Sell.Disenchants = 1.0
+AhBot.PriceMultiplier.Buy.Disenchants = 1.0
+
+AhBot.MaxAuctionCount.SimpleGems.green = 30
+AhBot.MaxAuctionCount.SimpleGems.blue = 20
+AhBot.MaxAuctionCount.SimpleGems.epic = 4
+AhBot.PriceMultiplier.Sell.SimpleGems = 1.0
+AhBot.PriceMultiplier.Buy.SimpleGems = 1.0
+
+AhBot.MaxAuctionCount.SocketGems.green = 50
+AhBot.MaxAuctionCount.SocketGems.blue = 20
+AhBot.MaxAuctionCount.SocketGems.epic = 4
+AhBot.PriceMultiplier.Sell.SocketGems = 1.0
+AhBot.PriceMultiplier.Buy.SocketGems = 1.0
+
+AhBot.MaxAuctionCount.OtherTrade.white = 10
+AhBot.PriceMultiplier.Sell.OtherTrade = 1.0
+AhBot.PriceMultiplier.Buy.OtherTrade = 1.0
+
+AhBot.PriceMultiplier.Sell.projectile = 1.0
+AhBot.PriceMultiplier.Buy.projectile = 1.0
+AhBot.PricingStrategy.projectile = buyOnlyRare
diff --git a/src/plugins/pch/pch.cpp b/src/plugins/pch/pch.cpp
new file mode 100644
index 0000000..1d9f38c
--- /dev/null
+++ b/src/plugins/pch/pch.cpp
@@ -0,0 +1 @@
+#include "pch.h"
diff --git a/src/plugins/pch/pch.h b/src/plugins/pch/pch.h
new file mode 100644
index 0000000..c7c6ca5
--- /dev/null
+++ b/src/plugins/pch/pch.h
@@ -0,0 +1,10 @@
+//add here most rarely modified headers to speed up debug build compilation
+
+#include "Common.h"
+#include "MapManager.h"
+#include "Log.h"
+#include "ObjectAccessor.h"
+#include "ObjectDefines.h"
+#include "Opcodes.h"
+#include "SharedDefines.h"
+#include "ObjectMgr.h"
diff --git a/src/plugins/pchdef.h b/src/plugins/pchdef.h
new file mode 100644
index 0000000..f58aae9
--- /dev/null
+++ b/src/plugins/pchdef.h
@@ -0,0 +1,4 @@
+#ifndef PCHDEF_H_
+#define PCHDEF_H_
+
+#endif /* PCHDEF_H_ */
diff --git a/src/plugins/playerbot/AiFactory.cpp b/src/plugins/playerbot/AiFactory.cpp
new file mode 100644
index 0000000..cfe621e
--- /dev/null
+++ b/src/plugins/playerbot/AiFactory.cpp
@@ -0,0 +1,229 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "AiFactory.h"
+#include "strategy/Engine.h"
+
+#include "strategy/priest/PriestAiObjectContext.h"
+#include "strategy/mage/MageAiObjectContext.h"
+#include "strategy/warlock/WarlockAiObjectContext.h"
+#include "strategy/warrior/WarriorAiObjectContext.h"
+#include "strategy/shaman/ShamanAiObjectContext.h"
+#include "strategy/paladin/PaladinAiObjectContext.h"
+#include "strategy/druid/DruidAiObjectContext.h"
+#include "strategy/hunter/HunterAiObjectContext.h"
+#include "strategy/rogue/RogueAiObjectContext.h"
+#include "../Entities/Player/Player.h"
+#include "PlayerbotAIConfig.h"
+#include "RandomPlayerbotMgr.h"
+
+
+AiObjectContext* AiFactory::createAiObjectContext(Player* player, PlayerbotAI* ai)
+{
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:
+        return new PriestAiObjectContext(ai);
+        break;
+    case CLASS_MAGE:
+        return new MageAiObjectContext(ai);
+        break;
+    case CLASS_WARLOCK:
+        return new WarlockAiObjectContext(ai);
+        break;
+    case CLASS_WARRIOR:
+        return new WarriorAiObjectContext(ai);
+        break;
+    case CLASS_SHAMAN:
+        return new ShamanAiObjectContext(ai);
+        break;
+    case CLASS_PALADIN:
+        return new PaladinAiObjectContext(ai);
+        break;
+    case CLASS_DRUID:
+        return new DruidAiObjectContext(ai);
+        break;
+    case CLASS_HUNTER:
+        return new HunterAiObjectContext(ai);
+        break;
+    case CLASS_ROGUE:
+        return new RogueAiObjectContext(ai);
+        break;
+    }
+    return new AiObjectContext(ai);
+}
+
+int AiFactory::GetPlayerSpecTab(Player* player)
+{
+    int c0 = 0, c1 = 0, c2 = 0;
+    PlayerTalentMap& talentMap = player->GetTalentMap(0);
+    for (PlayerTalentMap::iterator i = talentMap.begin(); i != talentMap.end(); ++i)
+    {
+        uint32 spellId = i->first;
+        TalentSpellPos const* talentPos = GetTalentSpellPos(spellId);
+        if(!talentPos)
+            continue;
+
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id);
+        if (!talentInfo)
+            continue;
+
+        uint32 const* talentTabIds = GetTalentTabPages(player->getClass());
+        if (talentInfo->TalentTab == talentTabIds[0]) c0++;
+        if (talentInfo->TalentTab == talentTabIds[1]) c1++;
+        if (talentInfo->TalentTab == talentTabIds[2]) c2++;
+    }
+
+    if (c0 >= c1 && c0 >= c2)
+        return 0;
+
+    if (c1 >= c0 && c1 >= c2)
+        return 1;
+
+    return 2;
+}
+
+void AiFactory::AddDefaultCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* engine)
+{
+    int tab = GetPlayerSpecTab(player);
+
+    engine->addStrategies("attack weak", "racials", "chat", "default", "aoe", "potions", "cast time", "conserve mana", "duel", "pvp", NULL);
+
+    switch (player->getClass())
+    {
+        case CLASS_PRIEST:
+            if (tab == 2)
+            {
+                engine->addStrategies("dps", "threat", NULL);
+                if (player->getLevel() > 19)
+                    engine->addStrategy("dps debuff");
+            }
+            else
+                engine->addStrategy("heal");
+
+            engine->addStrategy("flee");
+            break;
+        case CLASS_MAGE:
+            if (tab == 0)
+                engine->addStrategies("arcane", "threat", NULL);
+            else if (tab == 1)
+                engine->addStrategies("fire", "fire aoe", "threat", NULL);
+            else
+                engine->addStrategies("frost", "frost aoe", "threat", NULL);
+
+            engine->addStrategy("flee");
+            break;
+        case CLASS_WARRIOR:
+            if (tab == 2)
+                engine->addStrategies("tank", "tank aoe", NULL);
+            else
+                engine->addStrategies("dps", "threat", NULL);
+            break;
+        case CLASS_SHAMAN:
+            if (tab == 0)
+                engine->addStrategies("caster", "caster aoe", "bmana", "threat", "flee", NULL);
+            else if (tab == 2)
+                engine->addStrategies("heal", "bmana", "flee", NULL);
+            else
+                engine->addStrategies("dps", "melee aoe", "bdps", "threat", NULL);
+            break;
+        case CLASS_PALADIN:
+            if (tab == 1)
+                engine->addStrategies("tank", "tank aoe", "barmor", NULL);
+            else
+                engine->addStrategies("dps", "bdps", "threat", NULL);
+            break;
+        case CLASS_DRUID:
+            if (tab == 0)
+            {
+                engine->addStrategies("caster", "caster aoe", "threat", "flee", NULL);
+                if (player->getLevel() > 19)
+                    engine->addStrategy("caster debuff");
+            }
+            else if (tab == 2)
+                engine->addStrategies("heal", "flee", NULL);
+            else
+                engine->addStrategies("bear", "tank aoe", "flee", NULL);
+            break;
+        case CLASS_HUNTER:
+            engine->addStrategies("dps", "bdps", "threat", NULL);
+            if (player->getLevel() > 19)
+                engine->addStrategy("dps debuff");
+            break;
+        case CLASS_ROGUE:
+            engine->addStrategies("dps", "threat", NULL);
+            break;
+        case CLASS_WARLOCK:
+            if (tab == 1)
+                engine->addStrategies("tank", "threat", NULL);
+            else
+                engine->addStrategies("dps", "threat", NULL);
+
+            if (player->getLevel() > 19)
+                engine->addStrategy("dps debuff");
+
+            engine->addStrategy("flee");
+            break;
+    }
+
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        engine->ChangeStrategy(sPlayerbotAIConfig.randomBotCombatStrategies);
+        if (player->getClass() == CLASS_DRUID && player->getLevel() < 20)
+            engine->addStrategies("bear", NULL);
+    }
+}
+
+Engine* AiFactory::createCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+	Engine* engine = new Engine(facade, AiObjectContext);
+    AddDefaultCombatStrategies(player, facade, engine);
+    return engine;
+}
+
+void AiFactory::AddDefaultNonCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* nonCombatEngine)
+{
+    int tab = GetPlayerSpecTab(player);
+
+    switch (player->getClass()){
+        case CLASS_PALADIN:
+        case CLASS_HUNTER:
+        case CLASS_SHAMAN:
+            nonCombatEngine->addStrategy("bmana");
+            break;
+        case CLASS_MAGE:
+            if (tab == 1)
+                nonCombatEngine->addStrategy("bdps");
+            else
+                nonCombatEngine->addStrategy("bmana");
+            break;
+    }
+    nonCombatEngine->addStrategies("nc", "attack weak", "food", "stay", "chat",
+            "default", "quest", "loot", "gather", "duel", "emote", "lfg", NULL);
+
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        nonCombatEngine->ChangeStrategy(sPlayerbotAIConfig.randomBotNonCombatStrategies);
+    }
+
+}
+
+Engine* AiFactory::createNonCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+	Engine* nonCombatEngine = new Engine(facade, AiObjectContext);
+
+    AddDefaultNonCombatStrategies(player, facade, nonCombatEngine);
+	return nonCombatEngine;
+}
+
+void AiFactory::AddDefaultDeadStrategies(Player* player, PlayerbotAI* const facade, Engine* deadEngine)
+{
+    deadEngine->addStrategies("dead", "stay", "chat", "default", "follow", NULL);
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        deadEngine->removeStrategy("follow");
+    }
+}
+
+Engine* AiFactory::createDeadEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+    Engine* deadEngine = new Engine(facade, AiObjectContext);
+    AddDefaultDeadStrategies(player, facade, deadEngine);
+    return deadEngine;
+}
diff --git a/src/plugins/playerbot/AiFactory.h b/src/plugins/playerbot/AiFactory.h
new file mode 100644
index 0000000..a101092
--- /dev/null
+++ b/src/plugins/playerbot/AiFactory.h
@@ -0,0 +1,20 @@
+#pragma once
+
+class Player;
+
+using namespace ai;
+
+class AiFactory
+{
+public:
+    static AiObjectContext* createAiObjectContext(Player* player, PlayerbotAI* ai);
+	static Engine* createCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+	static Engine* createNonCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+    static Engine* createDeadEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+    static void AddDefaultNonCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* nonCombatEngine);
+    static void AddDefaultDeadStrategies(Player* player, PlayerbotAI* const facade, Engine* deadEngine);
+    static void AddDefaultCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* engine);
+
+public:
+    static int GetPlayerSpecTab(Player* player);
+};
diff --git a/src/plugins/playerbot/ChatFilter.cpp b/src/plugins/playerbot/ChatFilter.cpp
new file mode 100644
index 0000000..8d9656c
--- /dev/null
+++ b/src/plugins/playerbot/ChatFilter.cpp
@@ -0,0 +1,257 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "ChatFilter.h"
+#include "strategy/values/RtiTargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+string ChatFilter::Filter(string message)
+{
+    if (message.find("@") == string::npos)
+        return message;
+
+    return message.substr(message.find(" ") + 1);
+}
+
+class StrategyChatFilter : public ChatFilter
+{
+public:
+    StrategyChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool tank = message.find("@tank") == 0;
+        if (tank && !ai->IsTank(bot))
+            return "";
+
+        bool dps = message.find("@dps") == 0;
+        if (dps && ai->IsTank(bot))
+            return "";
+
+        bool heal = message.find("@heal") == 0;
+        if (heal && !ai->IsHeal(bot))
+            return "";
+
+        if (tank || dps)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+};
+
+class LevelChatFilter : public ChatFilter
+{
+public:
+    LevelChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        if (message[0] != '@')
+            return message;
+
+        if (message.find("-") != string::npos)
+        {
+            int fromLevel = atoi(message.substr(message.find("@") + 1, message.find("-")).c_str());
+            int toLevel = atoi(message.substr(message.find("-") + 1, message.find(" ")).c_str());
+
+            if (bot->getLevel() >= fromLevel && bot->getLevel() <= toLevel)
+                return ChatFilter::Filter(message);
+
+            return message;
+        }
+
+		int level = atoi(message.substr(message.find("@") + 1, message.find(" ")).c_str());
+        if (bot->getLevel() == level)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+};
+
+class CombatTypeChatFilter : public ChatFilter
+{
+public:
+    CombatTypeChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool melee = message.find("@melee") == 0;
+        bool ranged = message.find("@ranged") == 0;
+
+        if (!melee && !ranged)
+            return message;
+
+        switch (bot->getClass())
+        {
+            case CLASS_WARRIOR:
+            case CLASS_PALADIN:
+            case CLASS_ROGUE:
+            case CLASS_DEATH_KNIGHT:
+                if (ranged)
+                    return "";
+                break;
+
+            case CLASS_HUNTER:
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_WARLOCK:
+                if (melee)
+                    return "";
+                break;
+
+            case CLASS_DRUID:
+                if (ranged && ai->IsTank(bot))
+                    return "";
+                if (melee && !ai->IsTank(bot))
+                    return "";
+                break;
+
+            case CLASS_SHAMAN:
+                if (melee && ai->IsHeal(bot))
+                    return "";
+                if (ranged && !ai->IsHeal(bot))
+                    return "";
+                break;
+        }
+
+        return ChatFilter::Filter(message);
+    }
+};
+
+class RtiChatFilter : public ChatFilter
+{
+public:
+    RtiChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+    {
+        rtis.push_back("@star");
+        rtis.push_back("@circle");
+        rtis.push_back("@diamond");
+        rtis.push_back("@triangle");
+        rtis.push_back("@moon");
+        rtis.push_back("@square");
+        rtis.push_back("@cross");
+        rtis.push_back("@skull");
+    }
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+        Group *group = bot->GetGroup();
+        if(!group)
+            return message;
+
+        bool found = false;
+        for (list<string>::iterator i = rtis.begin(); i != rtis.end(); i++)
+        {
+            string rti = *i;
+
+            bool isRti = message.find(rti) == 0;
+            if (!isRti)
+                continue;
+
+            ObjectGuid rtiTarget = group->GetTargetIcon(RtiTargetValue::GetRtiIndex(rti.substr(1)));
+            if (bot->GetGUID() == rtiTarget)
+                return ChatFilter::Filter(message);
+
+            Unit* target = *ai->GetAiObjectContext()->GetValue<Unit*>("current target");
+            if (!target)
+                return "";
+
+            if (target->GetGUID() != rtiTarget)
+                return "";
+
+            if (found |= isRti)
+                break;
+        }
+
+        if (found)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+
+private:
+    list<string> rtis;
+};
+
+class ClassChatFilter : public ChatFilter
+{
+public:
+    ClassChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+    {
+        classNames["@death_knight"] = CLASS_DEATH_KNIGHT;
+        classNames["@druid"] = CLASS_DRUID;
+        classNames["@hunter"] = CLASS_HUNTER;
+        classNames["@mage"] = CLASS_MAGE;
+        classNames["@paladin"] = CLASS_PALADIN;
+        classNames["@priest"] = CLASS_PRIEST;
+        classNames["@rogue"] = CLASS_ROGUE;
+        classNames["@shaman"] = CLASS_SHAMAN;
+        classNames["@warlock"] = CLASS_WARLOCK;
+        classNames["@warrior"] = CLASS_WARRIOR;
+    }
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool found = false;
+        for (map<string, uint8>::iterator i = classNames.begin(); i != classNames.end(); i++)
+        {
+            bool isClass = message.find(i->first) == 0;
+            if (isClass && bot->getClass() != i->second)
+                return "";
+
+            if (found |= isClass)
+                break;
+        }
+
+        if (found)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+
+private:
+    map<string, uint8> classNames;
+};
+
+
+
+CompositeChatFilter::CompositeChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+{
+    filters.push_back(new StrategyChatFilter(ai));
+    filters.push_back(new ClassChatFilter(ai));
+    filters.push_back(new RtiChatFilter(ai));
+    filters.push_back(new CombatTypeChatFilter(ai));
+    filters.push_back(new LevelChatFilter(ai));
+}
+
+CompositeChatFilter::~CompositeChatFilter()
+{
+    for (list<ChatFilter*>::iterator i = filters.begin(); i != filters.end(); i++)
+        delete (*i);
+}
+
+string CompositeChatFilter::Filter(string message)
+{
+    for (int j = 0; j < filters.size(); ++j)
+    {
+        for (list<ChatFilter*>::iterator i = filters.begin(); i != filters.end(); i++)
+        {
+            message = (*i)->Filter(message);
+            if (message.empty())
+                break;
+        }
+    }
+
+    return message;
+}
+
diff --git a/src/plugins/playerbot/ChatFilter.h b/src/plugins/playerbot/ChatFilter.h
new file mode 100644
index 0000000..16dde4d
--- /dev/null
+++ b/src/plugins/playerbot/ChatFilter.h
@@ -0,0 +1,24 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    class ChatFilter : public PlayerbotAIAware
+    {
+    public:
+        ChatFilter(PlayerbotAI* ai) : PlayerbotAIAware(ai) {}
+        virtual string Filter(string message);
+    };
+
+    class CompositeChatFilter : public ChatFilter
+    {
+    public:
+        CompositeChatFilter(PlayerbotAI* ai);
+        virtual ~CompositeChatFilter();
+        string Filter(string message);
+
+    private:
+        list<ChatFilter*> filters;
+    };
+};
diff --git a/src/plugins/playerbot/ChatHelper.cpp b/src/plugins/playerbot/ChatHelper.cpp
new file mode 100644
index 0000000..a84a55c
--- /dev/null
+++ b/src/plugins/playerbot/ChatHelper.cpp
@@ -0,0 +1,450 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "ChatHelper.h"
+
+using namespace ai;
+using namespace std;
+
+map<string, uint32> ChatHelper::consumableSubClasses;
+map<string, uint32> ChatHelper::tradeSubClasses;
+map<string, uint32> ChatHelper::itemQualities;
+map<string, uint32> ChatHelper::slots;
+map<string, ChatMsg> ChatHelper::chats;
+map<uint8, string> ChatHelper::classes;
+map<uint8, string> ChatHelper::races;
+map<uint8, map<uint8, string> > ChatHelper::specs;
+
+template<class T>
+static bool substrContainsInMap(string searchTerm, map<string, T> searchIn)
+{
+    for (typename map<string, T>::iterator i = searchIn.begin(); i != searchIn.end(); ++i)
+    {
+		string term = i->first;
+		if (term.size() > 1 && searchTerm.find(term) != string::npos)
+            return true;
+    }
+
+    return false;
+}
+
+ChatHelper::ChatHelper(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    itemQualities["poor"] = ITEM_QUALITY_POOR;
+    itemQualities["gray"] = ITEM_QUALITY_POOR;
+    itemQualities["normal"] = ITEM_QUALITY_NORMAL;
+    itemQualities["white"] = ITEM_QUALITY_NORMAL;
+    itemQualities["uncommon"] = ITEM_QUALITY_UNCOMMON;
+    itemQualities["green"] = ITEM_QUALITY_UNCOMMON;
+    itemQualities["rare"] = ITEM_QUALITY_RARE;
+    itemQualities["blue"] = ITEM_QUALITY_RARE;
+    itemQualities["epic"] = ITEM_QUALITY_EPIC;
+    itemQualities["violet"] = ITEM_QUALITY_EPIC;
+
+    consumableSubClasses["potion"] = ITEM_SUBCLASS_POTION;
+    consumableSubClasses["elixir"] = ITEM_SUBCLASS_ELIXIR;
+    consumableSubClasses["flask"] = ITEM_SUBCLASS_FLASK;
+    consumableSubClasses["scroll"] = ITEM_SUBCLASS_SCROLL;
+    consumableSubClasses["food"] = ITEM_SUBCLASS_FOOD;
+    consumableSubClasses["bandage"] = ITEM_SUBCLASS_BANDAGE;
+    consumableSubClasses["enchant"] = ITEM_SUBCLASS_CONSUMABLE_OTHER;
+
+    tradeSubClasses["cloth"] = ITEM_SUBCLASS_CLOTH;
+    tradeSubClasses["leather"] = ITEM_SUBCLASS_LEATHER;
+    tradeSubClasses["metal"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["stone"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["ore"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["meat"] = ITEM_SUBCLASS_MEAT;
+    tradeSubClasses["herb"] = ITEM_SUBCLASS_HERB;
+    tradeSubClasses["elemental"] = ITEM_SUBCLASS_ELEMENTAL;
+    tradeSubClasses["disenchants"] = ITEM_SUBCLASS_ENCHANTING;
+    tradeSubClasses["enchanting"] = ITEM_SUBCLASS_ENCHANTING;
+    tradeSubClasses["gems"] = ITEM_SUBCLASS_JEWELCRAFTING;
+    tradeSubClasses["jewels"] = ITEM_SUBCLASS_JEWELCRAFTING;
+    tradeSubClasses["jewelcrafting"] = ITEM_SUBCLASS_JEWELCRAFTING;
+
+    slots["head"] = EQUIPMENT_SLOT_HEAD;
+    slots["neck"] = EQUIPMENT_SLOT_NECK;
+    slots["shoulder"] = EQUIPMENT_SLOT_SHOULDERS;
+    slots["shirt"] = EQUIPMENT_SLOT_BODY;
+    slots["chest"] = EQUIPMENT_SLOT_CHEST;
+    slots["waist"] = EQUIPMENT_SLOT_WAIST;
+    slots["legs"] = EQUIPMENT_SLOT_LEGS;
+    slots["feet"] = EQUIPMENT_SLOT_FEET;
+    slots["wrist"] = EQUIPMENT_SLOT_WRISTS;
+    slots["hands"] = EQUIPMENT_SLOT_HANDS;
+    slots["finger 1"] = EQUIPMENT_SLOT_FINGER1;
+    slots["finger 2"] = EQUIPMENT_SLOT_FINGER2;
+    slots["trinket 1"] = EQUIPMENT_SLOT_TRINKET1;
+    slots["trinket 2"] = EQUIPMENT_SLOT_TRINKET2;
+    slots["back"] = EQUIPMENT_SLOT_BACK;
+    slots["main hand"] = EQUIPMENT_SLOT_MAINHAND;
+    slots["off hand"] = EQUIPMENT_SLOT_OFFHAND;
+    slots["ranged"] = EQUIPMENT_SLOT_RANGED;
+    slots["tabard"] = EQUIPMENT_SLOT_TABARD;
+
+    chats["party"] = CHAT_MSG_PARTY;
+    chats["p"] = CHAT_MSG_PARTY;
+    chats["guild"] = CHAT_MSG_GUILD;
+    chats["g"] = CHAT_MSG_GUILD;
+    chats["raid"] = CHAT_MSG_RAID;
+    chats["r"] = CHAT_MSG_RAID;
+    chats["whisper"] = CHAT_MSG_WHISPER;
+    chats["w"] = CHAT_MSG_WHISPER;
+
+    classes[CLASS_DRUID] = "druid";
+    specs[CLASS_DRUID][0] = "balance";
+    specs[CLASS_DRUID][1] = "feral combat";
+    specs[CLASS_DRUID][2] = "restoration";
+
+    classes[CLASS_HUNTER] = "hunter";
+    specs[CLASS_HUNTER][0] = "beast mastery";
+    specs[CLASS_HUNTER][1] = "marksmanship";
+    specs[CLASS_HUNTER][2] = "survival";
+
+    classes[CLASS_MAGE] = "mage";
+    specs[CLASS_MAGE][0] = "arcane";
+    specs[CLASS_MAGE][1] = "fire";
+    specs[CLASS_MAGE][2] = "frost";
+
+    classes[CLASS_PALADIN] = "paladin";
+    specs[CLASS_PALADIN][0] = "holy";
+    specs[CLASS_PALADIN][1] = "protection";
+    specs[CLASS_PALADIN][2] = "retribution";
+
+    classes[CLASS_PRIEST] = "priest";
+    specs[CLASS_PRIEST][0] = "discipline";
+    specs[CLASS_PRIEST][1] = "holy";
+    specs[CLASS_PRIEST][2] = "shadow";
+
+    classes[CLASS_ROGUE] = "rogue";
+    specs[CLASS_ROGUE][0] = "assasination";
+    specs[CLASS_ROGUE][1] = "combat";
+    specs[CLASS_ROGUE][2] = "subtlety";
+
+    classes[CLASS_SHAMAN] = "shaman";
+    specs[CLASS_SHAMAN][0] = "elemental";
+    specs[CLASS_SHAMAN][1] = "enhancement";
+    specs[CLASS_SHAMAN][2] = "restoration";
+
+    classes[CLASS_WARLOCK] = "warlock";
+    specs[CLASS_WARLOCK][0] = "affliction";
+    specs[CLASS_WARLOCK][1] = "demonology";
+    specs[CLASS_WARLOCK][2] = "destruction";
+
+    classes[CLASS_WARRIOR] = "warrior";
+    specs[CLASS_WARRIOR][0] = "arms";
+    specs[CLASS_WARRIOR][1] = "fury";
+    specs[CLASS_WARRIOR][2] = "protection";
+
+    races[RACE_BLOODELF] = "Blood Elf";
+    races[RACE_DRAENEI] = "Draenei";
+    races[RACE_DWARF] = "Dwarf";
+    races[RACE_GNOME] = "Gnome";
+    races[RACE_HUMAN] = "Human";
+    races[RACE_NIGHTELF] = "Night Elf";
+    races[RACE_ORC] = "Orc";
+    races[RACE_TAUREN] = "Tauren";
+    races[RACE_TROLL] = "Troll";
+    races[RACE_UNDEAD_PLAYER] = "Undead";
+}
+
+string ChatHelper::formatMoney(uint32 copper)
+{
+    ostringstream out;
+	if (!copper)
+	{
+		out << "0|TInterface\\AddOns\\AtlasLoot\\Images\\bronze:0|t";
+		return out.str();
+	}
+
+    uint32 gold = uint32(copper / 10000);
+    copper -= (gold * 10000);
+    uint32 silver = uint32(copper / 100);
+    copper -= (silver * 100);
+    out << " ";
+    if (gold > 0)
+        out << gold <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\gold:0|t ";
+    if (silver > 0 && gold < 50)
+        out << silver <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\silver:0|t ";
+	if (copper > 0 && gold < 10)
+		out << copper <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\bronze:0|t";
+
+    return out.str();
+}
+
+uint32 ChatHelper::parseMoney(string& text)
+{
+    // if user specified money in ##g##s##c format
+    string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+ItemIds ChatHelper::parseItems(string& text)
+{
+    ItemIds itemIds;
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.insert(id);
+    }
+
+    return itemIds;
+}
+
+string ChatHelper::formatQuest(Quest const* quest)
+{
+    ostringstream out;
+    out << "|cFFFFFF00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << quest->GetTitle() << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatGameobject(GameObject* go)
+{
+    ostringstream out;
+    out << "|cFFFFFF00|Hfound:" << go->GetGUID() << ":" << go->GetEntry() << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatSpell(SpellInfo const *sInfo)
+{
+    ostringstream out;
+    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[LOCALE_enUS] << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatItem(ItemTemplate const * proto, int count)
+{
+    char color[32];
+    sprintf(color, "%x", ItemQualityColors[proto->Quality]);
+
+    ostringstream out;
+    out << "|c" << color << "|Hitem:" << proto->ItemId
+        << ":0:0:0:0:0:0:0" << "|h[" << proto->Name1
+        << "]|h|r";
+
+    if (count > 1)
+        out << "x" << count;
+
+    return out.str();
+}
+
+ChatMsg ChatHelper::parseChat(string& text)
+{
+    if (chats.find(text) != chats.end())
+        return chats[text];
+
+    return CHAT_MSG_SYSTEM;
+}
+
+string ChatHelper::formatChat(ChatMsg chat)
+{
+    switch (chat)
+    {
+    case CHAT_MSG_GUILD:
+        return "guild";
+    case CHAT_MSG_PARTY:
+        return "party";
+    case CHAT_MSG_WHISPER:
+        return "whisper";
+    case CHAT_MSG_RAID:
+        return "raid";
+    }
+
+    return "unknown";
+}
+
+
+uint32 ChatHelper::parseSpell(string& text)
+{
+    PlayerbotChatHandler handler(ai->GetBot());
+    return handler.extractSpellId(text);
+}
+
+list<ObjectGuid> ChatHelper::parseGameobjects(string& text)
+{
+    list<ObjectGuid> gos;
+    //    Link format
+    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << gInfo->name << "]|h|r";
+    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        // extract GO guid
+        int i = text.find("Hfound:", pos);     // base H = 11
+        if (i == -1)     // break if error
+            break;
+
+        pos = i + 7;     //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos);     // end of window in text 22
+        if (endPos == -1)     //break if error
+            break;
+        istringstream stream(text.substr(pos, endPos - pos));
+        uint64 guid; stream >> guid;
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos);     // end of window in text
+        if (endPos == -1)     //break if error
+            break;
+
+        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
+        uint32 entry = atol(entryC.c_str());     // convert ascii to float
+
+        ObjectGuid lootCurrent = ObjectGuid(guid);
+
+        if (guid)
+            gos.push_back(lootCurrent);
+    }
+
+    return gos;
+}
+
+string ChatHelper::formatQuestObjective(string name, int available, int required)
+{
+    ostringstream out;
+    out << "|cFFFFFFFF" << name << (available >= required ? "|c0000FF00: " : "|c00FF0000: ")
+        << available << "/" << required << "|r";
+
+    return out.str();
+}
+
+
+uint32 ChatHelper::parseItemQuality(string text)
+{
+    if (itemQualities.find(text) == itemQualities.end())
+        return MAX_ITEM_QUALITY;
+
+    return itemQualities[text];
+}
+
+bool ChatHelper::parseItemClass(string text, uint32 *itemClass, uint32 *itemSubClass)
+{
+    if (text == "questitem")
+    {
+        *itemClass = ITEM_CLASS_QUEST;
+        *itemSubClass = ITEM_SUBCLASS_QUEST;
+        return true;
+    }
+
+    if (consumableSubClasses.find(text) != consumableSubClasses.end())
+    {
+        *itemClass = ITEM_CLASS_CONSUMABLE;
+        *itemSubClass = consumableSubClasses[text];
+        return true;
+    }
+
+    if (tradeSubClasses.find(text) != tradeSubClasses.end())
+    {
+        *itemClass = ITEM_CLASS_TRADE_GOODS;
+        *itemSubClass = tradeSubClasses[text];
+        return true;
+    }
+
+    return false;
+}
+
+uint32 ChatHelper::parseSlot(string text)
+{
+    if (slots.find(text) != slots.end())
+        return slots[text];
+
+    return EQUIPMENT_SLOT_END;
+}
+
+bool ChatHelper::parseable(string text)
+{
+    return text.find("|H") != string::npos ||
+            text == "questitem" ||
+            substrContainsInMap<uint32>(text, consumableSubClasses) ||
+            substrContainsInMap<uint32>(text, tradeSubClasses) ||
+            substrContainsInMap<uint32>(text, itemQualities) ||
+            substrContainsInMap<uint32>(text, slots) ||
+            substrContainsInMap<ChatMsg>(text, chats) ||
+            parseMoney(text) > 0;
+}
+
+string ChatHelper::formatClass(Player* player, int spec)
+{
+    uint8 cls = player->getClass();
+
+    ostringstream out;
+    out << specs[cls][spec] << " (";
+
+    int c0 = 0, c1 = 0, c2 = 0;
+    PlayerTalentMap& talentMap = player->GetTalentMap(0);
+    for (PlayerTalentMap::iterator i = talentMap.begin(); i != talentMap.end(); ++i)
+    {
+        uint32 spellId = i->first;
+        TalentSpellPos const* talentPos = GetTalentSpellPos(spellId);
+        if(!talentPos)
+            continue;
+
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id);
+
+        if (!talentInfo)
+            continue;
+
+        uint32 const* talentTabIds = GetTalentTabPages(player->getClass());
+        if (talentInfo->TalentTab == talentTabIds[0]) c0++;
+        if (talentInfo->TalentTab == talentTabIds[1]) c1++;
+        if (talentInfo->TalentTab == talentTabIds[2]) c2++;
+    }
+
+    out << (c0 ? "|h|cff00ff00" : "") << c0 << "|h|cffffffff/";
+    out << (c1 ? "|h|cff00ff00" : "") << c1 << "|h|cffffffff/";
+    out << (c2 ? "|h|cff00ff00" : "") << c2 << "|h|cffffffff";
+
+    out <<  ") " << classes[cls];
+    return out.str();
+}
+
+string ChatHelper::formatClass(uint8 cls)
+{
+    return classes[cls];
+}
+
+string ChatHelper::formatRace(uint8 race)
+{
+    return races[race];
+}
diff --git a/src/plugins/playerbot/ChatHelper.h b/src/plugins/playerbot/ChatHelper.h
new file mode 100644
index 0000000..3d493d1
--- /dev/null
+++ b/src/plugins/playerbot/ChatHelper.h
@@ -0,0 +1,52 @@
+#pragma once
+
+using namespace std;
+
+typedef set<uint32> ItemIds;
+typedef set<uint32> SpellIds;
+
+#include "../pchdef.h"
+
+namespace ai
+{
+    class ChatHelper : public PlayerbotAIAware
+    {
+    public:
+        ChatHelper(PlayerbotAI* ai);
+
+    public:
+        static string formatMoney(uint32 copper);
+        static uint32 parseMoney(string& text);
+        static ItemIds parseItems(string& text);
+        uint32 parseSpell(string& text);
+        static string formatQuest(Quest const* quest);
+        static string formatItem(ItemTemplate const * proto, int count = 0);
+        static string formatSpell(SpellInfo const *sInfo);
+        static string formatGameobject(GameObject* go);
+        static string formatQuestObjective(string name, int available, int required);
+        static list<ObjectGuid> parseGameobjects(string& text);
+
+        static ChatMsg parseChat(string& text);
+        static string formatChat(ChatMsg chat);
+
+        static string formatClass(Player* player, int spec);
+        static string formatClass(uint8 cls);
+        static string formatRace(uint8 race);
+
+        static uint32 parseItemQuality(string text);
+        static bool parseItemClass(string text, uint32 *itemClass, uint32 *itemSubClass);
+        static uint32 parseSlot(string text);
+
+        static bool parseable(string text);
+
+    private:
+        static map<string, uint32> consumableSubClasses;
+        static map<string, uint32> tradeSubClasses;
+        static map<string, uint32> itemQualities;
+        static map<string, uint32> slots;
+        static map<string, ChatMsg> chats;
+        static map<uint8, string> classes;
+        static map<uint8, string> races;
+        static map<uint8, map<uint8, string> > specs;
+    };
+};
diff --git a/src/plugins/playerbot/FleeManager.cpp b/src/plugins/playerbot/FleeManager.cpp
new file mode 100644
index 0000000..f7d9591
--- /dev/null
+++ b/src/plugins/playerbot/FleeManager.cpp
@@ -0,0 +1,174 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "FleeManager.h"
+#include "PlayerbotAIConfig.h"
+#include "../Groups/Group.h"
+#include "strategy/values/LastMovementValue.h"
+
+using namespace ai;
+using namespace std;
+
+void FleeManager::calculateDistanceToPlayers(FleePoint *point)
+{
+	Group* group = bot->GetGroup();
+	if (!group)
+		return;
+
+	for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+		Player* player = gref->GetSource();
+		if(player == bot)
+			continue;
+
+		float d = player->GetDistance(point->x, point->y, point->z);
+		point->toAllPlayers.probe(d);
+		switch (player->getClass()) {
+			case CLASS_HUNTER:
+			case CLASS_MAGE:
+			case CLASS_PRIEST:
+			case CLASS_WARLOCK:
+				point->toRangedPlayers.probe(d);
+				break;
+			case CLASS_PALADIN:
+			case CLASS_ROGUE:
+			case CLASS_WARRIOR:
+				point->toMeleePlayers.probe(d);
+				break;
+		}
+	}
+}
+
+void FleeManager::calculateDistanceToCreatures(FleePoint *point)
+{
+	RangePair &distance = point->toCreatures;
+
+	list<ObjectGuid> units = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<list<ObjectGuid> >("possible targets");
+	for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+		Unit* unit = bot->GetPlayerbotAI()->GetUnit(*i);
+		if (!unit)
+		    continue;
+
+		float d = unit->GetDistance(point->x, point->y, point->z);
+		if (d <= sPlayerbotAIConfig.tooCloseDistance)
+		    continue;
+
+		distance.probe(d);
+	}
+}
+
+void FleeManager::calculatePossibleDestinations(list<FleePoint*> &points)
+{
+	float botPosX = bot->GetPositionX();
+	float botPosY = bot->GetPositionY();
+	float botPosZ = bot->GetPositionZ();
+
+	for (float distance = maxAllowedDistance; distance > sPlayerbotAIConfig.tooCloseDistance + 5.0f; distance -= 5.0f)
+	{
+        for (float angle = followAngle; angle < followAngle + 2 * M_PI; angle += M_PI / 4)
+        {
+            float x = botPosX + cos(angle) * distance;
+            float y = botPosY + sin(angle) * distance;
+
+            if (!bot->IsWithinLOS(x, y, botPosZ))
+                continue;
+
+            FleePoint *point = new FleePoint(x, y, botPosZ);
+            calculateDistanceToPlayers(point);
+            calculateDistanceToCreatures(point);
+            points.push_back(point);
+        }
+	}
+}
+
+void FleeManager::cleanup(list<FleePoint*> &points)
+{
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		delete point;
+	}
+	points.clear();
+}
+
+bool FleePoint::isReasonable()
+{
+	return toAllPlayers.max <= sPlayerbotAIConfig.sightDistance && toCreatures.min >= sPlayerbotAIConfig.tooCloseDistance;
+}
+
+bool FleePoint::isBetterByCreatures(FleePoint* other)
+{
+    return toCreatures.min > 0 && other->toCreatures.min > 0 &&
+            (toCreatures.min - other->toCreatures.min) >= 0;
+}
+
+bool FleePoint::isBetterByAll(FleePoint* other)
+{
+    bool isFartherFromCreatures = isBetterByCreatures(other);
+    bool isNearerToRangedPlayers = toRangedPlayers.max > 0 && other->toRangedPlayers.max > 0 &&
+            (toRangedPlayers.max - other->toRangedPlayers.max) <= 0;
+    bool isFartherFromMeleePlayers = toMeleePlayers.min > 0 && other->toMeleePlayers.min > 0 &&
+            (toMeleePlayers.min - other->toMeleePlayers.min) >= 0;
+
+    return isFartherFromCreatures && (isNearerToRangedPlayers || isFartherFromMeleePlayers);
+}
+
+FleePoint* FleeManager::selectOptimalDestination(list<FleePoint*> &points)
+{
+	FleePoint* byCreatures = NULL;
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		if (point->isReasonable() && (!byCreatures || point->isBetterByCreatures(byCreatures)))
+			byCreatures = point;
+	}
+
+	FleePoint* byAll = NULL;
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		if (point->isReasonable() && (!byAll || point->isBetterByAll(byAll)))
+		    byAll = point;
+	}
+
+	if (byAll && byCreatures)
+	{
+	    if (byAll->isBetterByCreatures(byCreatures))
+	        return byAll;
+	}
+
+	return byCreatures;
+}
+
+bool FleeManager::CalculateDestination(float* rx, float* ry, float* rz)
+{
+    LastMovement& lastMovement = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<LastMovement&>("last movement");
+    if ((lastMovement.lastMoveToX || lastMovement.lastMoveToY) && !lastMovement.lastFollow)
+    {
+        FleePoint last(lastMovement.lastMoveToX, lastMovement.lastMoveToY, lastMovement.lastMoveToZ);
+        if (last.isReasonable())
+        {
+            *rx = lastMovement.lastMoveToX;
+            *ry = lastMovement.lastMoveToY;
+            *rz = lastMovement.lastMoveToZ;
+            return true;
+        }
+    }
+
+	list<FleePoint*> points;
+	calculatePossibleDestinations(points);
+
+    FleePoint* point = selectOptimalDestination(points);
+    if (!point)
+    {
+        cleanup(points);
+        return false;
+    }
+
+	*rx = point->x;
+	*ry = point->y;
+	*rz = bot->GetPositionZ();
+
+    cleanup(points);
+	return true;
+}
diff --git a/src/plugins/playerbot/FleeManager.h b/src/plugins/playerbot/FleeManager.h
new file mode 100644
index 0000000..5b49c66
--- /dev/null
+++ b/src/plugins/playerbot/FleeManager.h
@@ -0,0 +1,82 @@
+#pragma once
+
+using namespace std;
+
+class Player;
+
+namespace ai
+{
+    class Engine;
+
+	class RangePair {
+	public:
+		RangePair() {
+			min = -1.0f;
+			max = -1.0f;
+		}
+
+	public:
+		float min;
+		float max;
+
+	public:
+		void probe(float d) {
+			if (min < 0 || min > d)
+				min = d;
+
+			if (max < 0 || max < d)
+				max = d;
+		}
+	};
+
+	class FleePoint {
+	public:
+		FleePoint(float x, float y, float z) {
+			this->x = x;
+			this->y = y;
+			this->z = z;
+		}
+
+    public:
+        bool isReasonable();
+        bool isBetterByCreatures(FleePoint* other);
+        bool isBetterByAll(FleePoint* other);
+
+	public:
+		float x;
+		float y;
+		float z;
+
+		RangePair toCreatures;
+		RangePair toAllPlayers;
+		RangePair toMeleePlayers;
+		RangePair toRangedPlayers;
+	};
+
+	class FleeManager
+	{
+	public:
+		FleeManager(Player* bot, float maxAllowedDistance, float followAngle) {
+			this->bot = bot;
+			this->maxAllowedDistance = maxAllowedDistance;
+			this->followAngle = followAngle;
+		}
+
+	public:
+		bool CalculateDestination(float* rx, float* ry, float* rz);
+
+	private:
+		void calculatePossibleDestinations(list<FleePoint*> &points);
+		void calculateDistanceToPlayers(FleePoint *point);
+		void calculateDistanceToCreatures(FleePoint *point);
+		void cleanup(list<FleePoint*> &points);
+		FleePoint* selectOptimalDestination(list<FleePoint*> &points);
+		bool isBetterThan(FleePoint* point, FleePoint* other);
+
+	private:
+		Player* bot;
+		float maxAllowedDistance;
+		float followAngle;
+	};
+
+};
diff --git a/src/plugins/playerbot/GuildTaskMgr.cpp b/src/plugins/playerbot/GuildTaskMgr.cpp
new file mode 100644
index 0000000..9a8b00a
--- /dev/null
+++ b/src/plugins/playerbot/GuildTaskMgr.cpp
@@ -0,0 +1,726 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "GuildTaskMgr.h"
+
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "../../server/game/Mails/Mail.h"
+#include "PlayerbotAI.h"
+
+#include "../../plugins/ahbot/AhBotConfig.h"
+#include "RandomItemMgr.h"
+
+char * strstri (const char* str1, const char* str2);
+
+enum GuildTaskType
+{
+    GUILD_TASK_TYPE_NONE = 0,
+    GUILD_TASK_TYPE_ITEM = 1,
+    GUILD_TASK_TYPE_KILL = 2
+};
+
+GuildTaskMgr::GuildTaskMgr()
+{
+}
+
+GuildTaskMgr::~GuildTaskMgr()
+{
+}
+
+void GuildTaskMgr::Update(Player* player, Player* guildMaster)
+{
+    if (!sPlayerbotAIConfig.guildTaskEnabled)
+        return;
+
+    uint32 guildId = guildMaster->GetGuildId();
+    if (!guildId || !guildMaster->GetPlayerbotAI() || !guildMaster->GetGuild())
+        return;
+
+    if (!player->IsFriendlyTo(guildMaster))
+        return;
+
+    DenyReason reason = PLAYERBOT_DENY_NONE;
+    PlayerbotSecurityLevel secLevel = guildMaster->GetPlayerbotAI()->GetSecurity()->LevelFor(player, &reason);
+    if (secLevel == PLAYERBOT_SECURITY_DENY_ALL || (secLevel == PLAYERBOT_SECURITY_TALK && reason != PLAYERBOT_DENY_FAR))
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: skipping guild task update - not enough security level, reason = %u",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str(), reason);
+        return;
+    }
+
+    uint32 owner = (uint32)player->GetGUID().GetRawValue();
+
+    uint32 activeTask = GetTaskValue(owner, guildId, "activeTask");
+    if (!activeTask)
+    {
+        SetTaskValue(owner, guildId, "killTask", 0, 0);
+        SetTaskValue(owner, guildId, "itemTask", 0, 0);
+        SetTaskValue(owner, guildId, "itemCount", 0, 0);
+        SetTaskValue(owner, guildId, "killTask", 0, 0);
+        SetTaskValue(owner, guildId, "killCount", 0, 0);
+        SetTaskValue(owner, guildId, "payment", 0, 0);
+        SetTaskValue(owner, guildId, "thanks", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "reward", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+
+        uint32 task = CreateTask(owner, guildId);
+
+        if (task == GUILD_TASK_TYPE_NONE)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error creating guild task",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+
+        uint32 time = urand(sPlayerbotAIConfig.minGuildTaskChangeTime, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "activeTask", task, time);
+        SetTaskValue(owner, guildId, "advertisement", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskAdvertisementTime, sPlayerbotAIConfig.maxGuildTaskAdvertisementTime));
+
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task %u is set for %u secs",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str(),
+                task, time);
+        return;
+    }
+
+    uint32 advertisement = GetTaskValue(owner, guildId, "advertisement");
+    if (!advertisement)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending advertisement",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (SendAdvertisement(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "advertisement", 1,
+                    urand(sPlayerbotAIConfig.minGuildTaskAdvertisementTime, sPlayerbotAIConfig.maxGuildTaskAdvertisementTime));
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending advertisement",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+
+    uint32 thanks = GetTaskValue(owner, guildId, "thanks");
+    if (!thanks)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending thanks",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (SendThanks(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "thanks", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+            SetTaskValue(owner, guildId, "payment", 0, 0);
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending thanks",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+
+    uint32 reward = GetTaskValue(owner, guildId, "reward");
+    if (!reward)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending reward",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (Reward(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "reward", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+            SetTaskValue(owner, guildId, "payment", 0, 0);
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending reward",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+}
+
+uint32 GuildTaskMgr::CreateTask(uint32 owner, uint32 guildId)
+{
+    switch (urand(0, 1))
+    {
+    case 0:
+        CreateItemTask(owner, guildId);
+        return GUILD_TASK_TYPE_ITEM;
+    default:
+        CreateKillTask(owner, guildId);
+        return GUILD_TASK_TYPE_KILL;
+    }
+}
+
+bool GuildTaskMgr::CreateItemTask(uint32 owner, uint32 guildId)
+{
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    uint32 itemId = sRandomItemMgr.GetRandomItem(RANDOM_ITEM_GUILD_TASK);
+    if (!itemId)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: no items avaible for item task",
+                sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str());
+        return false;
+    }
+
+    uint32 count = GetMaxItemTaskCount(itemId);
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: item task %u (x%d)",
+            sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str(),
+            itemId, count);
+
+    SetTaskValue(owner, guildId, "itemCount", count, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    SetTaskValue(owner, guildId, "itemTask", itemId, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    return true;
+}
+
+bool GuildTaskMgr::CreateKillTask(uint32 owner, uint32 guildId)
+{
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    vector<uint32> ids;
+    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+    {
+        CreatureTemplate const& co = i->second;
+        if (co.rank != CREATURE_ELITE_RARE)
+            continue;
+
+        if (co.minlevel > player->getLevel() || co.maxlevel < player->getLevel() - 5)
+            continue;
+
+        ids.push_back(i->first);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: no rare creatures available for kill task",
+                sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str());
+        return false;
+    }
+
+    uint32 index = urand(0, ids.size() - 1);
+    uint32 creatureId = ids[index];
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: kill task %u",
+            sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str(),
+            creatureId);
+
+    SetTaskValue(owner, guildId, "killTask", creatureId, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    return true;
+}
+
+bool GuildTaskMgr::SendAdvertisement(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 validIn;
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask", &validIn);
+    if (itemTask)
+        return SendItemAdvertisement(itemTask, owner, guildId, validIn);
+
+    uint32 killTask = GetTaskValue(owner, guildId, "killTask", &validIn);
+    if (killTask)
+        return SendKillAdvertisement(killTask, owner, guildId, validIn);
+
+    return false;
+}
+
+string formatTime(uint32 secs)
+{
+    ostringstream out;
+    if (secs < 3600)
+    {
+        out << secs / 60 << " min";
+    }
+    else if (secs < 7200)
+    {
+        out << "1 hr " << (secs - 3600) / 60 << " min";
+    }
+    else if (secs < 3600 * 24)
+    {
+        out << secs / 3600 << " hr";
+    } else
+    {
+        out << secs / 3600 / 24 << " days";
+    }
+
+    return out.str();
+}
+
+bool GuildTaskMgr::SendItemAdvertisement(uint32 itemId, uint32 owner, uint32 guildId, uint32 validIn)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return false;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+    body << "We are in a great need of " << proto->Name1 << ". If you could sell us ";
+    uint32 count = GetTaskValue(owner, guildId, "itemCount");
+    if (count > 1)
+        body << "at least " << count << " of them ";
+    else
+        body << "some ";
+    body << "we'd really appreciate that and pay a high price.\n";
+    body << "The task will expire in " << formatTime(validIn) << "\n";
+    body << "\n";
+    body << "Best Regards,\n";
+    body << guild->GetName() << "\n";
+    body << leader->GetName() << "\n";
+
+    ostringstream subject;
+    subject << "Guild Task: " << proto->Name1;
+    MailDraft(subject.str(), body.str()).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    return true;
+}
+
+
+bool GuildTaskMgr::SendKillAdvertisement(uint32 creatureId, uint32 owner, uint32 guildId, uint32 validIn)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+
+    CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(creatureId);
+    if (!proto)
+        return false;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+    body << "As you probably know " << proto->Name << " is wanted dead for the crimes it did against our guild. If you should kill it ";
+    body << "we'd really appreciate that.\n";
+    body << "The task will expire in " << formatTime(validIn) << "\n";
+    body << "\n";
+    body << "Best Regards,\n";
+    body << guild->GetName() << "\n";
+    body << leader->GetName() << "\n";
+
+    ostringstream subject;
+    subject << "Guild Task: " << proto->Name;
+    MailDraft(subject.str(), body.str()).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    return true;
+}
+
+bool GuildTaskMgr::SendThanks(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    if (itemTask)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTask);
+        if (!proto)
+            return false;
+
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        ostringstream body;
+        body << "Hello, " << player->GetName() << ",\n";
+        body << "\n";
+        body << "One of our guild members wishes to thank you for the " << proto->Name1 << "! If we have another ";
+        uint32 count = GetTaskValue(owner, guildId, "itemCount");
+        body << count << " of them that would help us tremendously.\n";
+        body << "\n";
+        body << "Thanks again,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+
+        MailDraft("Thank You", body.str()).
+                AddMoney(GetTaskValue(owner, guildId, "payment")).
+                SendMailTo(trans, MailReceiver(player), MailSender(leader));
+
+        CharacterDatabase.CommitTransaction(trans);
+
+        return true;
+    }
+
+    return false;
+}
+
+uint32 GuildTaskMgr::GetMaxItemTaskCount(uint32 itemId)
+{
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return 0;
+
+    if (proto->Quality < ITEM_QUALITY_RARE && proto->Stackable && proto->GetMaxStackSize() > 1)
+        return proto->GetMaxStackSize();
+
+    return 1;
+}
+
+bool GuildTaskMgr::IsGuildTaskItem(uint32 itemId, uint32 guildId)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_guild_tasks where `value` = '%u' and guildid = '%u' and `type` = 'itemTask'",
+            itemId, guildId);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 validIn = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= validIn)
+            value = 0;
+    }
+
+    return value;
+}
+
+map<uint32,uint32> GuildTaskMgr::GetTaskValues(uint32 owner, string type, uint32 *validIn /* = NULL */)
+{
+    map<uint32,uint32> result;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn, guildid from ai_playerbot_guild_tasks where owner = '%u' and `type` = '%s'",
+            owner, type.c_str());
+
+    if (!results)
+        return result;
+
+    do
+    {
+        Field* fields = results->Fetch();
+        uint32 value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 secs = fields[2].GetUInt32();
+        uint32 guildId = fields[3].GetUInt32();
+        if ((time(0) - lastChangeTime) >= secs)
+            value = 0;
+
+        result[guildId] = value;
+
+    } while (results->NextRow());
+
+    return result;
+}
+
+uint32 GuildTaskMgr::GetTaskValue(uint32 owner, uint32 guildId, string type, uint32 *validIn /* = NULL */)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_guild_tasks where owner = '%u' and guildid = '%u' and `type` = '%s'",
+            owner, guildId, type.c_str());
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 secs = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= secs)
+            value = 0;
+
+        if (validIn) *validIn = secs;
+    }
+
+    return value;
+}
+
+uint32 GuildTaskMgr::SetTaskValue(uint32 owner, uint32 guildId, string type, uint32 value, uint32 validIn)
+{
+    CharacterDatabase.PExecute("delete from ai_playerbot_guild_tasks where owner = '%u' and guildid = '%u' and `type` = '%s'",
+            owner, guildId, type.c_str());
+    if (value)
+    {
+        CharacterDatabase.PExecute(
+                "insert into ai_playerbot_guild_tasks (owner, guildid, `time`, validIn, `type`, `value`) values ('%u', '%u', '%u', '%u', '%s', '%u')",
+                owner, guildId, (uint32)time(0), validIn, type.c_str(), value);
+    }
+
+    return value;
+}
+
+bool GuildTaskMgr::HandleConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!sPlayerbotAIConfig.guildTaskEnabled)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Guild task system is currently disabled!");
+        return false;
+    }
+
+    if (!args || !*args)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Usage: gtask stats/reset");
+        return false;
+    }
+
+    string cmd = args;
+
+    if (cmd == "reset")
+    {
+        CharacterDatabase.PExecute("delete from ai_playerbot_guild_tasks");
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Guild tasks were reset for all players");
+        return true;
+    }
+
+    if (cmd == "stats")
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Usage: gtask stats <player name>");
+        return true;
+    }
+
+    if (cmd.find("stats ") != string::npos)
+    {
+        string charName = cmd.substr(cmd.find("stats ") + 6);
+        ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(charName);
+        if (!guid)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Player %s not found", charName.c_str());
+            return false;
+        }
+
+        uint32 owner = (uint32)guid.GetRawValue();
+
+        QueryResult result = CharacterDatabase.PQuery(
+                "select `value`, `time`, validIn, guildid, `type` from ai_playerbot_guild_tasks where owner = '%u' order by guildid, `type`",
+                owner);
+
+        if (result)
+        {
+            do
+            {
+                Field* fields = result->Fetch();
+                uint32 value = fields[0].GetUInt32();
+                uint32 lastChangeTime = fields[1].GetUInt32();
+                uint32 validIn = fields[2].GetUInt32();
+                if ((time(0) - lastChangeTime) >= validIn)
+                    value = 0;
+                uint32 guildId = fields[3].GetUInt32();
+                string type = fields[4].GetString();
+
+                Guild *guild = sGuildMgr->GetGuildById(guildId);
+                if (!guild)
+                    continue;
+
+                sLog->outMessage("gtask", LOG_LEVEL_INFO, "Player '%s' Guild '%s' %s=%u (%u secs)",
+                        charName.c_str(), guild->GetName().c_str(),
+                        type.c_str(), value, validIn);
+
+            } while (result->NextRow());
+
+            Field* fields = result->Fetch();
+        }
+
+        return true;
+    }
+
+    if (cmd == "reward")
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Usage: gtask reward <player name>");
+        return true;
+    }
+
+    if (cmd.find("reward ") != string::npos)
+    {
+        string charName = cmd.substr(cmd.find("reward ") + 7);
+        ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(charName);
+        if (!guid)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Player %s not found", charName.c_str());
+            return false;
+        }
+
+        uint32 owner = (uint32)guid.GetRawValue();
+        QueryResult result = CharacterDatabase.PQuery(
+                "select distinct guildid from ai_playerbot_guild_tasks where owner = '%u'",
+                owner);
+
+        if (result)
+        {
+            do
+            {
+                Field* fields = result->Fetch();
+                uint32 guildId = fields[0].GetUInt32();
+                Guild *guild = sGuildMgr->GetGuildById(guildId);
+                if (!guild)
+                    continue;
+
+                sGuildTaskMgr.Reward(owner, guildId);
+            } while (result->NextRow());
+
+            Field* fields = result->Fetch();
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void GuildTaskMgr::CheckItemTask(uint32 itemId, uint32 obtained, Player* ownerPlayer, Player* bot, bool byMail)
+{
+    uint32 guildId = bot->GetGuildId();
+    if (!guildId)
+        return;
+
+    uint32 owner = (uint32)ownerPlayer->GetGUID().GetRawValue();
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: checking guild task",
+            bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    if (itemTask != itemId)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: item %u is not guild task item (%u)",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str(),
+                itemId, itemTask);
+        return;
+    }
+
+    if (byMail)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            return;
+
+        uint32 money = GetTaskValue(owner, guildId, "payment");
+        SetTaskValue(owner, guildId, "payment", money + auctionbot.GetBuyPrice(proto) * obtained,
+                sPlayerbotAIConfig.maxGuildTaskRewardTime);
+    }
+
+    uint32 count = GetTaskValue(owner, guildId, "itemCount");
+    if (obtained >= count)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task complete",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+        SetTaskValue(owner, guildId, "reward", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+        ChatHandler(ownerPlayer->GetSession()).PSendSysMessage("You have completed a guild task");
+    }
+    else
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task progress",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+        SetTaskValue(owner, guildId, "itemCount", count - obtained, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "thanks", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+    }
+}
+
+bool GuildTaskMgr::Reward(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    uint32 killTask = GetTaskValue(owner, guildId, "killTask");
+    if (!itemTask && !killTask)
+        return false;
+
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+
+    if (itemTask)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTask);
+        if (!proto)
+            return false;
+
+        body << "We wish to thank you for the " << proto->Name1 << " you provided so kindly. We really appreciate this and may this small gift bring you our thanks!\n";
+        body << "\n";
+        body << "Many thanks,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+    }
+    else if (killTask)
+    {
+        CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(killTask);
+        if (!proto)
+            return false;
+
+        body << "We wish to thank you for the " << proto->Name << " you've killed recently. We really appreciate this and may this small gift bring you our thanks!\n";
+        body << "\n";
+        body << "Many thanks,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    MailDraft draft("Thank You", body.str());
+
+    uint32 itemId = sRandomItemMgr.GetRandomItem(RANDOM_ITEM_GUILD_TASK_REWARD);
+    if (itemId)
+    {
+        Item* item = Item::CreateItem(itemId, 1, leader);
+        item->SaveToDB(trans);
+        draft.AddItem(item);
+    }
+
+    draft.AddMoney(GetTaskValue(owner, guildId, "payment")).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    SetTaskValue(owner, guildId, "activeTask", 0, 0);
+    return true;
+}
+
+void GuildTaskMgr::CheckKillTask(Player* player, Unit* victim)
+{
+    uint32 owner = player->GetGUID().GetCounter();
+    Creature* creature = victim->ToCreature();
+    if (!creature)
+        return;
+
+    map<uint32,uint32> tasks = GetTaskValues(owner, "killTask");
+    for (map<uint32,uint32>::iterator i = tasks.begin(); i != tasks.end(); ++i)
+    {
+        uint32 guildId = i->first;
+        uint32 value = i->second;
+        Guild* guild = sGuildMgr->GetGuildById(guildId);
+
+        if (value != creature->GetCreatureTemplate()->Entry)
+            continue;
+
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task complete",
+                guild->GetName().c_str(), player->GetName().c_str());
+        SetTaskValue(owner, guildId, "reward", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+        ChatHandler(player->GetSession()).PSendSysMessage("You have completed a guild task");
+    }
+}
diff --git a/src/plugins/playerbot/GuildTaskMgr.h b/src/plugins/playerbot/GuildTaskMgr.h
new file mode 100644
index 0000000..ba74df7
--- /dev/null
+++ b/src/plugins/playerbot/GuildTaskMgr.h
@@ -0,0 +1,45 @@
+#ifndef _GuildTaskMgr_H
+#define _GuildTaskMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+using namespace std;
+
+class GuildTaskMgr
+{
+    public:
+        GuildTaskMgr();
+        virtual ~GuildTaskMgr();
+        static GuildTaskMgr& instance()
+        {
+            static GuildTaskMgr instance;
+            return instance;
+        }
+
+        void Update(Player* owner, Player* guildMaster);
+
+	public:
+        static bool HandleConsoleCommand(ChatHandler* handler, char const* args);
+        bool IsGuildTaskItem(uint32 itemId, uint32 guildId);
+        void CheckItemTask(uint32 itemId, uint32 obtained, Player* owner, Player* bot, bool byMail = false);
+        void CheckKillTask(Player* owner, Unit* victim);
+
+    private:
+        map<uint32,uint32> GetTaskValues(uint32 owner, string type, uint32 *validIn = NULL);
+        uint32 GetTaskValue(uint32 owner, uint32 guildId, string type, uint32 *validIn = NULL);
+        uint32 SetTaskValue(uint32 owner, uint32 guildId, string type, uint32 value, uint32 validIn);
+        uint32 CreateTask(uint32 owner, uint32 guildId);
+        bool SendAdvertisement(uint32 owner, uint32 guildId);
+        bool SendItemAdvertisement(uint32 itemId, uint32 owner, uint32 guildId, uint32 validIn);
+        bool SendKillAdvertisement(uint32 creatureId, uint32 owner, uint32 guildId, uint32 validIn);
+        bool SendThanks(uint32 owner, uint32 guildId);
+        bool Reward(uint32 owner, uint32 guildId);
+        bool CreateItemTask(uint32 owner, uint32 guildId);
+        bool CreateKillTask(uint32 owner, uint32 guildId);
+        uint32 GetMaxItemTaskCount(uint32 itemId);
+};
+
+#define sGuildTaskMgr GuildTaskMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/Helpers.cpp b/src/plugins/playerbot/Helpers.cpp
new file mode 100644
index 0000000..1d0b408
--- /dev/null
+++ b/src/plugins/playerbot/Helpers.cpp
@@ -0,0 +1,90 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include <algorithm>
+#include <functional>
+#include <cctype>
+#include <locale>
+
+vector<string>& split(const string &s, char delim, vector<string> &elems)
+{
+    stringstream ss(s);
+    string item;
+    while(getline(ss, item, delim))
+    {
+        elems.push_back(item);
+    }
+    return elems;
+}
+
+
+vector<string> split(const string &s, char delim)
+{
+    vector<string> elems;
+    return split(s, delim, elems);
+}
+
+char *strstri(const char *haystack, const char *needle)
+{
+    if ( !*needle )
+    {
+        return (char*)haystack;
+    }
+    for ( ; *haystack; ++haystack )
+    {
+        if ( tolower(*haystack) == tolower(*needle) )
+        {
+            const char *h = haystack, *n = needle;
+            for ( ; *h && *n; ++h, ++n )
+            {
+                if ( tolower(*h) != tolower(*n) )
+                {
+                    break;
+                }
+            }
+            if ( !*n )
+            {
+                return (char*)haystack;
+            }
+        }
+    }
+    return 0;
+}
+
+
+
+uint64 extractGuid(WorldPacket& packet)
+{
+    uint8 mask;
+    packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while (true)
+    {
+        if (mask & testMask)
+        {
+            uint8 word;
+            packet >> word;
+            guid += (word << bit);
+        }
+        if (bit == 7)
+            break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+std::string &ltrim(std::string &s) {
+        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
+        return s;
+}
+
+std::string &rtrim(std::string &s) {
+        s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
+        return s;
+}
+
+std::string &trim(std::string &s) {
+        return ltrim(rtrim(s));
+}
diff --git a/src/plugins/playerbot/LazyCalculatedValue.h b/src/plugins/playerbot/LazyCalculatedValue.h
new file mode 100644
index 0000000..f7d3d31
--- /dev/null
+++ b/src/plugins/playerbot/LazyCalculatedValue.h
@@ -0,0 +1,42 @@
+#pragma once
+
+using namespace std;
+
+namespace ai 
+{
+    template <class TValue, class TOwner>
+    class LazyCalculatedValue
+    {
+    public:
+        typedef TValue (TOwner::*Calculator)();
+
+    public:
+        LazyCalculatedValue(TOwner* owner, Calculator calculator) 
+        {
+            this->calculator = calculator;
+            this->owner = owner;
+            Reset();
+        }
+
+    public:
+        TValue GetValue()
+        {
+            if (!calculated)
+            {
+                value = (owner->*calculator)();
+                calculated = true;
+            }
+            return value;
+        }
+        void Reset() 
+        {
+            calculated = false;
+        }
+
+    protected:
+        Calculator calculator;
+        TOwner* owner;
+        bool calculated;
+        TValue value;
+    };
+};
\ No newline at end of file
diff --git a/src/plugins/playerbot/LootObjectStack.cpp b/src/plugins/playerbot/LootObjectStack.cpp
new file mode 100644
index 0000000..faf459c
--- /dev/null
+++ b/src/plugins/playerbot/LootObjectStack.cpp
@@ -0,0 +1,234 @@
+#include "../pchdef.h"
+#include "LootObjectStack.h"
+#include "playerbot.h"
+
+using namespace ai;
+using namespace std;
+
+#define MAX_LOOT_OBJECT_COUNT 10
+
+LootTarget::LootTarget(ObjectGuid guid) : guid(guid), asOfTime(time(0))
+{
+}
+
+LootTarget::LootTarget(LootTarget const& other)
+{
+    guid = other.guid;
+    asOfTime = other.asOfTime;
+}
+
+LootTarget& LootTarget::operator=(LootTarget const& other)
+{
+    if((void*)this == (void*)&other)
+        return *this;
+
+    guid = other.guid;
+    asOfTime = other.asOfTime;
+
+    return *this;
+}
+
+bool LootTarget::operator< (const LootTarget& other) const
+{
+    return guid < other.guid;
+}
+
+void LootTargetList::shrink(time_t fromTime)
+{
+    for (set<LootTarget>::iterator i = begin(); i != end(); )
+    {
+        if (i->asOfTime <= fromTime)
+            erase(i++);
+		else
+			++i;
+    }
+}
+
+LootObject::LootObject(Player* bot, ObjectGuid guid)
+	: guid(), skillId(SKILL_NONE), reqSkillValue(0), reqItem(NULL)
+{
+    Refresh(bot, guid);
+}
+
+void LootObject::Refresh(Player* bot, ObjectGuid guid)
+{
+    skillId = SKILL_NONE;
+    reqSkillValue = 0;
+    reqItem = NULL;
+    this->guid = ObjectGuid();
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+    Creature *creature = ai->GetCreature(guid);
+    if (creature && creature->getDeathState() == CORPSE)
+    {
+        if (creature->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+            this->guid = guid;
+
+        if (creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+        {
+            skillId = creature->GetCreatureTemplate()->GetRequiredLootSkill();
+            uint32 targetLevel = creature->getLevel();
+            reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+            if (bot->HasSkill(skillId) && bot->GetSkillValue(skillId) >= reqSkillValue)
+                this->guid = guid;
+        }
+
+        return;
+    }
+
+    GameObject* go = ai->GetGameObject(guid);
+    if (go && go->isSpawned())
+    {
+        uint32 lockId = go->GetGOInfo()->GetLockId();
+        LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+        if (!lockInfo)
+            return;
+
+        this->guid = guid;
+        for (int i = 0; i < 8; ++i)
+        {
+            switch (lockInfo->Type[i])
+            {
+            case LOCK_KEY_ITEM:
+                if (lockInfo->Index[i] > 0)
+                {
+                    reqItem = lockInfo->Index[i];
+                }
+                break;
+            case LOCK_KEY_SKILL:
+                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
+                {
+                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                    reqSkillValue = lockInfo->Skill[i];
+                }
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+
+WorldObject* LootObject::GetWorldObject(Player* bot)
+{
+    Refresh(bot, guid);
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+
+    Creature *creature = ai->GetCreature(guid);
+    if (creature && creature->getDeathState() == CORPSE)
+        return creature;
+
+    GameObject* go = ai->GetGameObject(guid);
+    if (go && go->isSpawned())
+        return go;
+
+    return NULL;
+}
+
+LootObject::LootObject(const LootObject& other)
+{
+    guid = other.guid;
+    skillId = other.skillId;
+    reqSkillValue = other.reqSkillValue;
+    reqItem = other.reqItem;
+}
+
+bool LootObject::IsLootPossible(Player* bot)
+{
+    if (IsEmpty() || !GetWorldObject(bot))
+        return false;
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+
+    if (reqItem && !bot->HasItemCount(reqItem, 1))
+        return false;
+
+    if (skillId == SKILL_NONE)
+        return true;
+
+    if (skillId == SKILL_FISHING)
+        return false;
+
+    if (!bot->HasSkill(skillId))
+        return false;
+
+    if (!reqSkillValue)
+        return true;
+
+    uint32 skillValue = uint32(bot->GetPureSkillValue(skillId));
+    if (reqSkillValue > skillValue)
+        return false;
+
+    if (skillId == SKILL_MINING && !bot->HasItemTotemCategory(TC_MINING_PICK))
+        return false;
+
+    if (skillId == SKILL_SKINNING && !bot->HasItemTotemCategory(TC_SKINNING_KNIFE))
+        return false;
+
+    return true;
+}
+
+bool LootObjectStack::Add(ObjectGuid guid)
+{
+    if (!availableLoot.insert(guid).second)
+        return false;
+
+    if (availableLoot.size() < MAX_LOOT_OBJECT_COUNT)
+        return true;
+
+    vector<LootObject> ordered = OrderByDistance();
+    for (size_t i = MAX_LOOT_OBJECT_COUNT; i < ordered.size(); i++)
+        Remove(ordered[i].guid);
+
+    return true;
+}
+
+void LootObjectStack::Remove(ObjectGuid guid)
+{
+    LootTargetList::iterator i = availableLoot.find(guid);
+    if (i != availableLoot.end())
+        availableLoot.erase(i);
+}
+
+void LootObjectStack::Clear()
+{
+    availableLoot.clear();
+}
+
+bool LootObjectStack::CanLoot(float maxDistance)
+{
+    vector<LootObject> ordered = OrderByDistance(maxDistance);
+    return !ordered.empty();
+}
+
+LootObject LootObjectStack::GetLoot(float maxDistance)
+{
+    vector<LootObject> ordered = OrderByDistance(maxDistance);
+    return ordered.empty() ? LootObject() : *ordered.begin();
+}
+
+vector<LootObject> LootObjectStack::OrderByDistance(float maxDistance)
+{
+    availableLoot.shrink(time(0) - 30);
+
+    map<float, LootObject> sortedMap;
+    LootTargetList safeCopy(availableLoot);
+    for (LootTargetList::iterator i = safeCopy.begin(); i != safeCopy.end(); i++)
+    {
+        ObjectGuid guid = i->guid;
+        LootObject lootObject(bot, guid);
+        if (!lootObject.IsLootPossible(bot))
+            continue;
+
+        float distance = bot->GetDistance(lootObject.GetWorldObject(bot));
+        if (!maxDistance || distance <= maxDistance)
+            sortedMap[distance] = lootObject;
+    }
+
+    vector<LootObject> result;
+    for (map<float, LootObject>::iterator i = sortedMap.begin(); i != sortedMap.end(); i++)
+        result.push_back(i->second);
+    return result;
+}
+
diff --git a/src/plugins/playerbot/LootObjectStack.h b/src/plugins/playerbot/LootObjectStack.h
new file mode 100644
index 0000000..a35bdd2
--- /dev/null
+++ b/src/plugins/playerbot/LootObjectStack.h
@@ -0,0 +1,76 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    enum LootStrategy
+    {
+        LOOTSTRATEGY_QUEST = 1,
+        LOOTSTRATEGY_SKILL = 2,
+        LOOTSTRATEGY_GRAY = 3,
+        LOOTSTRATEGY_NORMAL = 4,
+        LOOTSTRATEGY_ALL = 5
+    };
+
+    class LootObject
+    {
+    public:
+        LootObject() {}
+        LootObject(Player* bot, ObjectGuid guid);
+        LootObject(const LootObject& other);
+
+    public:
+        bool IsEmpty() { return !guid; }
+        bool IsLootPossible(Player* bot);
+        void Refresh(Player* bot, ObjectGuid guid);
+        WorldObject* GetWorldObject(Player* bot);
+        ObjectGuid guid;
+
+        uint32 skillId;
+        uint32 reqSkillValue;
+        uint32 reqItem;
+    };
+
+    class LootTarget
+    {
+    public:
+        LootTarget(ObjectGuid guid);
+        LootTarget(LootTarget const& other);
+
+    public:
+        LootTarget& operator=(LootTarget const& other);
+        bool operator< (const LootTarget& other) const;
+
+    public:
+        ObjectGuid guid;
+        time_t asOfTime;
+    };
+
+    class LootTargetList : public set<LootTarget>
+    {
+    public:
+        void shrink(time_t fromTime);
+    };
+
+    class LootObjectStack
+    {
+    public:
+        LootObjectStack(Player* bot) : bot(bot) {}
+
+    public:
+        bool Add(ObjectGuid guid);
+        void Remove(ObjectGuid guid);
+        void Clear();
+        bool CanLoot(float maxDistance);
+        LootObject GetLoot(float maxDistance = 0);
+
+    private:
+        vector<LootObject> OrderByDistance(float maxDistance = 0);
+
+    private:
+        Player* bot;
+        LootTargetList availableLoot;
+    };
+
+};
diff --git a/src/plugins/playerbot/PlayerbotAI.cpp b/src/plugins/playerbot/PlayerbotAI.cpp
new file mode 100644
index 0000000..bea74d9
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAI.cpp
@@ -0,0 +1,1424 @@
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "playerbot.h"
+
+#include "AiFactory.h"
+
+#include "../Grids/Notifiers/GridNotifiers.h"
+#include "../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../Grids/Cells/CellImpl.h"
+#include "strategy/values/LastMovementValue.h"
+#include "strategy/actions/LogLevelAction.h"
+#include "strategy/values/LastSpellCastValue.h"
+#include "LootObjectStack.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotFactory.h"
+#include "PlayerbotSecurity.h"
+#include "../Groups/Group.h"
+#include "../Entities/Pet/Pet.h"
+#include "../Spells/Auras/SpellAuraEffects.h"
+
+using namespace ai;
+using namespace std;
+
+vector<string>& split(const string &s, char delim, vector<string> &elems);
+vector<string> split(const string &s, char delim);
+uint64 extractGuid(WorldPacket& packet);
+std::string &trim(std::string &s);
+
+uint32 PlayerbotChatHandler::extractQuestId(string str)
+{
+    char* source = (char*)str.c_str();
+    char* cId = extractKeyFromLink(source,"Hquest");
+    return cId ? atol(cId) : 0;
+}
+
+void PacketHandlingHelper::AddHandler(uint16 opcode, string handler)
+{
+    handlers[opcode] = handler;
+}
+
+void PacketHandlingHelper::Handle(ExternalEventHelper &helper)
+{
+    while (!queue.empty())
+    {
+        helper.HandlePacket(handlers, queue.top());
+        queue.pop();
+    }
+}
+
+void PacketHandlingHelper::AddPacket(const WorldPacket& packet)
+{
+	if (handlers.find(packet.GetOpcode()) != handlers.end())
+        queue.push(WorldPacket(packet));
+}
+
+
+PlayerbotAI::PlayerbotAI() : PlayerbotAIBase(), bot(NULL), aiObjectContext(NULL),
+    currentEngine(NULL), chatHelper(this), chatFilter(this), accountId(0), security(NULL), master(NULL)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+        engines[i] = NULL;
+}
+
+PlayerbotAI::PlayerbotAI(Player* bot) :
+    PlayerbotAIBase(), chatHelper(this), chatFilter(this), security(bot), master(NULL)
+{
+	this->bot = bot;
+
+	accountId = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+
+    aiObjectContext = AiFactory::createAiObjectContext(bot, this);
+
+    engines[BOT_STATE_COMBAT] = AiFactory::createCombatEngine(bot, this, aiObjectContext);
+    engines[BOT_STATE_NON_COMBAT] = AiFactory::createNonCombatEngine(bot, this, aiObjectContext);
+    engines[BOT_STATE_DEAD] = AiFactory::createDeadEngine(bot, this, aiObjectContext);
+    currentEngine = engines[BOT_STATE_NON_COMBAT];
+    currentState = BOT_STATE_NON_COMBAT;
+
+    masterIncomingPacketHandlers.AddHandler(CMSG_GAMEOBJ_REPORT_USE, "use game object");
+    masterIncomingPacketHandlers.AddHandler(CMSG_AREATRIGGER, "area trigger");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GAMEOBJ_USE, "use game object");
+    masterIncomingPacketHandlers.AddHandler(CMSG_LOOT_ROLL, "loot roll");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GOSSIP_HELLO, "gossip hello");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_HELLO, "gossip hello");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_COMPLETE_QUEST, "complete quest");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_ACCEPT_QUEST, "accept quest");
+    masterIncomingPacketHandlers.AddHandler(CMSG_ACTIVATETAXI, "activate taxi");
+    masterIncomingPacketHandlers.AddHandler(CMSG_ACTIVATETAXIEXPRESS, "activate taxi");
+    masterIncomingPacketHandlers.AddHandler(CMSG_MOVE_SPLINE_DONE, "taxi done");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GROUP_UNINVITE_GUID, "uninvite");
+    masterIncomingPacketHandlers.AddHandler(CMSG_PUSHQUESTTOPARTY, "quest share");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GUILD_INVITE, "guild invite");
+    masterIncomingPacketHandlers.AddHandler(CMSG_LFG_TELEPORT, "lfg teleport");
+
+    botOutgoingPacketHandlers.AddHandler(SMSG_GROUP_INVITE, "group invite");
+    botOutgoingPacketHandlers.AddHandler(BUY_ERR_NOT_ENOUGHT_MONEY, "not enough money");
+    botOutgoingPacketHandlers.AddHandler(BUY_ERR_REPUTATION_REQUIRE, "not enough reputation");
+    botOutgoingPacketHandlers.AddHandler(SMSG_GROUP_SET_LEADER, "group set leader");
+    botOutgoingPacketHandlers.AddHandler(SMSG_FORCE_RUN_SPEED_CHANGE, "check mount state");
+    botOutgoingPacketHandlers.AddHandler(SMSG_RESURRECT_REQUEST, "resurrect request");
+    botOutgoingPacketHandlers.AddHandler(SMSG_INVENTORY_CHANGE_FAILURE, "cannot equip");
+    botOutgoingPacketHandlers.AddHandler(SMSG_TRADE_STATUS, "trade status");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LOOT_RESPONSE, "loot response");
+    botOutgoingPacketHandlers.AddHandler(SMSG_QUESTUPDATE_ADD_KILL, "quest objective completed");
+    botOutgoingPacketHandlers.AddHandler(SMSG_ITEM_PUSH_RESULT, "item push result");
+    botOutgoingPacketHandlers.AddHandler(SMSG_PARTY_COMMAND_RESULT, "party command");
+    botOutgoingPacketHandlers.AddHandler(SMSG_CAST_FAILED, "cast failed");
+    botOutgoingPacketHandlers.AddHandler(SMSG_DUEL_REQUESTED, "duel requested");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LFG_ROLE_CHOSEN, "lfg role check");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LFG_PROPOSAL_UPDATE, "lfg proposal");
+
+    masterOutgoingPacketHandlers.AddHandler(SMSG_PARTY_COMMAND_RESULT, "party command");
+    masterOutgoingPacketHandlers.AddHandler(MSG_RAID_READY_CHECK, "ready check");
+    masterOutgoingPacketHandlers.AddHandler(MSG_RAID_READY_CHECK_FINISHED, "ready check finished");
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        if (engines[i])
+            delete engines[i];
+    }
+
+    if (aiObjectContext)
+        delete aiObjectContext;
+}
+
+void PlayerbotAI::UpdateAI(uint32 elapsed)
+{
+    if (bot->IsBeingTeleported())
+        return;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown &&
+            bot->IsNonMeleeSpellCast(true, true, false) &&
+            *GetAiObjectContext()->GetValue<bool>("invalid target", "current target"))
+    {
+        Spell* spell = bot->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+        if (spell && !spell->GetSpellInfo()->IsPositive())
+        {
+            InterruptSpell();
+            SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+        }
+    }
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.maxWaitForMove && bot->IsInCombat() && !bot->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+    {
+        nextAICheckDelay = sPlayerbotAIConfig.maxWaitForMove;
+    }
+
+    PlayerbotAIBase::UpdateAI(elapsed);
+}
+
+void PlayerbotAI::UpdateAIInternal(uint32 elapsed)
+{
+    ExternalEventHelper helper(aiObjectContext);
+    while (!chatCommands.empty())
+    {
+        ChatCommandHolder holder = chatCommands.top();
+        string command = holder.GetCommand();
+        Player* owner = holder.GetOwner();
+        if (!helper.ParseChatCommand(command, owner) && holder.GetType() == CHAT_MSG_WHISPER)
+        {
+            ostringstream out; out << "Unknown command " << command;
+            TellMaster(out);
+            helper.ParseChatCommand("help");
+        }
+        chatCommands.pop();
+    }
+
+    botOutgoingPacketHandlers.Handle(helper);
+    masterIncomingPacketHandlers.Handle(helper);
+    masterOutgoingPacketHandlers.Handle(helper);
+
+	DoNextAction();
+}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+	bot->GetMotionMaster()->Clear(true);
+	if (bot->IsBeingTeleportedNear())
+	{
+		WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+		p.appendPackGUID(bot->GetGUID());
+		p << (uint32) 0; // supposed to be flags? not used currently
+		p << (uint32) time(0); // time - not currently used
+		bot->GetSession()->HandleMoveTeleportAck(p);
+	}
+	else if (bot->IsBeingTeleportedFar())
+	{
+		bot->GetSession()->HandleMoveWorldportAck();
+		SetNextCheckDelay(1000);
+	}
+}
+
+void PlayerbotAI::Reset()
+{
+    if (bot->IsFlying())
+        return;
+
+    currentEngine = engines[BOT_STATE_NON_COMBAT];
+    nextAICheckDelay = 0;
+
+    aiObjectContext->GetValue<Unit*>("old target")->Set(NULL);
+    aiObjectContext->GetValue<Unit*>("current target")->Set(NULL);
+    aiObjectContext->GetValue<LootObject>("loot target")->Set(LootObject());
+    aiObjectContext->GetValue<uint32>("lfg proposal")->Set(0);
+
+    LastSpellCast & lastSpell = aiObjectContext->GetValue<LastSpellCast& >("last spell cast")->Get();
+    lastSpell.Reset();
+
+    LastMovement & lastMovement = aiObjectContext->GetValue<LastMovement& >("last movement")->Get();
+    lastMovement.Set(NULL);
+
+    bot->GetMotionMaster()->Clear();
+    bot->m_taxi.ClearTaxiDestinations();
+    InterruptSpell();
+
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        engines[i]->Init();
+    }
+}
+
+void PlayerbotAI::HandleCommand(uint32 type, const string& text, Player& fromPlayer)
+{
+    if (!GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, type != CHAT_MSG_WHISPER, &fromPlayer))
+        return;
+
+    if (type == CHAT_MSG_ADDON)
+        return;
+
+    string filtered = text;
+    if (!sPlayerbotAIConfig.commandPrefix.empty())
+    {
+        if (filtered.find(sPlayerbotAIConfig.commandPrefix) != 0)
+            return;
+
+        filtered = filtered.substr(sPlayerbotAIConfig.commandPrefix.size());
+    }
+
+    filtered = chatFilter.Filter(trim((string&)filtered));
+    if (filtered.empty())
+        return;
+
+    if (filtered.find("who") != 0 && !GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_ALLOW_ALL, type != CHAT_MSG_WHISPER, &fromPlayer))
+        return;
+
+    if (type == CHAT_MSG_RAID_WARNING && filtered.find(bot->GetName()) != string::npos && filtered.find("award") == string::npos)
+    {
+        ChatCommandHolder cmd("warning", &fromPlayer, type);
+        chatCommands.push(cmd);
+        return;
+    }
+
+    if (filtered.size() > 2 && filtered.substr(0, 2) == "d " || filtered.size() > 3 && filtered.substr(0, 3) == "do ")
+    {
+        std::string action = filtered.substr(filtered.find(" ") + 1);
+        DoSpecificAction(action);
+    }
+    else if (filtered == "reset")
+    {
+        Reset();
+    }
+    else
+    {
+        ChatCommandHolder cmd(filtered, &fromPlayer, type);
+        chatCommands.push(cmd);
+    }
+}
+
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+    case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+            p.readPackGUID(guid);
+            if (guid != bot->GetGUID())
+                return;
+
+            bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+            return;
+        }
+    case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+            p.readPackGUID(guid);
+            if (guid != bot->GetGUID())
+                return;
+            bot->m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FLYING);
+            return;
+        }
+    case SMSG_CAST_FAILED:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint8 castCount, result;
+            uint32 spellId;
+            p >> castCount >> spellId >> result;
+            if (result != SPELL_CAST_OK)
+            {
+                SpellInterrupted(spellId);
+                botOutgoingPacketHandlers.AddPacket(packet);
+            }
+            return;
+        }
+    case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+            if (casterGuid != bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            uint32 spellId;
+            p >> castCount;
+            p >> spellId;
+            SpellInterrupted(spellId);
+            return;
+        }
+    case SMSG_SPELL_DELAYED:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+
+            if (casterGuid != bot->GetGUID())
+                return;
+
+            uint32 delaytime;
+            p >> delaytime;
+            if (delaytime <= 1000)
+                IncreaseNextCheckDelay(delaytime);
+            return;
+        }
+    default:
+        botOutgoingPacketHandlers.AddPacket(packet);
+    }
+}
+
+void PlayerbotAI::SpellInterrupted(uint32 spellid)
+{
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+    if (lastSpell.id != spellid)
+        return;
+
+    lastSpell.Reset();
+
+    time_t now = time(0);
+    if (now <= lastSpell.time)
+        return;
+
+    uint32 castTimeSpent = 1000 * (now - lastSpell.time);
+
+    int32 globalCooldown = CalculateGlobalCooldown(lastSpell.id);
+    if (castTimeSpent < globalCooldown)
+        SetNextCheckDelay(globalCooldown - castTimeSpent);
+    else
+        SetNextCheckDelay(0);
+
+    lastSpell.id = 0;
+}
+
+int32 PlayerbotAI::CalculateGlobalCooldown(uint32 spellid)
+{
+    if (!spellid)
+        return 0;
+
+    if (bot->GetSpellHistory()->HasCooldown(spellid))
+        return sPlayerbotAIConfig.globalCoolDown;
+
+    return sPlayerbotAIConfig.reactDelay;
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    masterIncomingPacketHandlers.AddPacket(packet);
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    masterOutgoingPacketHandlers.AddPacket(packet);
+}
+
+void PlayerbotAI::ChangeEngine(BotState type)
+{
+    Engine* engine = engines[type];
+
+    if (currentEngine != engine)
+    {
+        currentEngine = engine;
+        currentState = type;
+        ReInitCurrentEngine();
+
+        switch (type)
+        {
+        case BOT_STATE_COMBAT:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s COMBAT ===", bot->GetName().c_str());
+            break;
+        case BOT_STATE_NON_COMBAT:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s NON-COMBAT ===", bot->GetName().c_str());
+            break;
+        case BOT_STATE_DEAD:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s DEAD ===", bot->GetName().c_str());
+            break;
+        }
+    }
+}
+
+void PlayerbotAI::DoNextAction()
+{
+    if (bot->IsBeingTeleported() || (GetMaster() && GetMaster()->IsBeingTeleported()))
+        return;
+
+    currentEngine->DoNextAction(NULL);
+
+    if (bot->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+    {
+        bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+
+        // TODO
+        //WorldPacket packet(CMSG_MOVE_SET_FLY);
+        //packet.appendPackGUID(bot->GetGUID());
+        //packet << bot->m_movementInfo;
+        bot->SetMover(bot);
+        //bot->GetSession()->HandleMovementOpcodes(packet);
+    }
+
+    Player* master = GetMaster();
+    if (bot->IsMounted() && bot->IsFlying())
+    {
+        bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+
+        bot->SetSpeed(MOVE_FLIGHT, 1.0f);
+        bot->SetSpeed(MOVE_RUN, 1.0f);
+
+        if (master)
+        {
+            bot->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT));
+            bot->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT));
+        }
+
+    }
+
+    if (currentEngine != engines[BOT_STATE_DEAD] && !bot->IsAlive())
+        ChangeEngine(BOT_STATE_DEAD);
+
+    if (currentEngine == engines[BOT_STATE_DEAD] && bot->IsAlive())
+        ChangeEngine(BOT_STATE_NON_COMBAT);
+
+    Group *group = bot->GetGroup();
+    if (!master && group)
+    {
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* member = gref->GetSource();
+            PlayerbotAI* ai = bot->GetPlayerbotAI();
+            if (member && member->IsInWorld() && !member->GetPlayerbotAI() && (!master || master->GetPlayerbotAI()))
+            {
+                ai->SetMaster(member);
+                ai->ResetStrategies();
+                ai->TellMaster("Hello");
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::ReInitCurrentEngine()
+{
+    InterruptSpell();
+    currentEngine->Init();
+}
+
+void PlayerbotAI::ChangeStrategy(string names, BotState type)
+{
+    Engine* e = engines[type];
+    if (!e)
+        return;
+
+    e->ChangeStrategy(names);
+}
+
+void PlayerbotAI::DoSpecificAction(string name)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        ostringstream out;
+        ActionResult res = engines[i]->ExecuteAction(name);
+        switch (res)
+        {
+        case ACTION_RESULT_UNKNOWN:
+            continue;
+        case ACTION_RESULT_OK:
+            out << name << ": done";
+            TellMaster(out);
+            PlaySound(TEXT_EMOTE_NOD);
+            return;
+        case ACTION_RESULT_IMPOSSIBLE:
+            out << name << ": impossible";
+            TellMaster(out);
+            PlaySound(TEXT_EMOTE_NO);
+            return;
+        case ACTION_RESULT_USELESS:
+            out << name << ": useless";
+            TellMaster(out);
+            PlaySound(TEXT_EMOTE_NO);
+            return;
+        case ACTION_RESULT_FAILED:
+            out << name << ": failed";
+            TellMaster(out);
+            return;
+        }
+    }
+    ostringstream out;
+    out << name << ": unknown action";
+    TellMaster(out);
+}
+
+bool PlayerbotAI::PlaySound(uint32 emote)
+{
+    if (EmotesTextSoundEntry const* soundEntry = FindTextSoundEmoteFor(emote, bot->getRace(), bot->getGender()))
+    {
+        bot->PlayDistanceSound(soundEntry->SoundId);
+        return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::ContainsStrategy(StrategyType type)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        if (engines[i]->ContainsStrategy(type))
+            return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::HasStrategy(string name, BotState type)
+{
+    return engines[type]->HasStrategy(name);
+}
+
+void PlayerbotAI::ResetStrategies()
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+        engines[i]->removeAllStrategies();
+
+    AiFactory::AddDefaultCombatStrategies(bot, this, engines[BOT_STATE_COMBAT]);
+    AiFactory::AddDefaultNonCombatStrategies(bot, this, engines[BOT_STATE_NON_COMBAT]);
+    AiFactory::AddDefaultDeadStrategies(bot, this, engines[BOT_STATE_DEAD]);
+}
+
+bool PlayerbotAI::IsRanged(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_RANGED);
+
+    switch (player->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+    case CLASS_ROGUE:
+        return false;
+    case CLASS_DRUID:
+        return !HasAnyAuraOf(player, "cat form", "bear form", "dire bear form", NULL);
+    }
+    return true;
+}
+
+bool PlayerbotAI::IsTank(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_TANK);
+
+    switch (player->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+        return true;
+    case CLASS_DRUID:
+        return HasAnyAuraOf(player, "bear form", "dire bear form", NULL);
+    }
+    return false;
+}
+
+bool PlayerbotAI::IsHeal(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_HEAL);
+
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:
+        return true;
+    case CLASS_DRUID:
+        return HasAnyAuraOf(player, "tree of life form", NULL);
+    }
+    return false;
+}
+
+
+
+namespace MaNGOS
+{
+
+    class UnitByGuidInRangeCheck
+    {
+    public:
+        UnitByGuidInRangeCheck(WorldObject const* obj, ObjectGuid guid, float range) : i_obj(obj), i_range(range), i_guid(guid) {}
+        WorldObject const& GetFocusObject() const { return *i_obj; }
+        bool operator()(Unit* u)
+        {
+            return u->GetGUID() == i_guid && i_obj->IsWithinDistInMap(u, i_range);
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        ObjectGuid i_guid;
+    };
+
+    class GameObjectByGuidInRangeCheck
+    {
+    public:
+        GameObjectByGuidInRangeCheck(WorldObject const* obj, ObjectGuid guid, float range) : i_obj(obj), i_range(range), i_guid(guid) {}
+        WorldObject const& GetFocusObject() const { return *i_obj; }
+        bool operator()(GameObject* u)
+        {
+            if (u && i_obj->IsWithinDistInMap(u, i_range) && u->isSpawned() && u->GetGOInfo() && u->GetGUID() == i_guid)
+                return true;
+
+            return false;
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        ObjectGuid i_guid;
+    };
+
+};
+
+
+Unit* PlayerbotAI::GetUnit(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return ObjectAccessor::GetUnit(*bot, guid);
+}
+
+
+Creature* PlayerbotAI::GetCreature(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return map->GetCreature(guid);
+}
+
+GameObject* PlayerbotAI::GetGameObject(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return map->GetGameObject(guid);
+}
+
+bool PlayerbotAI::TellMasterNoFacing(string text, PlayerbotSecurityLevel securityLevel)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!GetSecurity()->CheckLevelFor(securityLevel, true, master))
+        return false;
+
+    if (sPlayerbotAIConfig.whisperDistance && !bot->GetGroup() && sRandomPlayerbotMgr.IsRandomBot(bot) &&
+            master->GetSession()->GetSecurity() < SEC_GAMEMASTER &&
+            (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.whisperDistance))
+        return false;
+
+    bot->Whisper(text, LANG_UNIVERSAL, master);
+    return true;
+}
+
+bool PlayerbotAI::TellMaster(string text, PlayerbotSecurityLevel securityLevel)
+{
+    if (!TellMasterNoFacing(text, securityLevel))
+        return false;
+
+    if (!bot->isMoving() && !bot->IsInCombat() && bot->GetMapId() == master->GetMapId())
+    {
+        if (!bot->isInFront(master, M_PI / 2))
+            bot->SetFacingTo(bot->GetAngle(master));
+
+        bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+
+    return true;
+}
+
+bool IsRealAura(Player* bot, Aura const* aura, Unit* unit)
+{
+    if (!aura)
+        return false;
+
+    if (!unit->IsHostileTo(bot))
+        return true;
+
+    uint32 stacks = aura->GetStackAmount();
+    if (stacks >= aura->GetSpellInfo()->StackAmount)
+        return true;
+
+    if (aura->GetCaster() == bot || aura->GetSpellInfo()->IsPositive() || aura->IsArea())
+        return true;
+
+    return false;
+}
+
+bool PlayerbotAI::HasAura(string name, Unit* unit)
+{
+    if (!unit)
+        return false;
+
+    uint32 spellId = aiObjectContext->GetValue<uint32>("spell id", name)->Get();
+    if (spellId)
+        return HasAura(spellId, unit);
+
+    wstring wnamepart;
+    if (!Utf8toWStr(name, wnamepart))
+        return 0;
+
+    wstrToLower(wnamepart);
+
+    Unit::AuraApplicationMap& map = unit->GetAppliedAuras();
+    for (Unit::AuraApplicationMap::iterator i = map.begin(); i != map.end(); ++i)
+    {
+        Aura const* aura  = i->second->GetBase();
+        if (!aura)
+            continue;
+
+        const string auraName = aura->GetSpellInfo()->SpellName[0];
+        if (auraName.empty() || auraName.length() != wnamepart.length() || !Utf8FitTo(auraName, wnamepart))
+            continue;
+
+        if (IsRealAura(bot, aura, unit))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit* unit)
+{
+    if (!spellId || !unit)
+        return false;
+
+    for (uint32 effect = EFFECT_0; effect <= EFFECT_2; effect++)
+    {
+        Aura* aura = ((Unit*)unit)->GetAura(spellId);
+
+        if (IsRealAura(bot, aura, (Unit*)unit))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAnyAuraOf(Unit* player, ...)
+{
+    if (!player)
+        return false;
+
+    va_list vl;
+    va_start(vl, player);
+
+    const char* cur;
+    do {
+        cur = va_arg(vl, const char*);
+        if (cur && HasAura(cur, player)) {
+            va_end(vl);
+            return true;
+        }
+    }
+    while (cur);
+
+    va_end(vl);
+    return false;
+}
+
+bool PlayerbotAI::CanCastSpell(string name, Unit* target)
+{
+    return CanCastSpell(aiObjectContext->GetValue<uint32>("spell id", name)->Get(), target);
+}
+
+bool PlayerbotAI::CanCastSpell(uint32 spellid, Unit* target, bool checkHasSpell)
+{
+    if (!spellid)
+        return false;
+
+    if (!target)
+        target = bot;
+
+    if (checkHasSpell && !bot->HasSpell(spellid))
+        return false;
+
+    if (bot->GetSpellHistory()->HasCooldown(spellid))
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid );
+    if (!spellInfo)
+        return false;
+
+    bool positiveSpell = spellInfo->IsPositive();
+    if (positiveSpell && bot->IsHostileTo(target))
+        return false;
+
+    if (!positiveSpell && bot->IsFriendlyTo(target))
+        return false;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return false;
+
+    if (bot != target && bot->GetDistance(target) > sPlayerbotAIConfig.sightDistance)
+        return false;
+
+    Unit* oldSel = bot->GetSelectedUnit();
+    bot->SetSelection(target->GetGUID());
+    Spell *spell = new Spell(bot, spellInfo, TRIGGERED_NONE);
+
+    spell->m_targets.SetUnitTarget(target);
+    spell->m_CastItem = aiObjectContext->GetValue<Item*>("item for spell", spellid)->Get();
+    spell->m_targets.SetItemTarget(spell->m_CastItem);
+    SpellCastResult result = spell->CheckCast(false);
+    delete spell;
+	if (oldSel)
+		bot->SetSelection(oldSel->GetGUID());
+
+    switch (result)
+    {
+    case SPELL_FAILED_NOT_INFRONT:
+    case SPELL_FAILED_NOT_STANDING:
+    case SPELL_FAILED_UNIT_NOT_INFRONT:
+    case SPELL_FAILED_SUCCESS:
+    case SPELL_FAILED_MOVING:
+    case SPELL_FAILED_TRY_AGAIN:
+    case SPELL_FAILED_NOT_IDLE:
+    case SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW:
+    case SPELL_FAILED_SUMMON_PENDING:
+    case SPELL_FAILED_BAD_IMPLICIT_TARGETS:
+    case SPELL_FAILED_BAD_TARGETS:
+    case SPELL_CAST_OK:
+    case SPELL_FAILED_ITEM_NOT_FOUND:
+        return true;
+    default:
+        return false;
+    }
+}
+
+
+bool PlayerbotAI::CastSpell(string name, Unit* target)
+{
+    bool result = CastSpell(aiObjectContext->GetValue<uint32>("spell id", name)->Get(), target);
+    if (result)
+    {
+        aiObjectContext->GetValue<time_t>("last spell cast time", name)->Set(time(0));
+    }
+
+    return result;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit* target)
+{
+    if (!spellId)
+        return false;
+
+    if (!target)
+        target = bot;
+
+    Pet* pet = bot->GetPet();
+    const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (pet && pet->HasSpell(spellId))
+    {
+        pet->GetCharmInfo()->SetSpellAutocast(pSpellInfo, true);
+        pet->GetCharmInfo()->ToggleCreatureAutocast(pSpellInfo, true);
+        TellMaster("My pet will auto-cast this spell");
+        return true;
+    }
+
+    aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get().Set(spellId, target->GetGUID(), time(0));
+    aiObjectContext->GetValue<LastMovement&>("last movement")->Get().Set(NULL);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+
+    if (bot->IsFlying())
+        return false;
+
+    bot->ClearUnitState( UNIT_STATE_ALL_STATE_SUPPORTED );
+
+    Unit* oldSel = bot->GetSelectedUnit();
+    bot->SetSelection(target->GetGUID());
+
+    Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+    if (bot->isMoving() && spell->GetCastTime())
+    {
+        delete spell;
+        return false;
+    }
+
+    SpellCastTargets targets;
+    WorldObject* faceTo = target;
+
+    if (pSpellInfo->Targets & TARGET_FLAG_SOURCE_LOCATION ||
+            pSpellInfo->Targets & TARGET_FLAG_DEST_LOCATION)
+    {
+        targets.SetDst(target->GetPosition());
+    }
+    else
+    {
+        targets.SetUnitTarget(target);
+    }
+
+    if (pSpellInfo->Targets & TARGET_FLAG_ITEM)
+    {
+        spell->m_CastItem = aiObjectContext->GetValue<Item*>("item for spell", spellId)->Get();
+        targets.SetItemTarget(spell->m_CastItem);
+    }
+
+    if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_OPEN_LOCK ||
+        pSpellInfo->Effects[0].Effect == SPELL_EFFECT_SKINNING)
+    {
+        LootObject loot = *aiObjectContext->GetValue<LootObject>("loot target");
+        if (!loot.IsLootPossible(bot))
+        {
+            delete spell;
+            return false;
+        }
+
+        GameObject* go = GetGameObject(loot.guid);
+        if (go && go->isSpawned())
+        {
+            WorldPacket* const packetgouse = new WorldPacket(CMSG_GAMEOBJ_REPORT_USE, 8);
+            *packetgouse << loot.guid;
+            bot->GetSession()->QueuePacket(packetgouse);
+            targets.SetGOTarget(go);
+            faceTo = go;
+        }
+        else
+        {
+            Unit* creature = GetUnit(loot.guid);
+            if (creature)
+            {
+                targets.SetUnitTarget(creature);
+                faceTo = creature;
+            }
+        }
+    }
+
+
+    if (!bot->isInFront(faceTo, M_PI / 2))
+    {
+        bot->SetFacingTo(bot->GetAngle(faceTo));
+        delete spell;
+        SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+        return false;
+    }
+
+	spell->prepare(&targets);
+	WaitForSpellCast(spell);
+
+    if (oldSel)
+        bot->SetSelection(oldSel->GetGUID());
+
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+    return lastSpell.id == spellId;
+}
+
+void PlayerbotAI::WaitForSpellCast(Spell *spell)
+{
+    const SpellInfo* const pSpellInfo = spell->GetSpellInfo();
+
+    float castTime = spell->GetCastTime() + sPlayerbotAIConfig.reactDelay;
+    if (pSpellInfo->IsChanneled())
+    {
+        int32 duration = pSpellInfo->GetDuration();
+        if (duration > 0)
+            castTime += duration;
+    }
+
+    castTime = ceil(castTime);
+
+    uint32 globalCooldown = CalculateGlobalCooldown(pSpellInfo->Id);
+    if (castTime < globalCooldown)
+        castTime = globalCooldown;
+
+    SetNextCheckDelay(castTime);
+}
+
+void PlayerbotAI::InterruptSpell()
+{
+    if (bot->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+        return;
+
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+
+    for (int type = CURRENT_MELEE_SPELL; type < CURRENT_CHANNELED_SPELL; type++)
+    {
+        Spell* spell = bot->GetCurrentSpell((CurrentSpellTypes)type);
+        if (!spell)
+            continue;
+
+        bot->InterruptSpell((CurrentSpellTypes)type);
+
+        WorldPacket data(SMSG_SPELL_FAILURE, 8 + 1 + 4 + 1);
+        data.appendPackGUID(bot->GetGUID());
+        data << uint8(1);
+        data << uint32(spell->m_spellInfo->Id);
+        data << uint8(0);
+        bot->SendMessageToSet(&data, true);
+
+        data.Initialize(SMSG_SPELL_FAILED_OTHER, 8 + 1 + 4 + 1);
+        data.appendPackGUID(bot->GetGUID());
+        data << uint8(1);
+        data << uint32(spell->m_spellInfo->Id);
+        data << uint8(0);
+        bot->SendMessageToSet(&data, true);
+
+        SpellInterrupted(spell->m_spellInfo->Id);
+    }
+
+    SpellInterrupted(lastSpell.id);
+}
+
+
+void PlayerbotAI::RemoveAura(string name)
+{
+    uint32 spellid = aiObjectContext->GetValue<uint32>("spell id", name)->Get();
+    if (spellid && HasAura(spellid, bot))
+        bot->RemoveAurasDueToSpell(spellid);
+}
+
+bool PlayerbotAI::IsInterruptableSpellCasting(Unit* target, string spell)
+{
+    uint32 spellid = aiObjectContext->GetValue<uint32>("spell id", spell)->Get();
+    if (!spellid || !target->IsNonMeleeSpellCast(true))
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid );
+    if (!spellInfo)
+        return false;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return false;
+
+    for (uint32 i = EFFECT_0; i <= EFFECT_2; i++)
+    {
+        if ((spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT) && spellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
+            return true;
+
+        if ((spellInfo->Effects[i].Effect == SPELL_EFFECT_REMOVE_AURA || spellInfo->Effects[i].Effect == SPELL_EFFECT_INTERRUPT_CAST) &&
+                !target->IsImmunedToSpellEffect(spellInfo, i))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAuraToDispel(Unit* target, uint32 dispelType)
+{
+    for (uint32 type = SPELL_AURA_NONE; type < TOTAL_AURAS; ++type)
+    {
+        Unit::AuraEffectList const& auras = target->GetAuraEffectsByType((AuraType)type);
+        for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            const AuraEffect *const aura = *itr;
+			const SpellInfo* entry = aura->GetSpellInfo();
+            uint32 spellId = entry->Id;
+
+            bool isPositiveSpell = entry->IsPositive();
+            if (isPositiveSpell && bot->IsFriendlyTo(target))
+                continue;
+
+            if (!isPositiveSpell && bot->IsHostileTo(target))
+                continue;
+
+            if (canDispel(entry, dispelType))
+                return true;
+        }
+    }
+    return false;
+}
+
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+bool PlayerbotAI::canDispel(const SpellInfo* entry, uint32 dispelType)
+{
+    if (entry->Dispel != dispelType)
+        return false;
+
+    return !entry->SpellName[0] ||
+        (strcmpi((const char*)entry->SpellName[0], "demon skin") &&
+        strcmpi((const char*)entry->SpellName[0], "mage armor") &&
+        strcmpi((const char*)entry->SpellName[0], "frost armor") &&
+        strcmpi((const char*)entry->SpellName[0], "wavering will") &&
+        strcmpi((const char*)entry->SpellName[0], "chilled") &&
+        strcmpi((const char*)entry->SpellName[0], "ice armor"));
+}
+
+bool IsAlliance(uint8 race)
+{
+    return race == RACE_HUMAN || race == RACE_DWARF || race == RACE_NIGHTELF ||
+            race == RACE_GNOME || race == RACE_DRAENEI;
+}
+
+bool PlayerbotAI::IsOpposing(Player* player)
+{
+    return IsOpposing(player->getRace(), bot->getRace());
+}
+
+bool PlayerbotAI::IsOpposing(uint8 race1, uint8 race2)
+{
+    return (IsAlliance(race1) && !IsAlliance(race2)) || (!IsAlliance(race1) && IsAlliance(race2));
+}
+
+void PlayerbotAI::RemoveShapeshift()
+{
+    RemoveAura("bear form");
+    RemoveAura("dire bear form");
+    RemoveAura("moonkin form");
+    RemoveAura("travel form");
+    RemoveAura("cat form");
+    RemoveAura("flight form");
+    RemoveAura("swift flight form");
+    RemoveAura("aquatic form");
+    RemoveAura("ghost wolf");
+    RemoveAura("tree of life");
+}
+
+uint32 PlayerbotAI::GetEquipGearScore(Player* player, bool withBags, bool withBank)
+{
+    std::vector<uint32> gearScore(EQUIPMENT_SLOT_END);
+    uint32 twoHandScore = 0;
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            _fillGearScoreData(player, item, &gearScore, twoHandScore);
+    }
+
+    if (withBags)
+    {
+        // check inventory
+        for (int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                _fillGearScoreData(player, item, &gearScore, twoHandScore);
+        }
+
+        // check bags
+        for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        {
+            if (Bag* pBag = (Bag*)player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                {
+                    if (Item* item2 = pBag->GetItemByPos(j))
+                        _fillGearScoreData(player, item2, &gearScore, twoHandScore);
+                }
+            }
+        }
+    }
+
+    if (withBank)
+    {
+        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                _fillGearScoreData(player, item, &gearScore, twoHandScore);
+        }
+
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                if (item->IsBag())
+                {
+                    Bag* bag = (Bag*)item;
+                    for (uint8 j = 0; j < bag->GetBagSize(); ++j)
+                    {
+                        if (Item* item2 = bag->GetItemByPos(j))
+                            _fillGearScoreData(player, item2, &gearScore, twoHandScore);
+                    }
+                }
+            }
+        }
+    }
+
+    uint8 count = EQUIPMENT_SLOT_END - 2;   // ignore body and tabard slots
+    uint32 sum = 0;
+
+    // check if 2h hand is higher level than main hand + off hand
+    if (gearScore[EQUIPMENT_SLOT_MAINHAND] + gearScore[EQUIPMENT_SLOT_OFFHAND] < twoHandScore * 2)
+    {
+        gearScore[EQUIPMENT_SLOT_OFFHAND] = 0;  // off hand is ignored in calculations if 2h weapon has higher score
+        --count;
+        gearScore[EQUIPMENT_SLOT_MAINHAND] = twoHandScore;
+    }
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+       sum += gearScore[i];
+    }
+
+    if (count)
+    {
+        uint32 res = uint32(sum / count);
+        return res;
+    }
+    else
+        return 0;
+}
+
+void PlayerbotAI::_fillGearScoreData(Player *player, Item* item, std::vector<uint32>* gearScore, uint32& twoHandScore)
+{
+    if (!item)
+        return;
+
+    if (player->CanUseItem(item->GetTemplate()) != EQUIP_ERR_OK)
+        return;
+
+    uint8 type   = item->GetTemplate()->InventoryType;
+    uint32 level = item->GetTemplate()->ItemLevel;
+
+    switch (type)
+    {
+        case INVTYPE_2HWEAPON:
+            twoHandScore = std::max(twoHandScore, level);
+            break;
+        case INVTYPE_WEAPON:
+        case INVTYPE_WEAPONMAINHAND:
+            (*gearScore)[SLOT_MAIN_HAND] = std::max((*gearScore)[SLOT_MAIN_HAND], level);
+            break;
+        case INVTYPE_SHIELD:
+        case INVTYPE_WEAPONOFFHAND:
+            (*gearScore)[EQUIPMENT_SLOT_OFFHAND] = std::max((*gearScore)[EQUIPMENT_SLOT_OFFHAND], level);
+            break;
+        case INVTYPE_THROWN:
+        case INVTYPE_RANGEDRIGHT:
+        case INVTYPE_RANGED:
+        case INVTYPE_QUIVER:
+        case INVTYPE_RELIC:
+            (*gearScore)[EQUIPMENT_SLOT_RANGED] = std::max((*gearScore)[EQUIPMENT_SLOT_RANGED], level);
+            break;
+        case INVTYPE_HEAD:
+            (*gearScore)[EQUIPMENT_SLOT_HEAD] = std::max((*gearScore)[EQUIPMENT_SLOT_HEAD], level);
+            break;
+        case INVTYPE_NECK:
+            (*gearScore)[EQUIPMENT_SLOT_NECK] = std::max((*gearScore)[EQUIPMENT_SLOT_NECK], level);
+            break;
+        case INVTYPE_SHOULDERS:
+            (*gearScore)[EQUIPMENT_SLOT_SHOULDERS] = std::max((*gearScore)[EQUIPMENT_SLOT_SHOULDERS], level);
+            break;
+        case INVTYPE_BODY:
+            (*gearScore)[EQUIPMENT_SLOT_BODY] = std::max((*gearScore)[EQUIPMENT_SLOT_BODY], level);
+            break;
+        case INVTYPE_CHEST:
+            (*gearScore)[EQUIPMENT_SLOT_CHEST] = std::max((*gearScore)[EQUIPMENT_SLOT_CHEST], level);
+            break;
+        case INVTYPE_WAIST:
+            (*gearScore)[EQUIPMENT_SLOT_WAIST] = std::max((*gearScore)[EQUIPMENT_SLOT_WAIST], level);
+            break;
+        case INVTYPE_LEGS:
+            (*gearScore)[EQUIPMENT_SLOT_LEGS] = std::max((*gearScore)[EQUIPMENT_SLOT_LEGS], level);
+            break;
+        case INVTYPE_FEET:
+            (*gearScore)[EQUIPMENT_SLOT_FEET] = std::max((*gearScore)[EQUIPMENT_SLOT_FEET], level);
+            break;
+        case INVTYPE_WRISTS:
+            (*gearScore)[EQUIPMENT_SLOT_WRISTS] = std::max((*gearScore)[EQUIPMENT_SLOT_WRISTS], level);
+            break;
+        case INVTYPE_HANDS:
+            (*gearScore)[EQUIPMENT_SLOT_HEAD] = std::max((*gearScore)[EQUIPMENT_SLOT_HEAD], level);
+            break;
+        // equipped gear score check uses both rings and trinkets for calculation, assume that for bags/banks it is the same
+        // with keeping second highest score at second slot
+        case INVTYPE_FINGER:
+        {
+            if ((*gearScore)[EQUIPMENT_SLOT_FINGER1] < level)
+            {
+                (*gearScore)[EQUIPMENT_SLOT_FINGER2] = (*gearScore)[EQUIPMENT_SLOT_FINGER1];
+                (*gearScore)[EQUIPMENT_SLOT_FINGER1] = level;
+            }
+            else if ((*gearScore)[EQUIPMENT_SLOT_FINGER2] < level)
+                (*gearScore)[EQUIPMENT_SLOT_FINGER2] = level;
+            break;
+        }
+        case INVTYPE_TRINKET:
+        {
+            if ((*gearScore)[EQUIPMENT_SLOT_TRINKET1] < level)
+            {
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET2] = (*gearScore)[EQUIPMENT_SLOT_TRINKET1];
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET1] = level;
+            }
+            else if ((*gearScore)[EQUIPMENT_SLOT_TRINKET2] < level)
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET2] = level;
+            break;
+        }
+        case INVTYPE_CLOAK:
+            (*gearScore)[EQUIPMENT_SLOT_BACK] = std::max((*gearScore)[EQUIPMENT_SLOT_BACK], level);
+            break;
+        default:
+            break;
+    }
+}
+
+string PlayerbotAI::HandleRemoteCommand(string command)
+{
+    if (command == "state")
+    {
+        switch (currentState)
+        {
+        case BOT_STATE_COMBAT:
+            return "combat";
+        case BOT_STATE_DEAD:
+            return "dead";
+        case BOT_STATE_NON_COMBAT:
+            return "non-combat";
+        default:
+            return "unknown";
+        }
+    }
+    else if (command == "position")
+    {
+        ostringstream out; out << bot->GetPositionX() << " " << bot->GetPositionY() << " " << bot->GetPositionZ() << " " << bot->GetMapId() << " " << bot->GetOrientation();
+        return out.str();
+    }
+    else if (command == "tpos")
+    {
+        Unit* target = *GetAiObjectContext()->GetValue<Unit*>("current target");
+        if (!target) {
+            return "";
+        }
+
+        ostringstream out; out << target->GetPositionX() << " " << target->GetPositionY() << " " << target->GetPositionZ() << " " << target->GetMapId() << " " << target->GetOrientation();
+        return out.str();
+    }
+    else if (command == "movement")
+    {
+        LastMovement& data = *GetAiObjectContext()->GetValue<LastMovement&>("last movement");
+        ostringstream out; out << data.lastMoveToX << " " << data.lastMoveToY << " " << data.lastMoveToZ << " " << bot->GetMapId() << " " << data.lastMoveToOri;
+        return out.str();
+    }
+    else if (command == "target")
+    {
+        Unit* target = *GetAiObjectContext()->GetValue<Unit*>("current target");
+        if (!target) {
+            return "";
+        }
+
+        return target->GetName();
+    }
+    else if (command == "hp")
+    {
+        int pct = (int)((static_cast<float> (bot->GetHealth()) / bot->GetMaxHealth()) * 100);
+        ostringstream out; out << pct << "%";
+
+        Unit* target = *GetAiObjectContext()->GetValue<Unit*>("current target");
+        if (!target) {
+            return out.str();
+        }
+
+        pct = (int)((static_cast<float> (target->GetHealth()) / target->GetMaxHealth()) * 100);
+        out << " / " << pct << "%";
+        return out.str();
+    }
+    else if (command == "strategy")
+    {
+        return currentEngine->ListStrategies();
+    }
+    else if (command == "action")
+    {
+        return currentEngine->GetLastAction();
+    }
+    else if (command == "values")
+    {
+        return GetAiObjectContext()->FormatValues();
+    }
+    ostringstream out; out << "invalid command: " << command;
+    return out.str();
+}
diff --git a/src/plugins/playerbot/PlayerbotAI.h b/src/plugins/playerbot/PlayerbotAI.h
new file mode 100644
index 0000000..353f61f
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAI.h
@@ -0,0 +1,187 @@
+#pragma once
+
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "PlayerbotAIBase.h"
+#include "strategy/AiObjectContext.h"
+#include "strategy/Engine.h"
+#include "strategy/ExternalEventHelper.h"
+#include "ChatFilter.h"
+#include "PlayerbotSecurity.h"
+#include <stack>
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+using namespace ai;
+
+bool IsAlliance(uint8 race);
+
+class PlayerbotChatHandler: protected ChatHandler
+{
+public:
+    explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer->GetSession()) {}
+    void sysmessage(string str) { SendSysMessage(str.c_str()); }
+    uint32 extractQuestId(string str);
+    uint32 extractSpellId(string str)
+    {
+        char* source = (char*)str.c_str();
+        return extractSpellIdFromLink(source);
+    }
+};
+
+namespace ai
+{
+	class MinValueCalculator {
+	public:
+		MinValueCalculator(float def = 0.0f) {
+			param = NULL;
+			minValue = def;
+		}
+
+	public:
+		void probe(float value, void* p) {
+			if (!param || minValue >= value) {
+				minValue = value;
+				param = p;
+			}
+		}
+
+	public:
+		void* param;
+		float minValue;
+	};
+};
+
+enum BotState
+{
+    BOT_STATE_COMBAT = 0,
+    BOT_STATE_NON_COMBAT = 1,
+    BOT_STATE_DEAD = 2
+};
+
+#define BOT_STATE_MAX 3
+
+class PacketHandlingHelper
+{
+public:
+    void AddHandler(uint16 opcode, string handler);
+    void Handle(ExternalEventHelper &helper);
+    void AddPacket(const WorldPacket& packet);
+
+private:
+    map<uint16, string> handlers;
+    stack<WorldPacket> queue;
+};
+
+class ChatCommandHolder
+{
+public:
+    ChatCommandHolder(string command, Player* owner = NULL, uint32 type = CHAT_MSG_WHISPER) : command(command), owner(owner), type(type) {}
+    ChatCommandHolder(ChatCommandHolder const& other)
+    {
+        this->command = other.command;
+        this->owner = other.owner;
+        this->type = other.type;
+    }
+
+public:
+    string GetCommand() { return command; }
+    Player* GetOwner() { return owner; }
+    uint32 GetType() { return type; }
+
+private:
+    string command;
+    Player* owner;
+    uint32 type;
+};
+
+class PlayerbotAI : public PlayerbotAIBase
+{
+public:
+	PlayerbotAI();
+	PlayerbotAI(Player* bot);
+	virtual ~PlayerbotAI();
+
+public:
+	virtual void UpdateAI(uint32 elapsed);
+	virtual void UpdateAIInternal(uint32 elapsed);
+	string HandleRemoteCommand(string command);
+    void HandleCommand(uint32 type, const string& text, Player& fromPlayer);
+	void HandleBotOutgoingPacket(const WorldPacket& packet);
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+	void HandleTeleportAck();
+    void ChangeEngine(BotState type);
+    void DoNextAction();
+    void DoSpecificAction(string name);
+    void ChangeStrategy(string name, BotState type);
+    bool ContainsStrategy(StrategyType type);
+    bool HasStrategy(string name, BotState type);
+    void ResetStrategies();
+    void ReInitCurrentEngine();
+    void Reset();
+    bool IsTank(Player* player);
+    bool IsHeal(Player* player);
+    bool IsRanged(Player* player);
+    Creature* GetCreature(ObjectGuid guid);
+    Unit* GetUnit(ObjectGuid guid);
+    GameObject* GetGameObject(ObjectGuid guid);
+    bool TellMaster(ostringstream &stream, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL) { return TellMaster(stream.str(), securityLevel); }
+    bool TellMaster(string text, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL);
+    bool TellMasterNoFacing(string text, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL);
+    void SpellInterrupted(uint32 spellid);
+    int32 CalculateGlobalCooldown(uint32 spellid);
+    void InterruptSpell();
+    void RemoveAura(string name);
+    void RemoveShapeshift();
+    void WaitForSpellCast(Spell *spell);
+    bool PlaySound(uint32 emote);
+
+    virtual bool CanCastSpell(string name, Unit* target);
+    virtual bool CastSpell(string name, Unit* target);
+    virtual bool HasAura(string spellName, Unit* player);
+    virtual bool HasAnyAuraOf(Unit* player, ...);
+
+    virtual bool IsInterruptableSpellCasting(Unit* player, string spell);
+    virtual bool HasAuraToDispel(Unit* player, uint32 dispelType);
+    bool CanCastSpell(uint32 spellid, Unit* target, bool checkHasSpell = true);
+
+    bool HasAura(uint32 spellId, const Unit* player);
+    bool CastSpell(uint32 spellId, Unit* target);
+    bool canDispel(const SpellInfo* entry, uint32 dispelType);
+
+    uint32 GetEquipGearScore(Player* player, bool withBags, bool withBank);
+
+private:
+    void _fillGearScoreData(Player *player, Item* item, std::vector<uint32>* gearScore, uint32& twoHandScore);
+
+public:
+	Player* GetBot() { return bot; }
+    Player* GetMaster() { return master; }
+    void SetMaster(Player* master) { this->master = master; }
+    AiObjectContext* GetAiObjectContext() { return aiObjectContext; }
+    ChatHelper* GetChatHelper() { return &chatHelper; }
+    bool IsOpposing(Player* player);
+    static bool IsOpposing(uint8 race1, uint8 race2);
+    PlayerbotSecurity* GetSecurity() { return &security; }
+
+protected:
+	Player* bot;
+	Player* master;
+	uint32 accountId;
+    AiObjectContext* aiObjectContext;
+    Engine* currentEngine;
+    Engine* engines[BOT_STATE_MAX];
+    BotState currentState;
+    ChatHelper chatHelper;
+    stack<ChatCommandHolder> chatCommands;
+    PacketHandlingHelper botOutgoingPacketHandlers;
+    PacketHandlingHelper masterIncomingPacketHandlers;
+    PacketHandlingHelper masterOutgoingPacketHandlers;
+    CompositeChatFilter chatFilter;
+    PlayerbotSecurity security;
+};
+
diff --git a/src/plugins/playerbot/PlayerbotAIAware.h b/src/plugins/playerbot/PlayerbotAIAware.h
new file mode 100644
index 0000000..740628a
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIAware.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+    class PlayerbotAIAware 
+    {
+    public:
+        PlayerbotAIAware(PlayerbotAI* const ai) : ai(ai) { }
+
+    protected:
+        PlayerbotAI* ai;
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/PlayerbotAIBase.cpp b/src/plugins/playerbot/PlayerbotAIBase.cpp
new file mode 100644
index 0000000..4acb310
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIBase.cpp
@@ -0,0 +1,51 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+PlayerbotAIBase::PlayerbotAIBase() : nextAICheckDelay(0)
+{
+}
+
+void PlayerbotAIBase::UpdateAI(uint32 elapsed)
+{
+    if (nextAICheckDelay > elapsed)
+        nextAICheckDelay -= elapsed;
+    else
+        nextAICheckDelay = 0;
+
+    if (!CanUpdateAI())
+        return;
+
+    UpdateAIInternal(elapsed);
+    YieldThread();
+}
+
+void PlayerbotAIBase::SetNextCheckDelay(const uint32 delay)
+{
+    nextAICheckDelay = delay;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown)
+        sLog->outMessage("playerbot", LOG_LEVEL_TRACE, "set next check delay: %d", nextAICheckDelay);
+}
+
+void PlayerbotAIBase::IncreaseNextCheckDelay(uint32 delay)
+{
+    nextAICheckDelay += delay;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown)
+        sLog->outMessage("playerbot", LOG_LEVEL_TRACE, "increase next check delay: %d", nextAICheckDelay);
+}
+
+bool PlayerbotAIBase::CanUpdateAI()
+{
+    return nextAICheckDelay < 100;
+}
+
+void PlayerbotAIBase::YieldThread()
+{
+    if (nextAICheckDelay < sPlayerbotAIConfig.reactDelay)
+        nextAICheckDelay = sPlayerbotAIConfig.reactDelay;
+}
diff --git a/src/plugins/playerbot/PlayerbotAIBase.h b/src/plugins/playerbot/PlayerbotAIBase.h
new file mode 100644
index 0000000..8e72bf0
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIBase.h
@@ -0,0 +1,24 @@
+#pragma once
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+
+class PlayerbotAIBase
+{
+public:
+	PlayerbotAIBase();
+
+public:
+	bool CanUpdateAI();
+	void SetNextCheckDelay(const uint32 delay);
+    void IncreaseNextCheckDelay(uint32 delay);
+	void YieldThread();
+    virtual void UpdateAI(uint32 elapsed);
+    virtual void UpdateAIInternal(uint32 elapsed) = 0;
+
+protected:
+	uint32 nextAICheckDelay;
+};
diff --git a/src/plugins/playerbot/PlayerbotAIConfig.cpp b/src/plugins/playerbot/PlayerbotAIConfig.cpp
new file mode 100644
index 0000000..ed8440d
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIConfig.cpp
@@ -0,0 +1,230 @@
+#include "../pchdef.h"
+#include "PlayerbotAIConfig.h"
+#include "playerbot.h"
+#include "RandomPlayerbotFactory.h"
+#include "../../game/Accounts/AccountMgr.h"
+
+using namespace std;
+
+PlayerbotAIConfig::PlayerbotAIConfig()
+{
+}
+
+template <class T>
+void LoadList(string value, T &list)
+{
+    vector<string> ids = split(value, ',');
+    for (vector<string>::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        uint32 id = atoi((*i).c_str());
+        if (!id)
+            continue;
+
+        list.push_back(id);
+    }
+}
+
+bool PlayerbotAIConfig::Initialize()
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing AI Playerbot by ike3, based on the original Playerbot by blueboy");
+
+    string error;
+	vector<string> args;
+    if (!config.LoadInitial("aiplayerbot.conf", args, error))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot is Disabled. Unable to open configuration file aiplayerbot.conf");
+        return false;
+    }
+
+    enabled = config.GetBoolDefault("AiPlayerbot.Enabled", true);
+    if (!enabled)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot is Disabled in aiplayerbot.conf");
+        return false;
+    }
+
+    globalCoolDown = (uint32) config.GetIntDefault("AiPlayerbot.GlobalCooldown", 500);
+    maxWaitForMove = config.GetIntDefault("AiPlayerbot.MaxWaitForMove", 3000);
+    reactDelay = (uint32) config.GetIntDefault("AiPlayerbot.ReactDelay", 100);
+
+    sightDistance = config.GetFloatDefault("AiPlayerbot.SightDistance", 50.0f);
+    spellDistance = config.GetFloatDefault("AiPlayerbot.SpellDistance", 25.0f);
+    reactDistance = config.GetFloatDefault("AiPlayerbot.ReactDistance", 150.0f);
+    grindDistance = config.GetFloatDefault("AiPlayerbot.GrindDistance", 100.0f);
+    lootDistance = config.GetFloatDefault("AiPlayerbot.LootDistance", 20.0f);
+    fleeDistance = config.GetFloatDefault("AiPlayerbot.FleeDistance", 20.0f);
+    tooCloseDistance = config.GetFloatDefault("AiPlayerbot.TooCloseDistance", 5.0f);
+    meleeDistance = config.GetFloatDefault("AiPlayerbot.MeleeDistance", 0.5f);
+    followDistance = config.GetFloatDefault("AiPlayerbot.FollowDistance", 1.5f);
+    whisperDistance = config.GetFloatDefault("AiPlayerbot.WhisperDistance", 6000.0f);
+    contactDistance = config.GetFloatDefault("AiPlayerbot.ContactDistance", 0.5f);
+
+    criticalHealth = config.GetIntDefault("AiPlayerbot.CriticalHealth", 20);
+    lowHealth = config.GetIntDefault("AiPlayerbot.LowHealth", 50);
+    mediumHealth = config.GetIntDefault("AiPlayerbot.MediumHealth", 70);
+    almostFullHealth = config.GetIntDefault("AiPlayerbot.AlmostFullHealth", 85);
+    lowMana = config.GetIntDefault("AiPlayerbot.LowMana", 15);
+    mediumMana = config.GetIntDefault("AiPlayerbot.MediumMana", 40);
+
+    randomGearLoweringChance = config.GetFloatDefault("AiPlayerbot.RandomGearLoweringChance", 0.15);
+    randomBotMaxLevelChance = config.GetFloatDefault("AiPlayerbot.RandomBotMaxLevelChance", 0.4);
+
+    iterationsPerTick = config.GetIntDefault("AiPlayerbot.IterationsPerTick", 10);
+
+    allowGuildBots = config.GetBoolDefault("AiPlayerbot.AllowGuildBots", true);
+
+    randomBotMapsAsString = config.GetStringDefault("AiPlayerbot.RandomBotMaps", "0,1,530,571");
+    LoadList<vector<uint32> >(randomBotMapsAsString, randomBotMaps);
+    LoadList<list<uint32> >(config.GetStringDefault("AiPlayerbot.RandomBotQuestItems", "6948,5175,5176,5177,5178"), randomBotQuestItems);
+    LoadList<list<uint32> >(config.GetStringDefault("AiPlayerbot.RandomBotSpellIds", "54197"), randomBotSpellIds);
+
+    randomBotAutologin = config.GetBoolDefault("AiPlayerbot.RandomBotAutologin", true);
+    minRandomBots = config.GetIntDefault("AiPlayerbot.MinRandomBots", 50);
+    maxRandomBots = config.GetIntDefault("AiPlayerbot.MaxRandomBots", 200);
+    randomBotUpdateInterval = config.GetIntDefault("AiPlayerbot.RandomBotUpdateInterval", 60);
+    randomBotCountChangeMinInterval = config.GetIntDefault("AiPlayerbot.RandomBotCountChangeMinInterval", 24 * 3600);
+    randomBotCountChangeMaxInterval = config.GetIntDefault("AiPlayerbot.RandomBotCountChangeMaxInterval", 3 * 24 * 3600);
+    minRandomBotInWorldTime = config.GetIntDefault("AiPlayerbot.MinRandomBotInWorldTime", 24 * 3600);
+    maxRandomBotInWorldTime = config.GetIntDefault("AiPlayerbot.MaxRandomBotInWorldTime", 14 * 24 * 3600);
+    minRandomBotRandomizeTime = config.GetIntDefault("AiPlayerbot.MinRandomBotRandomizeTime", 2 * 3600);
+    maxRandomBotRandomizeTime = config.GetIntDefault("AiPlayerbot.MaxRandomRandomizeTime", 14 * 24 * 3600);
+    minRandomBotReviveTime = config.GetIntDefault("AiPlayerbot.MinRandomBotReviveTime", 60);
+    maxRandomBotReviveTime = config.GetIntDefault("AiPlayerbot.MaxRandomReviveTime", 300);
+    randomBotTeleportDistance = config.GetIntDefault("AiPlayerbot.RandomBotTeleportDistance", 1000);
+    minRandomBotsPerInterval = config.GetIntDefault("AiPlayerbot.MinRandomBotsPerInterval", 50);
+    maxRandomBotsPerInterval = config.GetIntDefault("AiPlayerbot.MaxRandomBotsPerInterval", 100);
+    minRandomBotsPriceChangeInterval = config.GetIntDefault("AiPlayerbot.MinRandomBotsPriceChangeInterval", 2 * 3600);
+    maxRandomBotsPriceChangeInterval = config.GetIntDefault("AiPlayerbot.MaxRandomBotsPriceChangeInterval", 48 * 3600);
+    randomBotJoinLfg = config.GetBoolDefault("AiPlayerbot.RandomBotJoinLfg", true);
+    logInGroupOnly = config.GetBoolDefault("AiPlayerbot.LogInGroupOnly", true);
+    logValuesPerTick = config.GetBoolDefault("AiPlayerbot.LogValuesPerTick", false);
+    fleeingEnabled = config.GetBoolDefault("AiPlayerbot.FleeingEnabled", true);
+    randomBotMinLevel = config.GetIntDefault("AiPlayerbot.RandomBotMinLevel", 1);
+    randomBotMaxLevel = config.GetIntDefault("AiPlayerbot.RandomBotMaxLevel", 255);
+    randomBotLoginAtStartup = config.GetBoolDefault("AiPlayerbot.RandomBotLoginAtStartup", true);
+    randomBotTeleLevel = config.GetIntDefault("AiPlayerbot.RandomBotTeleLevel", 3);
+
+    randomChangeMultiplier = config.GetFloatDefault("AiPlayerbot.RandomChangeMultiplier", 1.0);
+
+    randomBotCombatStrategies = config.GetStringDefault("AiPlayerbot.RandomBotCombatStrategies", "+dps,+attack weak,-threat");
+    randomBotNonCombatStrategies = config.GetStringDefault("AiPlayerbot.RandomBotNonCombatStrategies", "+grind,+move random,+loot");
+
+    commandPrefix = config.GetStringDefault("AiPlayerbot.CommandPrefix", "");
+
+    commandServerPort = config.GetIntDefault("AiPlayerbot.CommandServerPort", 0);
+
+    for (uint32 cls = 0; cls < MAX_CLASSES; ++cls)
+    {
+        for (uint32 spec = 0; spec < 3; ++spec)
+        {
+            ostringstream os; os << "AiPlayerbot.RandomClassSpecProbability." << cls << "." << spec;
+            specProbability[cls][spec] = config.GetIntDefault(os.str().c_str(), 33);
+        }
+    }
+
+    randomBotAccountPrefix = config.GetStringDefault("AiPlayerbot.RandomBotAccountPrefix", "rndbot");
+    randomBotAccountCount = config.GetIntDefault("AiPlayerbot.RandomBotAccountCount", 50);
+    deleteRandomBotAccounts = config.GetBoolDefault("AiPlayerbot.DeleteRandomBotAccounts", false);
+    randomBotGuildCount = config.GetIntDefault("AiPlayerbot.RandomBotGuildCount", 50);
+    deleteRandomBotGuilds = config.GetBoolDefault("AiPlayerbot.DeleteRandomBotGuilds", false);
+
+    guildTaskEnabled = config.GetBoolDefault("AiPlayerbot.EnableGuildTasks", true);
+    minGuildTaskChangeTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskChangeTime", 2 * 24 * 3600);
+    maxGuildTaskChangeTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskChangeTime", 5 * 24 * 3600);
+    minGuildTaskAdvertisementTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskAdvertisementTime", 8 * 3600);
+    maxGuildTaskAdvertisementTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskAdvertisementTime", 4 * 24 * 3600);
+    minGuildTaskRewardTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskRewardTime", 60);
+    maxGuildTaskRewardTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskRewardTime", 600);
+
+    RandomPlayerbotFactory::CreateRandomBots();
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot configuration loaded");
+
+    return true;
+}
+
+
+bool PlayerbotAIConfig::IsInRandomAccountList(uint32 id)
+{
+    return find(randomBotAccounts.begin(), randomBotAccounts.end(), id) != randomBotAccounts.end();
+}
+
+bool PlayerbotAIConfig::IsInRandomQuestItemList(uint32 id)
+{
+    return find(randomBotQuestItems.begin(), randomBotQuestItems.end(), id) != randomBotQuestItems.end();
+}
+
+string PlayerbotAIConfig::GetValue(string name)
+{
+    ostringstream out;
+
+    if (name == "GlobalCooldown")
+        out << globalCoolDown;
+    else if (name == "ReactDelay")
+        out << reactDelay;
+
+    else if (name == "SightDistance")
+        out << sightDistance;
+    else if (name == "SpellDistance")
+        out << spellDistance;
+    else if (name == "ReactDistance")
+        out << reactDistance;
+    else if (name == "GrindDistance")
+        out << grindDistance;
+    else if (name == "LootDistance")
+        out << lootDistance;
+    else if (name == "FleeDistance")
+        out << fleeDistance;
+
+    else if (name == "CriticalHealth")
+        out << criticalHealth;
+    else if (name == "LowHealth")
+        out << lowHealth;
+    else if (name == "MediumHealth")
+        out << mediumHealth;
+    else if (name == "AlmostFullHealth")
+        out << almostFullHealth;
+    else if (name == "LowMana")
+        out << lowMana;
+
+    else if (name == "IterationsPerTick")
+        out << iterationsPerTick;
+
+    return out.str();
+}
+
+void PlayerbotAIConfig::SetValue(string name, string value)
+{
+    istringstream out(value, istringstream::in);
+
+    if (name == "GlobalCooldown")
+        out >> globalCoolDown;
+    else if (name == "ReactDelay")
+        out >> reactDelay;
+
+    else if (name == "SightDistance")
+        out >> sightDistance;
+    else if (name == "SpellDistance")
+        out >> spellDistance;
+    else if (name == "ReactDistance")
+        out >> reactDistance;
+    else if (name == "GrindDistance")
+        out >> grindDistance;
+    else if (name == "LootDistance")
+        out >> lootDistance;
+    else if (name == "FleeDistance")
+        out >> fleeDistance;
+
+    else if (name == "CriticalHealth")
+        out >> criticalHealth;
+    else if (name == "LowHealth")
+        out >> lowHealth;
+    else if (name == "MediumHealth")
+        out >> mediumHealth;
+    else if (name == "AlmostFullHealth")
+        out >> almostFullHealth;
+    else if (name == "LowMana")
+        out >> lowMana;
+
+    else if (name == "IterationsPerTick")
+        out >> iterationsPerTick;
+}
diff --git a/src/plugins/playerbot/PlayerbotAIConfig.h b/src/plugins/playerbot/PlayerbotAIConfig.h
new file mode 100644
index 0000000..1bbb57d
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIConfig.h
@@ -0,0 +1,82 @@
+#pragma once
+
+#include "../../common/Configuration/Config.h"
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+class PlayerbotAIConfig
+{
+public:
+    PlayerbotAIConfig();
+    static PlayerbotAIConfig& instance()
+    {
+        static PlayerbotAIConfig instance;
+        return instance;
+    }
+
+public:
+    bool Initialize();
+    bool IsInRandomAccountList(uint32 id);
+    bool IsInRandomQuestItemList(uint32 id);
+
+    bool enabled;
+    bool allowGuildBots;
+    uint32 globalCoolDown, reactDelay, maxWaitForMove;
+    float sightDistance, spellDistance, reactDistance, grindDistance, lootDistance,
+        fleeDistance, tooCloseDistance, meleeDistance, followDistance, whisperDistance, contactDistance;
+    uint32 criticalHealth, lowHealth, mediumHealth, almostFullHealth;
+    uint32 lowMana, mediumMana;
+
+    bool randomBotAutologin;
+    std::string randomBotMapsAsString;
+    std::vector<uint32> randomBotMaps;
+    std::list<uint32> randomBotQuestItems;
+    std::list<uint32> randomBotAccounts;
+    std::list<uint32> randomBotSpellIds;
+    uint32 randomBotTeleportDistance;
+    float randomGearLoweringChance;
+    float randomBotMaxLevelChance;
+    uint32 minRandomBots, maxRandomBots;
+    uint32 randomBotUpdateInterval, randomBotCountChangeMinInterval, randomBotCountChangeMaxInterval;
+    uint32 minRandomBotInWorldTime, maxRandomBotInWorldTime;
+    uint32 minRandomBotRandomizeTime, maxRandomBotRandomizeTime;
+    uint32 minRandomBotReviveTime, maxRandomBotReviveTime;
+    uint32 minRandomBotPvpTime, maxRandomBotPvpTime;
+    uint32 minRandomBotsPerInterval, maxRandomBotsPerInterval;
+    uint32 minRandomBotsPriceChangeInterval, maxRandomBotsPriceChangeInterval;
+    bool randomBotJoinLfg;
+    bool randomBotLoginAtStartup;
+    uint32 randomBotTeleLevel;
+    bool logInGroupOnly, logValuesPerTick;
+    bool fleeingEnabled;
+    std::string randomBotCombatStrategies, randomBotNonCombatStrategies;
+    uint32 randomBotMinLevel, randomBotMaxLevel;
+    float randomChangeMultiplier;
+    uint32 specProbability[MAX_CLASSES][3];
+    std::string commandPrefix;
+    std::string randomBotAccountPrefix;
+    uint32 randomBotAccountCount;
+    bool deleteRandomBotAccounts;
+    uint32 randomBotGuildCount;
+    bool deleteRandomBotGuilds;
+    std::list<uint32> randomBotGuilds;
+
+    bool guildTaskEnabled;
+    uint32 minGuildTaskChangeTime, maxGuildTaskChangeTime;
+    uint32 minGuildTaskAdvertisementTime, maxGuildTaskAdvertisementTime;
+    uint32 minGuildTaskRewardTime, maxGuildTaskRewardTime;
+
+    uint32 iterationsPerTick;
+
+    int commandServerPort;
+
+    std::string GetValue(std::string name);
+    void SetValue(std::string name, std::string value);
+
+private:
+    ConfigMgr config;
+};
+
+#define sPlayerbotAIConfig PlayerbotAIConfig::instance()
diff --git a/src/plugins/playerbot/PlayerbotCommandServer.cpp b/src/plugins/playerbot/PlayerbotCommandServer.cpp
new file mode 100644
index 0000000..07aceb2
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotCommandServer.cpp
@@ -0,0 +1,94 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "PlayerbotCommandServer.h"
+#include <cstdlib>
+#include <iostream>
+#include <boost/bind.hpp>
+#include <boost/smart_ptr.hpp>
+#include <boost/asio.hpp>
+#include <boost/thread/thread.hpp>
+
+
+using namespace std;
+using boost::asio::ip::tcp;
+typedef boost::shared_ptr<tcp::socket> socket_ptr;
+
+bool ReadLine(socket_ptr sock, string* buffer, string* line)
+{
+    // Do the real reading from fd until buffer has '\n'.
+    string::iterator pos;
+    while ((pos = find(buffer->begin(), buffer->end(), '\n')) == buffer->end())
+    {
+        char buf[1025];
+        boost::system::error_code error;
+        size_t n = sock->read_some(boost::asio::buffer(buf), error);
+        if (n == -1 || error == boost::asio::error::eof)
+            return false;
+        else if (error)
+            throw boost::system::system_error(error); // Some other error.
+
+        buf[n] = 0;
+        *buffer += buf;
+    }
+
+    *line = string(buffer->begin(), pos);
+    *buffer = string(pos + 1, buffer->end());
+    return true;
+}
+
+void session(socket_ptr sock)
+{
+    try
+    {
+        string buffer, request;
+        while (ReadLine(sock, &buffer, &request)) {
+            string response = sRandomPlayerbotMgr.HandleRemoteCommand(request) + "\n";
+            boost::asio::write(*sock, boost::asio::buffer(response.c_str(), response.size()));
+            request = "";
+        }
+    }
+    catch (std::exception& e)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, e.what());
+    }
+}
+
+void server(boost::asio::io_service& io_service, short port)
+{
+    tcp::acceptor a(io_service, tcp::endpoint(tcp::v4(), port));
+    for (;;)
+    {
+        socket_ptr sock(new tcp::socket(io_service));
+        a.accept(*sock);
+        boost::thread t(boost::bind(session, sock));
+    }
+}
+
+void Run()
+{
+    if (!sPlayerbotAIConfig.commandServerPort) {
+        return;
+    }
+
+    ostringstream s; s << "Starting Playerbot Command Server on port " << sPlayerbotAIConfig.commandServerPort;
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, s.str().c_str());
+
+    try
+    {
+        boost::asio::io_service io_service;
+        server(io_service, sPlayerbotAIConfig.commandServerPort);
+    }
+    catch (std::exception& e)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, e.what());
+    }
+}
+
+
+void PlayerbotCommandServer::Start()
+{
+    thread serverThread(Run);
+    serverThread.detach();
+}
diff --git a/src/plugins/playerbot/PlayerbotCommandServer.h b/src/plugins/playerbot/PlayerbotCommandServer.h
new file mode 100644
index 0000000..0ea66c7
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotCommandServer.h
@@ -0,0 +1,26 @@
+#ifndef _PlayerbotCommandServer_H
+#define _PlayerbotCommandServer_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "PlayerbotMgr.h"
+
+using namespace std;
+
+class PlayerbotCommandServer
+{
+public:
+    PlayerbotCommandServer() {}
+    virtual ~PlayerbotCommandServer() {}
+    static PlayerbotCommandServer& instance()
+    {
+        static PlayerbotCommandServer instance;
+        return instance;
+    }
+
+    void Start();
+};
+
+#define sPlayerbotCommandServer PlayerbotCommandServer::instance()
+
+#endif
diff --git a/src/plugins/playerbot/PlayerbotFactory.cpp b/src/plugins/playerbot/PlayerbotFactory.cpp
new file mode 100644
index 0000000..a5ac3a3
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotFactory.cpp
@@ -0,0 +1,1737 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotFactory.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "../ItemTemplate.h"
+#include "PlayerbotAIConfig.h"
+#include "../../shared/DataStores/DBCStore.h"
+#include "../Miscellaneous/SharedDefines.h"
+#include "../ahbot/AhBot.h"
+#include "../Entities/Pet/Pet.h"
+#include "RandomPlayerbotFactory.h"
+
+using namespace ai;
+using namespace std;
+
+uint32 PlayerbotFactory::tradeSkills[] =
+{
+    SKILL_ALCHEMY,
+    SKILL_ENCHANTING,
+    SKILL_SKINNING,
+    SKILL_JEWELCRAFTING,
+    SKILL_INSCRIPTION,
+    SKILL_TAILORING,
+    SKILL_LEATHERWORKING,
+    SKILL_ENGINEERING,
+    SKILL_HERBALISM,
+    SKILL_MINING,
+    SKILL_BLACKSMITHING,
+    SKILL_COOKING,
+    SKILL_FIRST_AID,
+    SKILL_FISHING
+};
+
+void PlayerbotFactory::Randomize()
+{
+    Randomize(true);
+}
+
+void PlayerbotFactory::Refresh()
+{
+    Prepare();
+    InitEquipment(true);
+    InitAmmo();
+    InitFood();
+    InitPotions();
+
+    uint32 money = urand(level * 1000, level * 5 * 1000);
+    if (bot->GetMoney() < money)
+        bot->SetMoney(money);
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::CleanRandomize()
+{
+    Randomize(false);
+}
+
+void PlayerbotFactory::Prepare()
+{
+    if (!itemQuality)
+    {
+        if (level <= 10)
+            itemQuality = urand(ITEM_QUALITY_NORMAL, ITEM_QUALITY_UNCOMMON);
+        else if (level <= 20)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_RARE);
+        else if (level <= 40)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_EPIC);
+        else if (level < 60)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_EPIC);
+        else
+            itemQuality = urand(ITEM_QUALITY_RARE, ITEM_QUALITY_EPIC);
+    }
+
+    if (bot->isDead())
+        bot->ResurrectPlayer(1.0f, false);
+
+    bot->CombatStop(true);
+    bot->SetLevel(level);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK);
+}
+
+void PlayerbotFactory::Randomize(bool incremental)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Preparing to randomize...");
+    Prepare();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Resetting player...");
+    bot->ResetTalents(true);
+    ClearSpells();
+    ClearInventory();
+    bot->SaveToDB();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing quests...");
+    InitQuests();
+    // quest rewards boost bot level, so reduce back
+    bot->SetLevel(level);
+    ClearInventory();
+    bot->SetUInt32Value(PLAYER_XP, 0);
+    CancelAuras();
+    bot->SaveToDB();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing spells (step 1)...");
+    InitAvailableSpells();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing skills (step 1)...");
+    InitSkills();
+    InitTradeSkills();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing talents...");
+    InitTalents();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing spells (step 2)...");
+    InitAvailableSpells();
+    InitSpecialSpells();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing mounts...");
+    InitMounts();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing skills (step 2)...");
+    UpdateTradeSkills();
+    bot->SaveToDB();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing equipmemt...");
+    InitEquipment(incremental);
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing bags...");
+    InitBags();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing ammo...");
+    InitAmmo();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing food...");
+    InitFood();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing potions...");
+    InitPotions();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing second equipment set...");
+    InitSecondEquipmentSet();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing inventory...");
+    InitInventory();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing glyphs...");
+    InitGlyphs();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing guilds...");
+    InitGuild();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing pet...");
+    InitPet();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Saving to DB...");
+    bot->SetMoney(urand(level * 1000, level * 5 * 1000));
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::InitPet()
+{
+    Pet* pet = bot->GetPet();
+    if (!pet)
+    {
+        if (bot->getClass() != CLASS_HUNTER)
+            return;
+
+        Map* map = bot->GetMap();
+        if (!map)
+            return;
+
+		vector<uint32> ids;
+	    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+	    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+	    {
+	        CreatureTemplate const& co = i->second;
+            if (!co.IsTameable(false))
+                continue;
+
+            if (co.minlevel > bot->getLevel())
+                continue;
+
+			PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co.Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+			ids.push_back(i->first);
+		}
+
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No pets available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+            return;
+        }
+
+		for (int i = 0; i < 100; i++)
+		{
+			int index = urand(0, ids.size() - 1);
+			CreatureTemplate const* co = sObjectMgr->GetCreatureTemplate(ids[index]);
+
+            PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co->Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+            uint32 guid = map->GenerateLowGuid<HighGuid::Pet>();
+            pet = new Pet(bot, HUNTER_PET);
+            if (!pet->Create(guid, map, 0, ids[index], 0))
+            {
+                delete pet;
+                pet = NULL;
+                continue;
+            }
+
+            pet->SetPosition(bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), bot->GetOrientation());
+            pet->setFaction(bot->getFaction());
+            pet->SetLevel(bot->getLevel());
+            bot->SetPetGUID(pet->GetGUID());
+            bot->GetMap()->AddToMap(pet->ToCreature());
+            bot->SetMinion(pet, true);
+            pet->InitTalentForLevel();
+            bot->PetSpellInitialize();
+            bot->InitTamedPet(pet, bot->getLevel(), 0);
+
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "Bot %s: assign pet %d (%d level)", bot->GetName().c_str(), co->Entry, bot->getLevel());
+            pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+            break;
+        }
+    }
+
+    if (!pet)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot create pet for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        if(itr->second.state == PETSPELL_REMOVED)
+            continue;
+
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (spellInfo->IsPassive())
+            continue;
+
+        pet->ToggleAutocast(spellInfo, true);
+    }
+}
+
+void PlayerbotFactory::ClearSpells()
+{
+    list<uint32> spells;
+    for(PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || spellInfo->IsPassive())
+            continue;
+
+        spells.push_back(spellId);
+    }
+
+    for (list<uint32>::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        bot->RemoveSpell(*i, false, false);
+    }
+}
+
+void PlayerbotFactory::InitSpells()
+{
+    for (int i = 0; i < 15; i++)
+        InitAvailableSpells();
+}
+
+void PlayerbotFactory::InitTalents()
+{
+    uint32 point = urand(0, 100);
+    uint8 cls = bot->getClass();
+    uint32 p1 = sPlayerbotAIConfig.specProbability[cls][0];
+    uint32 p2 = p1 + sPlayerbotAIConfig.specProbability[cls][1];
+
+    uint32 specNo = (point < p1 ? 0 : (point < p2 ? 1 : 2));
+    InitTalents(specNo);
+
+    if (bot->GetFreeTalentPoints())
+        InitTalents(2 - specNo);
+}
+
+
+class DestroyItemsVisitor : public IterateItemsVisitor
+{
+public:
+    DestroyItemsVisitor(Player* bot) : IterateItemsVisitor(), bot(bot) {}
+
+    virtual bool Visit(Item* item)
+    {
+        uint32 id = item->GetTemplate()->ItemId;
+        if (CanKeep(id))
+        {
+            keep.insert(id);
+            return true;
+        }
+
+        bot->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+        return true;
+    }
+
+private:
+    bool CanKeep(uint32 id)
+    {
+        if (keep.find(id) != keep.end())
+            return false;
+
+        if (sPlayerbotAIConfig.IsInRandomQuestItemList(id))
+            return true;
+
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(id);
+        if (proto->Class == ITEM_CLASS_MISC && (proto->SubClass == ITEM_SUBCLASS_JUNK_REAGENT || proto->SubClass == ITEM_SUBCLASS_JUNK))
+            return true;
+
+        return false;
+    }
+
+private:
+    Player* bot;
+    set<uint32> keep;
+
+};
+
+bool PlayerbotFactory::CanEquipArmor(ItemTemplate const* proto)
+{
+    if (bot->HasSkill(SKILL_SHIELD) && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        return true;
+
+    if (bot->HasSkill(SKILL_PLATE_MAIL))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
+            return false;
+    }
+    else if (bot->HasSkill(SKILL_MAIL))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
+            return false;
+    }
+    else if (bot->HasSkill(SKILL_LEATHER))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
+            return false;
+    }
+
+    if (proto->Quality <= ITEM_QUALITY_NORMAL)
+        return true;
+
+    uint8 sp = 0, ap = 0, tank = 0;
+    for (int j = 0; j < MAX_ITEM_PROTO_STATS; ++j)
+    {
+        // for ItemStatValue != 0
+        if(!proto->ItemStat[j].ItemStatValue)
+            continue;
+
+        AddItemStats(proto->ItemStat[j].ItemStatType, sp, ap, tank);
+    }
+
+    return CheckItemStats(sp, ap, tank);
+}
+
+bool PlayerbotFactory::CheckItemStats(uint8 sp, uint8 ap, uint8 tank)
+{
+    switch (bot->getClass())
+    {
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+        if (!sp || ap > sp || tank > sp)
+            return false;
+        break;
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+        if ((!ap && !tank) || sp > ap || sp > tank)
+            return false;
+        break;
+    case CLASS_HUNTER:
+    case CLASS_ROGUE:
+        if (!ap || sp > ap || sp > tank)
+            return false;
+        break;
+    }
+
+    return sp || ap || tank;
+}
+
+void PlayerbotFactory::AddItemStats(uint32 mod, uint8 &sp, uint8 &ap, uint8 &tank)
+{
+    switch (mod)
+    {
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_MANA:
+    case ITEM_MOD_INTELLECT:
+    case ITEM_MOD_SPIRIT:
+    case ITEM_MOD_MANA_REGENERATION:
+    case ITEM_MOD_SPELL_POWER:
+    case ITEM_MOD_SPELL_PENETRATION:
+    case ITEM_MOD_HIT_SPELL_RATING:
+    case ITEM_MOD_CRIT_SPELL_RATING:
+    case ITEM_MOD_HASTE_SPELL_RATING:
+        sp++;
+        break;
+    }
+
+    switch (mod)
+    {
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_AGILITY:
+    case ITEM_MOD_STRENGTH:
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_DEFENSE_SKILL_RATING:
+    case ITEM_MOD_DODGE_RATING:
+    case ITEM_MOD_PARRY_RATING:
+    case ITEM_MOD_BLOCK_RATING:
+    case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+    case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+    case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+    case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+    case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+    case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+    case ITEM_MOD_HIT_TAKEN_RATING:
+    case ITEM_MOD_CRIT_TAKEN_RATING:
+    case ITEM_MOD_RESILIENCE_RATING:
+    case ITEM_MOD_BLOCK_VALUE:
+        tank++;
+        break;
+    }
+
+    switch (mod)
+    {
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_AGILITY:
+    case ITEM_MOD_STRENGTH:
+    case ITEM_MOD_HIT_MELEE_RATING:
+    case ITEM_MOD_HIT_RANGED_RATING:
+    case ITEM_MOD_CRIT_MELEE_RATING:
+    case ITEM_MOD_CRIT_RANGED_RATING:
+    case ITEM_MOD_HASTE_MELEE_RATING:
+    case ITEM_MOD_HASTE_RANGED_RATING:
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_EXPERTISE_RATING:
+    case ITEM_MOD_ATTACK_POWER:
+    case ITEM_MOD_RANGED_ATTACK_POWER:
+    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+        ap++;
+        break;
+    }
+}
+
+bool PlayerbotFactory::CanEquipWeapon(ItemTemplate const* proto)
+{
+    switch (bot->getClass())
+    {
+    case CLASS_PRIEST:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE)
+            return false;
+        break;
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+            return false;
+        break;
+    case CLASS_WARRIOR:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_THROWN)
+            return false;
+        break;
+    case CLASS_PALADIN:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+            return false;
+        break;
+    case CLASS_SHAMAN:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+            return false;
+        break;
+    case CLASS_DRUID:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+            return false;
+        break;
+    case CLASS_HUNTER:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_AXE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW)
+            return false;
+        break;
+    case CLASS_ROGUE:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_THROWN)
+            return false;
+        break;
+    }
+
+    return true;
+}
+
+bool PlayerbotFactory::CanEquipItem(ItemTemplate const* proto, uint32 desiredQuality)
+{
+    if (proto->Duration & 0x80000000)
+        return false;
+
+    if (proto->Quality != desiredQuality)
+        return false;
+
+    if (proto->Bonding == BIND_QUEST_ITEM || proto->Bonding == BIND_WHEN_USE)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_CONTAINER)
+        return true;
+
+    uint32 requiredLevel = proto->RequiredLevel;
+    if (!requiredLevel)
+        return false;
+
+    uint32 level = bot->getLevel();
+    uint32 delta = 2;
+    if (level < 15)
+        delta = urand(7, 15);
+    else if (proto->Class == ITEM_CLASS_WEAPON || proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        delta = urand(2, 3);
+    else if (!(level % 10) || (level % 10) == 9)
+        delta = 2;
+    else if (level < 40)
+        delta = urand(5, 10);
+    else if (level < 60)
+        delta = urand(3, 7);
+    else if (level < 70)
+        delta = urand(2, 5);
+    else if (level < 80)
+        delta = urand(2, 4);
+
+    if (desiredQuality > ITEM_QUALITY_NORMAL &&
+            (requiredLevel > level || requiredLevel < level - delta))
+        return false;
+
+    for (uint32 gap = 60; gap <= 80; gap += 10)
+    {
+        if (level > gap && requiredLevel <= gap)
+            return false;
+    }
+
+    return true;
+}
+
+void PlayerbotFactory::InitEquipment(bool incremental)
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor, ITERATE_ALL_ITEMS);
+
+    map<uint8, vector<uint32> > items;
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        if (slot == EQUIPMENT_SLOT_TABARD || slot == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        uint32 desiredQuality = itemQuality;
+        if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+            desiredQuality--;
+        }
+
+        do
+        {
+            ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+            for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+            {
+                uint32 itemId = i->first;
+                ItemTemplate const* proto = &i->second;
+                if (!proto)
+                    continue;
+
+                if (proto->Class != ITEM_CLASS_WEAPON &&
+                    proto->Class != ITEM_CLASS_ARMOR &&
+                    proto->Class != ITEM_CLASS_CONTAINER &&
+                    proto->Class != ITEM_CLASS_PROJECTILE)
+                    continue;
+
+                if (!CanEquipItem(proto, desiredQuality))
+                    continue;
+
+                if (proto->Class == ITEM_CLASS_ARMOR && (
+                    slot == EQUIPMENT_SLOT_HEAD ||
+                    slot == EQUIPMENT_SLOT_SHOULDERS ||
+                    slot == EQUIPMENT_SLOT_CHEST ||
+                    slot == EQUIPMENT_SLOT_WAIST ||
+                    slot == EQUIPMENT_SLOT_LEGS ||
+                    slot == EQUIPMENT_SLOT_FEET ||
+                    slot == EQUIPMENT_SLOT_WRISTS ||
+                    slot == EQUIPMENT_SLOT_HANDS) && !CanEquipArmor(proto))
+                        continue;
+
+                if (proto->Class == ITEM_CLASS_WEAPON && !CanEquipWeapon(proto))
+                    continue;
+
+                if (slot == EQUIPMENT_SLOT_OFFHAND && bot->getClass() == CLASS_ROGUE && proto->Class != ITEM_CLASS_WEAPON)
+                    continue;
+
+                uint16 dest = 0;
+                if (CanEquipUnseenItem(slot, dest, itemId))
+                    items[slot].push_back(itemId);
+            }
+        } while (items[slot].empty() && desiredQuality-- > ITEM_QUALITY_NORMAL);
+    }
+
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        if (slot == EQUIPMENT_SLOT_TABARD || slot == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        vector<uint32>& ids = items[slot];
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no items to equip for slot %d", bot->GetName().c_str(), slot);
+            continue;
+        }
+
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+            Item* oldItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+
+            if (incremental && !IsDesiredReplacement(oldItem)) {
+                continue;
+            }
+
+            uint16 dest;
+            if (!CanEquipUnseenItem(slot, dest, newItemId))
+                continue;
+
+            if (oldItem)
+            {
+                bot->RemoveItem(INVENTORY_SLOT_BAG_0, slot, true);
+                oldItem->DestroyForPlayer(bot, false);
+            }
+
+            Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+            if (newItem)
+            {
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                bot->AutoUnequipOffhandIfNeed();
+                EnchantItem(newItem);
+                break;
+            }
+        }
+    }
+}
+
+bool PlayerbotFactory::IsDesiredReplacement(Item* item)
+{
+    if (!item)
+        return true;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    int delta = 1 + (80 - bot->getLevel()) / 10;
+    return (int)bot->getLevel() - (int)proto->RequiredLevel > delta;
+}
+
+void PlayerbotFactory::InitSecondEquipmentSet()
+{
+    if (bot->getClass() == CLASS_MAGE || bot->getClass() == CLASS_WARLOCK || bot->getClass() == CLASS_PRIEST)
+        return;
+
+    map<uint32, vector<uint32> > items;
+
+    uint32 desiredQuality = itemQuality;
+    while (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+        desiredQuality--;
+    }
+
+    do
+    {
+        ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+        for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+        {
+            uint32 itemId = i->first;
+            ItemTemplate const* proto = &i->second;
+            if (!proto)
+                continue;
+
+            if (!CanEquipItem(proto, desiredQuality))
+                continue;
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (!CanEquipWeapon(proto))
+                    continue;
+
+                Item* existingItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+                if (existingItem)
+                {
+                    switch (existingItem->GetTemplate()->SubClass)
+                    {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD)
+                            continue;
+                        break;
+                    default:
+                        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_AXE && proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                            proto->SubClass != ITEM_SUBCLASS_WEAPON_FIST && proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                            proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+                            continue;
+                        break;
+                    }
+                }
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (!CanEquipArmor(proto))
+                    continue;
+
+                Item* existingItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+                if (existingItem && existingItem->GetTemplate()->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    continue;
+            }
+            else
+                continue;
+
+            items[proto->Class].push_back(itemId);
+        }
+    } while (items[ITEM_CLASS_ARMOR].empty() && items[ITEM_CLASS_WEAPON].empty() && desiredQuality-- > ITEM_QUALITY_NORMAL);
+
+    for (map<uint32, vector<uint32> >::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        vector<uint32>& ids = i->second;
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no items to make second equipment set for slot %d", bot->GetName().c_str(), i->first);
+            continue;
+        }
+
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+
+            ItemPosCountVec sDest;
+            Item* newItem = StoreItem(newItemId, 1);
+            if (newItem)
+            {
+                EnchantItem(newItem);
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotFactory::InitBags()
+{
+    vector<uint32> ids;
+
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto || proto->Class != ITEM_CLASS_CONTAINER)
+            continue;
+
+        if (!CanEquipItem(proto, ITEM_QUALITY_NORMAL))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "%s: no bags found", bot->GetName().c_str());
+        return;
+    }
+
+    for (uint8 slot = INVENTORY_SLOT_BAG_START; slot < INVENTORY_SLOT_BAG_END; ++slot)
+    {
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+
+            uint16 dest;
+            if (!CanEquipUnseenItem(slot, dest, newItemId))
+                continue;
+
+            Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+            if (newItem)
+            {
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotFactory::EnchantItem(Item* item)
+{
+    if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance)
+        return;
+
+    if (bot->getLevel() < urand(40, 50))
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    int32 itemLevel = proto->ItemLevel;
+
+    vector<uint32> ids;
+    for (int id = 0; id < sSpellStore.GetNumRows(); ++id)
+    {
+        SpellInfo const *entry = sSpellMgr->GetSpellInfo(id);
+        if (!entry)
+            continue;
+
+        int32 requiredLevel = (int32)entry->BaseLevel;
+        if (requiredLevel && (requiredLevel > itemLevel || requiredLevel < itemLevel - 35))
+            continue;
+
+        if (entry->MaxLevel && level > entry->MaxLevel)
+            continue;
+
+        uint32 spellLevel = entry->SpellLevel;
+        if (spellLevel && (spellLevel > level || spellLevel < level - 10))
+            continue;
+
+        for (int j = 0; j < 3; ++j)
+        {
+            if (entry->Effects[j].Effect != SPELL_EFFECT_ENCHANT_ITEM)
+                continue;
+
+            uint32 enchant_id = entry->Effects[j].MiscValue;
+            if (!enchant_id)
+                continue;
+
+            SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchant || enchant->slot != PERM_ENCHANTMENT_SLOT)
+                continue;
+
+            if (enchant->requiredLevel && enchant->requiredLevel > level)
+                continue;
+
+            uint8 sp = 0, ap = 0, tank = 0;
+            for (int i = 0; i < 3; ++i)
+            {
+                if (enchant->type[i] != ITEM_ENCHANTMENT_TYPE_STAT)
+                    continue;
+
+                AddItemStats(enchant->spellid[i], sp, ap, tank);
+            }
+
+            if (!CheckItemStats(sp, ap, tank))
+                continue;
+
+            if (enchant->EnchantmentCondition && !bot->EnchantmentFitsRequirements(enchant->EnchantmentCondition, -1))
+                continue;
+
+            if (!item->IsFitToSpellRequirements(entry))
+                continue;
+
+            ids.push_back(enchant_id);
+        }
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no enchantments found for item %d", bot->GetName().c_str(), item->GetTemplate()->ItemId);
+        return;
+    }
+
+    int index = urand(0, ids.size() - 1);
+    uint32 id = ids[index];
+
+    SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(id);
+    if (!enchant)
+        return;
+
+    bot->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+    item->SetEnchantment(PERM_ENCHANTMENT_SLOT, id, 0, 0);
+    bot->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+}
+
+bool PlayerbotFactory::CanEquipUnseenItem(uint8 slot, uint16 &dest, uint32 item)
+{
+    dest = 0;
+    Item *pItem = Item::CreateItem(item, 1, bot);
+    if (pItem)
+    {
+        InventoryResult result = bot->CanEquipItem(slot, dest, pItem, true, false);
+        pItem->RemoveFromUpdateQueueOf(bot);
+        delete pItem;
+        return result == EQUIP_ERR_OK;
+    }
+
+    return false;
+}
+
+void PlayerbotFactory::InitTradeSkills()
+{
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+
+    vector<uint32> firstSkills;
+    vector<uint32> secondSkills;
+    switch (bot->getClass())
+    {
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+        firstSkills.push_back(SKILL_MINING);
+        secondSkills.push_back(SKILL_BLACKSMITHING);
+        secondSkills.push_back(SKILL_ENGINEERING);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_DRUID:
+    case CLASS_HUNTER:
+    case CLASS_ROGUE:
+        firstSkills.push_back(SKILL_SKINNING);
+        secondSkills.push_back(SKILL_LEATHERWORKING);
+        break;
+    default:
+        firstSkills.push_back(SKILL_TAILORING);
+        secondSkills.push_back(SKILL_ENCHANTING);
+    }
+
+    SetRandomSkill(SKILL_FIRST_AID);
+    SetRandomSkill(SKILL_FISHING);
+    SetRandomSkill(SKILL_COOKING);
+
+    switch (urand(0, 3))
+    {
+    case 0:
+        SetRandomSkill(SKILL_HERBALISM);
+        SetRandomSkill(SKILL_ALCHEMY);
+        break;
+    case 1:
+        SetRandomSkill(SKILL_HERBALISM);
+        SetRandomSkill(SKILL_INSCRIPTION);
+        break;
+    case 2:
+        SetRandomSkill(SKILL_MINING);
+        SetRandomSkill(SKILL_JEWELCRAFTING);
+        break;
+    case 3:
+        SetRandomSkill(firstSkills[urand(0, firstSkills.size() - 1)]);
+        SetRandomSkill(secondSkills[urand(0, secondSkills.size() - 1)]);
+        break;
+    }
+}
+
+void PlayerbotFactory::UpdateTradeSkills()
+{
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        if (bot->GetSkillValue(tradeSkills[i]) == 1)
+            bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+}
+
+void PlayerbotFactory::InitSkills()
+{
+    uint32 maxValue = level * 5;
+    SetRandomSkill(SKILL_DEFENSE);
+    SetRandomSkill(SKILL_SWORDS);
+    SetRandomSkill(SKILL_AXES);
+    SetRandomSkill(SKILL_BOWS);
+    SetRandomSkill(SKILL_GUNS);
+    SetRandomSkill(SKILL_MACES);
+    SetRandomSkill(SKILL_2H_SWORDS);
+    SetRandomSkill(SKILL_STAVES);
+    SetRandomSkill(SKILL_2H_MACES);
+    SetRandomSkill(SKILL_2H_AXES);
+    SetRandomSkill(SKILL_DAGGERS);
+    SetRandomSkill(SKILL_THROWN);
+    SetRandomSkill(SKILL_CROSSBOWS);
+    SetRandomSkill(SKILL_WANDS);
+    SetRandomSkill(SKILL_POLEARMS);
+    SetRandomSkill(SKILL_FIST_WEAPONS);
+
+    if (bot->getLevel() >= 70)
+        bot->SetSkill(SKILL_RIDING, 0, 300, 300);
+    else if (bot->getLevel() >= 60)
+        bot->SetSkill(SKILL_RIDING, 0, 225, 225);
+    else if (bot->getLevel() >= 40)
+        bot->SetSkill(SKILL_RIDING, 0, 150, 150);
+    else if (bot->getLevel() >= 20)
+        bot->SetSkill(SKILL_RIDING, 0, 75, 75);
+    else
+        bot->SetSkill(SKILL_RIDING, 0, 0, 0);
+
+    uint32 skillLevel = bot->getLevel() < 40 ? 0 : 1;
+    switch (bot->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+        bot->SetSkill(SKILL_PLATE_MAIL, 0, skillLevel, skillLevel);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_HUNTER:
+        bot->SetSkill(SKILL_MAIL, 0, skillLevel, skillLevel);
+    }
+}
+
+void PlayerbotFactory::SetRandomSkill(uint16 id)
+{
+    uint32 maxValue = level * 5;
+    uint32 curValue = urand(maxValue - level, maxValue);
+    bot->SetSkill(id, 0, curValue, maxValue);
+
+}
+
+void PlayerbotFactory::InitAvailableSpells()
+{
+    bot->LearnDefaultSkills();
+
+    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+    {
+        CreatureTemplate const& co = i->second;
+        if (co.trainer_type != TRAINER_TYPE_TRADESKILLS && co.trainer_type != TRAINER_TYPE_CLASS)
+            continue;
+
+        if (co.trainer_type == TRAINER_TYPE_CLASS && co.trainer_class != bot->getClass())
+            continue;
+
+		uint32 trainerId = co.Entry;
+
+		TrainerSpellData const* trainer_spells = sObjectMgr->GetNpcTrainerSpells(trainerId);
+        if (!trainer_spells)
+            trainer_spells = sObjectMgr->GetNpcTrainerSpells(trainerId);
+
+        if (!trainer_spells)
+            continue;
+
+        for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+        {
+            TrainerSpell const* tSpell = &itr->second;
+
+            if (!tSpell)
+                continue;
+
+            if (!tSpell->learnedSpell[0] && !bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+                continue;
+
+            TrainerSpellState state = bot->GetTrainerSpellState(tSpell);
+            if (state != TRAINER_SPELL_GREEN)
+                continue;
+
+            if (tSpell->learnedSpell)
+                bot->LearnSpell(tSpell->learnedSpell[0], false);
+            else
+                ai->CastSpell(tSpell->spell, bot);
+        }
+    }
+}
+
+void PlayerbotFactory::InitSpecialSpells()
+{
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotSpellIds.begin(); i != sPlayerbotAIConfig.randomBotSpellIds.end(); ++i)
+    {
+        uint32 spellId = *i;
+        bot->LearnSpell(spellId, false);
+    }
+}
+
+void PlayerbotFactory::InitTalents(uint32 specNo)
+{
+    uint32 classMask = bot->getClassMask();
+
+    map<uint32, vector<TalentEntry const*> > spells;
+    for (uint32 i = 0; i < sTalentStore.GetNumRows(); ++i)
+    {
+        TalentEntry const *talentInfo = sTalentStore.LookupEntry(i);
+        if(!talentInfo)
+            continue;
+
+        TalentTabEntry const *talentTabInfo = sTalentTabStore.LookupEntry( talentInfo->TalentTab );
+        if(!talentTabInfo || talentTabInfo->tabpage != specNo)
+            continue;
+
+        if( (classMask & talentTabInfo->ClassMask) == 0 )
+            continue;
+
+        spells[talentInfo->Row].push_back(talentInfo);
+    }
+
+    uint32 freePoints = bot->GetFreeTalentPoints();
+    for (map<uint32, vector<TalentEntry const*> >::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        vector<TalentEntry const*> &spells = i->second;
+        if (spells.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "%s: No spells for talent row %d", bot->GetName().c_str(), i->first);
+            continue;
+        }
+
+        int attemptCount = 0;
+        while (!spells.empty() && (int)freePoints - (int)bot->GetFreeTalentPoints() < 5 && attemptCount++ < 3 && bot->GetFreeTalentPoints())
+        {
+            int index = urand(0, spells.size() - 1);
+            TalentEntry const *talentInfo = spells[index];
+            int maxRank = 0;
+            for (int rank = 0; rank < min((uint32)MAX_TALENT_RANK, bot->GetFreeTalentPoints()); ++rank)
+            {
+                uint32 spellId = talentInfo->RankID[rank];
+                if (!spellId)
+                    continue;
+
+                maxRank = rank;
+            }
+
+            bot->LearnTalent(talentInfo->TalentID, maxRank);
+			spells.erase(spells.begin() + index);
+        }
+
+        freePoints = bot->GetFreeTalentPoints();
+    }
+
+    for (uint32 i = 0; i < MAX_TALENT_SPECS; ++i)
+    {
+        for (PlayerTalentMap::iterator itr = bot->GetTalentMap(i).begin(); itr != bot->GetTalentMap(i).end(); ++itr)
+        {
+            if (itr->second->state != PLAYERSPELL_REMOVED)
+                itr->second->state = PLAYERSPELL_CHANGED;
+        }
+    }
+}
+
+ObjectGuid PlayerbotFactory::GetRandomBot()
+{
+    vector<ObjectGuid> guids;
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            ObjectGuid guid = ObjectGuid(HighGuid::Player, fields[0].GetUInt32());
+            if (!sObjectMgr->GetPlayerByLowGUID(guid))
+                guids.push_back(guid);
+        } while (result->NextRow());
+    }
+
+    if (guids.empty())
+        return ObjectGuid();
+
+    int index = urand(0, guids.size() - 1);
+    return guids[index];
+}
+
+void AddPrevQuests(uint32 questId, list<uint32>& questIds)
+{
+    Quest const *quest = sObjectMgr->GetQuestTemplate(questId);
+    for (Quest::PrevQuests::const_iterator iter = quest->prevQuests.begin(); iter != quest->prevQuests.end(); ++iter)
+    {
+        uint32 prevId = abs(*iter);
+        AddPrevQuests(prevId, questIds);
+        questIds.push_back(prevId);
+    }
+}
+
+void PlayerbotFactory::InitQuests()
+{
+    ObjectMgr::QuestMap const& questTemplates = sObjectMgr->GetQuestTemplates();
+    list<uint32> questIds;
+    for (ObjectMgr::QuestMap::const_iterator i = questTemplates.begin(); i != questTemplates.end(); ++i)
+    {
+        uint32 questId = i->first;
+        Quest const *quest = i->second;
+
+        if (!quest->GetRequiredClasses() ||
+                quest->GetMinLevel() > bot->getLevel() ||
+                quest->IsDailyOrWeekly() || quest->IsRepeatable() || quest->IsMonthly())
+            continue;
+
+        AddPrevQuests(questId, questIds);
+        questIds.push_back(questId);
+    }
+
+    for (list<uint32>::iterator i = questIds.begin(); i != questIds.end(); ++i)
+    {
+        uint32 questId = *i;
+        Quest const *quest = sObjectMgr->GetQuestTemplate(questId);
+
+        if (!bot->SatisfyQuestClass(quest, false) ||
+                !bot->SatisfyQuestRace(quest, false))
+            continue;
+
+        bot->RemoveActiveQuest(questId, false);
+        bot->RemoveRewardedQuest(questId, false);
+
+        bot->SetQuestStatus(questId, QUEST_STATUS_COMPLETE);
+        bot->RewardQuest(quest, 0, bot, false);
+        ClearInventory();
+    }
+}
+
+void PlayerbotFactory::ClearInventory()
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor);
+}
+
+void PlayerbotFactory::InitAmmo()
+{
+    if (bot->getClass() != CLASS_HUNTER && bot->getClass() != CLASS_ROGUE && bot->getClass() != CLASS_WARRIOR)
+        return;
+
+    Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
+    if (!pItem)
+        return;
+
+    uint32 subClass = 0;
+    switch (pItem->GetTemplate()->SubClass)
+    {
+    case ITEM_SUBCLASS_WEAPON_GUN:
+        subClass = ITEM_SUBCLASS_BULLET;
+        break;
+    case ITEM_SUBCLASS_WEAPON_BOW:
+    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+        subClass = ITEM_SUBCLASS_ARROW;
+        break;
+    }
+
+    if (!subClass)
+        return;
+
+    QueryResult results = WorldDatabase.PQuery("select max(entry), max(RequiredLevel) from item_template where class = '%u' and subclass = '%u' and RequiredLevel <= '%u'",
+            ITEM_CLASS_PROJECTILE, subClass, bot->getLevel());
+
+    Field* fields = results->Fetch();
+    if (fields)
+    {
+        uint32 entry = fields[0].GetUInt32();
+        for (int i = 0; i < 5; i++)
+        {
+            bot->StoreNewItemInBestSlots(entry, 1000);
+        }
+        bot->SetAmmo(entry);
+    }
+}
+
+void PlayerbotFactory::InitMounts()
+{
+    map<uint32, map<int32, vector<uint32> > > allSpells;
+
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); ++spellId)
+    {
+        SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo || spellInfo->Effects[0].ApplyAuraName != SPELL_AURA_MOUNTED)
+            continue;
+
+        if (spellInfo->GetDuration() != -1)
+            continue;
+
+        int32 effect = max(spellInfo->Effects[1].BasePoints, spellInfo->Effects[2].BasePoints);
+        if (effect < 50)
+            continue;
+
+        uint32 index = (spellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS ||
+                spellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS) ? 1 : 0;
+        allSpells[index][effect].push_back(spellId);
+    }
+
+    for (uint32 type = 0; type < 2; ++type)
+    {
+        map<int32, vector<uint32> >& spells = allSpells[type];
+        for (map<int32, vector<uint32> >::iterator i = spells.begin(); i != spells.end(); ++i)
+        {
+            int32 effect = i->first;
+            vector<uint32>& ids = i->second;
+            uint32 index = urand(0, ids.size() - 1);
+            if (index >= ids.size())
+                continue;
+
+            bot->LearnSpell(ids[index], false);
+        }
+    }
+}
+
+void PlayerbotFactory::InitPotions()
+{
+    map<uint32, vector<uint32> > items;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE ||
+            proto->SubClass != ITEM_SUBCLASS_POTION ||
+            proto->Spells[0].SpellCategory != 4 ||
+            proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        if (proto->Area || proto->Map || proto->RequiredCityRank || proto->RequiredHonorRank)
+            continue;
+
+        for (int j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+        {
+            const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[j].SpellId);
+            if (!spellInfo)
+                continue;
+
+            for (int i = 0 ; i < 3; i++)
+            {
+                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_HEAL || spellInfo->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)
+                {
+                    items[spellInfo->Effects[i].Effect].push_back(itemId);
+                    break;
+                }
+            }
+        }
+    }
+
+    uint32 effects[] = { SPELL_EFFECT_HEAL, SPELL_EFFECT_ENERGIZE };
+    for (int i = 0; i < sizeof(effects) / sizeof(uint32); ++i)
+    {
+        uint32 effect = effects[i];
+        vector<uint32>& ids = items[effect];
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        bot->StoreNewItemInBestSlots(itemId, urand(1, proto->GetMaxStackSize()));
+   }
+}
+
+void PlayerbotFactory::InitFood()
+{
+    map<uint32, vector<uint32> > items;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE ||
+            proto->SubClass != ITEM_SUBCLASS_FOOD ||
+            (proto->Spells[0].SpellCategory != 11 && proto->Spells[0].SpellCategory != 59) ||
+            proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        if (proto->Area || proto->Map || proto->RequiredCityRank || proto->RequiredHonorRank)
+            continue;
+
+        items[proto->Spells[0].SpellCategory].push_back(itemId);
+    }
+
+    uint32 categories[] = { 11, 59 };
+    for (int i = 0; i < sizeof(categories) / sizeof(uint32); ++i)
+    {
+        uint32 category = categories[i];
+        vector<uint32>& ids = items[category];
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        bot->StoreNewItemInBestSlots(itemId, urand(1, proto->GetMaxStackSize()));
+   }
+}
+
+
+void PlayerbotFactory::CancelAuras()
+{
+    bot->RemoveAllAuras();
+}
+
+void PlayerbotFactory::InitInventory()
+{
+    InitInventoryTrade();
+    InitInventoryEquip();
+    InitInventorySkill();
+}
+
+void PlayerbotFactory::InitInventorySkill()
+{
+    if (bot->HasSkill(SKILL_MINING)) {
+        StoreItem(2901, 1); // Mining Pick
+    }
+    if (bot->HasSkill(SKILL_JEWELCRAFTING)) {
+        StoreItem(20815, 1); // Jeweler's Kit
+        StoreItem(20824, 1); // Simple Grinder
+    }
+    if (bot->HasSkill(SKILL_BLACKSMITHING) || bot->HasSkill(SKILL_ENGINEERING)) {
+        StoreItem(5956, 1); // Blacksmith Hammer
+    }
+    if (bot->HasSkill(SKILL_ENGINEERING)) {
+        StoreItem(6219, 1); // Arclight Spanner
+    }
+    if (bot->HasSkill(SKILL_ENCHANTING)) {
+        StoreItem(44452, 1); // Runed Titanium Rod
+    }
+    if (bot->HasSkill(SKILL_INSCRIPTION)) {
+        StoreItem(39505, 1); // Virtuoso Inking Set
+    }
+    if (bot->HasSkill(SKILL_SKINNING)) {
+        StoreItem(7005, 1); // Skinning Knife
+    }
+}
+
+Item* PlayerbotFactory::StoreItem(uint32 itemId, uint32 count)
+{
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    ItemPosCountVec sDest;
+    InventoryResult msg = bot->CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, itemId, count);
+    if (msg != EQUIP_ERR_OK)
+        return NULL;
+
+    return bot->StoreNewItem(sDest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+}
+
+void PlayerbotFactory::InitInventoryTrade()
+{
+    vector<uint32> ids;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_TRADE_GOODS || proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->ItemLevel < bot->getLevel())
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No trade items available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+        return;
+    }
+
+    uint32 index = urand(0, ids.size() - 1);
+    if (index >= ids.size())
+        return;
+
+    uint32 itemId = ids[index];
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    uint32 count = 1, stacks = 1;
+    switch (proto->Quality)
+    {
+    case ITEM_QUALITY_NORMAL:
+        count = proto->GetMaxStackSize();
+        stacks = urand(1, 7) / auctionbot.GetRarityPriceMultiplier(proto);
+        break;
+    case ITEM_QUALITY_UNCOMMON:
+        stacks = 1;
+        count = urand(1, proto->GetMaxStackSize());
+        break;
+    case ITEM_QUALITY_RARE:
+        stacks = 1;
+        count = urand(1, min(uint32(3), proto->GetMaxStackSize()));
+        break;
+    }
+
+    for (uint32 i = 0; i < stacks; i++)
+        StoreItem(itemId, count);
+}
+
+void PlayerbotFactory::InitInventoryEquip()
+{
+    vector<uint32> ids;
+
+    uint32 desiredQuality = itemQuality;
+    if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+        desiredQuality--;
+    }
+
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_ARMOR && proto->Class != ITEM_CLASS_WEAPON || (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_WHEN_USE))
+            continue;
+
+        if (proto->Class == ITEM_CLASS_ARMOR && !CanEquipArmor(proto))
+            continue;
+
+        if (proto->Class == ITEM_CLASS_WEAPON && !CanEquipWeapon(proto))
+            continue;
+
+        if (!CanEquipItem(proto, desiredQuality))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    int maxCount = urand(0, 3);
+    int count = 0;
+    for (int attempts = 0; attempts < 15; attempts++)
+    {
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        if (StoreItem(itemId, 1) && count++ >= maxCount)
+            break;
+   }
+}
+
+void PlayerbotFactory::InitGlyphs()
+{
+    bot->InitGlyphsForLevel();
+
+    for (uint32 slotIndex = 0; slotIndex < MAX_GLYPH_SLOT_INDEX; ++slotIndex)
+    {
+        bot->SetGlyph(slotIndex, 0);
+    }
+
+    uint32 level = bot->getLevel();
+    uint32 maxSlot = 0;
+    if (level >= 15)
+        maxSlot = 2;
+    if (level >= 30)
+        maxSlot = 3;
+    if (level >= 50)
+        maxSlot = 4;
+    if (level >= 70)
+        maxSlot = 5;
+    if (level >= 80)
+        maxSlot = 6;
+
+    if (!maxSlot)
+        return;
+
+    list<uint32> glyphs;
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_GLYPH)
+            continue;
+
+        if ((proto->AllowableClass & bot->getClassMask()) == 0 || (proto->AllowableRace & bot->getRaceMask()) == 0)
+            continue;
+
+        for (uint32 spell = 0; spell < MAX_ITEM_PROTO_SPELLS; spell++)
+        {
+            uint32 spellId = proto->Spells[spell].SpellId;
+            SpellInfo const *entry = sSpellMgr->GetSpellInfo(spellId);
+            if (!entry)
+                continue;
+
+            for (uint32 effect = 0; effect <= EFFECT_2; ++effect)
+            {
+                if (entry->Effects[effect].Effect != SPELL_EFFECT_APPLY_GLYPH)
+                    continue;
+
+                uint32 glyph = entry->Effects[effect].MiscValue;
+                glyphs.push_back(glyph);
+            }
+        }
+    }
+
+    if (glyphs.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No glyphs found for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    set<uint32> chosen;
+    for (uint32 slotIndex = 0; slotIndex < maxSlot; ++slotIndex)
+    {
+        uint32 slot = bot->GetGlyphSlot(slotIndex);
+        GlyphSlotEntry const *gs = sGlyphSlotStore.LookupEntry(slot);
+        if (!gs)
+            continue;
+
+        vector<uint32> ids;
+        for (list<uint32>::iterator i = glyphs.begin(); i != glyphs.end(); ++i)
+        {
+            uint32 id = *i;
+            GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(id);
+            if (!gp || gp->TypeFlags != gs->TypeFlags)
+                continue;
+
+            ids.push_back(id);
+        }
+
+        int maxCount = urand(0, 3);
+        int count = 0;
+        bool found = false;
+        for (int attempts = 0; attempts < 15; ++attempts)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            if (index >= ids.size())
+                continue;
+
+            uint32 id = ids[index];
+            if (chosen.find(id) != chosen.end())
+                continue;
+
+            chosen.insert(id);
+
+            bot->SetGlyph(slotIndex, id);
+            found = true;
+            break;
+        }
+        if (!found)
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No glyphs found for bot %s index %d slot %d", bot->GetName().c_str(), slotIndex, slot);
+    }
+}
+
+void PlayerbotFactory::InitGuild()
+{
+    if (bot->GetGuildId())
+        return;
+
+    if (sPlayerbotAIConfig.randomBotGuilds.empty())
+        RandomPlayerbotFactory::CreateRandomGuilds();
+
+    vector<uint32> guilds;
+    for(list<uint32>::iterator i = sPlayerbotAIConfig.randomBotGuilds.begin(); i != sPlayerbotAIConfig.randomBotGuilds.end(); ++i)
+        guilds.push_back(*i);
+
+    if (guilds.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No random guilds available");
+        return;
+    }
+
+    int index = urand(0, guilds.size() - 1);
+    uint32 guildId = guilds[index];
+    Guild* guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Invalid guild %u", guildId);
+        return;
+    }
+
+    if (guild->GetMemberCount() < 10)
+        guild->AddMember(bot->GetGUID(), urand(GR_OFFICER, GR_INITIATE));
+}
diff --git a/src/plugins/playerbot/PlayerbotFactory.h b/src/plugins/playerbot/PlayerbotFactory.h
new file mode 100644
index 0000000..e9535f0
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotFactory.h
@@ -0,0 +1,68 @@
+#pragma once
+
+#include "strategy/actions/InventoryAction.h"
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+using ai::InventoryAction;
+
+class PlayerbotFactory : public InventoryAction
+{
+public:
+    PlayerbotFactory(Player* bot, uint32 level, uint32 itemQuality = 0) :
+        bot(bot), level(level), itemQuality(itemQuality), InventoryAction(bot->GetPlayerbotAI(), "factory") {}
+
+    static ObjectGuid GetRandomBot();
+    void CleanRandomize();
+    void Randomize();
+    void Refresh();
+
+private:
+    void Randomize(bool incremental);
+    void Prepare();
+    void InitSecondEquipmentSet();
+    void InitEquipment(bool incremental);
+    bool CanEquipItem(ItemTemplate const* proto, uint32 desiredQuality);
+    bool CanEquipUnseenItem(uint8 slot, uint16 &dest, uint32 item);
+    void InitSkills();
+    void InitTradeSkills();
+    void UpdateTradeSkills();
+    void SetRandomSkill(uint16 id);
+    void InitSpells();
+    void ClearSpells();
+    void InitAvailableSpells();
+    void InitSpecialSpells();
+    void InitTalents();
+    void InitTalents(uint32 specNo);
+    void InitQuests();
+    void InitPet();
+    void ClearInventory();
+    void InitAmmo();
+    void InitMounts();
+    void InitPotions();
+    void InitFood();
+    bool CanEquipArmor(ItemTemplate const* proto);
+    bool CanEquipWeapon(ItemTemplate const* proto);
+    void EnchantItem(Item* item);
+    void AddItemStats(uint32 mod, uint8 &sp, uint8 &ap, uint8 &tank);
+    bool CheckItemStats(uint8 sp, uint8 ap, uint8 tank);
+    void CancelAuras();
+    bool IsDesiredReplacement(Item* item);
+    void InitBags();
+    void InitInventory();
+    void InitInventoryTrade();
+    void InitInventoryEquip();
+    void InitInventorySkill();
+    Item* StoreItem(uint32 itemId, uint32 count);
+    void InitGlyphs();
+    void InitGuild();
+
+private:
+    Player* bot;
+    uint32 level;
+    uint32 itemQuality;
+    static uint32 tradeSkills[];
+};
diff --git a/src/plugins/playerbot/PlayerbotMgr.cpp b/src/plugins/playerbot/PlayerbotMgr.cpp
new file mode 100644
index 0000000..945764f
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotMgr.cpp
@@ -0,0 +1,472 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "RandomPlayerbotMgr.h"
+
+
+class LoginQueryHolder;
+class CharacterHandler;
+
+PlayerbotHolder::PlayerbotHolder() : PlayerbotAIBase()
+{
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); spellId++)
+        sSpellStore.LookupEntry(spellId);
+}
+
+PlayerbotHolder::~PlayerbotHolder()
+{
+    LogoutAllBots();
+}
+
+
+void PlayerbotHolder::UpdateAIInternal(uint32 elapsed)
+{
+}
+
+void PlayerbotHolder::UpdateSessions(uint32 elapsed)
+{
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+    {
+        Player* const bot = itr->second;
+        if (bot->IsBeingTeleported())
+        {
+            bot->GetPlayerbotAI()->HandleTeleportAck();
+        }
+        else if (bot->IsInWorld())
+        {
+            bot->GetSession()->HandleBotPackets();
+        }
+    }
+}
+
+void PlayerbotHolder::LogoutAllBots()
+{
+    while (true)
+    {
+        PlayerBotMap::const_iterator itr = GetPlayerBotsBegin();
+        if (itr == GetPlayerBotsEnd()) break;
+        Player* bot= itr->second;
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
+void PlayerbotHolder::LogoutPlayerBot(uint64 guid)
+{
+    Player* bot = GetPlayerBot(guid);
+    if (bot)
+    {
+        bot->GetPlayerbotAI()->TellMaster("Goodbye!");
+        //bot->SaveToDB();
+
+        WorldSession * botWorldSessionPtr = bot->GetSession();
+        playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(true); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+Player* PlayerbotHolder::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = playerBots.find(playerGuid);
+    return (it == playerBots.end()) ? 0 : it->second;
+}
+
+void PlayerbotHolder::OnBotLogin(Player * const bot)
+{
+	PlayerbotAI* ai = new PlayerbotAI(bot);
+	bot->SetPlayerbotAI(ai);
+	OnBotLoginInternal(bot);
+
+    playerBots[bot->GetGUID()] = bot;
+
+    Player* master = ai->GetMaster();
+    if (master)
+    {
+        ObjectGuid masterGuid = master->GetGUID();
+        if (master->GetGroup() &&
+            ! master->GetGroup()->IsLeader(masterGuid))
+            master->GetGroup()->ChangeLeader(masterGuid);
+    }
+
+    Group *group = bot->GetGroup();
+    if (group)
+    {
+        bool groupValid = false;
+        Group::MemberSlotList const& slots = group->GetMemberSlots();
+        for (Group::MemberSlotList::const_iterator i = slots.begin(); i != slots.end(); ++i)
+        {
+            ObjectGuid member = i->guid;
+            uint32 account = sObjectMgr->GetPlayerAccountIdByGUID(member);
+            if (!sPlayerbotAIConfig.IsInRandomAccountList(account))
+            {
+                groupValid = true;
+                break;
+            }
+        }
+
+        if (!groupValid)
+        {
+            WorldPacket p;
+            string member = bot->GetName();
+            p << uint32(PARTY_OP_LEAVE) << member << uint32(0);
+            bot->GetSession()->HandleGroupDisbandOpcode(p);
+        }
+    }
+
+    ai->ResetStrategies();
+    ai->TellMaster("Hello!");
+}
+
+string PlayerbotHolder::ProcessBotCommand(string cmd, ObjectGuid guid, bool admin, uint32 masterAccountId, uint32 masterGuildId)
+{
+    if (!sPlayerbotAIConfig.enabled || guid.IsEmpty())
+        return "bot system is disabled";
+
+    uint32 botAccount = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    bool isRandomBot = sRandomPlayerbotMgr.IsRandomBot(guid);
+    bool isRandomAccount = sPlayerbotAIConfig.IsInRandomAccountList(botAccount);
+    bool isMasterAccount = (masterAccountId == botAccount);
+
+    if (isRandomAccount && !isRandomBot && !admin)
+    {
+        Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (bot->GetGuildId() != masterGuildId)
+            return "not in your guild";
+    }
+
+    if (!isRandomAccount && !isMasterAccount && !admin)
+        return "not in your account";
+
+    if (cmd == "add" || cmd == "login")
+    {
+        if (sObjectMgr->GetPlayerByLowGUID(guid))
+            return "player already logged in";
+
+        AddPlayerBot(guid.GetRawValue(), masterAccountId);
+        return "ok";
+    }
+    else if (cmd == "remove" || cmd == "logout" || cmd == "rm")
+    {
+        if (!sObjectMgr->GetPlayerByLowGUID(guid))
+            return "player is offline";
+
+        if (!GetPlayerBot(guid.GetRawValue()))
+            return "not your bot";
+
+        LogoutPlayerBot(guid.GetRawValue());
+        return "ok";
+    }
+
+    if (admin)
+    {
+        Player* bot = GetPlayerBot(guid.GetRawValue());
+        if (!bot)
+            return "bot not found";
+
+        Player* master = bot->GetPlayerbotAI()->GetMaster();
+        if (master)
+        {
+            if (cmd == "init=white" || cmd == "init=common")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_NORMAL);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=green" || cmd == "init=uncommon")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_UNCOMMON);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=blue" || cmd == "init=rare")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_RARE);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=epic" || cmd == "init=purple")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_EPIC);
+                factory.CleanRandomize();
+                return "ok";
+            }
+        }
+
+        if (cmd == "update")
+        {
+            PlayerbotFactory factory(bot, bot->getLevel());
+            factory.Refresh();
+            return "ok";
+        }
+        else if (cmd == "random")
+        {
+            sRandomPlayerbotMgr.Randomize(bot);
+            return "ok";
+        }
+    }
+
+    return "unknown command";
+}
+
+bool PlayerbotMgr::HandlePlayerbotMgrCommand(ChatHandler* handler, char const* args)
+{
+	if (!sPlayerbotAIConfig.enabled)
+	{
+		handler->PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
+		handler->SetSentErrorMessage(true);
+        return false;
+	}
+
+    WorldSession *m_session = handler->GetSession();
+
+    if (!m_session)
+    {
+        handler->PSendSysMessage("You may only add bots from an active session");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    Player* player = m_session->GetPlayer();
+    PlayerbotMgr* mgr = player->GetPlayerbotMgr();
+    if (!mgr)
+    {
+        handler->PSendSysMessage("you cannot control bots yet");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    list<string> messages = mgr->HandlePlayerbotCommand(args, player);
+    if (messages.empty())
+        return true;
+
+    for (list<string>::iterator i = messages.begin(); i != messages.end(); ++i)
+    {
+        handler->PSendSysMessage(i->c_str());
+    }
+
+    handler->SetSentErrorMessage(true);
+    return false;
+}
+
+list<string> PlayerbotHolder::HandlePlayerbotCommand(char const* args, Player* master)
+{
+    list<string> messages;
+
+    if (!*args)
+    {
+        messages.push_back("usage: add/init/remove PLAYERNAME");
+        return messages;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if (!cmd || !charname)
+    {
+        messages.push_back("usage: add/init/remove PLAYERNAME");
+        return messages;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    set<string> bots;
+    if (charnameStr == "*" && master)
+    {
+        Group* group = master->GetGroup();
+        if (!group)
+        {
+            messages.push_back("you must be in group");
+            return messages;
+        }
+
+        Group::MemberSlotList slots = group->GetMemberSlots();
+        for (Group::member_citerator i = slots.begin(); i != slots.end(); i++)
+        {
+			ObjectGuid member = i->guid;
+
+			if (member == master->GetGUID())
+				continue;
+
+			string bot;
+			if (sObjectMgr->GetPlayerNameByGUID(member, bot))
+			    bots.insert(bot);
+        }
+    }
+
+    if (charnameStr == "!" && master && master->GetSession()->GetSecurity() > SEC_GAMEMASTER)
+    {
+        for (PlayerBotMap::const_iterator i = GetPlayerBotsBegin(); i != GetPlayerBotsEnd(); ++i)
+        {
+            Player* bot = i->second;
+            if (bot && bot->IsInWorld())
+                bots.insert(bot->GetName());
+        }
+    }
+
+    vector<string> chars = split(charnameStr, ',');
+    for (vector<string>::iterator i = chars.begin(); i != chars.end(); i++)
+    {
+        string s = *i;
+
+        uint32 accountId = GetAccountId(s);
+        if (!accountId)
+        {
+            bots.insert(s);
+            continue;
+        }
+
+        QueryResult results = CharacterDatabase.PQuery(
+            "SELECT name FROM characters WHERE account = '%u'",
+            accountId);
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                string charName = fields[0].GetString();
+                bots.insert(charName);
+            } while (results->NextRow());
+        }
+	}
+
+    for (set<string>::iterator i = bots.begin(); i != bots.end(); ++i)
+    {
+        string bot = *i;
+        ostringstream out;
+        out << cmdStr << ": " << bot << " - ";
+
+        ObjectGuid member = sObjectMgr->GetPlayerGUIDByName(bot);
+        if (!member)
+        {
+            out << "character not found";
+        }
+        else if (master && member != master->GetGUID())
+        {
+            out << ProcessBotCommand(cmdStr, member,
+                    master->GetSession()->GetSecurity() >= SEC_GAMEMASTER,
+                    master->GetSession()->GetAccountId(),
+                    master->GetGuildId());
+        }
+        else if (!master)
+        {
+            out << ProcessBotCommand(cmdStr, member, true, -1, -1);
+        }
+
+        messages.push_back(out.str());
+    }
+
+    return messages;
+}
+
+uint32 PlayerbotHolder::GetAccountId(string name)
+{
+    uint32 accountId = 0;
+
+    QueryResult results = LoginDatabase.PQuery("SELECT id FROM account WHERE username = '%s'", name.c_str());
+    if(results)
+    {
+        Field* fields = results->Fetch();
+        accountId = fields[0].GetUInt32();
+    }
+
+    return accountId;
+}
+
+
+
+PlayerbotMgr::PlayerbotMgr(Player* const master) : PlayerbotHolder(),  master(master)
+{
+}
+
+PlayerbotMgr::~PlayerbotMgr()
+{
+}
+
+void PlayerbotMgr::UpdateAIInternal(uint32 elapsed)
+{
+    SetNextCheckDelay(sPlayerbotAIConfig.reactDelay);
+}
+
+void PlayerbotMgr::HandleCommand(uint32 type, const string& text)
+{
+    Player *master = GetMaster();
+    if (!master)
+        return;
+
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleCommand(type, text, *master);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == master)
+            bot->GetPlayerbotAI()->HandleCommand(type, text, *master);
+    }
+}
+
+void PlayerbotMgr::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleMasterIncomingPacket(packet);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->GetPlayerbotAI()->HandleMasterIncomingPacket(packet);
+    }
+
+    switch (packet.GetOpcode())
+    {
+        // if master is logging out, log out all bots
+        case CMSG_LOGOUT_REQUEST:
+        {
+            LogoutAllBots();
+            return;
+        }
+    }
+}
+void PlayerbotMgr::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleMasterOutgoingPacket(packet);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->GetPlayerbotAI()->HandleMasterOutgoingPacket(packet);
+    }
+}
+
+void PlayerbotMgr::SaveToDB()
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->SaveToDB();
+    }
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->SaveToDB();
+    }
+}
+
+void PlayerbotMgr::OnBotLoginInternal(Player * const bot)
+{
+    bot->GetPlayerbotAI()->SetMaster(master);
+    bot->GetPlayerbotAI()->ResetStrategies();
+}
+
diff --git a/src/plugins/playerbot/PlayerbotMgr.h b/src/plugins/playerbot/PlayerbotMgr.h
new file mode 100644
index 0000000..d22074c
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotMgr.h
@@ -0,0 +1,69 @@
+#ifndef _PLAYERBOTMGR_H
+#define _PLAYERBOTMGR_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "../pchdef.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+typedef map<uint64, Player*> PlayerBotMap;
+
+class PlayerbotHolder : public PlayerbotAIBase
+{
+public:
+    PlayerbotHolder();
+    virtual ~PlayerbotHolder();
+
+    void AddPlayerBot(uint64 guid, uint32 masterAccountId);
+    void LogoutPlayerBot(uint64 guid);
+    Player* GetPlayerBot (uint64 guid) const;
+    PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return playerBots.begin(); }
+    PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return playerBots.end();   }
+
+    virtual void UpdateAIInternal(uint32 elapsed);
+    void UpdateSessions(uint32 elapsed);
+
+    void LogoutAllBots();
+    void OnBotLogin(Player * const bot);
+
+    list<string> HandlePlayerbotCommand(char const* args, Player* master = NULL);
+    string ProcessBotCommand(string cmd, ObjectGuid guid, bool admin, uint32 masterAccountId, uint32 masterGuildId);
+    uint32 GetAccountId(string name);
+
+protected:
+    virtual void OnBotLoginInternal(Player * const bot) = 0;
+
+protected:
+    PlayerBotMap playerBots;
+};
+
+class PlayerbotMgr : public PlayerbotHolder
+{
+public:
+    PlayerbotMgr(Player* const master);
+    virtual ~PlayerbotMgr();
+
+    static bool HandlePlayerbotMgrCommand(ChatHandler* handler, char const* args);
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+    void HandleCommand(uint32 type, const string& text);
+
+    virtual void UpdateAIInternal(uint32 elapsed);
+
+    Player* GetMaster() const { return master; };
+
+    void SaveToDB();
+
+protected:
+    virtual void OnBotLoginInternal(Player * const bot);
+
+private:
+    Player* const master;
+};
+
+#endif
diff --git a/src/plugins/playerbot/PlayerbotSecurity.cpp b/src/plugins/playerbot/PlayerbotSecurity.cpp
new file mode 100644
index 0000000..38368a9
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotSecurity.cpp
@@ -0,0 +1,187 @@
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotAI.h"
+#include "ChatHelper.h"
+
+PlayerbotSecurity::PlayerbotSecurity(Player* const bot) : bot(bot)
+{
+    if (bot)
+        account = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+}
+
+PlayerbotSecurityLevel PlayerbotSecurity::LevelFor(Player* from, DenyReason* reason, bool ignoreGroup)
+{
+    if (from->GetSession()->GetSecurity() >= SEC_GAMEMASTER)
+        return PLAYERBOT_SECURITY_ALLOW_ALL;
+
+    if (from->GetPlayerbotAI())
+    {
+        if (reason) *reason = PLAYERBOT_DENY_IS_BOT;
+        return PLAYERBOT_SECURITY_DENY_ALL;
+    }
+
+    if (bot->GetPlayerbotAI()->IsOpposing(from))
+    {
+        if (reason) *reason = PLAYERBOT_DENY_OPPOSING;
+        return PLAYERBOT_SECURITY_DENY_ALL;
+    }
+
+    if (sPlayerbotAIConfig.IsInRandomAccountList(account))
+    {
+        if (bot->GetPlayerbotAI()->IsOpposing(from))
+        {
+            if (reason) *reason = PLAYERBOT_DENY_OPPOSING;
+            return PLAYERBOT_SECURITY_DENY_ALL;
+        }
+
+        Group* group = from->GetGroup();
+        if (group)
+        {
+            for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+            {
+                Player* player = gref->GetSource();
+                if (player == bot && !ignoreGroup)
+                    return PLAYERBOT_SECURITY_ALLOW_ALL;
+            }
+        }
+
+        if ((int)bot->getLevel() - (int)from->getLevel() > 5)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_LOW_LEVEL;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (bot->GetMapId() != from->GetMapId() || bot->GetDistance(from) > sPlayerbotAIConfig.whisperDistance)
+        {
+            if (!bot->GetGuildId() || bot->GetGuildId() != from->GetGuildId())
+            {
+                if (reason) *reason = PLAYERBOT_DENY_FAR;
+                return PLAYERBOT_SECURITY_TALK;
+            }
+        }
+
+        int botGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(bot, false, false);
+        int fromGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(from, false, false);
+        if (botGS && bot->getLevel() > 15 && (100 * (botGS - fromGS) / botGS) >= 20)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_GEARSCORE;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (bot->isDead())
+        {
+            if (reason) *reason = PLAYERBOT_DENY_DEAD;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        group = bot->GetGroup();
+        if (!group)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_INVITE;
+            return PLAYERBOT_SECURITY_INVITE;
+        }
+
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* player = gref->GetSource();
+            if (player == from)
+                return PLAYERBOT_SECURITY_ALLOW_ALL;
+        }
+
+        if (group->IsFull())
+        {
+            if (reason) *reason = PLAYERBOT_DENY_FULL_GROUP;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (reason) *reason = PLAYERBOT_DENY_INVITE;
+        return PLAYERBOT_SECURITY_INVITE;
+    }
+
+    return PLAYERBOT_SECURITY_ALLOW_ALL;
+}
+
+bool PlayerbotSecurity::CheckLevelFor(PlayerbotSecurityLevel level, bool silent, Player* from, bool ignoreGroup)
+{
+    DenyReason reason = PLAYERBOT_DENY_NONE;
+    PlayerbotSecurityLevel realLevel = LevelFor(from, &reason, ignoreGroup);
+    if (realLevel >= level)
+        return true;
+
+    if (silent || from->GetPlayerbotAI())
+        return false;
+
+    Player* master = bot->GetPlayerbotAI()->GetMaster();
+    if (master && bot->GetPlayerbotAI() && bot->GetPlayerbotAI()->IsOpposing(master) && master->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+        return false;
+
+    ostringstream out;
+    switch (realLevel)
+    {
+    case PLAYERBOT_SECURITY_DENY_ALL:
+        out << "I'm kind of busy now";
+        break;
+    case PLAYERBOT_SECURITY_TALK:
+        switch (reason)
+        {
+        case PLAYERBOT_DENY_NONE:
+            out << "I'll do it later";
+            break;
+        case PLAYERBOT_DENY_LOW_LEVEL:
+            out << "You are too low level: |cffff0000" << (uint32)from->getLevel() << "|cffffffff/|cff00ff00" << (uint32)bot->getLevel();
+            break;
+        case PLAYERBOT_DENY_GEARSCORE:
+            {
+                int botGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(bot, false, false);
+                int fromGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(from, false, false);
+                out << "Your gearscore is too low: |cffff0000" << fromGS << "|cffffffff/|cff00ff00" << botGS;
+            }
+            break;
+        case PLAYERBOT_DENY_NOT_YOURS:
+            out << "I have a master already";
+            break;
+        case PLAYERBOT_DENY_IS_BOT:
+            out << "You are a bot";
+            break;
+        case PLAYERBOT_DENY_OPPOSING:
+            out << "You are the enemy";
+            break;
+        case PLAYERBOT_DENY_DEAD:
+            out << "I'm dead. Will do it later";
+            break;
+        case PLAYERBOT_DENY_INVITE:
+            out << "Invite me to your group first";
+            break;
+        case PLAYERBOT_DENY_FAR:
+            {
+                out << "I am too far away";
+
+                uint32 area = bot->GetAreaId();
+                if (area)
+                {
+					const AreaTableEntry* entry = sAreaTableStore.LookupEntry(area);
+                    if (entry)
+                    {
+                        out << " |cffffffff(|cffff0000" << entry->area_name[0] << "|cffffffff)";
+                    }
+                }
+            }
+            break;
+        case PLAYERBOT_DENY_FULL_GROUP:
+            out << "I am in a full group. Will do it later";
+            break;
+        default:
+            out << "I can't do that";
+            break;
+        }
+        break;
+    case PLAYERBOT_SECURITY_INVITE:
+        out << "Invite me to your group first";
+        break;
+    }
+
+	bot->Whisper(out.str(), LANG_UNIVERSAL, from);
+    return false;
+}
diff --git a/src/plugins/playerbot/PlayerbotSecurity.h b/src/plugins/playerbot/PlayerbotSecurity.h
new file mode 100644
index 0000000..5349555
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotSecurity.h
@@ -0,0 +1,42 @@
+#ifndef _PlayerbotSecurity_H
+#define _PlayerbotSecurity_H
+
+using namespace std;
+
+enum PlayerbotSecurityLevel
+{
+    PLAYERBOT_SECURITY_DENY_ALL = 0,
+    PLAYERBOT_SECURITY_TALK = 1,
+    PLAYERBOT_SECURITY_INVITE = 2,
+    PLAYERBOT_SECURITY_ALLOW_ALL = 3
+};
+
+enum DenyReason
+{
+    PLAYERBOT_DENY_NONE,
+    PLAYERBOT_DENY_LOW_LEVEL,
+    PLAYERBOT_DENY_GEARSCORE,
+    PLAYERBOT_DENY_NOT_YOURS,
+    PLAYERBOT_DENY_IS_BOT,
+    PLAYERBOT_DENY_OPPOSING,
+    PLAYERBOT_DENY_DEAD,
+    PLAYERBOT_DENY_FAR,
+    PLAYERBOT_DENY_INVITE,
+    PLAYERBOT_DENY_FULL_GROUP
+};
+
+class PlayerbotSecurity
+{
+    public:
+        PlayerbotSecurity(Player* const bot);
+
+	public:
+        PlayerbotSecurityLevel LevelFor(Player* from, DenyReason* reason = NULL, bool ignoreGroup = false);
+        bool CheckLevelFor(PlayerbotSecurityLevel level, bool silent, Player* from, bool ignoreGroup = false);
+
+    private:
+        Player* const bot;
+        uint32 account;
+};
+
+#endif
diff --git a/src/plugins/playerbot/RandomItemMgr.cpp b/src/plugins/playerbot/RandomItemMgr.cpp
new file mode 100644
index 0000000..4d4b404
--- /dev/null
+++ b/src/plugins/playerbot/RandomItemMgr.cpp
@@ -0,0 +1,154 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "RandomItemMgr.h"
+
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "PlayerbotAI.h"
+
+#include "../../plugins/ahbot/AhBotConfig.h"
+
+char * strstri (const char* str1, const char* str2);
+
+class RandomItemGuildTaskPredicate : public RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto)
+    {
+        if (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_QUEST_ITEM ||
+                proto->Bonding == BIND_WHEN_USE)
+            return false;
+
+        if (proto->Quality < ITEM_QUALITY_UNCOMMON)
+            return false;
+
+        if ((proto->Class == ITEM_CLASS_ARMOR || proto->Class == ITEM_CLASS_WEAPON) && proto->Quality >= ITEM_QUALITY_RARE)
+            return true;
+
+        if (proto->Class == ITEM_CLASS_TRADE_GOODS || proto->Class == ITEM_CLASS_CONSUMABLE)
+            return true;
+
+        return false;
+    }
+};
+
+class RandomItemGuildTaskRewardPredicate : public RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto)
+    {
+        if (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_QUEST_ITEM ||
+                proto->Bonding == BIND_WHEN_USE)
+            return false;
+
+        if (proto->Quality < ITEM_QUALITY_RARE)
+            return false;
+
+        if (proto->Class == ITEM_CLASS_QUEST)
+            return false;
+
+        return true;
+    }
+};
+
+RandomItemMgr::RandomItemMgr()
+{
+    predicates[RANDOM_ITEM_GUILD_TASK] = new RandomItemGuildTaskPredicate();
+    predicates[RANDOM_ITEM_GUILD_TASK_REWARD] = new RandomItemGuildTaskRewardPredicate();
+}
+
+RandomItemMgr::~RandomItemMgr()
+{
+    for (map<RandomItemType, RandomItemPredicate*>::iterator i = predicates.begin(); i != predicates.end(); ++i)
+        delete i->second;
+
+    predicates.clear();
+}
+
+bool RandomItemMgr::HandleConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!args || !*args)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Usage: rnditem");
+        return false;
+    }
+
+    return false;
+}
+
+RandomItemList RandomItemMgr::Query(RandomItemType type, RandomItemPredicate* predicate)
+{
+    RandomItemList &list = cache[type];
+    if (list.empty())
+        list = cache[type] = Query(type);
+
+    RandomItemList result;
+    for (RandomItemList::iterator i = list.begin(); i != list.end(); ++i)
+    {
+        uint32 itemId = *i;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (predicate && !predicate->Apply(proto))
+            continue;
+
+        result.push_back(itemId);
+    }
+
+    return result;
+}
+
+RandomItemList RandomItemMgr::Query(RandomItemType type)
+{
+    RandomItemList items;
+
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto)
+            continue;
+
+        if (proto->Duration & 0x80000000)
+            continue;
+
+        if (sAhBotConfig.ignoreItemIds.find(proto->ItemId) != sAhBotConfig.ignoreItemIds.end())
+            continue;
+
+        if (strstri(proto->Name1.c_str(), "qa") || strstri(proto->Name1.c_str(), "test") || strstri(proto->Name1.c_str(), "deprecated"))
+            continue;
+
+        if ((proto->RequiredLevel && proto->RequiredLevel > sAhBotConfig.maxRequiredLevel) || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+            continue;
+
+        if (predicates[type] && !predicates[type]->Apply(proto))
+            continue;
+
+        if (!auctionbot.GetSellPrice(proto))
+            continue;
+
+        items.push_back(itemId);
+    }
+
+    if (items.empty())
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "no items available for random item query %u", type);
+
+    return items;
+}
+
+uint32 RandomItemMgr::GetRandomItem(RandomItemType type, RandomItemPredicate* predicate)
+{
+    RandomItemList const& list = Query(type, predicate);
+    if (list.empty())
+        return 0;
+
+    uint32 index = urand(0, list.size() - 1);
+    uint32 itemId = list[index];
+
+    return itemId;
+}
diff --git a/src/plugins/playerbot/RandomItemMgr.h b/src/plugins/playerbot/RandomItemMgr.h
new file mode 100644
index 0000000..a0f8149
--- /dev/null
+++ b/src/plugins/playerbot/RandomItemMgr.h
@@ -0,0 +1,50 @@
+#ifndef _RandomItemMgr_H
+#define _RandomItemMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+using namespace std;
+
+enum RandomItemType
+{
+    RANDOM_ITEM_GUILD_TASK,
+    RANDOM_ITEM_GUILD_TASK_REWARD
+};
+
+class RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto) = 0;
+};
+
+typedef vector<uint32> RandomItemList;
+typedef map<RandomItemType, RandomItemList> RandomItemCache;
+
+class RandomItemMgr
+{
+    public:
+        RandomItemMgr();
+        virtual ~RandomItemMgr();
+        static RandomItemMgr& instance()
+        {
+            static RandomItemMgr instance;
+            return instance;
+        }
+
+	public:
+        static bool HandleConsoleCommand(ChatHandler* handler, char const* args);
+        RandomItemList Query(RandomItemType type, RandomItemPredicate* predicate);
+        uint32 GetRandomItem(RandomItemType type, RandomItemPredicate* predicate = NULL);
+
+    private:
+        RandomItemList Query(RandomItemType type);
+
+    private:
+        RandomItemCache cache;
+        map<RandomItemType, RandomItemPredicate*> predicates;
+};
+
+#define sRandomItemMgr RandomItemMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/RandomPlayerbotFactory.cpp b/src/plugins/playerbot/RandomPlayerbotFactory.cpp
new file mode 100644
index 0000000..964b015
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotFactory.cpp
@@ -0,0 +1,382 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "PlayerbotAI.h"
+#include "../../server/game/Entities/Player/Player.h"
+#include "../../server/game/Guilds/Guild.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "RandomPlayerbotFactory.h"
+
+map<uint8, vector<uint8> > RandomPlayerbotFactory::availableRaces;
+
+RandomPlayerbotFactory::RandomPlayerbotFactory(uint32 accountId) : accountId(accountId)
+{
+    availableRaces[CLASS_WARRIOR].push_back(RACE_HUMAN);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_GNOME);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_DWARF);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_ORC);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_TAUREN);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_TROLL);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_DRAENEI);
+
+    availableRaces[CLASS_PALADIN].push_back(RACE_HUMAN);
+    availableRaces[CLASS_PALADIN].push_back(RACE_DWARF);
+    availableRaces[CLASS_PALADIN].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_PALADIN].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_ROGUE].push_back(RACE_HUMAN);
+    availableRaces[CLASS_ROGUE].push_back(RACE_DWARF);
+    availableRaces[CLASS_ROGUE].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_ROGUE].push_back(RACE_GNOME);
+    availableRaces[CLASS_ROGUE].push_back(RACE_ORC);
+    availableRaces[CLASS_ROGUE].push_back(RACE_TROLL);
+    availableRaces[CLASS_ROGUE].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_PRIEST].push_back(RACE_HUMAN);
+    availableRaces[CLASS_PRIEST].push_back(RACE_DWARF);
+    availableRaces[CLASS_PRIEST].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_PRIEST].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_PRIEST].push_back(RACE_TROLL);
+    availableRaces[CLASS_PRIEST].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_PRIEST].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_MAGE].push_back(RACE_HUMAN);
+    availableRaces[CLASS_MAGE].push_back(RACE_GNOME);
+    availableRaces[CLASS_MAGE].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_MAGE].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_MAGE].push_back(RACE_TROLL);
+    availableRaces[CLASS_MAGE].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_WARLOCK].push_back(RACE_HUMAN);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_GNOME);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_ORC);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_SHAMAN].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_ORC);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_TAUREN);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_TROLL);
+
+    availableRaces[CLASS_HUNTER].push_back(RACE_DWARF);
+    availableRaces[CLASS_HUNTER].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_HUNTER].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_HUNTER].push_back(RACE_ORC);
+    availableRaces[CLASS_HUNTER].push_back(RACE_TAUREN);
+    availableRaces[CLASS_HUNTER].push_back(RACE_TROLL);
+    availableRaces[CLASS_HUNTER].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_DRUID].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_DRUID].push_back(RACE_TAUREN);
+}
+
+typedef std::multimap<uint32, CharSectionsEntry const*> CharSectionsMap;
+extern CharSectionsMap sCharSectionMap;
+CharSectionsEntry const* GetRandomCharSection(uint8 race, CharSectionType genType, uint8 gender, uint8 color = 255)
+{
+    vector<CharSectionsEntry const*> charSections;
+    std::pair<CharSectionsMap::const_iterator, CharSectionsMap::const_iterator> eqr = sCharSectionMap.equal_range(uint32(genType) | uint32(gender << 8) | uint32(race << 16));
+    for (CharSectionsMap::const_iterator itr = eqr.first; itr != eqr.second; ++itr)
+    {
+        CharSectionsEntry const* charSection = itr->second;
+        if ((charSection->Flags & SECTION_FLAG_PLAYER) && !(charSection->Flags & SECTION_FLAG_DEATH_KNIGHT)
+                && (charSection->Color == color || color == 255))
+        {
+            charSections.push_back(itr->second);
+        }
+    }
+    if (charSections.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "No match for race=%u gender=%u color=%u type=%u",
+                race, gender, color, genType);
+        return NULL;
+    }
+
+    uint32 charSectionIndex = urand(0, charSections.size() - 1);
+    return charSections[charSectionIndex];
+}
+
+bool RandomPlayerbotFactory::CreateRandomBot(uint8 cls)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Creating new random bot for class %d", cls);
+
+    uint8 gender = rand() % 2 ? GENDER_MALE : GENDER_FEMALE;
+
+    uint8 race = availableRaces[cls][urand(0, availableRaces[cls].size() - 1)];
+    string name = CreateRandomBotName();
+    if (name.empty())
+        return false;
+
+    CharSectionsEntry const* skin = GetRandomCharSection(race, SECTION_TYPE_SKIN, gender);
+    CharSectionsEntry const* face = GetRandomCharSection(race, SECTION_TYPE_FACE, gender, skin->Color);
+    CharSectionsEntry const* hair = GetRandomCharSection(race, SECTION_TYPE_HAIR, gender);
+    CharSectionsEntry const* facialHair = GetRandomCharSection(race, SECTION_TYPE_FACIAL_HAIR, gender, hair->Color);
+    uint8 outfitId = 0;
+
+    WorldSession* session = new WorldSession(accountId, "rndbot", NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0, false);
+    if (!session)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Couldn't create session for random bot account %d", accountId);
+        delete session;
+        return false;
+    }
+
+    Player *player = new Player(session);
+
+    CharacterCreateInfo cci;
+    cci.Name = name;
+    cci.Race = race;
+    cci.Class = cls;
+    cci.Gender = gender;
+    cci.Skin = skin->Color;
+    cci.Face = face->Type;
+    cci.HairStyle = hair->Type;
+    cci.HairColor = hair->Color;
+    cci.FacialHair = facialHair ? facialHair->Type : 0;
+    cci.OutfitId = outfitId;
+
+    if (!player->Create(sObjectMgr->GetGenerator<HighGuid::Player>().Generate(), &cci))
+    {
+        player->DeleteFromDB(player->GetGUID(), accountId, true, true);
+        delete session;
+        delete player;
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Unable to create random bot for account %d - name: \"%s\"; race: %u; class: %u",
+                accountId, name.c_str(), race, cls);
+        return false;
+    }
+
+    player->setCinematic(2);
+    player->SetAtLoginFlag(AT_LOGIN_NONE);
+    player->SaveToDB(true);
+
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Random bot created for account %d - name: \"%s\"; race: %u; class: %u",
+            accountId, name.c_str(), race, cls);
+
+    return true;
+}
+
+string RandomPlayerbotFactory::CreateRandomBotName()
+{
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(name_id) FROM ai_playerbot_names");
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    Field *fields = result->Fetch();
+    uint32 maxId = fields[0].GetUInt32();
+
+    uint32 id = urand(0, maxId);
+    result = CharacterDatabase.PQuery("SELECT n.name FROM ai_playerbot_names n "
+            "LEFT OUTER JOIN characters e ON e.name = n.name "
+            "WHERE e.guid IS NULL AND n.name_id >= '%u' LIMIT 1", id);
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random bots");
+        return "";
+    }
+
+	fields = result->Fetch();
+    return fields[0].GetString();
+}
+
+
+void RandomPlayerbotFactory::CreateRandomBots()
+{
+    if (sPlayerbotAIConfig.deleteRandomBotAccounts)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Deleting random bot accounts...");
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username like '%s%%'", sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                sAccountMgr->DeleteAccount(fields[0].GetUInt32());
+            } while (results->NextRow());
+        }
+
+        CharacterDatabase.Execute("DELETE FROM ai_playerbot_random_bots");
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bot accounts deleted");
+    }
+
+    for (int accountNumber = 0; accountNumber < sPlayerbotAIConfig.randomBotAccountCount; ++accountNumber)
+    {
+        ostringstream out; out << sPlayerbotAIConfig.randomBotAccountPrefix << accountNumber;
+        string accountName = out.str();
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username = '%s'", accountName.c_str());
+        if (results)
+        {
+            continue;
+        }
+
+        string password = "";
+        for (int i = 0; i < 10; i++)
+        {
+            password += (char)urand('!', 'z');
+        }
+        sAccountMgr->CreateAccount(accountName, password, "playerbot");
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Account %s created for random bots", accountName.c_str());
+    }
+
+    LoginDatabase.PExecute("UPDATE account SET expansion = '%u' where username like '%s%%'", 2, sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+
+    int totalRandomBotChars = 0;
+    for (int accountNumber = 0; accountNumber < sPlayerbotAIConfig.randomBotAccountCount; ++accountNumber)
+    {
+        ostringstream out; out << sPlayerbotAIConfig.randomBotAccountPrefix << accountNumber;
+        string accountName = out.str();
+
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username = '%s'", accountName.c_str());
+        if (!results)
+            continue;
+
+        Field* fields = results->Fetch();
+        uint32 accountId = fields[0].GetUInt32();
+
+        sPlayerbotAIConfig.randomBotAccounts.push_back(accountId);
+
+        int count = sAccountMgr->GetCharactersCount(accountId);
+        if (count >= 10)
+        {
+            totalRandomBotChars += count;
+            continue;
+        }
+
+        RandomPlayerbotFactory factory(accountId);
+        for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+        {
+            if (cls != 10 && cls != CLASS_DEATH_KNIGHT)
+                factory.CreateRandomBot(cls);
+        }
+
+        totalRandomBotChars += sAccountMgr->GetCharactersCount(accountId);
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d random bot accounts with %d characters available", sPlayerbotAIConfig.randomBotAccounts.size(), totalRandomBotChars);
+}
+
+
+void RandomPlayerbotFactory::CreateRandomGuilds()
+{
+    vector<uint32> randomBots;
+    QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username like '%s%%'", sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 accountId = fields[0].GetUInt32();
+
+            QueryResult results2 = CharacterDatabase.PQuery("SELECT guid FROM characters where account  = '%u'", accountId);
+            if (results2)
+            {
+                do
+                {
+                    Field* fields = results2->Fetch();
+                    uint32 guid = fields[0].GetUInt32();
+                    randomBots.push_back(guid);
+                } while (results2->NextRow());
+            }
+
+        } while (results->NextRow());
+    }
+
+    if (sPlayerbotAIConfig.deleteRandomBotGuilds)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Deleting random bot guilds...");
+        for (vector<uint32>::iterator i = randomBots.begin(); i != randomBots.end(); ++i)
+        {
+            ObjectGuid leader(HighGuid::Player, *i);
+            Guild* guild = sGuildMgr->GetGuildByLeader(leader);
+            if (guild) guild->Disband();
+        }
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bot guilds deleted");
+    }
+
+    int guildNumber = 0;
+    vector<ObjectGuid> availableLeaders;
+    for (vector<uint32>::iterator i = randomBots.begin(); i != randomBots.end(); ++i)
+    {
+        ObjectGuid leader(HighGuid::Player, *i);
+        Guild* guild = sGuildMgr->GetGuildByLeader(leader);
+        if (guild)
+        {
+            ++guildNumber;
+            sPlayerbotAIConfig.randomBotGuilds.push_back(guild->GetId());
+        }
+        else
+        {
+            Player* player = sObjectMgr->GetPlayerByLowGUID(leader);
+            if (player)
+                availableLeaders.push_back(leader);
+        }
+    }
+
+    for (; guildNumber < sPlayerbotAIConfig.randomBotGuildCount; ++guildNumber)
+    {
+        string guildName = CreateRandomGuildName();
+        if (guildName.empty())
+            break;
+
+        if (availableLeaders.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No leaders for random guilds available");
+            break;
+        }
+
+        int index = urand(0, availableLeaders.size() - 1);
+        ObjectGuid leader = availableLeaders[index];
+        Player* player = sObjectMgr->GetPlayerByLowGUID(leader);
+        if (!player)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot find player for leader %u", leader);
+            break;
+        }
+
+        Guild* guild = new Guild();
+        if (!guild->Create(player, guildName))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Error creating guild %s", guildName.c_str());
+            break;
+        }
+
+        sGuildMgr->AddGuild(guild);
+        sPlayerbotAIConfig.randomBotGuilds.push_back(guild->GetId());
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d random bot guilds available", guildNumber);
+}
+
+string RandomPlayerbotFactory::CreateRandomGuildName()
+{
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(name_id) FROM ai_playerbot_guild_names");
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    Field *fields = result->Fetch();
+    uint32 maxId = fields[0].GetUInt32();
+
+    uint32 id = urand(0, maxId);
+    result = CharacterDatabase.PQuery("SELECT n.name FROM ai_playerbot_guild_names n "
+            "LEFT OUTER JOIN guild e ON e.name = n.name "
+            "WHERE e.guildid IS NULL AND n.name_id >= '%u' LIMIT 1", id);
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    fields = result->Fetch();
+    return fields[0].GetString();
+}
+
diff --git a/src/plugins/playerbot/RandomPlayerbotFactory.h b/src/plugins/playerbot/RandomPlayerbotFactory.h
new file mode 100644
index 0000000..76f4d08
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotFactory.h
@@ -0,0 +1,35 @@
+#ifndef _RandomPlayerbotFactory_H
+#define _RandomPlayerbotFactory_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+using namespace std;
+
+class RandomPlayerbotFactory
+{
+    public:
+        RandomPlayerbotFactory(uint32 accountId);
+		virtual ~RandomPlayerbotFactory() {}
+
+	public:
+        bool CreateRandomBot(uint8 cls);
+        static void CreateRandomBots();
+        static void CreateRandomGuilds();
+
+	private:
+        string CreateRandomBotName();
+        static string CreateRandomGuildName();
+
+    private:
+        uint32 accountId;
+        static map<uint8, vector<uint8> > availableRaces;
+};
+
+#endif
diff --git a/src/plugins/playerbot/RandomPlayerbotMgr.cpp b/src/plugins/playerbot/RandomPlayerbotMgr.cpp
new file mode 100644
index 0000000..81e5521
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotMgr.cpp
@@ -0,0 +1,912 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "PlayerbotAI.h"
+#include "AiFactory.h"
+#include "../../game/Maps/MapManager.h"
+#include "PlayerbotCommandServer.h"
+#include "GuildTaskMgr.h"
+
+RandomPlayerbotMgr::RandomPlayerbotMgr() : PlayerbotHolder(), processTicks(0)
+{
+    sPlayerbotCommandServer.Start();
+}
+
+RandomPlayerbotMgr::~RandomPlayerbotMgr()
+{
+}
+
+void RandomPlayerbotMgr::UpdateAIInternal(uint32 elapsed)
+{
+    SetNextCheckDelay(sPlayerbotAIConfig.randomBotUpdateInterval * 1000);
+
+    if (!sPlayerbotAIConfig.randomBotAutologin || !sPlayerbotAIConfig.enabled)
+        return;
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Processing random bots...");
+
+    int maxAllowedBotCount = GetEventValue(0, "bot_count");
+    if (!maxAllowedBotCount)
+    {
+        maxAllowedBotCount = urand(sPlayerbotAIConfig.minRandomBots, sPlayerbotAIConfig.maxRandomBots);
+        SetEventValue(0, "bot_count", maxAllowedBotCount,
+                urand(sPlayerbotAIConfig.randomBotCountChangeMinInterval, sPlayerbotAIConfig.randomBotCountChangeMaxInterval));
+    }
+
+    list<uint32> bots = GetBots();
+    int botCount = bots.size();
+    int allianceNewBots = 0, hordeNewBots = 0;
+    int randomBotsPerInterval = (int)urand(sPlayerbotAIConfig.minRandomBotsPerInterval, sPlayerbotAIConfig.maxRandomBotsPerInterval);
+    if (!processTicks)
+    {
+        if (sPlayerbotAIConfig.randomBotLoginAtStartup)
+            randomBotsPerInterval = bots.size();
+    }
+
+    while (botCount++ < maxAllowedBotCount)
+    {
+        bool alliance = botCount % 2;
+        uint32 bot = AddRandomBot(alliance);
+        if (bot)
+        {
+            if (alliance)
+                allianceNewBots++;
+            else
+                hordeNewBots++;
+
+            bots.push_back(bot);
+        }
+        else
+            break;
+    }
+
+    int botProcessed = 0;
+    for (list<uint32>::iterator i = bots.begin(); i != bots.end(); ++i)
+    {
+        uint32 bot = *i;
+        if (ProcessBot(bot))
+            botProcessed++;
+
+        if (botProcessed >= randomBotsPerInterval)
+            break;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d bots processed. %d alliance and %d horde bots added. %d bots online. Next check in %d seconds",
+            botProcessed, allianceNewBots, hordeNewBots, playerBots.size(), sPlayerbotAIConfig.randomBotUpdateInterval);
+
+    if (processTicks++ == 1)
+        PrintStats();
+}
+
+uint32 RandomPlayerbotMgr::AddRandomBot(bool alliance)
+{
+    vector<uint32> bots = GetFreeBots(alliance);
+    if (bots.size() == 0)
+        return 0;
+
+    int index = urand(0, bots.size() - 1);
+    uint32 bot = bots[index];
+    SetEventValue(bot, "add", 1, urand(sPlayerbotAIConfig.minRandomBotInWorldTime, sPlayerbotAIConfig.maxRandomBotInWorldTime));
+    uint32 randomTime = 30 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3);
+    ScheduleRandomize(bot, randomTime);
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Random bot %d added", bot);
+    return bot;
+}
+
+void RandomPlayerbotMgr::ScheduleRandomize(uint32 bot, uint32 time)
+{
+    SetEventValue(bot, "randomize", 1, time);
+    SetEventValue(bot, "logout", 1, time + 30 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3));
+}
+
+void RandomPlayerbotMgr::ScheduleTeleport(uint32 bot)
+{
+    SetEventValue(bot, "teleport", 1, 60 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3));
+}
+
+bool RandomPlayerbotMgr::ProcessBot(uint32 bot)
+{
+    uint32 isValid = GetEventValue(bot, "add");
+    if (!isValid)
+    {
+		Player* player = GetPlayerBot(bot);
+		if (!player || !player->GetGroup())
+		{
+			sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Bot %d expired", bot);
+			SetEventValue(bot, "add", 0, 0);
+		}
+        return true;
+    }
+
+    if (!GetPlayerBot(bot))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Bot %d logged in", bot);
+        AddPlayerBot(bot, 0);
+        if (!GetEventValue(bot, "online"))
+        {
+            SetEventValue(bot, "online", 1, sPlayerbotAIConfig.minRandomBotInWorldTime);
+        }
+        return true;
+    }
+
+    Player* player = GetPlayerBot(bot);
+    if (!player)
+        return false;
+
+    PlayerbotAI* ai = player->GetPlayerbotAI();
+    if (!ai)
+        return false;
+
+    if (player->GetGroup())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Skipping bot %d as it is in group", bot);
+        return false;
+    }
+
+    if (player->isDead())
+    {
+        if (!GetEventValue(bot, "dead"))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Setting dead flag for bot %d", bot);
+            uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotReviveTime, sPlayerbotAIConfig.maxRandomBotReviveTime);
+            SetEventValue(bot, "dead", 1, randomTime);
+            SetEventValue(bot, "revive", 1, randomTime - 60);
+            return false;
+        }
+
+        if (!GetEventValue(bot, "revive"))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Reviving dead bot %d", bot);
+            SetEventValue(bot, "dead", 0, 0);
+            SetEventValue(bot, "revive", 0, 0);
+            RandomTeleport(player, player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+            return true;
+        }
+
+        return false;
+    }
+
+    if (player->GetGuild() && player->GetGuild()->GetLeaderGUID() == player->GetGUID())
+    {
+        for (vector<Player*>::iterator i = players.begin(); i != players.end(); ++i)
+            sGuildTaskMgr.Update(*i, player);
+    }
+
+    uint32 randomize = GetEventValue(bot, "randomize");
+    if (!randomize)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bot %d", bot);
+        Randomize(player);
+        uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotRandomizeTime, sPlayerbotAIConfig.maxRandomBotRandomizeTime);
+        ScheduleRandomize(bot, randomTime);
+        return true;
+    }
+
+    uint32 logout = GetEventValue(bot, "logout");
+    if (!logout)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Logging out bot %d", bot);
+        LogoutPlayerBot(bot);
+        SetEventValue(bot, "logout", 1, sPlayerbotAIConfig.maxRandomBotInWorldTime);
+        return true;
+    }
+
+    uint32 teleport = GetEventValue(bot, "teleport");
+    if (!teleport)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %d", bot);
+        RandomTeleportForLevel(ai->GetBot());
+        SetEventValue(bot, "teleport", 1, sPlayerbotAIConfig.maxRandomBotInWorldTime);
+        return true;
+    }
+
+    return false;
+}
+
+void RandomPlayerbotMgr::RandomTeleport(Player* bot, vector<WorldLocation> &locs)
+{
+    if (bot->IsBeingTeleported())
+        return;
+
+    if (locs.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot teleport bot %s - no locations available", bot->GetName().c_str());
+        return;
+    }
+
+    for (int attemtps = 0; attemtps < 10; ++attemtps)
+    {
+        int index = urand(0, locs.size() - 1);
+        WorldLocation loc = locs[index];
+        float x = loc.m_positionX + urand(0, sPlayerbotAIConfig.grindDistance) - sPlayerbotAIConfig.grindDistance / 2;
+        float y = loc.m_positionY + urand(0, sPlayerbotAIConfig.grindDistance) - sPlayerbotAIConfig.grindDistance / 2;
+        float z = loc.m_positionZ;
+
+        Map* map = sMapMgr->FindMap(loc.GetMapId(), 0);
+        if (!map)
+            continue;
+
+        if (!map->IsOutdoors(x, y, z) ||
+                map->IsInWater(x, y, z))
+            continue;
+
+        uint32 areaId = map->GetAreaId(x, y, z);
+        if (!areaId)
+            continue;
+
+		AreaTableEntry const* area = sAreaTableStore.LookupEntry(areaId);
+        if (!area)
+            continue;
+
+        float ground = map->GetHeight(x, y, z + 0.5f);
+        if (ground <= INVALID_HEIGHT)
+            continue;
+
+        z = 0.05f + ground;
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %s to %s %f,%f,%f (1/%u locations)",
+                bot->GetName().c_str(), area->area_name[0], x, y, z, locs.size());
+
+        bot->GetMotionMaster()->Clear();
+        bot->TeleportTo(loc.GetMapId(), x, y, z, 0);
+        return;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot teleport bot %s - no locations available", bot->GetName().c_str());
+}
+
+void RandomPlayerbotMgr::RandomTeleportForLevel(Player* bot)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Preparing location to random teleporting bot %s for level %u", bot->GetName().c_str(), bot->getLevel());
+
+    if (locsPerLevelCache[bot->getLevel()].empty()) {
+        QueryResult results = WorldDatabase.PQuery("select map, position_x, position_y, position_z "
+            "from (select map, position_x, position_y, position_z, avg(t.maxlevel), avg(t.minlevel), "
+            "%u - (avg(t.maxlevel) + avg(t.minlevel)) / 2 delta "
+            "from creature c inner join creature_template t on c.id = t.entry group by t.entry) q "
+            "where delta >= 0 and delta <= %u and map in (%s) and not exists ( "
+            "select map, position_x, position_y, position_z from "
+            "("
+            "select map, c.position_x, c.position_y, c.position_z, avg(t.maxlevel), avg(t.minlevel), "
+            "%u - (avg(t.maxlevel) + avg(t.minlevel)) / 2 delta "
+            "from creature c "
+            "inner join creature_template t on c.id = t.entry group by t.entry "
+            ") q1 "
+            "where delta > %u and q1.map = q.map "
+            "and sqrt("
+            "(q1.position_x - q.position_x)*(q1.position_x - q.position_x) +"
+            "(q1.position_y - q.position_y)*(q1.position_y - q.position_y) +"
+            "(q1.position_z - q.position_z)*(q1.position_z - q.position_z)"
+            ") < %u)",
+            bot->getLevel(),
+            sPlayerbotAIConfig.randomBotTeleLevel,
+            sPlayerbotAIConfig.randomBotMapsAsString.c_str(),
+            bot->getLevel(),
+            sPlayerbotAIConfig.randomBotTeleLevel,
+            (uint32)sPlayerbotAIConfig.sightDistance
+            );
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                uint16 mapId = fields[0].GetUInt16();
+                float x = fields[1].GetFloat();
+                float y = fields[2].GetFloat();
+                float z = fields[3].GetFloat();
+                WorldLocation loc(mapId, x, y, z, 0);
+                locsPerLevelCache[bot->getLevel()].push_back(loc);
+            } while (results->NextRow());
+        }
+    }
+
+    RandomTeleport(bot, locsPerLevelCache[bot->getLevel()]);
+}
+
+void RandomPlayerbotMgr::RandomTeleport(Player* bot, uint16 mapId, float teleX, float teleY, float teleZ)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Preparing location to random teleporting bot %s", bot->GetName().c_str());
+
+    vector<WorldLocation> locs;
+    QueryResult results = WorldDatabase.PQuery("select position_x, position_y, position_z from creature where map = '%u' and abs(position_x - '%f') < '%u' and abs(position_y - '%f') < '%u'",
+            mapId, teleX, sPlayerbotAIConfig.randomBotTeleportDistance / 2, teleY, sPlayerbotAIConfig.randomBotTeleportDistance / 2);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            float x = fields[0].GetFloat();
+            float y = fields[1].GetFloat();
+            float z = fields[2].GetFloat();
+            WorldLocation loc(mapId, x, y, z, 0);
+            locs.push_back(loc);
+        } while (results->NextRow());
+    }
+
+    RandomTeleport(bot, locs);
+    Refresh(bot);
+}
+
+void RandomPlayerbotMgr::Randomize(Player* bot)
+{
+    if (bot->getLevel() == 1)
+        RandomizeFirst(bot);
+    else
+        IncreaseLevel(bot);
+}
+
+void RandomPlayerbotMgr::IncreaseLevel(Player* bot)
+{
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+    uint32 level = min((uint32)(bot->getLevel() + 1), maxLevel);
+    PlayerbotFactory factory(bot, level);
+    if (bot->GetGuildId())
+        factory.Refresh();
+    else
+        factory.Randomize();
+    RandomTeleportForLevel(bot);
+}
+
+void RandomPlayerbotMgr::RandomizeFirst(Player* bot)
+{
+    uint32 maxLevel = sPlayerbotAIConfig.randomBotMaxLevel;
+    if (maxLevel > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+    for (int attempt = 0; attempt < 10; ++attempt)
+    {
+        int index = urand(0, sPlayerbotAIConfig.randomBotMaps.size() - 1);
+        uint16 mapId = sPlayerbotAIConfig.randomBotMaps[index];
+
+        vector<GameTele const*> locs;
+        GameTeleContainer const & teleMap = sObjectMgr->GetGameTeleMap();
+        for(GameTeleContainer::const_iterator itr = teleMap.begin(); itr != teleMap.end(); ++itr)
+        {
+            GameTele const* tele = &itr->second;
+            if (tele->mapId == mapId)
+                locs.push_back(tele);
+        }
+
+        index = urand(0, locs.size() - 1);
+        GameTele const* tele = locs[index];
+        uint32 level = GetZoneLevel(tele->mapId, tele->position_x, tele->position_y, tele->position_z);
+        if (level > maxLevel + 5)
+            continue;
+
+        level = min(level, maxLevel);
+        if (!level) level = 1;
+
+        if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomBotMaxLevelChance)
+            level = maxLevel;
+
+        if (level < sPlayerbotAIConfig.randomBotMinLevel)
+            continue;
+
+        PlayerbotFactory factory(bot, level);
+        factory.CleanRandomize();
+        RandomTeleport(bot, tele->mapId, tele->position_x, tele->position_y, tele->position_z);
+        break;
+    }
+}
+
+uint32 RandomPlayerbotMgr::GetZoneLevel(uint16 mapId, float teleX, float teleY, float teleZ)
+{
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+	uint32 level;
+    QueryResult results = WorldDatabase.PQuery("select avg(t.minlevel) minlevel, avg(t.maxlevel) maxlevel from creature c "
+            "inner join creature_template t on c.id = t.entry "
+            "where map = '%u' and minlevel > 1 and abs(position_x - '%f') < '%u' and abs(position_y - '%f') < '%u'",
+            mapId, teleX, sPlayerbotAIConfig.randomBotTeleportDistance / 2, teleY, sPlayerbotAIConfig.randomBotTeleportDistance / 2);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint8 minLevel = fields[0].GetUInt8();
+        uint8 maxLevel = fields[1].GetUInt8();
+        level = urand(minLevel, maxLevel);
+        if (level > maxLevel)
+            level = maxLevel;
+    }
+    else
+    {
+        level = urand(1, maxLevel);
+    }
+
+    return level;
+}
+
+void RandomPlayerbotMgr::Refresh(Player* bot)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Refreshing bot %s", bot->GetName().c_str());
+    if (bot->isDead())
+    {
+        bot->ResurrectPlayer(1.0f);
+        bot->SpawnCorpseBones();
+        bot->SaveToDB();
+        bot->GetPlayerbotAI()->ResetStrategies();
+    }
+
+    bot->GetPlayerbotAI()->Reset();
+
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *unit = threatManager->GetOwner();
+        float threat = ref->getThreat();
+
+        unit->RemoveAllAttackers();
+        unit->ClearInCombat();
+
+        ref = ref->next();
+    }
+
+    bot->RemoveAllAttackers();
+    bot->ClearInCombat();
+
+    bot->DurabilityRepairAll(false, 1.0f, false);
+    bot->SetFullHealth();
+    bot->SetPvP(true);
+
+    if (bot->GetMaxPower(POWER_MANA) > 0)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA));
+
+    if (bot->GetMaxPower(POWER_ENERGY) > 0)
+        bot->SetPower(POWER_ENERGY, bot->GetMaxPower(POWER_ENERGY));
+}
+
+
+bool RandomPlayerbotMgr::IsRandomBot(Player* bot)
+{
+    return IsRandomBot(bot->GetGUID());
+}
+
+bool RandomPlayerbotMgr::IsRandomBot(uint32 bot)
+{
+    return GetEventValue(bot, "add");
+}
+
+list<uint32> RandomPlayerbotMgr::GetBots()
+{
+    list<uint32> bots;
+
+    QueryResult results = CharacterDatabase.Query(
+            "select bot from ai_playerbot_random_bots where owner = 0 and event = 'add'");
+
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 bot = fields[0].GetUInt32();
+            bots.push_back(bot);
+        } while (results->NextRow());
+    }
+
+    return bots;
+}
+
+vector<uint32> RandomPlayerbotMgr::GetFreeBots(bool alliance)
+{
+    set<uint32> bots;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `bot` from ai_playerbot_random_bots where event = 'add'");
+
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 bot = fields[0].GetUInt32();
+            bots.insert(bot);
+        } while (results->NextRow());
+    }
+
+    vector<uint32> guids;
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint8 race = fields[1].GetUInt8();
+            if (bots.find(guid) == bots.end() &&
+                    ((alliance && IsAlliance(race)) || ((!alliance && !IsAlliance(race))
+            )))
+                guids.push_back(guid);
+        } while (result->NextRow());
+    }
+
+
+    return guids;
+}
+
+uint32 RandomPlayerbotMgr::GetEventValue(uint32 bot, string event)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_random_bots where owner = 0 and bot = '%u' and event = '%s'",
+            bot, event.c_str());
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 validIn = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= validIn)
+            value = 0;
+    }
+
+    return value;
+}
+
+uint32 RandomPlayerbotMgr::SetEventValue(uint32 bot, string event, uint32 value, uint32 validIn)
+{
+    CharacterDatabase.PExecute("delete from ai_playerbot_random_bots where owner = 0 and bot = '%u' and event = '%s'",
+            bot, event.c_str());
+    if (value)
+    {
+        CharacterDatabase.PExecute(
+                "insert into ai_playerbot_random_bots (owner, bot, `time`, validIn, event, `value`) values ('%u', '%u', '%u', '%u', '%s', '%u')",
+                0, bot, (uint32)time(0), validIn, event.c_str(), value);
+    }
+
+    return value;
+}
+
+bool RandomPlayerbotMgr::HandlePlayerbotConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!sPlayerbotAIConfig.enabled)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Playerbot system is currently disabled!");
+        return false;
+    }
+
+    if (!args || !*args)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Usage: rndbot stats/update/reset/init/refresh/add/remove");
+        return false;
+    }
+
+    string cmd = args;
+
+    if (cmd == "reset")
+    {
+        CharacterDatabase.PExecute("delete from ai_playerbot_random_bots");
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bots were reset for all players");
+        return true;
+    }
+    else if (cmd == "stats")
+    {
+        sRandomPlayerbotMgr.PrintStats();
+        return true;
+    }
+    else if (cmd == "update")
+    {
+        sRandomPlayerbotMgr.UpdateAIInternal(0);
+        return true;
+    }
+    else if (cmd == "init" || cmd == "refresh" || cmd == "teleport")
+    {
+		sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bots for %d accounts", sPlayerbotAIConfig.randomBotAccounts.size());
+        list<uint32> botIds;
+        for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); ++i)
+        {
+            uint32 account = *i;
+            if (QueryResult results = CharacterDatabase.PQuery("SELECT guid FROM characters where account = '%u'", account))
+            {
+                do
+                {
+                    Field* fields = results->Fetch();
+
+                    uint32 botId = fields[0].GetUInt32();
+                    ObjectGuid guid = ObjectGuid(HighGuid::Player, botId);
+                    Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+                    if (!bot)
+                        continue;
+
+                    botIds.push_back(botId);
+                } while (results->NextRow());
+            }
+        }
+
+        int processed = 0;
+        for (list<uint32>::iterator i = botIds.begin(); i != botIds.end(); ++i)
+        {
+            ObjectGuid guid = ObjectGuid(HighGuid::Player, *i);
+            Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+            if (!bot)
+                continue;
+
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "[%u/%u] Processing command '%s' for bot '%s'",
+                    processed++, botIds.size(), cmd.c_str(), bot->GetName().c_str());
+
+            if (cmd == "init")
+            {
+                sRandomPlayerbotMgr.RandomizeFirst(bot);
+            }
+            else if (cmd == "teleport")
+            {
+                sRandomPlayerbotMgr.RandomTeleportForLevel(bot);
+            }
+            else
+            {
+                bot->SetLevel(bot->getLevel() - 1);
+                sRandomPlayerbotMgr.IncreaseLevel(bot);
+            }
+            uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotRandomizeTime, sPlayerbotAIConfig.maxRandomBotRandomizeTime);
+            CharacterDatabase.PExecute("update ai_playerbot_random_bots set validIn = '%u' where event = 'randomize' and bot = '%u'",
+                    randomTime, bot->GetGUID().GetCounter());
+            CharacterDatabase.PExecute("update ai_playerbot_random_bots set validIn = '%u' where event = 'logout' and bot = '%u'",
+                    sPlayerbotAIConfig.maxRandomBotInWorldTime, bot->GetGUID().GetCounter());
+        }
+        return true;
+    }
+    else
+    {
+        list<string> messages = sRandomPlayerbotMgr.HandlePlayerbotCommand(args, NULL);
+        for (list<string>::iterator i = messages.begin(); i != messages.end(); ++i)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, i->c_str());
+        }
+        return true;
+    }
+
+    return false;
+}
+
+void RandomPlayerbotMgr::HandleCommand(uint32 type, const string& text, Player& fromPlayer)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleCommand(type, text, fromPlayer);
+    }
+}
+
+void RandomPlayerbotMgr::OnPlayerLogout(Player* player)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        PlayerbotAI* ai = bot->GetPlayerbotAI();
+        if (player == ai->GetMaster())
+        {
+            ai->SetMaster(NULL);
+            ai->ResetStrategies();
+        }
+    }
+
+    if (!player->GetPlayerbotAI())
+    {
+        vector<Player*>::iterator i = find(players.begin(), players.end(), player);
+        if (i != players.end())
+            players.erase(i);
+    }
+}
+
+void RandomPlayerbotMgr::OnPlayerLogin(Player* player)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (player == bot || player->GetPlayerbotAI())
+            continue;
+
+        Group* group = bot->GetGroup();
+        if (!group)
+            continue;
+
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* member = gref->GetSource();
+            PlayerbotAI* ai = bot->GetPlayerbotAI();
+            if (member == player && (!ai->GetMaster() || ai->GetMaster()->GetPlayerbotAI()))
+            {
+                ai->SetMaster(player);
+                ai->ResetStrategies();
+                ai->TellMaster("Hello");
+                break;
+            }
+        }
+    }
+
+    if (player->GetPlayerbotAI())
+        return;
+
+    players.push_back(player);
+}
+
+Player* RandomPlayerbotMgr::GetRandomPlayer()
+{
+    if (players.empty())
+        return NULL;
+
+    uint32 index = urand(0, players.size() - 1);
+    return players[index];
+}
+
+void RandomPlayerbotMgr::PrintStats()
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d Random Bots online", playerBots.size());
+
+    map<uint32, int> alliance, horde;
+    for (uint32 i = 0; i < 10; ++i)
+    {
+        alliance[i] = 0;
+        horde[i] = 0;
+    }
+
+    map<uint8, int> perRace, perClass;
+    for (uint8 race = RACE_HUMAN; race < MAX_RACES; ++race)
+    {
+        perRace[race] = 0;
+    }
+    for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+    {
+        perClass[cls] = 0;
+    }
+
+    int dps = 0, heal = 0, tank = 0;
+    for (PlayerBotMap::iterator i = playerBots.begin(); i != playerBots.end(); ++i)
+    {
+        Player* bot = i->second;
+        if (IsAlliance(bot->getRace()))
+            alliance[bot->getLevel() / 10]++;
+        else
+            horde[bot->getLevel() / 10]++;
+
+        perRace[bot->getRace()]++;
+        perClass[bot->getClass()]++;
+
+        int spec = AiFactory::GetPlayerSpecTab(bot);
+        switch (bot->getClass())
+        {
+        case CLASS_DRUID:
+            if (spec == 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_PALADIN:
+            if (spec == 1)
+                tank++;
+            else if (spec == 0)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_PRIEST:
+            if (spec != 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_SHAMAN:
+            if (spec == 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_WARRIOR:
+            if (spec == 2)
+                tank++;
+            else
+                dps++;
+            break;
+        default:
+            dps++;
+            break;
+        }
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per level:");
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+    for (uint32 i = 0; i < 10; ++i)
+    {
+        if (!alliance[i] && !horde[i])
+            continue;
+
+        uint32 from = i*10;
+        uint32 to = min(from + 9, maxLevel);
+        if (!from) from = 1;
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %d..%d: %d alliance, %d horde", from, to, alliance[i], horde[i]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per race:");
+    for (uint8 race = RACE_HUMAN; race < MAX_RACES; ++race)
+    {
+        if (perRace[race])
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %s: %d", ChatHelper::formatRace(race).c_str(), perRace[race]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per class:");
+    for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+    {
+        if (perClass[cls])
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %s: %d", ChatHelper::formatClass(cls).c_str(), perClass[cls]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per role:");
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    tank: %d", tank);
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    heal: %d", heal);
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    dps: %d", dps);
+}
+
+double RandomPlayerbotMgr::GetBuyMultiplier(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    uint32 value = GetEventValue(id, "buymultiplier");
+    if (!value)
+    {
+        value = urand(1, 120);
+        uint32 validIn = urand(sPlayerbotAIConfig.minRandomBotsPriceChangeInterval, sPlayerbotAIConfig.maxRandomBotsPriceChangeInterval);
+        SetEventValue(id, "buymultiplier", value, validIn);
+    }
+
+    return (double)value / 100.0;
+}
+
+double RandomPlayerbotMgr::GetSellMultiplier(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    uint32 value = GetEventValue(id, "sellmultiplier");
+    if (!value)
+    {
+        value = urand(80, 250);
+        uint32 validIn = urand(sPlayerbotAIConfig.minRandomBotsPriceChangeInterval, sPlayerbotAIConfig.maxRandomBotsPriceChangeInterval);
+        SetEventValue(id, "sellmultiplier", value, validIn);
+    }
+
+    return (double)value / 100.0;
+}
+
+uint32 RandomPlayerbotMgr::GetLootAmount(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    return GetEventValue(id, "lootamount");
+}
+
+void RandomPlayerbotMgr::SetLootAmount(Player* bot, uint32 value)
+{
+    uint32 id = bot->GetGUID();
+    SetEventValue(id, "lootamount", value, 24 * 3600);
+}
+
+uint32 RandomPlayerbotMgr::GetTradeDiscount(Player* bot)
+{
+    Group* group = bot->GetGroup();
+    return GetLootAmount(bot) / (group ? group->GetMembersCount() : 10);
+}
+
+string RandomPlayerbotMgr::HandleRemoteCommand(string request)
+{
+    string::iterator pos = find(request.begin(), request.end(), ',');
+    if (pos == request.end())
+    {
+        ostringstream out; out << "invalid request: " << request;
+        return out.str();
+    }
+
+    string command = string(request.begin(), pos);
+    uint64 guid = atoi(string(pos + 1, request.end()).c_str());
+    Player* bot = GetPlayerBot(guid);
+    if (!bot)
+        return "invalid guid";
+
+    PlayerbotAI *ai = bot->GetPlayerbotAI();
+    if (!ai)
+        return "invalid guid";
+
+    return ai->HandleRemoteCommand(command);
+}
diff --git a/src/plugins/playerbot/RandomPlayerbotMgr.h b/src/plugins/playerbot/RandomPlayerbotMgr.h
new file mode 100644
index 0000000..0d0ada4
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotMgr.h
@@ -0,0 +1,74 @@
+#ifndef _RandomPlayerbotMgr_H
+#define _RandomPlayerbotMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "PlayerbotMgr.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+using namespace std;
+
+class RandomPlayerbotMgr : public PlayerbotHolder
+{
+    public:
+        RandomPlayerbotMgr();
+        virtual ~RandomPlayerbotMgr();
+        static RandomPlayerbotMgr& instance()
+        {
+            static RandomPlayerbotMgr instance;
+            return instance;
+        }
+
+        virtual void UpdateAIInternal(uint32 elapsed);
+
+	public:
+        static bool HandlePlayerbotConsoleCommand(ChatHandler* handler, char const* args);
+        bool IsRandomBot(Player* bot);
+        bool IsRandomBot(uint32 bot);
+        void Randomize(Player* bot);
+        void RandomizeFirst(Player* bot);
+        void IncreaseLevel(Player* bot);
+        void ScheduleTeleport(uint32 bot);
+        void HandleCommand(uint32 type, const string& text, Player& fromPlayer);
+        string HandleRemoteCommand(string request);
+        void OnPlayerLogout(Player* player);
+        void OnPlayerLogin(Player* player);
+        Player* GetRandomPlayer();
+        void PrintStats();
+        double GetBuyMultiplier(Player* bot);
+        double GetSellMultiplier(Player* bot);
+        uint32 GetLootAmount(Player* bot);
+        void SetLootAmount(Player* bot, uint32 value);
+        uint32 GetTradeDiscount(Player* bot);
+        void Refresh(Player* bot);
+        void RandomTeleportForLevel(Player* bot);
+
+	protected:
+	    virtual void OnBotLoginInternal(Player * const bot) {}
+
+    private:
+        uint32 GetEventValue(uint32 bot, string event);
+        uint32 SetEventValue(uint32 bot, string event, uint32 value, uint32 validIn);
+        list<uint32> GetBots();
+        vector<uint32> GetFreeBots(bool alliance);
+        uint32 AddRandomBot(bool alliance);
+        bool ProcessBot(uint32 bot);
+        void ScheduleRandomize(uint32 bot, uint32 time);
+        void RandomTeleport(Player* bot, uint16 mapId, float teleX, float teleY, float teleZ);
+        void RandomTeleport(Player* bot, vector<WorldLocation> &locs);
+        uint32 GetZoneLevel(uint16 mapId, float teleX, float teleY, float teleZ);
+
+    private:
+        vector<Player*> players;
+        int processTicks;
+        map<uint8, vector<WorldLocation> > locsPerLevelCache;
+};
+
+#define sRandomPlayerbotMgr RandomPlayerbotMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/aiplayerbot.conf.dist.in b/src/plugins/playerbot/aiplayerbot.conf.dist.in
new file mode 100644
index 0000000..54a2ad6
--- /dev/null
+++ b/src/plugins/playerbot/aiplayerbot.conf.dist.in
@@ -0,0 +1,183 @@
+##########################################
+# MANGOS Ai Playerbot Configuration file #
+##########################################
+
+[AiPlayerbotConf]
+ConfVersion=2010102201
+
+# Enable or disable AI Playerbot
+AiPlayerbot.Enabled = 1
+
+# Warrior
+AiPlayerbot.RandomClassSpecProbability.1.0 = 20
+AiPlayerbot.RandomClassSpecProbability.1.1 = 30
+AiPlayerbot.RandomClassSpecProbability.1.2 = 50
+# Paladin
+AiPlayerbot.RandomClassSpecProbability.2.0 = 20
+AiPlayerbot.RandomClassSpecProbability.2.1 = 50
+AiPlayerbot.RandomClassSpecProbability.2.2 = 30
+# Hunter
+AiPlayerbot.RandomClassSpecProbability.3.0 = 25
+AiPlayerbot.RandomClassSpecProbability.3.1 = 50
+AiPlayerbot.RandomClassSpecProbability.3.2 = 25
+# Rogue
+AiPlayerbot.RandomClassSpecProbability.4.0 = 40
+AiPlayerbot.RandomClassSpecProbability.4.1 = 50
+AiPlayerbot.RandomClassSpecProbability.4.2 = 10
+# Priest
+AiPlayerbot.RandomClassSpecProbability.5.0 = 40
+AiPlayerbot.RandomClassSpecProbability.5.1 = 40
+AiPlayerbot.RandomClassSpecProbability.5.2 = 20
+# Shaman
+AiPlayerbot.RandomClassSpecProbability.7.0 = 10
+AiPlayerbot.RandomClassSpecProbability.7.1 = 45
+AiPlayerbot.RandomClassSpecProbability.7.2 = 45
+# Mage
+AiPlayerbot.RandomClassSpecProbability.8.0 = 20
+AiPlayerbot.RandomClassSpecProbability.8.1 = 10
+AiPlayerbot.RandomClassSpecProbability.8.2 = 70
+# Warlock
+AiPlayerbot.RandomClassSpecProbability.9.0 = 33
+AiPlayerbot.RandomClassSpecProbability.9.1 = 33
+AiPlayerbot.RandomClassSpecProbability.9.2 = 33
+# Druid
+AiPlayerbot.RandomClassSpecProbability.11.0 = 10
+AiPlayerbot.RandomClassSpecProbability.11.1 = 45
+AiPlayerbot.RandomClassSpecProbability.11.2 = 45
+
+#
+# All other parameters are optional but can be changed by uncommenting them here
+#
+
+# Prefix for bot chat commands (e.g. follow, stay)
+AiPlayerbot.CommandPrefix =
+
+# Max AI iterations per tick
+#AiPlayerbot.IterationsPerTick = 10
+
+# Allow/deny bots from your guild
+#AiPlayerbot.AllowGuildBots = 1
+
+# Delay between two short-time spells cast
+#AiPlayerbot.GlobalCooldown = 500
+
+# Max wait time when moving
+#AiPlayerbot.MaxWaitForMove = 5000
+
+# Delay between two bot actions
+#AiPlayerbot.ReactDelay = 100
+
+# Distances
+#AiPlayerbot.SightDistance = 75.0
+#AiPlayerbot.SpellDistance = 30.0
+#AiPlayerbot.ReactDistance = 150.0
+#AiPlayerbot.GrindDistance = 100.0
+#AiPlayerbot.LootDistance = 20.0
+#AiPlayerbot.FleeDistance = 20.0
+#AiPlayerbot.TooCloseDistance = 7.0
+#AiPlayerbot.MeleeDistance = 1.0
+#AiPlayerbot.FollowDistance = 1.5
+#AiPlayerbot.WhisperDistance = 6000.0
+#AiPlayerbot.ContactDistance = 0.5
+
+# Bot can flee for enemy
+#AiPlayerbot.FleeingEnabled = 1
+
+# Health/Mana levels
+#AiPlayerbot.CriticalHealth = 25
+#AiPlayerbot.LowHealth = 45
+#AiPlayerbot.MediumHealth = 65
+#AiPlayerbot.AlmostFullHealth = 85
+#AiPlayerbot.LowMana = 15
+#AiPlayerbot.MediumMana = 40
+
+# Enable random bot system
+#AiPlayerbot.RandomBotAutologin = 1
+
+# Random bot default strategies (applied after defaults)
+#AiPlayerbot.RandomBotCombatStrategies = +dps,+attack weak
+#AiPlayerbot.RandomBotNonCombatStrategies = +grind,+move random,+loot
+
+# Create random bot characters automatically
+#AiPlayerbot.RandomBotAutoCreate = 1
+
+# Random bot count
+#AiPlayerbot.MinRandomBots = 50
+#AiPlayerbot.MaxRandomBots = 200
+#AiPlayerbot.RandomBotMinLevel = 1
+#AiPlayerbot.RandomBotMaxLevel = 255 (ignored if more than MaxPlayerLevel mangosd.conf value)
+
+# Accounts to create for random bots
+#AiPlayerbot.RandomBotAccountPrefix = rndbot
+#AiPlayerbot.RandomBotAccountCount = 50
+
+# Delete all random bot accounts
+#AiPlayerbot.DeleteRandomBotAccounts = 0
+
+# Random bot guild count
+#AiPlayerbot.RandomBotGuildCount = 50
+
+# Guild Task system
+#AiPlayerbot.EnableGuildTasks = 1
+
+# How often tasks are changed
+#AiPlayerbot.MinGuildTaskChangeTime = 172800
+#AiPlayerbot.MaxGuildTaskChangeTime = 432000
+# Mail spam interval
+#AiPlayerbot.MinGuildTaskAdvertisementTime = 300
+#AiPlayerbot.MaxGuildTaskAdvertisementTime = 28800
+# Delay before reward is sent
+#AiPlayerbot.MinGuildTaskRewardTime = 300
+#AiPlayerbot.MaxGuildTaskRewardTime = 3600
+
+# Delete all random bot guilds
+#AiPlayerbot.DeleteRandomBotGuilds = 0
+
+# Maps to teleport random bots
+#AiPlayerbot.RandomBotMaps = 0,1,530,571
+
+# Change random bot has lower gear
+#AiPlayerbot.RandomGearLoweringChance = 0.15
+
+# Chance random bot has max level on first randomize
+#AiPlayerbot.RandomBotMaxLevelChance = 0.4
+
+# Quest items to leave (do not destroy)
+#AiPlayerbot.RandomBotQuestItems = 6948,5175,5176,5177,5178
+
+# Spells every random bot will learn on randomize (54197 - cold weather flying)
+#AiPlayerbot.RandomBotSpellIds = 54197
+
+# Enable LFG for random bots
+#AiPlayerbot.RandomBotJoinLfg = 1
+
+# Level diff between random bots and nearby creatures for random teleports
+AiPlayerbot.RandomBotTeleLevel = 3
+
+# Intervals
+#AiPlayerbot.RandomBotUpdateInterval = 60
+#AiPlayerbot.RandomBotCountChangeMinInterval = 86400
+#AiPlayerbot.RandomBotCountChangeMaxInterval = 259200
+#AiPlayerbot.MinRandomBotInWorldTime = 7200
+#AiPlayerbot.MaxRandomBotInWorldTime = 1209600
+#AiPlayerbot.MinRandomBotRandomizeTime = 7200
+#AiPlayerbot.MaxRandomRandomizeTime = 1209600
+#AiPlayerbot.MinRandomBotsPerInterval = 50
+#AiPlayerbot.MaxRandomBotsPerInterval = 100
+#AiPlayerbot.MinRandomBotsPriceChangeInterval = 7200
+#AiPlayerbot.MaxRandomBotsPriceChangeInterval = 172800
+
+# Log on all random bots on start
+#AiPlayerbot.RandomBotLoginAtStartup = 1
+
+# How far random bots are teleported after death
+#AiPlayerbot.RandomBotTeleportDistance = 1000
+
+# Debug switches
+#AiPlayerbot.SpellDump = 0
+#AiPlayerbot.LogInGroupOnly = 1
+#AiPlayerbot.LogValuesPerTick = 0
+#AiPlayerbot.RandomChangeMultiplier = 1
+
+# Command server port, 0 - disabled
+#AiPlayerbot.CommandServerPort = 8888
diff --git a/src/plugins/playerbot/playerbot.h b/src/plugins/playerbot/playerbot.h
new file mode 100644
index 0000000..0a925a8
--- /dev/null
+++ b/src/plugins/playerbot/playerbot.h
@@ -0,0 +1,31 @@
+#pragma once
+
+std::vector<std::string> split(const std::string &s, char delim);
+#ifndef WIN32
+int strcmpi(std::string s1, std::string s2);
+#endif
+
+#include "../Spell.h"
+#include "WorldPacket.h"
+#include "../Loot/LootMgr.h"
+#include "../Entities/Creature/GossipDef.h"
+#include "../Chat/Chat.h"
+#include "../../common/Common.h"
+#include "../World/World.h"
+#include "../Spells/SpellMgr.h"
+#include "../Globals/ObjectMgr.h"
+#include "../Entities/Unit/Unit.h"
+#include "../Miscellaneous/SharedDefines.h"
+#include "../Movement/MotionMaster.h"
+#include "../Spells/Auras/SpellAuras.h"
+#include "../Guilds/Guild.h"
+#include "../Groups/Group.h"
+#include "../../game/Accounts/AccountMgr.h"
+#include "../../game/Globals/ObjectMgr.h"
+
+#include "playerbotDefs.h"
+#include "PlayerbotAIAware.h"
+#include "PlayerbotMgr.h"
+#include "RandomPlayerbotMgr.h"
+#include "ChatHelper.h"
+#include "PlayerbotAI.h"
diff --git a/src/plugins/playerbot/playerbotDefs.h b/src/plugins/playerbot/playerbotDefs.h
new file mode 100644
index 0000000..3f59c93
--- /dev/null
+++ b/src/plugins/playerbot/playerbotDefs.h
@@ -0,0 +1,2 @@
+#pragma once
+
diff --git a/src/plugins/playerbot/strategy/Action.cpp b/src/plugins/playerbot/strategy/Action.cpp
new file mode 100644
index 0000000..75e3301
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Action.cpp
@@ -0,0 +1,93 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObjectContext.h"
+#include "Action.h"
+
+using namespace ai;
+
+int NextAction::size(NextAction** actions)
+{
+    if (!actions)
+        return 0;
+
+    int size;
+    for (size=0; size<10 && actions[size]; ) 
+        size++;
+    return size;
+}
+
+NextAction** NextAction::clone(NextAction** actions)
+{
+    if (!actions)
+        return NULL;
+
+    int size = NextAction::size(actions);
+
+    NextAction** res = new NextAction*[size + 1];
+    for (int i=0; i<size; i++)
+        res[i] = new NextAction(*actions[i]);
+    res[size] = NULL;
+    return res;
+}
+
+NextAction** NextAction::merge(NextAction** left, NextAction** right)
+{
+    int leftSize = NextAction::size(left);
+    int rightSize = NextAction::size(right);
+
+    NextAction** res = new NextAction*[leftSize + rightSize + 1];
+    for (int i=0; i<leftSize; i++)
+        res[i] = new NextAction(*left[i]);
+    for (int i=0; i<rightSize; i++)
+        res[leftSize + i] = new NextAction(*right[i]);
+    res[leftSize + rightSize] = NULL;
+
+    NextAction::destroy(left);
+    NextAction::destroy(right);
+
+    return res;
+}
+
+NextAction** NextAction::array(uint8 nil, ...)
+{
+    va_list vl;
+    va_start(vl, nil);
+    
+    int size = 0;
+    NextAction* cur = NULL;
+    do 
+    {
+        cur = va_arg(vl, NextAction*);
+        size++;
+    }
+    while (cur);
+
+    va_end(vl);
+
+    NextAction** res = new NextAction*[size];
+    va_start(vl, nil);
+    for (int i=0; i<size; i++)
+        res[i] = va_arg(vl, NextAction*);
+    va_end(vl);
+
+    return res;
+}
+
+void NextAction::destroy(NextAction** actions)
+{
+    if (!actions)
+        return;
+
+    for (int i=0; i<10 && actions[i]; i++)
+        delete actions[i];
+}
+
+Value<Unit*>* Action::GetTargetValue()
+{
+    return context->GetValue<Unit*>(GetTargetName());
+}
+
+Unit* Action::GetTarget()
+{
+    return GetTargetValue()->Get();
+}
diff --git a/src/plugins/playerbot/strategy/Action.h b/src/plugins/playerbot/strategy/Action.h
new file mode 100644
index 0000000..b8d2a1c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Action.h
@@ -0,0 +1,138 @@
+#pragma once
+#include "Event.h"
+#include "Value.h"
+#include "AiObject.h"
+
+namespace ai
+{
+    class NextAction
+    {
+    public:
+        NextAction(string name, float relevance = 0.0f)
+        {
+            this->name = name;
+            this->relevance = relevance;
+        }
+        NextAction(const NextAction& o)
+        {
+            this->name = o.name;
+            this->relevance = o.relevance;
+        }
+
+    public:
+        string getName() { return name; }
+        float getRelevance() {return relevance;}
+
+    public:
+        static int size(NextAction** actions);
+        static NextAction** clone(NextAction** actions);
+        static NextAction** merge(NextAction** what, NextAction** with);
+        static NextAction** array(uint8 nil,...);
+        static void destroy(NextAction** actions);
+
+    private:
+        float relevance;
+        std::string name;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class ActionBasket;
+
+    enum ActionThreatType
+    {
+        ACTION_THREAT_NONE = 0,
+        ACTION_THREAT_SINGLE= 1,
+        ACTION_THREAT_AOE = 2
+    };
+
+    class Action : public AiNamedObject
+	{
+	public:
+        Action(PlayerbotAI* ai, string name = "action") : verbose(false), AiNamedObject(ai, name) { }
+        virtual ~Action(void) {}
+
+    public:
+        virtual bool Execute(Event event) { return true; }
+        virtual bool isPossible() { return true; }
+        virtual bool isUseful() { return true; }
+        virtual NextAction** getPrerequisites() { return NULL; }
+        virtual NextAction** getAlternatives() { return NULL; }
+        virtual NextAction** getContinuers() { return NULL; }
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_NONE; }
+        void Update() {}
+        void Reset() {}
+        virtual Unit* GetTarget();
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string GetTargetName() { return "self target"; }
+        void MakeVerbose() { verbose = true; }
+
+    protected:
+        bool verbose;
+	};
+
+    class ActionNode
+    {
+    public:
+        ActionNode(string name, NextAction** prerequisites = NULL, NextAction** alternatives = NULL, NextAction** continuers = NULL)
+        {
+            this->action = NULL;
+            this->name = name;
+            this->prerequisites = prerequisites;
+            this->alternatives = alternatives;
+            this->continuers = continuers;
+        }
+        virtual ~ActionNode()
+        {
+            NextAction::destroy(prerequisites);
+            NextAction::destroy(alternatives);
+            NextAction::destroy(continuers);
+        }
+
+    public:
+        Action* getAction() { return action; }
+        void setAction(Action* action) { this->action = action; }
+        string getName() { return name; }
+
+    public:
+        NextAction** getContinuers() { return NextAction::merge(NextAction::clone(continuers), action->getContinuers()); }
+        NextAction** getAlternatives() { return NextAction::merge(NextAction::clone(alternatives), action->getAlternatives()); }
+        NextAction** getPrerequisites() { return NextAction::merge(NextAction::clone(prerequisites), action->getPrerequisites()); }
+
+    private:
+        string name;
+        Action* action;
+        NextAction** continuers;
+        NextAction** alternatives;
+        NextAction** prerequisites;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+	class ActionBasket
+	{
+	public:
+        ActionBasket(ActionNode* action, float relevance, bool skipPrerequisites, Event event) :
+          action(action), relevance(relevance), skipPrerequisites(skipPrerequisites), event(event) {}
+        virtual ~ActionBasket(void) {}
+	public:
+		float getRelevance() {return relevance;}
+		ActionNode* getAction() {return action;}
+        Event getEvent() { return event; }
+        bool isSkipPrerequisites() { return skipPrerequisites; }
+        void AmendRelevance(float k) {relevance *= k; }
+        void setRelevance(float relevance) { this->relevance = relevance; }
+	private:
+		ActionNode* action;
+		float relevance;
+        bool skipPrerequisites;
+        Event event;
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+
+}
+
+#define AI_VALUE(type, name) context->GetValue<type>(name)->Get()
+#define AI_VALUE2(type, name, param) context->GetValue<type>(name, param)->Get()
diff --git a/src/plugins/playerbot/strategy/ActionBasket.cpp b/src/plugins/playerbot/strategy/ActionBasket.cpp
new file mode 100644
index 0000000..ef8e4b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ActionBasket.cpp
@@ -0,0 +1,4 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "ActionBasket.h"
+
diff --git a/src/plugins/playerbot/strategy/ActionBasket.h b/src/plugins/playerbot/strategy/ActionBasket.h
new file mode 100644
index 0000000..d85293b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ActionBasket.h
@@ -0,0 +1,5 @@
+#pragma once
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/AiObject.cpp b/src/plugins/playerbot/strategy/AiObject.cpp
new file mode 100644
index 0000000..3b807e2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObject.cpp
@@ -0,0 +1,16 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObject.h"
+
+AiObject::AiObject(PlayerbotAI* ai) :
+    PlayerbotAIAware(ai),
+    bot(ai->GetBot()),
+    context(ai->GetAiObjectContext()),
+    chat(ai->GetChatHelper())
+{
+}
+
+Player* AiObject::GetMaster()
+{
+    return ai->GetMaster();
+}
diff --git a/src/plugins/playerbot/strategy/AiObject.h b/src/plugins/playerbot/strategy/AiObject.h
new file mode 100644
index 0000000..0b4f214
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObject.h
@@ -0,0 +1,33 @@
+#pragma once
+
+class PlayerbotAI;
+
+namespace ai
+{
+    class AiObjectContext;
+    class ChatHelper;
+
+    class AiObject : public PlayerbotAIAware
+	{
+	public:
+        AiObject(PlayerbotAI* ai);
+
+    protected:
+        Player* bot;
+        Player* GetMaster();
+        AiObjectContext* context;
+        ChatHelper* chat;
+	};
+
+    class AiNamedObject : public AiObject
+    {
+    public:
+        AiNamedObject(PlayerbotAI* ai, string name) : AiObject(ai), name(name) {}
+
+    public:
+        virtual string getName() { return name; }
+
+    protected:
+        string name;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/AiObjectContext.cpp b/src/plugins/playerbot/strategy/AiObjectContext.cpp
new file mode 100644
index 0000000..3c75542
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObjectContext.cpp
@@ -0,0 +1,48 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObjectContext.h"
+#include "NamedObjectContext.h"
+#include "StrategyContext.h"
+#include "triggers/TriggerContext.h"
+#include "actions/ActionContext.h"
+#include "triggers/ChatTriggerContext.h"
+#include "actions/ChatActionContext.h"
+#include "triggers/WorldPacketTriggerContext.h"
+#include "actions/WorldPacketActionContext.h"
+#include "values/ValueContext.h"
+
+using namespace ai;
+
+AiObjectContext::AiObjectContext(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    strategyContexts.Add(new StrategyContext());
+    strategyContexts.Add(new MovementStrategyContext());
+    strategyContexts.Add(new AssistStrategyContext());
+    strategyContexts.Add(new QuestStrategyContext());
+
+    actionContexts.Add(new ActionContext());
+    actionContexts.Add(new ChatActionContext());
+    actionContexts.Add(new WorldPacketActionContext());
+
+    triggerContexts.Add(new TriggerContext());
+    triggerContexts.Add(new ChatTriggerContext());
+    triggerContexts.Add(new WorldPacketTriggerContext());
+
+    valueContexts.Add(new ValueContext());
+}
+
+void AiObjectContext::Update()
+{
+    strategyContexts.Update();
+    triggerContexts.Update();
+    actionContexts.Update();
+    valueContexts.Update();
+}
+
+void AiObjectContext::Reset()
+{
+    strategyContexts.Reset();
+    triggerContexts.Reset();
+    actionContexts.Reset();
+    valueContexts.Reset();
+}
diff --git a/src/plugins/playerbot/strategy/AiObjectContext.h b/src/plugins/playerbot/strategy/AiObjectContext.h
new file mode 100644
index 0000000..d3750be
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObjectContext.h
@@ -0,0 +1,81 @@
+#pragma once
+
+#include "../PlayerbotAIAware.h"
+#include "Action.h"
+#include "Value.h"
+#include "NamedObjectContext.h"
+#include "Strategy.h"
+
+namespace ai
+{
+    class AiObjectContext : public PlayerbotAIAware
+    {
+    public:
+        AiObjectContext(PlayerbotAI* ai);
+        virtual ~AiObjectContext() {}
+
+    public:
+        virtual Strategy* GetStrategy(string name) { return strategyContexts.GetObject(name, ai); }
+        virtual set<string> GetSiblingStrategy(string name) { return strategyContexts.GetSiblings(name); }
+        virtual Trigger* GetTrigger(string name) { return triggerContexts.GetObject(name, ai); }
+        virtual Action* GetAction(string name) { return actionContexts.GetObject(name, ai); }
+        virtual UntypedValue* GetUntypedValue(string name) { return valueContexts.GetObject(name, ai); }
+
+        template<class T>
+        Value<T>* GetValue(string name)
+        {
+            return dynamic_cast<Value<T>*>(GetUntypedValue(name));
+        }
+
+        template<class T>
+        Value<T>* GetValue(string name, string param)
+        {
+            return GetValue<T>((string(name) + "::" + param));
+        }
+
+        template<class T>
+        Value<T>* GetValue(string name, uint32 param)
+        {
+        	ostringstream out; out << param;
+            return GetValue<T>(name, out.str());
+        }
+
+        set<string> GetSupportedStrategies()
+        {
+            return strategyContexts.supports();
+        }
+
+        string FormatValues()
+        {
+            ostringstream out;
+            set<string> names = valueContexts.GetCreated();
+            for (set<string>::iterator i = names.begin(); i != names.end(); ++i, out << "|")
+            {
+                UntypedValue* value = GetUntypedValue(*i);
+                if (!value)
+                    continue;
+
+                string text = value->Format();
+                if (text == "?")
+                    continue;
+
+                out << "{" << *i << "=" << text << "}";
+            }
+            return out.str();
+        }
+
+    public:
+        virtual void Update();
+        virtual void Reset();
+        virtual void AddShared(NamedObjectContext<UntypedValue>* sharedValues)
+        {
+            valueContexts.Add(sharedValues);
+        }
+
+    protected:
+        NamedObjectContextList<Strategy> strategyContexts;
+        NamedObjectContextList<Action> actionContexts;
+        NamedObjectContextList<Trigger> triggerContexts;
+        NamedObjectContextList<UntypedValue> valueContexts;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/CustomStrategy.cpp b/src/plugins/playerbot/strategy/CustomStrategy.cpp
new file mode 100644
index 0000000..ddc5511
--- /dev/null
+++ b/src/plugins/playerbot/strategy/CustomStrategy.cpp
@@ -0,0 +1,86 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "CustomStrategy.h"
+#include <regex>
+
+using namespace ai;
+
+map<string, string> CustomStrategy::actionLinesCache;
+
+NextAction* toNextAction(string action)
+{
+    vector<string> tokens = split(action, '|');
+    if (tokens.size() == 2)
+        return new NextAction(tokens[0], atof(tokens[1].c_str()));
+    else if (tokens.size() == 1)
+        return new NextAction(tokens[0], ACTION_NORMAL);
+
+    sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Invalid action '%s'", action);
+    return NULL;
+}
+
+NextAction** toNextActionArray(string actions)
+{
+    vector<string> tokens = split(actions, ',');
+    NextAction** res = new NextAction*[tokens.size() + 1];
+    int index = 0;
+    for (vector<string>::iterator i = tokens.begin(); i != tokens.end(); ++i)
+    {
+        res[index++] = toNextAction(*i);
+    }
+	res[index++] = NULL;
+    return res;
+}
+
+TriggerNode* toTriggerNode(string actionLine)
+{
+    vector<string> tokens = split(actionLine, '>');
+    if (tokens.size() == 2)
+        return new TriggerNode(tokens[0], toNextActionArray(tokens[1]));
+
+    sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Invalid action line '%s'", actionLine);
+    return NULL;
+}
+
+void CustomStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    if (actionLines.empty())
+    {
+        if (actionLinesCache[qualifier].empty())
+        {
+            QueryResult results = CharacterDatabase.PQuery("SELECT action_line FROM ai_playerbot_custom_strategy WHERE name = '%s'", qualifier.c_str());
+            if (results)
+            {
+                do
+                {
+                    Field* fields = results->Fetch();
+                    string action = fields[0].GetCString();
+                    this->actionLines.push_back(action);
+                } while (results->NextRow());
+            }
+        }
+        else
+        {
+            vector<string> tokens = split(actionLinesCache[qualifier], '\n');
+            regex tpl("\\(NULL,\\s*'.+',\\s*'(.+)'\\)(,|;)");
+            for (vector<string>::iterator i = tokens.begin(); i != tokens.end(); ++i)
+            {
+                string line = *i;
+                for (sregex_iterator j = sregex_iterator(line.begin(), line.end(), tpl); j != sregex_iterator(); ++j)
+                {
+                    smatch match = *j;
+                    string actionLine = match[1].str();
+                    if (!actionLine.empty())
+                        this->actionLines.push_back(actionLine);
+                }
+            }
+        }
+    }
+
+    for (list<string>::iterator i = actionLines.begin(); i != actionLines.end(); ++i)
+        triggers.push_back(toTriggerNode(*i));
+}
+
+CustomStrategy::CustomStrategy(PlayerbotAI* ai) : Strategy(ai), Qualified()
+{
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/CustomStrategy.h b/src/plugins/playerbot/strategy/CustomStrategy.h
new file mode 100644
index 0000000..bd55286
--- /dev/null
+++ b/src/plugins/playerbot/strategy/CustomStrategy.h
@@ -0,0 +1,21 @@
+#pragma once
+#include "Strategy.h"
+
+namespace ai
+{
+    class CustomStrategy : public Strategy, public Qualified
+    {
+    public:
+        CustomStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "custom::" + qualifier; }
+
+    private:
+        list<string> actionLines;
+
+    public:
+        static map<string, string> actionLinesCache;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Engine.cpp b/src/plugins/playerbot/strategy/Engine.cpp
new file mode 100644
index 0000000..25c46a7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Engine.cpp
@@ -0,0 +1,546 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+
+#include "Engine.h"
+#include "../PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+Engine::Engine(PlayerbotAI* ai, AiObjectContext *factory) : PlayerbotAIAware(ai), aiObjectContext(factory)
+{
+    lastRelevance = 0.0f;
+    testMode = false;
+}
+
+bool ActionExecutionListeners::Before(Action* action, Event event)
+{
+    bool result = true;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result &= (*i)->Before(action, event);
+    }
+    return result;
+}
+
+void ActionExecutionListeners::After(Action* action, bool executed, Event event)
+{
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        (*i)->After(action, executed, event);
+    }
+}
+
+bool ActionExecutionListeners::OverrideResult(Action* action, bool executed, Event event)
+{
+    bool result = executed;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result = (*i)->OverrideResult(action, result, event);
+    }
+    return result;
+}
+
+bool ActionExecutionListeners::AllowExecution(Action* action, Event event)
+{
+    bool result = true;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result &= (*i)->AllowExecution(action, event);
+    }
+    return result;
+}
+
+ActionExecutionListeners::~ActionExecutionListeners()
+{
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        delete *i;
+    }
+    listeners.clear();
+}
+
+
+Engine::~Engine(void)
+{
+    Reset();
+
+    strategies.clear();
+}
+
+void Engine::Reset()
+{
+    ActionNode* action = NULL;
+    do
+    {
+        action = queue.Pop();
+        delete action;
+    } while (action);
+
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        TriggerNode* trigger = *i;
+        delete trigger;
+    }
+    triggers.clear();
+
+    for (list<Multiplier*>::iterator i = multipliers.begin(); i != multipliers.end(); i++)
+    {
+        Multiplier* multiplier = *i;
+        delete multiplier;
+    }
+    multipliers.clear();
+}
+
+void Engine::Init()
+{
+    Reset();
+
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        strategy->InitMultipliers(multipliers);
+        strategy->InitTriggers(triggers);
+        Event emptyEvent;
+        MultiplyAndPush(strategy->getDefaultActions(), 0.0f, false, emptyEvent, "default");
+    }
+
+	if (testMode)
+	{
+        FILE* file = fopen("test.log", "w");
+        fprintf(file, "\n");
+        fclose(file);
+	}
+}
+
+
+bool Engine::DoNextAction(Unit* unit, int depth)
+{
+    LogAction("--- AI Tick ---");
+    if (sPlayerbotAIConfig.logValuesPerTick)
+        LogValues();
+
+    bool actionExecuted = false;
+    ActionBasket* basket = NULL;
+
+    time_t currentTime = time(0);
+    aiObjectContext->Update();
+    ProcessTriggers();
+
+    int iterations = 0;
+    int iterationsPerTick = queue.Size() * sPlayerbotAIConfig.iterationsPerTick;
+    do {
+        basket = queue.Peek();
+        if (basket) {
+            if (++iterations > iterationsPerTick)
+                break;
+
+            float relevance = basket->getRelevance(); // just for reference
+            bool skipPrerequisites = basket->isSkipPrerequisites();
+            Event event = basket->getEvent();
+            // NOTE: queue.Pop() deletes basket
+            ActionNode* actionNode = queue.Pop();
+            Action* action = InitializeAction(actionNode);
+
+            if (!action)
+            {
+                LogAction("A:%s - UNKNOWN", actionNode->getName().c_str());
+            }
+            else if (action->isUseful())
+            {
+                for (list<Multiplier*>::iterator i = multipliers.begin(); i!= multipliers.end(); i++)
+                {
+                    Multiplier* multiplier = *i;
+                    relevance *= multiplier->GetValue(action);
+                    if (!relevance)
+                    {
+                        LogAction("Multiplier %s made action %s useless", multiplier->getName().c_str(), action->getName().c_str());
+                        break;
+                    }
+                }
+
+                if (action->isPossible() && relevance)
+                {
+                    if (!skipPrerequisites)
+                    {
+                        LogAction("A:%s - PREREQ", action->getName().c_str());
+                        if (MultiplyAndPush(actionNode->getPrerequisites(), relevance + 0.02, false, event, "prereq"))
+                        {
+                            PushAgain(actionNode, relevance + 0.01, event);
+                            continue;
+                        }
+                    }
+
+                    actionExecuted = ListenAndExecute(action, event);
+
+                    if (actionExecuted)
+                    {
+                        LogAction("A:%s - OK", action->getName().c_str());
+                        MultiplyAndPush(actionNode->getContinuers(), 0, false, event, "cont");
+                        lastRelevance = relevance;
+                        delete actionNode;
+                        break;
+                    }
+                    else
+                    {
+                        LogAction("A:%s - FAILED", action->getName().c_str());
+                        MultiplyAndPush(actionNode->getAlternatives(), relevance + 0.03, false, event, "alt");
+                    }
+                }
+                else
+                {
+                    LogAction("A:%s - IMPOSSIBLE", action->getName().c_str());
+                    MultiplyAndPush(actionNode->getAlternatives(), relevance + 0.03, false, event, "alt");
+                }
+            }
+            else
+            {
+                lastRelevance = relevance;
+                LogAction("A:%s - USELESS", action->getName().c_str());
+            }
+            delete actionNode;
+        }
+    }
+    while (basket);
+
+    if (!basket)
+    {
+        lastRelevance = 0.0f;
+        PushDefaultActions();
+        if (queue.Peek() && depth < 2)
+            return DoNextAction(unit, depth + 1);
+    }
+
+    if (time(0) - currentTime > 1) {
+        LogAction("too long execution");
+    }
+
+    if (!actionExecuted)
+        LogAction("no actions executed");
+
+    return actionExecuted;
+}
+
+ActionNode* Engine::CreateActionNode(string name)
+{
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        ActionNode* node = strategy->GetAction(name);
+        if (node)
+            return node;
+    }
+    return new ActionNode (name,
+        /*P*/ NULL,
+        /*A*/ NULL,
+        /*C*/ NULL);
+}
+
+bool Engine::MultiplyAndPush(NextAction** actions, float forceRelevance, bool skipPrerequisites, Event event, const char* pushType)
+{
+    bool pushed = false;
+    if (actions)
+    {
+        for (int j=0; j<10; j++) // TODO: remove 10
+        {
+            NextAction* nextAction = actions[j];
+            if (nextAction)
+            {
+                ActionNode* action = CreateActionNode(nextAction->getName());
+                InitializeAction(action);
+
+                float k = nextAction->getRelevance();
+                if (forceRelevance > 0.0f)
+                {
+                    k = forceRelevance;
+                }
+
+                if (k > 0)
+                {
+                    LogAction("PUSH:%s - %f (%s)", action->getName().c_str(), k, pushType);
+                    queue.Push(new ActionBasket(action, k, skipPrerequisites, event));
+                    pushed = true;
+                }
+
+                delete nextAction;
+            }
+            else
+                break;
+        }
+        delete actions;
+    }
+    return pushed;
+}
+
+ActionResult Engine::ExecuteAction(string name)
+{
+	bool result = false;
+
+    ActionNode *actionNode = CreateActionNode(name);
+    if (!actionNode)
+        return ACTION_RESULT_UNKNOWN;
+
+    Action* action = InitializeAction(actionNode);
+    if (!action)
+        return ACTION_RESULT_UNKNOWN;
+
+    if (!action->isPossible())
+    {
+        delete actionNode;
+        return ACTION_RESULT_IMPOSSIBLE;
+    }
+
+    if (!action->isUseful())
+    {
+        delete actionNode;
+        return ACTION_RESULT_USELESS;
+    }
+
+    action->MakeVerbose();
+    Event emptyEvent;
+    result = ListenAndExecute(action, emptyEvent);
+    MultiplyAndPush(action->getContinuers(), 0.0f, false, emptyEvent, "default");
+    delete actionNode;
+	return result ? ACTION_RESULT_OK : ACTION_RESULT_FAILED;
+}
+
+void Engine::addStrategy(string name)
+{
+    removeStrategy(name);
+
+    Strategy* strategy = aiObjectContext->GetStrategy(name);
+    if (strategy)
+    {
+        set<string> siblings = aiObjectContext->GetSiblingStrategy(name);
+        for (set<string>::iterator i = siblings.begin(); i != siblings.end(); i++)
+            removeStrategy(*i);
+
+        LogAction("S:+%s", strategy->getName().c_str());
+        strategies[strategy->getName()] = strategy;
+    }
+    Init();
+}
+
+void Engine::addStrategies(string first, ...)
+{
+	addStrategy(first);
+
+	va_list vl;
+	va_start(vl, first);
+
+	const char* cur;
+	do
+	{
+		cur = va_arg(vl, const char*);
+		if (cur)
+			addStrategy(cur);
+	}
+	while (cur);
+
+	va_end(vl);
+}
+
+bool Engine::removeStrategy(string name)
+{
+    map<string, Strategy*>::iterator i = strategies.find(name);
+    if (i == strategies.end())
+        return false;
+
+    LogAction("S:-%s", name.c_str());
+    strategies.erase(i);
+    Init();
+    return true;
+}
+
+void Engine::removeAllStrategies()
+{
+    strategies.clear();
+    Init();
+}
+
+void Engine::toggleStrategy(string name)
+{
+    if (!removeStrategy(name))
+        addStrategy(name);
+}
+
+bool Engine::HasStrategy(string name)
+{
+    return strategies.find(name) != strategies.end();
+}
+
+void Engine::ProcessTriggers()
+{
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        TriggerNode* node = *i;
+        if (!node)
+            continue;
+
+        Trigger* trigger = node->getTrigger();
+        if (!trigger)
+        {
+            trigger = aiObjectContext->GetTrigger(node->getName());
+            node->setTrigger(trigger);
+        }
+
+        if (!trigger)
+            continue;
+
+        if (testMode || trigger->needCheck())
+        {
+            Event event = trigger->Check();
+            if (!event)
+                continue;
+
+            LogAction("T:%s", trigger->getName().c_str());
+            MultiplyAndPush(node->getHandlers(), 0.0f, false, event, "trigger");
+        }
+    }
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        Trigger* trigger = (*i)->getTrigger();
+        if (trigger) trigger->Reset();
+    }
+}
+
+void Engine::PushDefaultActions()
+{
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        Event emptyEvent;
+        MultiplyAndPush(strategy->getDefaultActions(), 0.0f, false, emptyEvent, "default");
+    }
+}
+
+string Engine::ListStrategies()
+{
+    string s = "Strategies: ";
+
+    if (strategies.empty())
+        return s;
+
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        s.append(i->first);
+        s.append(", ");
+    }
+    return s.substr(0, s.length() - 2);
+}
+
+void Engine::PushAgain(ActionNode* actionNode, float relevance, Event event)
+{
+    NextAction** nextAction = new NextAction*[2];
+    nextAction[0] = new NextAction(actionNode->getName(), relevance);
+    nextAction[1] = NULL;
+    MultiplyAndPush(nextAction, relevance, true, event, "again");
+    delete actionNode;
+}
+
+bool Engine::ContainsStrategy(StrategyType type)
+{
+	for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+	{
+		Strategy* strategy = i->second;
+		if (strategy->GetType() & type)
+			return true;
+	}
+	return false;
+}
+
+Action* Engine::InitializeAction(ActionNode* actionNode)
+{
+    Action* action = actionNode->getAction();
+    if (!action)
+    {
+        action = aiObjectContext->GetAction(actionNode->getName());
+        actionNode->setAction(action);
+    }
+    return action;
+}
+
+bool Engine::ListenAndExecute(Action* action, Event event)
+{
+    bool actionExecuted = false;
+
+    if (actionExecutionListeners.Before(action, event))
+    {
+        actionExecuted = actionExecutionListeners.AllowExecution(action, event) ? action->Execute(event) : true;
+    }
+
+    actionExecuted = actionExecutionListeners.OverrideResult(action, actionExecuted, event);
+    actionExecutionListeners.After(action, actionExecuted, event);
+    return actionExecuted;
+}
+
+void Engine::LogAction(const char* format, ...)
+{
+    char buf[1024];
+
+    va_list ap;
+    va_start(ap, format);
+    vsprintf(buf, format, ap);
+    va_end(ap);
+    lastAction += "|";
+    lastAction += buf;
+    if (lastAction.size() > 512)
+    {
+        lastAction = lastAction.substr(512);
+        size_t pos = lastAction.find("|");
+        lastAction = (pos == string::npos ? "" : lastAction.substr(pos));
+    }
+
+    if (testMode)
+    {
+        FILE* file = fopen("test.log", "a");
+        fprintf(file, buf);
+        fprintf(file, "\n");
+        fclose(file);
+    }
+    else
+    {
+        Player* bot = ai->GetBot();
+        if (sPlayerbotAIConfig.logInGroupOnly && !bot->GetGroup())
+            return;
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "%s %s", bot->GetName().c_str(), buf);
+    }
+}
+
+void Engine::ChangeStrategy(string names)
+{
+    vector<string> splitted = split(names, ',');
+    for (vector<string>::iterator i = splitted.begin(); i != splitted.end(); i++)
+    {
+        const char* name = i->c_str();
+        switch (name[0])
+        {
+        case '+':
+            addStrategy(name+1);
+            break;
+        case '-':
+            removeStrategy(name+1);
+            break;
+        case '~':
+            toggleStrategy(name+1);
+            break;
+        case '?':
+            ai->TellMaster(ListStrategies());
+            break;
+        }
+    }
+}
+
+void Engine::LogValues()
+{
+    if (testMode)
+        return;
+
+    Player* bot = ai->GetBot();
+    if (sPlayerbotAIConfig.logInGroupOnly && !bot->GetGroup())
+        return;
+
+    string text = ai->GetAiObjectContext()->FormatValues();
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Values for %s: %s", bot->GetName().c_str(), text.c_str());
+}
diff --git a/src/plugins/playerbot/strategy/Engine.h b/src/plugins/playerbot/strategy/Engine.h
new file mode 100644
index 0000000..a904534
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Engine.h
@@ -0,0 +1,123 @@
+#pragma once
+
+#include "Action.h"
+#include "Queue.h"
+#include "Trigger.h"
+#include "Multiplier.h"
+#include "AiObjectContext.h"
+#include "Strategy.h"
+
+namespace ai
+{
+    class ActionExecutionListener
+    {
+    public:
+        virtual bool Before(Action* action, Event event) = 0;
+        virtual bool AllowExecution(Action* action, Event event) = 0;
+        virtual void After(Action* action, bool executed, Event event) = 0;
+        virtual bool OverrideResult(Action* action, bool executed, Event event) = 0;
+    };
+
+    // -----------------------------------------------------------------------------------------------------------------------
+
+    class ActionExecutionListeners : public ActionExecutionListener
+    {
+    public:
+        virtual ~ActionExecutionListeners();
+
+    // ActionExecutionListener
+    public:
+        virtual bool Before(Action* action, Event event);
+        virtual bool AllowExecution(Action* action, Event event);
+        virtual void After(Action* action, bool executed, Event event);
+        virtual bool OverrideResult(Action* action, bool executed, Event event);
+
+    public:
+        void Add(ActionExecutionListener* listener)
+        {
+            listeners.push_back(listener);
+        }
+        void Remove(ActionExecutionListener* listener)
+        {
+            listeners.remove(listener);
+        }
+
+    private:
+        std::list<ActionExecutionListener*> listeners;
+    };
+
+    // -----------------------------------------------------------------------------------------------------------------------
+
+    enum ActionResult
+    {
+        ACTION_RESULT_UNKNOWN,
+        ACTION_RESULT_OK,
+        ACTION_RESULT_IMPOSSIBLE,
+        ACTION_RESULT_USELESS,
+        ACTION_RESULT_FAILED
+    };
+
+    class Engine : public PlayerbotAIAware
+    {
+    public:
+        Engine(PlayerbotAI* ai, AiObjectContext *factory);
+
+	    void Init();
+        void addStrategy(string name);
+		void addStrategies(string first, ...);
+        bool removeStrategy(string name);
+        bool HasStrategy(string name);
+        void removeAllStrategies();
+        void toggleStrategy(string name);
+        std::string ListStrategies();
+		bool ContainsStrategy(StrategyType type);
+		void ChangeStrategy(string names);
+		string GetLastAction() { return lastAction; }
+
+    public:
+	    virtual bool DoNextAction(Unit*, int depth = 0);
+	    ActionResult ExecuteAction(string name);
+
+    public:
+        void AddActionExecutionListener(ActionExecutionListener* listener)
+        {
+            actionExecutionListeners.Add(listener);
+        }
+        void removeActionExecutionListener(ActionExecutionListener* listener)
+        {
+            actionExecutionListeners.Remove(listener);
+        }
+
+    public:
+	    virtual ~Engine(void);
+
+    private:
+        bool MultiplyAndPush(NextAction** actions, float forceRelevance, bool skipPrerequisites, Event event, const char* pushType);
+        void Reset();
+        void ProcessTriggers();
+        void PushDefaultActions();
+        void PushAgain(ActionNode* actionNode, float relevance, Event event);
+        ActionNode* CreateActionNode(string name);
+        Action* InitializeAction(ActionNode* actionNode);
+        bool ListenAndExecute(Action* action, Event event);
+
+    private:
+        void LogAction(const char* format, ...);
+        void LogValues();
+
+    protected:
+	    Queue queue;
+	    std::list<TriggerNode*> triggers;
+        std::list<Multiplier*> multipliers;
+        AiObjectContext* aiObjectContext;
+        std::map<string, Strategy*> strategies;
+        float lastRelevance;
+        std::string lastAction;
+
+    public:
+		bool testMode;
+
+    private:
+        ActionExecutionListeners actionExecutionListeners;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Event.cpp b/src/plugins/playerbot/strategy/Event.cpp
new file mode 100644
index 0000000..1a0f28c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Event.cpp
@@ -0,0 +1,20 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Event.h"
+
+
+using namespace ai;
+
+ObjectGuid Event::getObject()
+{
+    if (packet.empty())
+        return ObjectGuid();
+
+    WorldPacket p(packet);
+    p.rpos(0);
+    
+    ObjectGuid guid;
+    p >> guid;
+
+    return guid;
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Event.h b/src/plugins/playerbot/strategy/Event.h
new file mode 100644
index 0000000..86ea279
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Event.h
@@ -0,0 +1,36 @@
+#pragma once
+
+namespace ai
+{
+    class Event
+	{
+	public:
+        Event(Event const& other)
+        {
+            source = other.source;
+            param = other.param;
+            packet = other.packet;
+            owner = other.owner;
+        }
+        Event() {}
+        Event(string source) : source(source) {}
+        Event(string source, string param, Player* owner = NULL) : source(source), param(param), owner(owner) {}
+        Event(string source, WorldPacket &packet, Player* owner = NULL) : source(source), packet(packet), owner(owner) {}
+        virtual ~Event() {}
+
+	public:
+        string getSource() { return source; }
+        string getParam() { return param; }
+        WorldPacket& getPacket() { return packet; }
+        ObjectGuid getObject();
+        Player* getOwner() { return owner; }
+        bool operator! () const { return source.empty(); }
+
+    protected:
+        string source;
+        string param;
+        WorldPacket packet;
+        ObjectGuid object;
+        Player* owner;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/ExternalEventHelper.h b/src/plugins/playerbot/strategy/ExternalEventHelper.h
new file mode 100644
index 0000000..a25154e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ExternalEventHelper.h
@@ -0,0 +1,69 @@
+#pragma once
+
+#include "Trigger.h"
+
+namespace ai
+{
+    class ExternalEventHelper {
+    public:
+        ExternalEventHelper(AiObjectContext* aiObjectContext) : aiObjectContext(aiObjectContext) {}
+
+        bool ParseChatCommand(string command, Player* owner = NULL)
+        {
+            if (HandleCommand(command, "", owner))
+                return true;
+
+            size_t i = string::npos;
+            while (true)
+            {
+                size_t found = command.rfind(" ", i);
+                if (found == string::npos || !found)
+                    break;
+
+                string name = command.substr(0, found);
+                string param = command.substr(found + 1);
+
+                i = found - 1;
+
+                if (HandleCommand(name, param, owner))
+                    return true;
+            }
+
+            if (!ChatHelper::parseable(command))
+                return false;
+
+            HandleCommand("q", command, owner);
+            HandleCommand("c", command, owner);
+            HandleCommand("t", command, owner);
+            return true;
+        }
+
+        void HandlePacket(map<uint16, string> &handlers, const WorldPacket &packet, Player* owner = NULL)
+        {
+            uint16 opcode = packet.GetOpcode();
+            string name = handlers[opcode];
+            if (name.empty())
+                return;
+
+            Trigger* trigger = aiObjectContext->GetTrigger(name);
+            if (!trigger)
+                return;
+
+            WorldPacket p(packet);
+            trigger->ExternalEvent(p, owner);
+        }
+
+        bool HandleCommand(string name, string param, Player* owner = NULL)
+        {
+            Trigger* trigger = aiObjectContext->GetTrigger(name);
+            if (!trigger)
+                return false;
+
+            trigger->ExternalEvent(param, owner);
+            return true;
+        }
+
+    private:
+        AiObjectContext* aiObjectContext;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/ItemVisitors.h b/src/plugins/playerbot/strategy/ItemVisitors.h
new file mode 100644
index 0000000..09deb17
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ItemVisitors.h
@@ -0,0 +1,258 @@
+#pragma once
+
+char * strstri (const char* str1, const char* str2);
+
+namespace ai
+{
+    class IterateItemsVisitor
+    {
+    public:
+        IterateItemsVisitor() {}
+
+        virtual bool Visit(Item* item) = 0;
+    };
+
+    class FindItemVisitor : public IterateItemsVisitor {
+    public:
+        FindItemVisitor() : IterateItemsVisitor(), result(NULL) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (!Accept(item->GetTemplate()))
+                return true;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult() { return result; }
+
+    protected:
+        virtual bool Accept(const ItemTemplate* proto) = 0;
+
+    private:
+        list<Item*> result;
+    };
+
+    enum IterateItemsMask
+    {
+        ITERATE_ITEMS_IN_BAGS = 1,
+        ITERATE_ITEMS_IN_EQUIP = 2,
+        ITERATE_ALL_ITEMS = 255
+    };
+
+    class FindUsableItemVisitor : public FindItemVisitor {
+    public:
+        FindUsableItemVisitor(Player* bot) : FindItemVisitor()
+        {
+            this->bot = bot;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (bot->CanUseItem(item->GetTemplate()) == EQUIP_ERR_OK)
+                return FindItemVisitor::Visit(item);
+
+            return true;
+        }
+
+    private:
+        Player* bot;
+    };
+
+
+    class FindItemsByQualityVisitor : public IterateItemsVisitor
+    {
+    public:
+        FindItemsByQualityVisitor(uint32 quality, int count) : IterateItemsVisitor()
+        {
+            this->quality = quality;
+            this->count = count;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->GetTemplate()->Quality != quality)
+                return true;
+
+            if (result.size() >= (size_t)count)
+                return false;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult()
+        {
+            return result;
+        }
+
+    private:
+        uint32 quality;
+        int count;
+        list<Item*> result;
+    };
+
+    class FindItemsToTradeByQualityVisitor : public FindItemsByQualityVisitor
+    {
+    public:
+        FindItemsToTradeByQualityVisitor(uint32 quality, int count) : FindItemsByQualityVisitor(quality, count) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->IsSoulBound())
+                return true;
+
+            return FindItemsByQualityVisitor::Visit(item);
+        }
+    };
+
+    class FindItemsToTradeByClassVisitor : public IterateItemsVisitor
+    {
+    public:
+        FindItemsToTradeByClassVisitor(uint32 itemClass, uint32 itemSubClass, int count)
+            : IterateItemsVisitor(), count(count), itemClass(itemClass), itemSubClass(itemSubClass) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->IsSoulBound())
+                return true;
+
+            if (item->GetTemplate()->Class != itemClass || item->GetTemplate()->SubClass != itemSubClass)
+                return true;
+
+            if (result.size() >= (size_t)count)
+                return false;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult()
+        {
+            return result;
+        }
+
+    private:
+        uint32 itemClass;
+        uint32 itemSubClass;
+        int count;
+        list<Item*> result;
+    };
+
+    class QueryItemCountVisitor : public IterateItemsVisitor
+    {
+    public:
+        QueryItemCountVisitor(uint32 itemId)
+        {
+            count = 0;
+            this->itemId = itemId;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->GetTemplate()->ItemId == itemId)
+                count += item->GetCount();
+
+            return true;
+        }
+
+        int GetCount() { return count; }
+
+    protected:
+        int count;
+        uint32 itemId;
+    };
+
+
+    class QueryNamedItemCountVisitor : public QueryItemCountVisitor
+    {
+    public:
+        QueryNamedItemCountVisitor(string name) : QueryItemCountVisitor(0)
+        {
+            this->name = name;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            const ItemTemplate* proto = item->GetTemplate();
+            if (proto && !proto->Name1.empty() && strstri(proto->Name1.c_str(), name.c_str()))
+                count += item->GetCount();
+
+            return true;
+        }
+
+    private:
+        string name;
+    };
+
+    class FindUsableNamedItemVisitor : public FindUsableItemVisitor {
+    public:
+        FindUsableNamedItemVisitor(Player* bot, string name) : FindUsableItemVisitor(bot)
+        {
+            this->name = name;
+        }
+
+        virtual bool Accept(const ItemTemplate* proto)
+        {
+            return proto && !proto->Name1.empty() && strstri(proto->Name1.c_str(), name.c_str());
+        }
+
+    private:
+        string name;
+    };
+
+    class FindItemByIdVisitor : public FindItemVisitor {
+    public:
+        FindItemByIdVisitor(uint32 id) : FindItemVisitor()
+        {
+            this->id = id;
+        }
+
+        virtual bool Accept(const ItemTemplate* proto)
+        {
+            return proto->ItemId == id;
+        }
+
+    private:
+        uint32 id;
+    };
+
+    class ListItemsVisitor : public IterateItemsVisitor
+    {
+    public:
+        ListItemsVisitor() : IterateItemsVisitor() {}
+
+        map<uint32, int> items;
+
+        virtual bool Visit(Item* item)
+        {
+            uint32 id = item->GetTemplate()->ItemId;
+
+            if (items.find(id) == items.end())
+                items[id] = 0;
+
+            items[id] += item->GetCount();
+            return true;
+        }
+    };
+
+    class ItemCountByQuality : public IterateItemsVisitor
+    {
+    public:
+        ItemCountByQuality() : IterateItemsVisitor()
+        {
+            for (uint32 i = 0; i < MAX_ITEM_QUALITY; ++i)
+                count[i] = 0;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            count[item->GetTemplate()->Quality]++;
+            return true;
+        }
+
+    public:
+        map<uint32, int> count;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Multiplier.cpp b/src/plugins/playerbot/strategy/Multiplier.cpp
new file mode 100644
index 0000000..893d7f3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Multiplier.cpp
@@ -0,0 +1,5 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Multiplier.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Multiplier.h b/src/plugins/playerbot/strategy/Multiplier.h
new file mode 100644
index 0000000..e86fa05
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Multiplier.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "Action.h"
+
+namespace ai
+{
+    class Multiplier : public AiNamedObject
+    {
+    public:
+        Multiplier(PlayerbotAI* ai, string name) : AiNamedObject(ai, name) {}
+        virtual ~Multiplier() {}
+
+    public:
+        virtual float GetValue(Action* action) { return 1.0f; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/NamedObjectContext.h b/src/plugins/playerbot/strategy/NamedObjectContext.h
new file mode 100644
index 0000000..e79caf5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/NamedObjectContext.h
@@ -0,0 +1,249 @@
+#pragma once
+
+namespace ai
+{
+    using namespace std;
+
+    class Qualified
+    {
+    public:
+        Qualified() {};
+
+    public:
+        virtual void Qualify(string qualifier) { this->qualifier = qualifier; }
+
+    protected:
+        string qualifier;
+    };
+
+    template <class T> class NamedObjectFactory
+    {
+    protected:
+        typedef T* (*ActionCreator) (PlayerbotAI* ai);
+        map<string, ActionCreator> creators;
+
+    public:
+        T* create(string name, PlayerbotAI* ai)
+        {
+            size_t found = name.find("::");
+            string qualifier;
+            if (found != string::npos)
+            {
+                qualifier = name.substr(found + 2);
+                name = name.substr(0, found);
+            }
+
+            if (creators.find(name) == creators.end())
+                return NULL;
+
+            ActionCreator creator = creators[name];
+            if (!creator)
+                return NULL;
+
+            T *object = (*creator)(ai);
+            Qualified *q = dynamic_cast<Qualified *>(object);
+            if (q)
+                q->Qualify(qualifier);
+
+            return object;
+        }
+
+        set<string> supports()
+        {
+            set<string> keys;
+            for (typename map<string, ActionCreator>::iterator it = creators.begin(); it != creators.end(); it++)
+                keys.insert(it->first);
+            return keys;
+        }
+    };
+
+
+    template <class T> class NamedObjectContext : public NamedObjectFactory<T>
+    {
+    public:
+        NamedObjectContext(bool shared = false, bool supportsSiblings = false) :
+            NamedObjectFactory<T>(), shared(shared), supportsSiblings(supportsSiblings) {}
+
+        T* create(string name, PlayerbotAI* ai)
+        {
+            if (created.find(name) == created.end())
+                return created[name] = NamedObjectFactory<T>::create(name, ai);
+
+            return created[name];
+        }
+
+        virtual ~NamedObjectContext()
+        {
+            Clear();
+        }
+
+        void Clear()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    delete i->second;
+            }
+
+            created.clear();
+        }
+
+        void Update()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    i->second->Update();
+            }
+        }
+
+        void Reset()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    i->second->Reset();
+            }
+        }
+
+        bool IsShared() { return shared; }
+        bool IsSupportsSiblings() { return supportsSiblings; }
+
+        set<string> GetCreated()
+        {
+            set<string> keys;
+            for (typename map<string, T*>::iterator it = created.begin(); it != created.end(); it++)
+                keys.insert(it->first);
+            return keys;
+        }
+
+    protected:
+        map<string, T*> created;
+        bool shared;
+        bool supportsSiblings;
+    };
+
+    template <class T> class NamedObjectContextList
+    {
+    public:
+        virtual ~NamedObjectContextList()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                NamedObjectContext<T>* context = *i;
+                if (!context->IsShared())
+                    delete context;
+            }
+        }
+
+        void Add(NamedObjectContext<T>* context)
+        {
+            contexts.push_back(context);
+        }
+
+        T* GetObject(string name, PlayerbotAI* ai)
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                T* object = (*i)->create(name, ai);
+                if (object) return object;
+            }
+            return NULL;
+        }
+
+        void Update()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                if (!(*i)->IsShared())
+                    (*i)->Update();
+            }
+        }
+
+        void Reset()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                (*i)->Reset();
+            }
+        }
+
+        set<string> GetSiblings(string name)
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                if (!(*i)->IsSupportsSiblings())
+                    continue;
+
+                set<string> supported = (*i)->supports();
+                set<string>::iterator found = supported.find(name);
+                if (found == supported.end())
+                    continue;
+
+                supported.erase(found);
+                return supported;
+            }
+
+            return set<string>();
+        }
+
+        set<string> supports()
+        {
+            set<string> result;
+
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                set<string> supported = (*i)->supports();
+
+                for (set<string>::iterator j = supported.begin(); j != supported.end(); j++)
+                    result.insert(*j);
+            }
+            return result;
+        }
+
+        set<string> GetCreated()
+        {
+            set<string> result;
+
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                set<string> createdKeys = (*i)->GetCreated();
+
+                for (set<string>::iterator j = createdKeys.begin(); j != createdKeys.end(); j++)
+                    result.insert(*j);
+            }
+            return result;
+        }
+
+    private:
+        list<NamedObjectContext<T>*> contexts;
+    };
+
+    template <class T> class NamedObjectFactoryList
+    {
+    public:
+        virtual ~NamedObjectFactoryList()
+        {
+            for (typename list<NamedObjectFactory<T>*>::iterator i = factories.begin(); i != factories.end(); i++)
+                delete *i;
+        }
+
+        void Add(NamedObjectFactory<T>* context)
+        {
+            factories.push_front(context);
+        }
+
+        T* GetObject(string name, PlayerbotAI* ai)
+        {
+            for (typename list<NamedObjectFactory<T>*>::iterator i = factories.begin(); i != factories.end(); i++)
+            {
+                T* object = (*i)->create(name, ai);
+                if (object) return object;
+            }
+            return NULL;
+        }
+
+    private:
+        list<NamedObjectFactory<T>*> factories;
+    };
+};
diff --git a/src/plugins/playerbot/strategy/PassiveMultiplier.cpp b/src/plugins/playerbot/strategy/PassiveMultiplier.cpp
new file mode 100644
index 0000000..f987438
--- /dev/null
+++ b/src/plugins/playerbot/strategy/PassiveMultiplier.cpp
@@ -0,0 +1,47 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "PassiveMultiplier.h"
+
+using namespace ai;
+
+list<string> PassiveMultiplier::allowedActions;
+list<string> PassiveMultiplier::allowedParts;
+
+PassiveMultiplier::PassiveMultiplier(PlayerbotAI* ai) : Multiplier(ai, "passive")
+{
+    if (allowedActions.empty())
+    {
+        allowedActions.push_back("co");
+        allowedActions.push_back("nc");
+        allowedActions.push_back("reset ai");
+        allowedActions.push_back("check mount state");
+    }
+
+    if (allowedParts.empty())
+    {
+        allowedParts.push_back("follow");
+        allowedParts.push_back("stay");
+        allowedParts.push_back("chat shortcut");
+    }
+}
+
+float PassiveMultiplier::GetValue(Action* action) {
+    if (!action)
+		return 1.0f;
+
+    string name = action->getName();
+
+    for (list<string>::iterator i = allowedActions.begin(); i != allowedActions.end(); i++)
+    {
+        if (name == *i)
+            return 1.0f;
+    }
+
+    for (list<string>::iterator i = allowedParts.begin(); i != allowedParts.end(); i++)
+    {
+        if (name.find(*i) != string::npos)
+            return 1.0f;
+    }
+
+    return 0;
+}
diff --git a/src/plugins/playerbot/strategy/PassiveMultiplier.h b/src/plugins/playerbot/strategy/PassiveMultiplier.h
new file mode 100644
index 0000000..37985a0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/PassiveMultiplier.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "Action.h"
+#include "Multiplier.h"
+
+namespace ai
+{
+    class PassiveMultiplier : public Multiplier
+    {
+    public:
+        PassiveMultiplier(PlayerbotAI* ai);
+
+    public:
+        virtual float GetValue(Action* action);
+
+    private:
+        static list<string> allowedActions;
+        static list<string> allowedParts;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/Queue.cpp b/src/plugins/playerbot/strategy/Queue.cpp
new file mode 100644
index 0000000..8553b44
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Queue.cpp
@@ -0,0 +1,81 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Action.h"
+#include "Queue.h"
+
+using namespace ai;
+
+
+void Queue::Push(ActionBasket *action)
+{
+	if (action)
+    {
+        for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+        {
+            ActionBasket* basket = *iter;
+            if (action->getAction()->getName() == basket->getAction()->getName())
+            {
+				if (basket->getRelevance() < action->getRelevance())
+					basket->setRelevance(action->getRelevance());
+                delete action;
+                return;
+            }
+        }
+		actions.push_back(action);
+    }
+}
+
+void Queue::Push(ActionBasket **actions)
+{
+	if (actions)
+	{
+		for (int i=0; i<sizeof(actions)/sizeof(ActionBasket*); i++)
+		{
+			Push(actions[i]);
+		}
+	}
+}
+
+ActionNode* Queue::Pop()
+{
+	float max = -1;
+	ActionBasket* selection = NULL;
+	for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+	{
+		ActionBasket* basket = *iter;
+		if (basket->getRelevance() > max)
+		{
+			max = basket->getRelevance();
+			selection = basket;
+		}
+	}
+	if (selection != NULL)
+	{
+		ActionNode* action = selection->getAction();
+		actions.remove(selection);
+		delete selection;
+		return action;
+	}
+	return NULL;
+}
+
+ActionBasket* Queue::Peek()
+{
+    float max = -1;
+    ActionBasket* selection = NULL;
+    for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+    {
+        ActionBasket* basket = *iter;
+        if (basket->getRelevance() > max)
+        {
+            max = basket->getRelevance();
+            selection = basket;
+        }
+    }
+    return selection;
+}
+
+int Queue::Size()
+{
+	return actions.size();
+}
diff --git a/src/plugins/playerbot/strategy/Queue.h b/src/plugins/playerbot/strategy/Queue.h
new file mode 100644
index 0000000..b70a526
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Queue.h
@@ -0,0 +1,21 @@
+#include "ActionBasket.h"
+
+#pragma once
+namespace ai
+{
+class Queue
+{
+public:
+    Queue(void) {}
+public:
+    ~Queue(void) {}
+public:
+	void Push(ActionBasket *action);
+	void Push(ActionBasket **actions);
+	ActionNode* Pop();
+    ActionBasket* Peek();
+	int Size();
+private:
+	std::list<ActionBasket*> actions;
+};
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Strategy.cpp b/src/plugins/playerbot/strategy/Strategy.cpp
new file mode 100644
index 0000000..65ba60f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Strategy.cpp
@@ -0,0 +1,117 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Strategy.h"
+#include "NamedObjectContext.h"
+
+using namespace ai;
+using namespace std;
+
+
+class ActionNodeFactoryInternal : public NamedObjectFactory<ActionNode>
+{
+public:
+    ActionNodeFactoryInternal()
+    {
+        creators["melee"] = &melee;
+        creators["healthstone"] = &healthstone;
+        creators["be near"] = &follow_master_random;
+        creators["attack anything"] = &attack_anything;
+        creators["move random"] = &move_random;
+        creators["move to loot"] = &move_to_loot;
+        creators["food"] = &food;
+        creators["drink"] = &drink;
+        creators["mana potion"] = &mana_potion;
+        creators["healing potion"] = &healing_potion;
+        creators["flee"] = &flee;
+    }
+
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* healthstone(PlayerbotAI* ai)
+    {
+        return new ActionNode ("healthstone",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing potion"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* follow_master_random(PlayerbotAI* ai)
+    {
+        return new ActionNode ("be near",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("follow"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* attack_anything(PlayerbotAI* ai)
+    {
+        return new ActionNode ("attack anything",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* move_random(PlayerbotAI* ai)
+    {
+        return new ActionNode ("move random",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("stay line"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* move_to_loot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("move to loot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* food(PlayerbotAI* ai)
+    {
+        return new ActionNode ("food",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* drink(PlayerbotAI* ai)
+    {
+        return new ActionNode ("drink",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mana_potion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mana potion",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drink"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* healing_potion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("healing potion",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("food"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* flee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("flee",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+Strategy::Strategy(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    actionNodeFactories.Add(new ActionNodeFactoryInternal());
+}
+
+ActionNode* Strategy::GetAction(string name)
+{
+    return actionNodeFactories.GetObject(name, ai);
+}
+
diff --git a/src/plugins/playerbot/strategy/Strategy.h b/src/plugins/playerbot/strategy/Strategy.h
new file mode 100644
index 0000000..12e98eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Strategy.h
@@ -0,0 +1,55 @@
+#pragma once
+#include "Action.h"
+#include "Multiplier.h"
+#include "Trigger.h"
+#include "NamedObjectContext.h"
+
+namespace ai
+{
+	enum StrategyType
+	{
+		STRATEGY_TYPE_GENERIC = 0,
+		STRATEGY_TYPE_COMBAT = 1,
+		STRATEGY_TYPE_NONCOMBAT = 2,
+		STRATEGY_TYPE_TANK = 4,
+		STRATEGY_TYPE_DPS = 8,
+		STRATEGY_TYPE_HEAL = 16,
+		STRATEGY_TYPE_RANGED = 32,
+		STRATEGY_TYPE_MELEE = 64
+	};
+
+	enum ActionPriority
+	{
+	    ACTION_IDLE = 0,
+	    ACTION_NORMAL = 10,
+	    ACTION_HIGH = 20,
+	    ACTION_MOVE = 30,
+	    ACTION_INTERRUPT = 40,
+	    ACTION_DISPEL = 50,
+	    ACTION_LIGHT_HEAL = 60,
+	    ACTION_MEDIUM_HEAL = 70,
+	    ACTION_CRITICAL_HEAL = 80,
+	    ACTION_EMERGENCY = 90
+	};
+
+    class Strategy : public PlayerbotAIAware
+    {
+    public:
+        Strategy(PlayerbotAI* ai);
+        virtual ~Strategy() {}
+
+    public:
+        virtual NextAction** getDefaultActions() { return NULL; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers) {}
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers) {}
+        virtual string getName() = 0;
+		virtual int GetType() { return STRATEGY_TYPE_GENERIC; }
+        virtual ActionNode* GetAction(string name);
+        void Update() {}
+        void Reset() {}
+
+    protected:
+        NamedObjectFactoryList<ActionNode> actionNodeFactories;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/StrategyContext.h b/src/plugins/playerbot/strategy/StrategyContext.h
new file mode 100644
index 0000000..fe30489
--- /dev/null
+++ b/src/plugins/playerbot/strategy/StrategyContext.h
@@ -0,0 +1,149 @@
+#pragma once
+
+#include "CustomStrategy.h"
+#include "generic/NonCombatStrategy.h"
+#include "generic/RacialsStrategy.h"
+#include "generic/ChatCommandHandlerStrategy.h"
+#include "generic/WorldPacketHandlerStrategy.h"
+#include "generic/DeadStrategy.h"
+#include "generic/QuestStrategies.h"
+#include "generic/LootNonCombatStrategy.h"
+#include "generic/DuelStrategy.h"
+#include "generic/KiteStrategy.h"
+#include "generic/FleeStrategy.h"
+#include "generic/FollowMasterStrategy.h"
+#include "generic/RunawayStrategy.h"
+#include "generic/StayStrategy.h"
+#include "generic/UseFoodStrategy.h"
+#include "generic/ConserveManaStrategy.h"
+#include "generic/EmoteStrategy.h"
+#include "generic/AttackRtiStrategy.h"
+#include "generic/AttackWeakStrategy.h"
+#include "generic/TankAoeStrategy.h"
+#include "generic/TankAssistStrategy.h"
+#include "generic/DpsAoeStrategy.h"
+#include "generic/DpsAssistStrategy.h"
+#include "generic/PassiveStrategy.h"
+#include "generic/GrindingStrategy.h"
+#include "generic/UsePotionsStrategy.h"
+#include "generic/GuardStrategy.h"
+#include "generic/CastTimeStrategy.h"
+#include "generic/ThreatStrategy.h"
+#include "generic/TellTargetStrategy.h"
+#include "generic/AttackEnemyPlayersStrategy.h"
+#include "generic/MoveRandomStrategy.h"
+
+namespace ai
+{
+    class StrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        StrategyContext()
+        {
+            creators["racials"] = &StrategyContext::racials;
+            creators["loot"] = &StrategyContext::loot;
+            creators["gather"] = &StrategyContext::gather;
+            creators["emote"] = &StrategyContext::emote;
+            creators["passive"] = &StrategyContext::passive;
+            creators["conserve mana"] = &StrategyContext::conserve_mana;
+            creators["food"] = &StrategyContext::food;
+            creators["chat"] = &StrategyContext::chat;
+            creators["default"] = &StrategyContext::world_packet;
+            creators["ready check"] = &StrategyContext::ready_check;
+            creators["dead"] = &StrategyContext::dead;
+            creators["flee"] = &StrategyContext::flee;
+            creators["duel"] = &StrategyContext::duel;
+            creators["kite"] = &StrategyContext::kite;
+            creators["potions"] = &StrategyContext::potions;
+            creators["cast time"] = &StrategyContext::cast_time;
+            creators["threat"] = &StrategyContext::threat;
+            creators["tell target"] = &StrategyContext::tell_target;
+            creators["pvp"] = &StrategyContext::pvp;
+            creators["move random"] = &StrategyContext::move_random;
+            creators["lfg"] = &StrategyContext::lfg;
+            creators["custom"] = &StrategyContext::custom;
+        }
+
+    private:
+        static Strategy* tell_target(PlayerbotAI* ai) { return new TellTargetStrategy(ai); }
+        static Strategy* threat(PlayerbotAI* ai) { return new ThreatStrategy(ai); }
+        static Strategy* cast_time(PlayerbotAI* ai) { return new CastTimeStrategy(ai); }
+        static Strategy* potions(PlayerbotAI* ai) { return new UsePotionsStrategy(ai); }
+        static Strategy* kite(PlayerbotAI* ai) { return new KiteStrategy(ai); }
+        static Strategy* duel(PlayerbotAI* ai) { return new DuelStrategy(ai); }
+        static Strategy* flee(PlayerbotAI* ai) { return new FleeStrategy(ai); }
+        static Strategy* dead(PlayerbotAI* ai) { return new DeadStrategy(ai); }
+        static Strategy* racials(PlayerbotAI* ai) { return new RacialsStrategy(ai); }
+        static Strategy* loot(PlayerbotAI* ai) { return new LootNonCombatStrategy(ai); }
+        static Strategy* gather(PlayerbotAI* ai) { return new GatherStrategy(ai); }
+        static Strategy* emote(PlayerbotAI* ai) { return new EmoteStrategy(ai); }
+        static Strategy* passive(PlayerbotAI* ai) { return new PassiveStrategy(ai); }
+        static Strategy* conserve_mana(PlayerbotAI* ai) { return new ConserveManaStrategy(ai); }
+        static Strategy* food(PlayerbotAI* ai) { return new UseFoodStrategy(ai); }
+        static Strategy* chat(PlayerbotAI* ai) { return new ChatCommandHandlerStrategy(ai); }
+        static Strategy* world_packet(PlayerbotAI* ai) { return new WorldPacketHandlerStrategy(ai); }
+        static Strategy* ready_check(PlayerbotAI* ai) { return new ReadyCheckStrategy(ai); }
+        static Strategy* pvp(PlayerbotAI* ai) { return new AttackEnemyPlayersStrategy(ai); }
+        static Strategy* move_random(PlayerbotAI* ai) { return new MoveRandomStrategy(ai); }
+        static Strategy* lfg(PlayerbotAI* ai) { return new LfgStrategy(ai); }
+        static Strategy* custom(PlayerbotAI* ai) { return new CustomStrategy(ai); }
+    };
+
+    class MovementStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        MovementStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["follow"] = &MovementStrategyContext::follow_master;
+            creators["stay"] = &MovementStrategyContext::stay;
+            creators["runaway"] = &MovementStrategyContext::runaway;
+            creators["flee from adds"] = &MovementStrategyContext::flee_from_adds;
+            creators["guard"] = &MovementStrategyContext::guard;
+        }
+
+    private:
+        static Strategy* guard(PlayerbotAI* ai) { return new GuardStrategy(ai); }
+        static Strategy* follow_master(PlayerbotAI* ai) { return new FollowMasterStrategy(ai); }
+        static Strategy* stay(PlayerbotAI* ai) { return new StayStrategy(ai); }
+        static Strategy* runaway(PlayerbotAI* ai) { return new RunawayStrategy(ai); }
+        static Strategy* flee_from_adds(PlayerbotAI* ai) { return new FleeFromAddsStrategy(ai); }
+    };
+
+    class AssistStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        AssistStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["dps assist"] = &AssistStrategyContext::dps_assist;
+            creators["dps aoe"] = &AssistStrategyContext::dps_aoe;
+            creators["tank assist"] = &AssistStrategyContext::tank_assist;
+            creators["tank aoe"] = &AssistStrategyContext::tank_aoe;
+            creators["attack weak"] = &AssistStrategyContext::attack_weak;
+            creators["grind"] = &AssistStrategyContext::grind;
+            creators["attack rti"] = &AssistStrategyContext::attack_rti;
+        }
+
+    private:
+        static Strategy* dps_assist(PlayerbotAI* ai) { return new DpsAssistStrategy(ai); }
+        static Strategy* dps_aoe(PlayerbotAI* ai) { return new DpsAoeStrategy(ai); }
+        static Strategy* tank_assist(PlayerbotAI* ai) { return new TankAssistStrategy(ai); }
+        static Strategy* tank_aoe(PlayerbotAI* ai) { return new TankAoeStrategy(ai); }
+        static Strategy* attack_weak(PlayerbotAI* ai) { return new AttackWeakStrategy(ai); }
+        static Strategy* grind(PlayerbotAI* ai) { return new GrindingStrategy(ai); }
+        static Strategy* attack_rti(PlayerbotAI* ai) { return new AttackRtiStrategy(ai); }
+    };
+
+    class QuestStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        QuestStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["quest"] = &QuestStrategyContext::quest;
+            creators["accept all quests"] = &QuestStrategyContext::accept_all_quests;
+        }
+
+    private:
+        static Strategy* quest(PlayerbotAI* ai) { return new DefaultQuestStrategy(ai); }
+        static Strategy* accept_all_quests(PlayerbotAI* ai) { return new AcceptAllQuestsStrategy(ai); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/Trigger.cpp b/src/plugins/playerbot/strategy/Trigger.cpp
new file mode 100644
index 0000000..7487f33
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Trigger.cpp
@@ -0,0 +1,27 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Trigger.h"
+#include "Action.h"
+
+using namespace ai;
+
+Event Trigger::Check()
+{
+	if (IsActive())
+	{
+		Event event(getName());
+		return event;
+	}
+	Event event;
+	return event;
+}
+
+Value<Unit*>* Trigger::GetTargetValue()
+{
+    return context->GetValue<Unit*>(GetTargetName());
+}
+
+Unit* Trigger::GetTarget()
+{
+    return GetTargetValue()->Get();
+}
diff --git a/src/plugins/playerbot/strategy/Trigger.h b/src/plugins/playerbot/strategy/Trigger.h
new file mode 100644
index 0000000..2ae7276
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Trigger.h
@@ -0,0 +1,84 @@
+#pragma once
+#include "Action.h"
+#include "Event.h"
+#include "../PlayerbotAIAware.h"
+
+#define NEXT_TRIGGERS(name, relevance) \
+    virtual NextAction* getNextAction() { return new NextAction(name, relevance); }
+
+#define BEGIN_TRIGGER(clazz, super) \
+class clazz : public super \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : super(ai) {} \
+    public: \
+        virtual bool IsActive();
+
+#define END_TRIGGER() \
+    };
+
+namespace ai
+{
+    class Trigger : public AiNamedObject
+	{
+	public:
+        Trigger(PlayerbotAI* ai, string name = "trigger", int checkInterval = 1) : AiNamedObject(ai, name) {
+			this->checkInterval = checkInterval;
+			ticksElapsed = 0;
+        }
+        virtual ~Trigger() {}
+
+	public:
+        virtual Event Check();
+        virtual void ExternalEvent(string param, Player* owner = NULL) {}
+        virtual void ExternalEvent(WorldPacket &packet, Player* owner = NULL) {}
+        virtual bool IsActive() { return false; }
+        virtual NextAction** getHandlers() { return NULL; }
+        void Update() {}
+        virtual void Reset() {}
+        virtual Unit* GetTarget();
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string GetTargetName() { return "self target"; }
+
+		bool needCheck() {
+			if (++ticksElapsed >= checkInterval) {
+				ticksElapsed = 0;
+				return true;
+			}
+			return false;
+		}
+
+    protected:
+		int checkInterval;
+		int ticksElapsed;
+	};
+
+
+    class TriggerNode
+    {
+    public:
+        TriggerNode(string name, NextAction** handlers = NULL)
+        {
+            this->name = name;
+            this->handlers = handlers;
+            this->trigger = NULL;
+        }
+        virtual ~TriggerNode()
+        {
+            NextAction::destroy(handlers);
+        }
+
+    public:
+        Trigger* getTrigger() { return trigger; }
+        void setTrigger(Trigger* trigger) { this->trigger = trigger; }
+        string getName() { return name; }
+
+    public:
+        NextAction** getHandlers() { return NextAction::merge(NextAction::clone(handlers), trigger->getHandlers()); }
+
+    private:
+        Trigger* trigger;
+        NextAction** handlers;
+        std::string name;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Value.cpp b/src/plugins/playerbot/strategy/Value.cpp
new file mode 100644
index 0000000..8b87c26
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Value.cpp
@@ -0,0 +1,5 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Value.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/Value.h b/src/plugins/playerbot/strategy/Value.h
new file mode 100644
index 0000000..930e3f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Value.h
@@ -0,0 +1,177 @@
+#pragma once
+#include "Action.h"
+#include "Event.h"
+#include "../PlayerbotAIAware.h"
+#include "AiObject.h"
+
+namespace ai
+{
+    class UntypedValue : public AiNamedObject
+    {
+    public:
+        UntypedValue(PlayerbotAI* ai, string name) : AiNamedObject(ai, name) {}
+        virtual void Update() {}
+        virtual void Reset() {}
+        virtual string Format() { return "?"; }
+    };
+
+    template<class T>
+    class Value
+    {
+    public:
+        virtual T Get() = 0;
+        virtual void Set(T value) = 0;
+        operator T() { return Get(); }
+    };
+
+    template<class T>
+    class CalculatedValue : public UntypedValue, public Value<T>
+	{
+	public:
+        CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) : UntypedValue(ai, name),
+            checkInterval(checkInterval), ticksElapsed(checkInterval)
+        { }
+        virtual ~CalculatedValue() {}
+
+	public:
+        virtual T Get()
+        {
+            if (ticksElapsed >= checkInterval) {
+                ticksElapsed = 0;
+                value = Calculate();
+            }
+            return value;
+        }
+        virtual void Set(T value) { this->value = value; }
+        virtual void Update()
+        {
+            if (ticksElapsed < checkInterval) {
+                ticksElapsed++;
+            }
+        }
+
+    protected:
+        virtual T Calculate() = 0;
+
+    protected:
+		int checkInterval;
+		int ticksElapsed;
+        T value;
+	};
+
+    class Uint8CalculatedValue : public CalculatedValue<uint8>
+    {
+    public:
+        Uint8CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<uint8>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << (int)Calculate();
+            return out.str();
+        }
+    };
+
+    class Uint32CalculatedValue : public CalculatedValue<uint32>
+    {
+    public:
+        Uint32CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<uint32>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << (int)Calculate();
+            return out.str();
+        }
+    };
+
+    class FloatCalculatedValue : public CalculatedValue<float>
+    {
+    public:
+        FloatCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<float>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << Calculate();
+            return out.str();
+        }
+    };
+
+    class BoolCalculatedValue : public CalculatedValue<bool>
+    {
+    public:
+        BoolCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<bool>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            return Calculate() ? "true" : "false";
+        }
+    };
+
+    class UnitCalculatedValue : public CalculatedValue<Unit*>
+    {
+    public:
+        UnitCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<Unit*>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            Unit* unit = Calculate();
+            return unit ? unit->GetName() : "<none>";
+        }
+    };
+
+    class ObjectGuidListCalculatedValue : public CalculatedValue<list<ObjectGuid> >
+    {
+    public:
+        ObjectGuidListCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<list<ObjectGuid> >(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << "{";
+            list<ObjectGuid> guids = Calculate();
+            for (list<ObjectGuid>::iterator i = guids.begin(); i != guids.end(); ++i)
+            {
+                ObjectGuid guid = *i;
+                out << guid.GetRawValue() << ",";
+            }
+            out << "}";
+            return out.str();
+        }
+    };
+
+    template<class T>
+    class ManualSetValue : public UntypedValue, public Value<T>
+    {
+    public:
+        ManualSetValue(PlayerbotAI* ai, T defaultValue, string name = "value") :
+            UntypedValue(ai, name), value(defaultValue), defaultValue(defaultValue) {}
+        virtual ~ManualSetValue() {}
+
+    public:
+        virtual T Get() { return value; }
+        virtual void Set(T value) { this->value = value; }
+        virtual void Update() { }
+        virtual void Reset() { value = defaultValue; }
+
+    protected:
+        T value;
+        T defaultValue;
+    };
+
+    class UnitManualSetValue : public ManualSetValue<Unit*>
+    {
+    public:
+        UnitManualSetValue(PlayerbotAI* ai, Unit* defaultValue, string name = "value") :
+            ManualSetValue<Unit*>(ai, defaultValue, name) {}
+
+        virtual string Format()
+        {
+            Unit* unit = Get();
+            return unit ? unit->GetName() : "<none>";
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h b/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
new file mode 100644
index 0000000..461ea7e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AcceptDuelAction : public Action
+    {
+    public:
+        AcceptDuelAction(PlayerbotAI* ai) : Action(ai, "accept duel")
+        {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket p(event.getPacket());
+
+            ObjectGuid flagGuid;
+            p >> flagGuid;
+            ObjectGuid playerGuid;
+            p >> playerGuid;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+            *packet << flagGuid;
+            bot->GetSession()->QueuePacket(packet);
+
+            ai->ResetStrategies();
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h b/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
new file mode 100644
index 0000000..096fb84
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../../Globals/ObjectMgr.h"
+
+namespace ai
+{
+    class AcceptInvitationAction : public Action {
+    public:
+        AcceptInvitationAction(PlayerbotAI* ai) : Action(ai, "accept invitation") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = GetMaster();
+
+            Group* grp = bot->GetGroupInvite();
+            if (!grp)
+                return false;
+
+            Player* inviter = sObjectMgr->GetPlayerByLowGUID(grp->GetLeaderGUID());
+            if (!inviter)
+                return false;
+
+			if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, false, inviter))
+            {
+                WorldPacket data(SMSG_GROUP_DECLINE, 10);
+                data << bot->GetName();
+                inviter->GetSession()->SendPacket(&data);
+                bot->UninviteFromGroup();
+                return false;
+            }
+
+            WorldPacket p;
+            uint32 roles_mask = 0;
+            p << roles_mask;
+            bot->GetSession()->HandleGroupAcceptOpcode(p);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+                bot->GetPlayerbotAI()->SetMaster(inviter);
+
+            ai->ResetStrategies();
+            ai->TellMaster("Hello");
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
new file mode 100644
index 0000000..af63f76
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
@@ -0,0 +1,102 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AcceptQuestAction.h"
+
+using namespace ai;
+
+void AcceptAllQuestsAction::ProcessQuest(Quest const* quest, WorldObject* questGiver)
+{
+    AcceptQuest(quest, questGiver->GetGUID());
+}
+
+bool AcceptQuestAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+
+    if (!master)
+        return false;
+
+    Player *bot = ai->GetBot();
+    uint64 guid;
+    uint32 quest;
+
+    string text = event.getParam();
+    PlayerbotChatHandler ch(master);
+    quest = ch.extractQuestId(text);
+    if (quest)
+    {
+        Unit* npc = master->GetSelectedUnit();
+        if (!npc)
+        {
+            ai->TellMaster("Please select quest giver NPC");
+            return false;
+        }
+    }
+    else if (!event.getPacket().empty())
+    {
+        WorldPacket& p = event.getPacket();
+        p.rpos(0);
+        p >> guid >> quest;
+    }
+    else if (text == "*")
+    {
+        return QuestAction::Execute(event);
+    }
+    else
+        return false;
+
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+    if (!qInfo)
+        return false;
+
+    return AcceptQuest(qInfo, guid);
+}
+
+bool AcceptQuestShareAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    Player *bot = ai->GetBot();
+
+    WorldPacket& p = event.getPacket();
+    p.rpos(0);
+    uint32 quest;
+    p >> quest;
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+
+    if (!qInfo || !bot->GetDivider())
+        return false;
+
+    quest = qInfo->GetQuestId();
+    if( !bot->CanTakeQuest( qInfo, false ) )
+    {
+        // can't take quest
+        bot->SetDivider( ObjectGuid() );
+        ai->TellMaster("I can't take this quest");
+
+        return false;
+    }
+
+    // send msg to quest giving player
+    master->SendPushToPartyResponse( bot, QUEST_PARTY_MSG_ACCEPT_QUEST );
+    bot->SetDivider( ObjectGuid() );
+
+    if( bot->CanAddQuest( qInfo, false ) )
+    {
+        bot->AddQuest( qInfo, master );
+
+        if( bot->CanCompleteQuest( quest ) )
+            bot->CompleteQuest( quest );
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if( qInfo->GetSrcSpell() > 0 )
+            bot->CastSpell( bot, qInfo->GetSrcSpell(), true );
+
+        ai->TellMaster("Quest accepted");
+        return true;
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
new file mode 100644
index 0000000..856c697
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class AcceptAllQuestsAction : public QuestAction {
+    public:
+        AcceptAllQuestsAction(PlayerbotAI* ai, string name = "accept all quests") : QuestAction(ai, name) {}
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver);
+    };
+
+    class AcceptQuestAction : public AcceptAllQuestsAction {
+    public:
+        AcceptQuestAction(PlayerbotAI* ai) : AcceptAllQuestsAction(ai, "accept quest") {}
+        virtual bool Execute(Event event);
+    };
+
+    class AcceptQuestShareAction : public Action {
+    public:
+        AcceptQuestShareAction(PlayerbotAI* ai) : Action(ai, "accept quest share") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h b/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
new file mode 100644
index 0000000..77dd0dd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AcceptResurrectAction : public Action {
+    public:
+        AcceptResurrectAction(PlayerbotAI* ai) : Action(ai, "accept resurrect") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsAlive())
+                return false;
+
+            WorldPacket p(event.getPacket());
+            p.rpos(0);
+            ObjectGuid guid;
+            p >> guid;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_RESURRECT_RESPONSE, 8+1);
+            *packet << guid;
+            *packet << uint8(1);                        // accept
+            bot->GetSession()->QueuePacket(packet);   // queue the packet to get around race condition
+
+            ai->ChangeEngine(BOT_STATE_NON_COMBAT);
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ActionContext.h b/src/plugins/playerbot/strategy/actions/ActionContext.h
new file mode 100644
index 0000000..126fd59
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ActionContext.h
@@ -0,0 +1,113 @@
+#pragma once
+
+#include "GenericActions.h"
+#include "NonCombatActions.h"
+#include "EmoteAction.h"
+#include "AddLootAction.h"
+#include "LootAction.h"
+#include "AddLootAction.h"
+#include "StayActions.h"
+#include "FollowActions.h"
+#include "ChangeStrategyAction.h"
+#include "ChooseTargetActions.h"
+#include "SuggestWhatToDoAction.h"
+#include "PositionAction.h"
+#include "AttackAction.h"
+#include "CheckMailAction.h"
+#include "SayAction.h"
+
+namespace ai
+{
+    class ActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        ActionContext()
+        {
+            creators["attack"] = &ActionContext::melee;
+            creators["melee"] = &ActionContext::melee;
+            creators["reach spell"] = &ActionContext::ReachSpell;
+            creators["reach melee"] = &ActionContext::ReachMelee;
+            creators["flee"] = &ActionContext::flee;
+            creators["gift of the naaru"] = &ActionContext::gift_of_the_naaru;
+            creators["shoot"] = &ActionContext::shoot;
+            creators["lifeblood"] = &ActionContext::lifeblood;
+            creators["arcane torrent"] = &ActionContext::arcane_torrent;
+            creators["end pull"] = &ActionContext::end_pull;
+            creators["healthstone"] = &ActionContext::healthstone;
+            creators["healing potion"] = &ActionContext::healing_potion;
+            creators["mana potion"] = &ActionContext::mana_potion;
+            creators["food"] = &ActionContext::food;
+            creators["drink"] = &ActionContext::drink;
+            creators["tank assist"] = &ActionContext::tank_assist;
+            creators["dps assist"] = &ActionContext::dps_assist;
+            creators["attack rti target"] = &ActionContext::attack_rti_target;
+            creators["loot"] = &ActionContext::loot;
+            creators["add loot"] = &ActionContext::add_loot;
+            creators["add gathering loot"] = &ActionContext::add_gathering_loot;
+            creators["add all loot"] = &ActionContext::add_all_loot;
+            creators["shoot"] = &ActionContext::shoot;
+            creators["follow"] = &ActionContext::follow;
+            creators["follow"] = &ActionContext::follow;
+            creators["runaway"] = &ActionContext::runaway;
+            creators["stay"] = &ActionContext::stay;
+            creators["attack anything"] = &ActionContext::attack_anything;
+            creators["attack least hp target"] = &ActionContext::attack_least_hp_target;
+            creators["attack enemy player"] = &ActionContext::enemy_player_target;
+            creators["emote"] = &ActionContext::emote;
+            creators["suggest what to do"] = &ActionContext::suggest_what_to_do;
+            creators["move random"] = &ActionContext::move_random;
+            creators["move to loot"] = &ActionContext::move_to_loot;
+            creators["open loot"] = &ActionContext::open_loot;
+            creators["guard"] = &ActionContext::guard;
+            creators["move out of enemy contact"] = &ActionContext::move_out_of_enemy_contact;
+            creators["set facing"] = &ActionContext::set_facing;
+            creators["attack duel opponent"] = &ActionContext::attack_duel_opponent;
+            creators["drop target"] = &ActionContext::drop_target;
+            creators["check mail"] = &ActionContext::check_mail;
+            creators["say"] = &ActionContext::say;
+        }
+
+    private:
+        static Action* check_mail(PlayerbotAI* ai) { return new CheckMailAction(ai); }
+        static Action* drop_target(PlayerbotAI* ai) { return new DropTargetAction(ai); }
+        static Action* attack_duel_opponent(PlayerbotAI* ai) { return new AttackDuelOpponentAction(ai); }
+        static Action* guard(PlayerbotAI* ai) { return new GuardAction(ai); }
+        static Action* open_loot(PlayerbotAI* ai) { return new OpenLootAction(ai); }
+        static Action* move_to_loot(PlayerbotAI* ai) { return new MoveToLootAction(ai); }
+        static Action* move_random(PlayerbotAI* ai) { return new MoveRandomAction(ai); }
+        static Action* shoot(PlayerbotAI* ai) { return new CastShootAction(ai); }
+        static Action* melee(PlayerbotAI* ai) { return new MeleeAction(ai); }
+        static Action* ReachSpell(PlayerbotAI* ai) { return new ReachSpellAction(ai); }
+        static Action* ReachMelee(PlayerbotAI* ai) { return new ReachMeleeAction(ai); }
+        static Action* flee(PlayerbotAI* ai) { return new FleeAction(ai); }
+        static Action* gift_of_the_naaru(PlayerbotAI* ai) { return new CastGiftOfTheNaaruAction(ai); }
+        static Action* lifeblood(PlayerbotAI* ai) { return new CastLifeBloodAction(ai); }
+        static Action* arcane_torrent(PlayerbotAI* ai) { return new CastArcaneTorrentAction(ai); }
+        static Action* end_pull(PlayerbotAI* ai) { return new ChangeCombatStrategyAction(ai, "-pull"); }
+
+        static Action* emote(PlayerbotAI* ai) { return new EmoteAction(ai); }
+        static Action* suggest_what_to_do(PlayerbotAI* ai) { return new SuggestWhatToDoAction(ai); }
+        static Action* attack_anything(PlayerbotAI* ai) { return new AttackAnythingAction(ai); }
+        static Action* attack_least_hp_target(PlayerbotAI* ai) { return new AttackLeastHpTargetAction(ai); }
+        static Action* enemy_player_target(PlayerbotAI* ai) { return new AttackEnemyPlayerAction(ai); }
+        static Action* stay(PlayerbotAI* ai) { return new StayAction(ai); }
+        static Action* runaway(PlayerbotAI* ai) { return new RunAwayAction(ai); }
+        static Action* follow(PlayerbotAI* ai) { return new FollowAction(ai); }
+        static Action* add_gathering_loot(PlayerbotAI* ai) { return new AddGatheringLootAction(ai); }
+        static Action* add_loot(PlayerbotAI* ai) { return new AddLootAction(ai); }
+        static Action* add_all_loot(PlayerbotAI* ai) { return new AddAllLootAction(ai); }
+        static Action* loot(PlayerbotAI* ai) { return new LootAction(ai); }
+        static Action* dps_assist(PlayerbotAI* ai) { return new DpsAssistAction(ai); }
+        static Action* attack_rti_target(PlayerbotAI* ai) { return new AttackRtiTargetAction(ai); }
+        static Action* tank_assist(PlayerbotAI* ai) { return new TankAssistAction(ai); }
+        static Action* drink(PlayerbotAI* ai) { return new DrinkAction(ai); }
+        static Action* food(PlayerbotAI* ai) { return new EatAction(ai); }
+        static Action* mana_potion(PlayerbotAI* ai) { return new UseManaPotion(ai); }
+        static Action* healing_potion(PlayerbotAI* ai) { return new UseHealingPotion(ai); }
+        static Action* healthstone(PlayerbotAI* ai) { return new UseItemAction(ai, "healthstone"); }
+        static Action* move_out_of_enemy_contact(PlayerbotAI* ai) { return new MoveOutOfEnemyContactAction(ai); }
+        static Action* set_facing(PlayerbotAI* ai) { return new SetFacingTargetAction(ai); }
+        static Action* say(PlayerbotAI* ai) { return new SayAction(ai); }
+    };
+
+};
diff --git a/src/plugins/playerbot/strategy/actions/AddLootAction.cpp b/src/plugins/playerbot/strategy/actions/AddLootAction.cpp
new file mode 100644
index 0000000..4d2c3ae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AddLootAction.cpp
@@ -0,0 +1,62 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AddLootAction.h"
+
+#include "../../LootObjectStack.h"
+
+using namespace ai;
+
+bool AddLootAction::Execute(Event event)
+{
+    ObjectGuid guid = event.getObject();
+    if (!guid)
+        return false;
+
+    return AI_VALUE(LootObjectStack*, "available loot")->Add(guid);
+}
+
+bool AddAllLootAction::Execute(Event event)
+{
+    bool added = false;
+
+    list<ObjectGuid> gos = context->GetValue<list<ObjectGuid> >("nearest game objects")->Get();
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+        added |= AddLoot(*i);
+
+    list<ObjectGuid> corpses = context->GetValue<list<ObjectGuid> >("nearest corpses")->Get();
+    for (list<ObjectGuid>::iterator i = corpses.begin(); i != corpses.end(); i++)
+        added |= AddLoot(*i);
+
+    return added;
+}
+
+bool AddLootAction::isUseful()
+{
+    return AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool AddAllLootAction::isUseful()
+{
+    return AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool AddAllLootAction::AddLoot(ObjectGuid guid)
+{
+    return AI_VALUE(LootObjectStack*, "available loot")->Add(guid);
+}
+
+bool AddGatheringLootAction::AddLoot(ObjectGuid guid)
+{
+    LootObject loot(bot, guid);
+
+    if (loot.IsEmpty() || !loot.GetWorldObject(bot))
+        return false;
+
+    if (loot.skillId == SKILL_NONE)
+        return false;
+
+    if (!loot.IsLootPossible(bot))
+        return false;
+
+    return AddAllLootAction::AddLoot(guid);
+}
diff --git a/src/plugins/playerbot/strategy/actions/AddLootAction.h b/src/plugins/playerbot/strategy/actions/AddLootAction.h
new file mode 100644
index 0000000..402c50a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AddLootAction.h
@@ -0,0 +1,32 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AddLootAction : public Action {
+    public:
+        AddLootAction(PlayerbotAI* ai) : Action(ai, "add loot") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+    class AddAllLootAction : public Action {
+    public:
+        AddAllLootAction(PlayerbotAI* ai, string name = "add all loot") : Action(ai, name) {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+
+    protected:
+        virtual bool AddLoot(ObjectGuid guid);
+    };
+
+    class AddGatheringLootAction : public AddAllLootAction {
+    public:
+        AddGatheringLootAction(PlayerbotAI* ai) : AddAllLootAction(ai, "add gathering loot") {}
+
+    protected:
+        virtual bool AddLoot(ObjectGuid guid);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
new file mode 100644
index 0000000..0d427c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AreaTriggerAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+
+using namespace ai;
+
+bool ReachAreaTriggerAction::Execute(Event event)
+{
+    uint32 triggerId;
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    p >> triggerId;
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);
+    if(!atEntry)
+        return false;
+
+    AreaTrigger const* at = sObjectMgr->GetAreaTrigger(triggerId);
+    if (!at)
+    {
+        WorldPacket p1(CMSG_AREATRIGGER);
+        p1 << triggerId;
+        p1.rpos(0);
+        bot->GetSession()->HandleAreaTriggerOpcode(p1);
+
+        return true;
+    }
+
+    if (bot->GetMapId() != atEntry->mapid || bot->GetDistance(atEntry->x, atEntry->y, atEntry->z) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I won't follow: too far away");
+        return true;
+    }
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+	mm.MovePoint(atEntry->mapid, atEntry->x, atEntry->y, atEntry->z);
+    float distance = bot->GetDistance(atEntry->x, atEntry->y, atEntry->z);
+    float delay = 1000.0f * distance / bot->GetSpeed(MOVE_RUN) + sPlayerbotAIConfig.reactDelay;
+    ai->TellMaster("Wait for me");
+    ai->SetNextCheckDelay(delay);
+    context->GetValue<LastMovement&>("last movement")->Get().lastAreaTrigger = triggerId;
+
+    return true;
+}
+
+
+
+bool AreaTriggerAction::Execute(Event event)
+{
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+
+    uint32 triggerId = movement.lastAreaTrigger;
+    movement.lastAreaTrigger = 0;
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);
+    if(!atEntry)
+        return false;
+
+    AreaTrigger const* at = sObjectMgr->GetAreaTrigger(triggerId);
+    if (!at)
+        return true;
+
+    WorldPacket p(CMSG_AREATRIGGER);
+    p << triggerId;
+    p.rpos(0);
+    bot->GetSession()->HandleAreaTriggerOpcode(p);
+
+    ai->TellMaster("Hello");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
new file mode 100644
index 0000000..de2b63a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class ReachAreaTriggerAction : public MovementAction {
+    public:
+        ReachAreaTriggerAction(PlayerbotAI* ai) : MovementAction(ai, "reach area trigger") {}
+
+        virtual bool Execute(Event event);
+    };
+
+    class AreaTriggerAction : public MovementAction {
+    public:
+        AreaTriggerAction(PlayerbotAI* ai) : MovementAction(ai, "area trigger") {}
+
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/AttackAction.cpp b/src/plugins/playerbot/strategy/actions/AttackAction.cpp
new file mode 100644
index 0000000..ded8aab
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AttackAction.cpp
@@ -0,0 +1,104 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackAction.h"
+#include "../../../Movement/MovementGenerator.h"
+#include "../../../game/AI/CreatureAI.h"
+#include "../../../Entities/Pet/Pet.h"
+#include "../../LootObjectStack.h"
+
+using namespace ai;
+
+bool AttackAction::Execute(Event event)
+{
+    Unit* target = GetTarget();
+
+    if (!target)
+        return false;
+
+    return Attack(target);
+}
+
+bool AttackMyTargetAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* target = master->GetSelectedUnit();
+    if (!target)
+    {
+        if (verbose) ai->TellMaster("You have no target");
+        return false;
+    }
+
+    return Attack(target);
+}
+
+bool AttackAction::Attack(Unit* target)
+{
+    MotionMaster &mm = *bot->GetMotionMaster();
+    if (bot->IsFlying())
+    {
+        if (verbose) ai->TellMaster("I cannot attack in flight");
+        return false;
+    }
+
+    if (!target)
+    {
+        if (verbose) ai->TellMaster("I have no target");
+        return false;
+    }
+
+    ostringstream msg;
+    msg << target->GetName();
+    if (bot->IsFriendlyTo(target))
+    {
+        msg << " is friendly to me";
+        if (verbose) ai->TellMaster(msg.str());
+        return false;
+    }
+    if (!bot->IsWithinLOSInMap(target))
+    {
+        msg << " is not on my sight";
+        if (verbose) ai->TellMaster(msg.str());
+        return false;
+    }
+
+    if (bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+    }
+
+    ObjectGuid guid = target->GetGUID();
+    bot->SetSelection(target->GetGUID());
+
+    Unit* oldTarget = context->GetValue<Unit*>("current target")->Get();
+    context->GetValue<Unit*>("old target")->Set(oldTarget);
+
+    context->GetValue<Unit*>("current target")->Set(target);
+    context->GetValue<LootObjectStack*>("available loot")->Get()->Add(guid);
+
+    Pet* pet = bot->GetPet();
+    if (pet)
+    {
+        pet->SetTarget(target->GetGUID());
+        pet->AI()->EnterCombat(target);
+		pet->GetCharmInfo()->SetIsCommandAttack(true);
+		pet->AI()->AttackStart(target);
+    }
+
+    bot->Attack(target, true);
+    ai->ChangeEngine(BOT_STATE_COMBAT);
+    return true;
+}
+
+bool AttackDuelOpponentAction::isUseful()
+{
+    return AI_VALUE(Unit*, "duel target");
+}
+
+bool AttackDuelOpponentAction::Execute(Event event)
+{
+    return Attack(AI_VALUE(Unit*, "duel target"));
+}
diff --git a/src/plugins/playerbot/strategy/actions/AttackAction.h b/src/plugins/playerbot/strategy/actions/AttackAction.h
new file mode 100644
index 0000000..ede665d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AttackAction.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class AttackAction : public MovementAction
+	{
+	public:
+		AttackAction(PlayerbotAI* ai, string name) : MovementAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    protected:
+        bool Attack(Unit* target);
+    };
+
+    class AttackMyTargetAction : public AttackAction
+    {
+    public:
+        AttackMyTargetAction(PlayerbotAI* ai, string name = "attack my target") : AttackAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class AttackDuelOpponentAction : public AttackAction
+    {
+    public:
+        AttackDuelOpponentAction(PlayerbotAI* ai, string name = "attack duel opponent") : AttackAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/BankAction.cpp b/src/plugins/playerbot/strategy/actions/BankAction.cpp
new file mode 100644
index 0000000..c7254be
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BankAction.cpp
@@ -0,0 +1,168 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BankAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace std;
+using namespace ai;
+
+bool BankAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* npc = ai->GetUnit(*i);
+        if (!npc || !bot->GetNPCIfCanInteractWith(npc->GetGUID(), UNIT_NPC_FLAG_BANKER))
+            continue;
+
+        return Execute(text, npc);
+    }
+
+    ai->TellMaster("Cannot find banker nearby");
+    return false;
+}
+
+bool BankAction::Execute(string text, Unit* bank)
+{
+    if (text.empty() || text == "?")
+    {
+        ListItems();
+        return true;
+    }
+
+    bool result = false;
+    if (text[0] == '-')
+    {
+        ItemIds found = chat->parseItems(text);
+        for (ItemIds::iterator i = found.begin(); i != found.end(); i++)
+        {
+            uint32 itemId = *i;
+            result &= Withdraw(itemId);
+        }
+    }
+    else
+    {
+        list<Item*> found = parseItems(text);
+        if (found.empty())
+            return false;
+
+        for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        {
+            Item* item = *i;
+            if (!item)
+                continue;
+
+            result &= Deposit(item);
+        }
+    }
+
+    return result;
+}
+
+bool BankAction::Withdraw(const uint32 itemid)
+{
+    Item* pItem = FindItemInBank(itemid);
+    if (!pItem)
+        return false;
+
+    ItemPosCountVec dest;
+    InventoryResult msg = bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        bot->SendEquipError(msg, pItem, NULL);
+        return false;
+    }
+
+    bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+    bot->StoreItem(dest, pItem, true);
+
+    std::ostringstream out;
+    out << "got " << chat->formatItem(pItem->GetTemplate(), pItem->GetCount()) << " from bank";
+    ai->TellMaster(out.str());
+    return true;
+}
+
+bool BankAction::Deposit(Item* pItem)
+{
+    std::ostringstream out;
+
+    ItemPosCountVec dest;
+    InventoryResult msg = bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        bot->SendEquipError(msg, pItem, NULL);
+        return false;
+    }
+
+    bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+    bot->BankItem(dest, pItem, true);
+
+    out << "put " << chat->formatItem(pItem->GetTemplate(), pItem->GetCount()) << " to bank";
+    ai->TellMaster(out.str());
+	return true;
+}
+
+void BankAction::ListItems()
+{
+    ai->TellMaster("=== Bank ===");
+
+    map<uint32, int> items;
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = static_cast<Bag *>(bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            std::string bagName = pBagProto->Name1;
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = bot->GetItemByPos(bag, slot);
+                if (item)
+                    items[item->GetTemplate()->ItemId] = item->GetCount();
+            }
+        }
+    }
+
+    TellItems(items);
+}
+
+Item* BankAction::FindItemInBank(uint32 ItemId)
+{
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BankAction.h b/src/plugins/playerbot/strategy/actions/BankAction.h
new file mode 100644
index 0000000..6b22095
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BankAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BankAction : public InventoryAction {
+    public:
+        BankAction(PlayerbotAI* ai) : InventoryAction(ai, "bank") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Execute(string text, Unit* bank);
+        void ListItems();
+        bool Withdraw(const uint32 itemid);
+        bool Deposit(Item* pItem);
+        Item* FindItemInBank(uint32 ItemId);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuffAction.cpp b/src/plugins/playerbot/strategy/actions/BuffAction.cpp
new file mode 100644
index 0000000..0675f2e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuffAction.cpp
@@ -0,0 +1,118 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BuffAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+class FindBuffVisitor : public IterateItemsVisitor {
+public:
+    FindBuffVisitor(Player* bot) : IterateItemsVisitor(), bot(bot)
+    {
+    }
+
+    virtual bool Visit(Item* item)
+    {
+        if (bot->CanUseItem(item->GetTemplate()) != EQUIP_ERR_OK)
+            return true;
+
+        const ItemTemplate* proto = item->GetTemplate();
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE)
+            return true;
+
+        if (proto->SubClass != ITEM_SUBCLASS_ELIXIR && 
+            proto->SubClass != ITEM_SUBCLASS_FLASK &&
+            proto->SubClass != ITEM_SUBCLASS_SCROLL && 
+            proto->SubClass != ITEM_SUBCLASS_FOOD &&
+            proto->SubClass != ITEM_SUBCLASS_CONSUMABLE_OTHER &&
+            proto->SubClass != ITEM_SUBCLASS_ITEM_ENHANCEMENT)
+            return true;
+
+        for (int i=0; i<MAX_ITEM_PROTO_SPELLS; i++)
+        {
+            uint32 spellId = proto->Spells[i].SpellId;
+            if (!spellId)
+                continue;
+
+            if (bot->HasAura(spellId))
+                return true;
+
+            Item* itemForSpell = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<Item*>("item for spell", spellId);
+            if (itemForSpell && itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                return true;
+        
+            if (items.find(proto->SubClass) == items.end())
+                items[proto->SubClass] = list<Item*>();
+
+            items[proto->SubClass].push_back(item);
+            break;
+        }
+
+        return true;
+    }
+
+public:
+    map<uint32, list<Item*> > items;
+
+private:
+    Player* bot;
+};
+
+void BuffAction::TellHeader(uint32 subClass)
+{
+    switch (subClass)
+    {
+    case ITEM_SUBCLASS_ELIXIR:
+        ai->TellMaster("--- Elixir ---");
+        return;
+    case ITEM_SUBCLASS_FLASK:
+        ai->TellMaster("--- Flask ---");
+        return;
+    case ITEM_SUBCLASS_SCROLL:
+        ai->TellMaster("--- Scroll ---");
+        return;
+    case ITEM_SUBCLASS_FOOD:
+        ai->TellMaster("--- Food ---");
+        return;
+    case ITEM_SUBCLASS_GENERIC:
+        ai->TellMaster("--- Other ---");
+        return;
+    case ITEM_SUBCLASS_ITEM_ENHANCEMENT:
+        ai->TellMaster("--- Enchant ---");
+        return;
+    }
+}
+
+
+bool BuffAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    FindBuffVisitor visitor(bot);
+    IterateItems(&visitor);
+
+    uint32 oldSubClass = -1;
+    for (map<uint32, list<Item*> >::iterator i = visitor.items.begin(); i != visitor.items.end(); ++i)
+    {
+        list<Item*> items = i->second;
+
+        uint32 subClass = i->first;
+        if (oldSubClass != subClass)
+        {
+            if (!items.empty())
+                TellHeader(subClass);
+            oldSubClass = subClass;
+        }
+        for (list<Item*>::iterator j = items.begin(); j != items.end(); ++j)
+        {
+            Item* item = *j;
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate(), item->GetCount());
+            ai->TellMaster(out);
+        }
+    }
+    
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuffAction.h b/src/plugins/playerbot/strategy/actions/BuffAction.h
new file mode 100644
index 0000000..da8b6a6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuffAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BuffAction : public InventoryAction {
+    public:
+        BuffAction(PlayerbotAI* ai) : InventoryAction(ai, "buff") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void TellHeader(uint32 subClass);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuyAction.cpp b/src/plugins/playerbot/strategy/actions/BuyAction.cpp
new file mode 100644
index 0000000..20d9cea
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuyAction.cpp
@@ -0,0 +1,53 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BuyAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool BuyAction::Execute(Event event)
+{
+    string link = event.getParam();
+
+    ItemIds itemIds = chat->parseItems(link);
+    if (itemIds.empty())
+        return false;
+
+    Player* master = GetMaster();
+
+    if (!master)
+        return false;
+
+    Unit* vendor = master->GetSelectedUnit();
+    if (!vendor)
+        return false;
+
+    Creature *pCreature = bot->GetNPCIfCanInteractWith(vendor->GetGUID(), UNIT_NPC_FLAG_VENDOR);
+    if (!pCreature)
+    {
+        ai->TellMaster("Cannot talk to vendor");
+        return false;
+    }
+
+    VendorItemData const* tItems = pCreature->GetVendorItems();
+    if (!tItems)
+    {
+        ai->TellMaster("This vendor has no items");
+        return false;
+    }
+
+    for (ItemIds::iterator i = itemIds.begin(); i != itemIds.end(); i++)
+    {
+        for (uint32 slot = 0; slot < tItems->GetItemCount(); slot++)
+        {
+            if (tItems->GetItem(slot)->item == *i)
+            {
+                bot->BuyItemFromVendorSlot(vendor->GetGUID(), slot, *i, 1, NULL_BAG, NULL_SLOT);
+                ai->TellMaster("Bought item");
+            }
+        }
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuyAction.h b/src/plugins/playerbot/strategy/actions/BuyAction.h
new file mode 100644
index 0000000..2e0822c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuyAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BuyAction : public InventoryAction {
+    public:
+        BuyAction(PlayerbotAI* ai) : InventoryAction(ai, "buy") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool TradeItem(FindItemVisitor *visitor, int8 slot);
+        bool TradeItem(const Item& item, int8 slot);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
new file mode 100644
index 0000000..e59110e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
@@ -0,0 +1,48 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CastCustomSpellAction.h"
+
+using namespace ai;
+
+bool CastCustomSpellAction::Execute(Event event)
+{
+    Unit* target = NULL;
+
+    Player* master = GetMaster();
+    if (master)
+        target = master->GetSelectedUnit();
+
+    if (!target)
+        target = bot;
+
+    string text = event.getParam();
+
+    uint32 spell = chat->parseSpell(text);
+
+    ostringstream msg;
+    if (!ai->CanCastSpell(spell, target))
+    {
+        msg << "Cannot cast " << text << " on " << target->GetName();
+        ai->TellMaster(msg.str());
+        return false;
+    }
+
+    bool result = false;
+    if (spell)
+        result = ai->CastSpell(spell, target);
+    else
+        ai->CastSpell(text, target);
+
+    if (result)
+    {
+        msg << "Casting " << text << " on " << target->GetName();
+        ai->TellMasterNoFacing(msg.str());
+    }
+    else
+    {
+        msg << "Cast " << text << " on " << target->GetName() << " is failed";
+        ai->TellMaster(msg.str());
+    }
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
new file mode 100644
index 0000000..976a9e4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class CastCustomSpellAction : public Action
+    {
+    public:
+        CastCustomSpellAction(PlayerbotAI* ai) : Action(ai, "cast custom spell") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
new file mode 100644
index 0000000..32328db
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeChatAction.h"
+
+
+using namespace ai;
+
+
+bool ChangeChatAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ChatMsg parsed = chat->parseChat(text);
+    if (parsed == CHAT_MSG_SYSTEM)
+    {
+        ostringstream out; out << "Current chat is " << chat->formatChat(*context->GetValue<ChatMsg>("chat"));
+        ai->TellMaster(out);
+    }
+    else
+    {
+        context->GetValue<ChatMsg>("chat")->Set(parsed);
+        ostringstream out; out << "Chat set to " << chat->formatChat(parsed);
+        ai->TellMaster(out);
+    }
+    
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeChatAction.h b/src/plugins/playerbot/strategy/actions/ChangeChatAction.h
new file mode 100644
index 0000000..450a81a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeChatAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class ChangeChatAction : public Action {
+    public:
+        ChangeChatAction(PlayerbotAI* ai) : Action(ai, "chat") {}
+        virtual bool Execute(Event event);
+   
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
new file mode 100644
index 0000000..64538cc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeStrategyAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool ChangeCombatStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ai->ChangeStrategy(text.empty() ? getName() : text, BOT_STATE_COMBAT);
+    return true;
+}
+
+bool ChangeNonCombatStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    uint32 account = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+    if (sPlayerbotAIConfig.IsInRandomAccountList(account) && ai->GetMaster() && ai->GetMaster()->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+    {
+        if (text.find("loot") != string::npos || text.find("gather") != string::npos)
+        {
+            ai->TellMaster("You can change any strategy except loot and gather");
+            return false;
+        }
+    }
+
+    ai->ChangeStrategy(text, BOT_STATE_NON_COMBAT);
+    return true;
+}
+
+bool ChangeDeadStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ai->ChangeStrategy(text, BOT_STATE_DEAD);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
new file mode 100644
index 0000000..9c3f4c5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
@@ -0,0 +1,30 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class ChangeCombatStrategyAction : public Action {
+	public:
+		ChangeCombatStrategyAction(PlayerbotAI* ai, string name = "co") : Action(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class ChangeNonCombatStrategyAction : public Action {
+    public:
+        ChangeNonCombatStrategyAction(PlayerbotAI* ai) : Action(ai, "nc") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class ChangeDeadStrategyAction : public Action {
+    public:
+        ChangeDeadStrategyAction(PlayerbotAI* ai) : Action(ai, "dead") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
new file mode 100644
index 0000000..3a7dc71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeTalentsAction.h"
+
+using namespace ai;
+
+bool ChangeTalentsAction::Execute(Event event)
+{
+    
+
+    string text = event.getParam();
+    if (text == "1" || text == "primary")
+    {
+        bot->ActivateSpec(0);
+        ai->TellMaster("Primary talents activated");
+    }
+    else if (text == "2" || text == "secondary")
+    {
+        bot->ActivateSpec(1);
+        ai->TellMaster("Secondary talents activated");
+    }
+    else
+    {
+        ostringstream out; 
+        switch (bot->GetActiveSpec())
+        {
+        case 0: out << "Primary";
+            break;
+        default: out << "Secondary";
+            break;
+        }
+        out << " talents are active";
+        ai->TellMaster(out);
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
new file mode 100644
index 0000000..dd9941a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class ChangeTalentsAction : public Action {
+	public:
+		ChangeTalentsAction(PlayerbotAI* ai) : Action(ai, "talents") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ChatActionContext.h b/src/plugins/playerbot/strategy/actions/ChatActionContext.h
new file mode 100644
index 0000000..6a0ab6b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatActionContext.h
@@ -0,0 +1,184 @@
+#pragma once
+
+#include "ListQuestsActions.h"
+#include "StatsAction.h"
+#include "LeaveGroupAction.h"
+#include "TellReputationAction.h"
+#include "LogLevelAction.h"
+#include "TellLosAction.h"
+#include "DropQuestAction.h"
+#include "QueryQuestAction.h"
+#include "QueryItemUsageAction.h"
+#include "LootStrategyAction.h"
+#include "AddLootAction.h"
+#include "ReleaseSpiritAction.h"
+#include "TeleportAction.h"
+#include "TaxiAction.h"
+#include "RepairAllAction.h"
+#include "UseItemAction.h"
+#include "TellItemCountAction.h"
+#include "RewardAction.h"
+#include "BuyAction.h"
+#include "SellAction.h"
+#include "UnequipAction.h"
+#include "EquipAction.h"
+#include "TradeAction.h"
+#include "ChangeTalentsAction.h"
+#include "ListSpellsAction.h"
+#include "ChangeStrategyAction.h"
+#include "TrainerAction.h"
+#include "ChangeChatAction.h"
+#include "SetHomeAction.h"
+#include "ResetAiAction.h"
+#include "DestroyItemAction.h"
+#include "BuffAction.h"
+#include "AttackAction.h"
+#include "HelpAction.h"
+#include "GuildBankAction.h"
+#include "ChatShortcutActions.h"
+#include "GossipHelloAction.h"
+#include "CastCustomSpellAction.h"
+#include "InviteToGroupAction.h"
+#include "TellCastFailedAction.h"
+#include "RtiAction.h"
+#include "ReviveFromCorpseAction.h"
+#include "BankAction.h"
+#include "PositionAction.h"
+#include "TellTargetAction.h"
+#include "UseMeetingStoneAction.h"
+#include "WhoAction.h"
+#include "SaveManaAction.h"
+#include "../values/Formations.h"
+
+namespace ai
+{
+    class ChatActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        ChatActionContext()
+        {
+            creators["stats"] = &ChatActionContext::stats;
+            creators["quests"] = &ChatActionContext::quests;
+            creators["leave"] = &ChatActionContext::leave;
+            creators["reputation"] = &ChatActionContext::reputation;
+            creators["log"] = &ChatActionContext::log;
+            creators["los"] = &ChatActionContext::los;
+            creators["drop"] = &ChatActionContext::drop;
+            creators["query quest"] = &ChatActionContext::query_quest;
+            creators["query item usage"] = &ChatActionContext::query_item_usage;
+            creators["ll"] = &ChatActionContext::ll;
+            creators["add all loot"] = &ChatActionContext::add_all_loot;
+            creators["release"] = &ChatActionContext::release;
+            creators["teleport"] = &ChatActionContext::teleport;
+            creators["taxi"] = &ChatActionContext::taxi;
+            creators["repair"] = &ChatActionContext::repair;
+            creators["use"] = &ChatActionContext::use;
+            creators["item count"] = &ChatActionContext::item_count;
+            creators["equip"] = &ChatActionContext::equip;
+            creators["unequip"] = &ChatActionContext::unequip;
+            creators["sell"] = &ChatActionContext::sell;
+            creators["buy"] = &ChatActionContext::buy;
+            creators["reward"] = &ChatActionContext::reward;
+            creators["trade"] = &ChatActionContext::trade;
+            creators["talents"] = &ChatActionContext::talents;
+            creators["spells"] = &ChatActionContext::spells;
+            creators["co"] = &ChatActionContext::co;
+            creators["nc"] = &ChatActionContext::nc;
+            creators["dead"] = &ChatActionContext::dead;
+            creators["trainer"] = &ChatActionContext::trainer;
+            creators["attack my target"] = &ChatActionContext::attack_my_target;
+            creators["chat"] = &ChatActionContext::chat;
+            creators["home"] = &ChatActionContext::home;
+            creators["destroy"] = &ChatActionContext::destroy;
+            creators["reset ai"] = &ChatActionContext::reset_ai;
+            creators["buff"] = &ChatActionContext::buff;
+            creators["help"] = &ChatActionContext::help;
+            creators["gb"] = &ChatActionContext::gb;
+            creators["bank"] = &ChatActionContext::bank;
+            creators["follow chat shortcut"] = &ChatActionContext::follow_chat_shortcut;
+            creators["stay chat shortcut"] = &ChatActionContext::stay_chat_shortcut;
+            creators["flee chat shortcut"] = &ChatActionContext::flee_chat_shortcut;
+            creators["runaway chat shortcut"] = &ChatActionContext::runaway_chat_shortcut;
+            creators["grind chat shortcut"] = &ChatActionContext::grind_chat_shortcut;
+            creators["tank attack chat shortcut"] = &ChatActionContext::tank_attack_chat_shortcut;
+            creators["gossip hello"] = &ChatActionContext::gossip_hello;
+            creators["cast custom spell"] = &ChatActionContext::cast_custom_spell;
+            creators["invite"] = &ChatActionContext::invite;
+            creators["spell"] = &ChatActionContext::spell;
+            creators["rti"] = &ChatActionContext::rti;
+            creators["spirit healer"] = &ChatActionContext::spirit_healer;
+            creators["position"] = &ChatActionContext::position;
+            creators["tell target"] = &ChatActionContext::tell_target;
+            creators["summon"] = &ChatActionContext::summon;
+            creators["who"] = &ChatActionContext::who;
+            creators["save mana"] = &ChatActionContext::save_mana;
+            creators["max dps chat shortcut"] = &ChatActionContext::max_dps_chat_shortcut;
+            creators["tell attackers"] = &ChatActionContext::tell_attackers;
+            creators["formation"] = &ChatActionContext::formation;
+        }
+
+    private:
+        static Action* formation(PlayerbotAI* ai) { return new SetFormationAction(ai); }
+        static Action* tell_attackers(PlayerbotAI* ai) { return new TellAttackersAction(ai); }
+        static Action* max_dps_chat_shortcut(PlayerbotAI* ai) { return new MaxDpsChatShortcutAction(ai); }
+        static Action* save_mana(PlayerbotAI* ai) { return new SaveManaAction(ai); }
+        static Action* who(PlayerbotAI* ai) { return new WhoAction(ai); }
+        static Action* summon(PlayerbotAI* ai) { return new SummonAction(ai); }
+        static Action* tell_target(PlayerbotAI* ai) { return new TellTargetAction(ai); }
+        static Action* position(PlayerbotAI* ai) { return new PositionAction(ai); }
+        static Action* spirit_healer(PlayerbotAI* ai) { return new SpiritHealerAction(ai); }
+        static Action* rti(PlayerbotAI* ai) { return new RtiAction(ai); }
+        static Action* invite(PlayerbotAI* ai) { return new InviteToGroupAction(ai); }
+        static Action* spell(PlayerbotAI* ai) { return new TellSpellAction(ai); }
+        static Action* cast_custom_spell(PlayerbotAI* ai) { return new CastCustomSpellAction(ai); }
+        static Action* tank_attack_chat_shortcut(PlayerbotAI* ai) { return new TankAttackChatShortcutAction(ai); }
+        static Action* grind_chat_shortcut(PlayerbotAI* ai) { return new GrindChatShortcutAction(ai); }
+        static Action* flee_chat_shortcut(PlayerbotAI* ai) { return new FleeChatShortcutAction(ai); }
+        static Action* runaway_chat_shortcut(PlayerbotAI* ai) { return new GoawayChatShortcutAction(ai); }
+        static Action* stay_chat_shortcut(PlayerbotAI* ai) { return new StayChatShortcutAction(ai); }
+        static Action* follow_chat_shortcut(PlayerbotAI* ai) { return new FollowChatShortcutAction(ai); }
+        static Action* gb(PlayerbotAI* ai) { return new GuildBankAction(ai); }
+        static Action* bank(PlayerbotAI* ai) { return new BankAction(ai); }
+        static Action* help(PlayerbotAI* ai) { return new HelpAction(ai); }
+        static Action* buff(PlayerbotAI* ai) { return new BuffAction(ai); }
+        static Action* destroy(PlayerbotAI* ai) { return new DestroyItemAction(ai); }
+        static Action* home(PlayerbotAI* ai) { return new SetHomeAction(ai); }
+        static Action* chat(PlayerbotAI* ai) { return new ChangeChatAction(ai); }
+        static Action* attack_my_target(PlayerbotAI* ai) { return new AttackMyTargetAction(ai); }
+        static Action* trainer(PlayerbotAI* ai) { return new TrainerAction(ai); }
+        static Action* co(PlayerbotAI* ai) { return new ChangeCombatStrategyAction(ai); }
+        static Action* nc(PlayerbotAI* ai) { return new ChangeNonCombatStrategyAction(ai); }
+        static Action* dead(PlayerbotAI* ai) { return new ChangeDeadStrategyAction(ai); }
+        static Action* spells(PlayerbotAI* ai) { return new ListSpellsAction(ai); }
+        static Action* talents(PlayerbotAI* ai) { return new ChangeTalentsAction(ai); }
+
+        static Action* equip(PlayerbotAI* ai) { return new EquipAction(ai); }
+        static Action* unequip(PlayerbotAI* ai) { return new UnequipAction(ai); }
+        static Action* sell(PlayerbotAI* ai) { return new SellAction(ai); }
+        static Action* buy(PlayerbotAI* ai) { return new BuyAction(ai); }
+        static Action* reward(PlayerbotAI* ai) { return new RewardAction(ai); }
+        static Action* trade(PlayerbotAI* ai) { return new TradeAction(ai); }
+
+        static Action* item_count(PlayerbotAI* ai) { return new TellItemCountAction(ai); }
+        static Action* use(PlayerbotAI* ai) { return new UseItemAction(ai); }
+        static Action* repair(PlayerbotAI* ai) { return new RepairAllAction(ai); }
+        static Action* taxi(PlayerbotAI* ai) { return new TaxiAction(ai); }
+        static Action* teleport(PlayerbotAI* ai) { return new TeleportAction(ai); }
+        static Action* release(PlayerbotAI* ai) { return new ReleaseSpiritAction(ai); }
+        static Action* query_item_usage(PlayerbotAI* ai) { return new QueryItemUsageAction(ai); }
+        static Action* query_quest(PlayerbotAI* ai) { return new QueryQuestAction(ai); }
+        static Action* drop(PlayerbotAI* ai) { return new DropQuestAction(ai); }
+        static Action* stats(PlayerbotAI* ai) { return new StatsAction(ai); }
+        static Action* quests(PlayerbotAI* ai) { return new ListQuestsAction(ai); }
+        static Action* leave(PlayerbotAI* ai) { return new LeaveGroupAction(ai); }
+        static Action* reputation(PlayerbotAI* ai) { return new TellReputationAction(ai); }
+        static Action* log(PlayerbotAI* ai) { return new LogLevelAction(ai); }
+        static Action* los(PlayerbotAI* ai) { return new TellLosAction(ai); }
+        static Action* ll(PlayerbotAI* ai) { return new LootStrategyAction(ai); }
+        static Action* add_all_loot(PlayerbotAI* ai) { return new AddAllLootAction(ai); }
+        static Action* reset_ai(PlayerbotAI* ai) { return new ResetAiAction(ai); }
+        static Action* gossip_hello(PlayerbotAI* ai) { return new GossipHelloAction(ai); }
+    };
+
+
+};
diff --git a/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
new file mode 100644
index 0000000..e0c3f12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
@@ -0,0 +1,108 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChatShortcutActions.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool FollowChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+follow,-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-follow,-passive", BOT_STATE_COMBAT);
+    if (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I will not follow you - too far away");
+        return true;
+    }
+    ai->TellMaster("Following");
+    return true;
+}
+
+bool StayChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+stay,-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-follow,-passive", BOT_STATE_COMBAT);
+    ai->TellMaster("Staying");
+    return true;
+}
+
+bool FleeChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+follow,+passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("+follow,+passive", BOT_STATE_COMBAT);
+    if (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I will not flee with you - too far away");
+        return true;
+    }
+    ai->TellMaster("Fleeing");
+    return true;
+}
+
+bool GoawayChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+runaway", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("+runaway", BOT_STATE_COMBAT);
+    ai->TellMaster("Running away");
+    return true;
+}
+
+bool GrindChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+grind,-passive", BOT_STATE_NON_COMBAT);
+    ai->TellMaster("Grinding");
+    return true;
+}
+
+bool TankAttackChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!ai->IsTank(bot))
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-passive", BOT_STATE_COMBAT);
+    ai->TellMaster("Attacking");
+    return true;
+}
+
+bool MaxDpsChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("-threat,-conserve mana,-cast time,+dps debuff", BOT_STATE_COMBAT);
+    ai->TellMaster("Max DPS");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
new file mode 100644
index 0000000..de9a86a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class FollowChatShortcutAction : public Action
+    {
+    public:
+        FollowChatShortcutAction(PlayerbotAI* ai) : Action(ai, "follow chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class StayChatShortcutAction : public Action
+    {
+    public:
+        StayChatShortcutAction(PlayerbotAI* ai) : Action(ai, "stay chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class FleeChatShortcutAction : public Action
+    {
+    public:
+        FleeChatShortcutAction(PlayerbotAI* ai) : Action(ai, "flee chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class GoawayChatShortcutAction : public Action
+    {
+    public:
+        GoawayChatShortcutAction(PlayerbotAI* ai) : Action(ai, "runaway chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class GrindChatShortcutAction : public Action
+    {
+    public:
+        GrindChatShortcutAction(PlayerbotAI* ai) : Action(ai, "grind chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class TankAttackChatShortcutAction : public Action
+    {
+    public:
+        TankAttackChatShortcutAction(PlayerbotAI* ai) : Action(ai, "tank attack chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MaxDpsChatShortcutAction : public Action
+    {
+    public:
+        MaxDpsChatShortcutAction(PlayerbotAI* ai) : Action(ai, "max dps chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp b/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
new file mode 100644
index 0000000..c5aa48f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CheckMailAction.h"
+
+#include "../../GuildTaskMgr.h"
+using namespace ai;
+
+bool CheckMailAction::Execute(Event event)
+{
+    if (!bot->IsMailsLoaded())
+    {
+        WorldPacket p;
+        bot->GetSession()->HandleQueryNextMailTime(p);
+    }
+
+    if (!bot->GetMailSize())
+        return false;
+
+    list<uint32> ids;
+    for (PlayerMails::iterator i = bot->GetMailBegin(); i != bot->GetMailEnd(); ++i)
+    {
+        Mail* mail = *i;
+
+        if (!mail || mail->state == MAIL_STATE_DELETED)
+            continue;
+
+        Player* owner = sObjectMgr->GetPlayerByLowGUID(mail->sender);
+        if (!owner)
+            continue;
+
+        ProcessMail(mail, owner);
+        ids.push_back(mail->messageID);
+        mail->state = MAIL_STATE_DELETED;
+    }
+
+    for (list<uint32>::iterator i = ids.begin(); i != ids.end(); ++i)
+    {
+        uint32 id = *i;
+        bot->SendMailResult(id, MAIL_DELETED, MAIL_OK);
+        SQLTransaction tran = CharacterDatabase.BeginTransaction();
+        CharacterDatabase.PExecute("DELETE FROM mail WHERE id = '%u'", id);
+        CharacterDatabase.PExecute("DELETE FROM mail_items WHERE mail_id = '%u'", id);
+        CharacterDatabase.CommitTransaction(tran);
+        bot->RemoveMail(id);
+    }
+
+    return true;
+}
+
+
+void CheckMailAction::ProcessMail(Mail* mail, Player* owner)
+{
+    if (!mail->HasItems())
+        return;
+
+    for (MailItemInfoVec::iterator i = mail->items.begin(); i != mail->items.end(); ++i)
+    {
+        Item *item = bot->GetMItem(i->item_guid);
+        if (!item)
+            continue;
+
+        sGuildTaskMgr.CheckItemTask(i->item_template, item->GetCount(), owner, bot, true);
+        bot->RemoveMItem(i->item_guid);
+        item->DestroyForPlayer(bot);
+    }
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/CheckMailAction.h b/src/plugins/playerbot/strategy/actions/CheckMailAction.h
new file mode 100644
index 0000000..9da88a9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMailAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class CheckMailAction : public Action
+    {
+    public:
+        CheckMailAction(PlayerbotAI* ai) : Action(ai, "check mail") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ProcessMail(Mail* mail, Player* owner);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
new file mode 100644
index 0000000..3c94f97
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
@@ -0,0 +1,79 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../../../Spells/Auras/SpellAuraEffects.h"
+#include "CheckMountStateAction.h"
+
+using namespace ai;
+
+uint64 extractGuid(WorldPacket& packet);
+
+bool CheckMountStateAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!bot->GetGroup() || !master)
+        return false;
+
+    if (bot->IsFlying())
+        return false;
+
+    if (master->IsMounted() && !bot->IsMounted())
+    {
+        return Mount();
+    }
+    else if (!master->IsMounted() && bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+        return true;
+    }
+    return false;
+}
+
+
+bool CheckMountStateAction::Mount()
+{
+    Player* master = GetMaster();
+    ai->RemoveShapeshift();
+
+    Unit::AuraEffectList const& auras = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    const SpellInfo* masterSpell = auras.front()->GetSpellInfo();
+    int32 masterSpeed = max(masterSpell->Effects[1].BasePoints, masterSpell->Effects[2].BasePoints);
+
+    map<uint32, map<int32, vector<uint32> > > allSpells;
+    for(PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+
+        if (!spellInfo || spellInfo->Effects[0].ApplyAuraName != SPELL_AURA_MOUNTED)
+            continue;
+
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || spellInfo->IsPassive())
+            continue;
+
+        int32 effect = max(spellInfo->Effects[1].BasePoints, spellInfo->Effects[2].BasePoints);
+        if (effect < masterSpeed)
+            continue;
+
+        uint32 index = (spellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED ||
+                spellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ? 1 : 0;
+        allSpells[index][effect].push_back(spellId);
+    }
+
+    int masterMountType = (masterSpell->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED ||
+            masterSpell->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ? 1 : 0;
+
+    map<int32, vector<uint32> >& spells = allSpells[masterMountType];
+    for (map<int32,vector<uint32> >::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+		vector<uint32>& ids = i->second;
+        int index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        ai->CastSpell(ids[index], bot);
+        return true;
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
new file mode 100644
index 0000000..c5b087e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class CheckMountStateAction : public Action {
+    public:
+        CheckMountStateAction(PlayerbotAI* ai) : Action(ai, "check mount state") {}
+
+        virtual bool Execute(Event event);
+
+    private:
+        bool Mount();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h b/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
new file mode 100644
index 0000000..d0b1a9a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
@@ -0,0 +1,80 @@
+#pragma once
+
+#include "../Action.h"
+#include "AttackAction.h"
+#include "../../../DungeonFinding/LFGMgr.h"
+
+namespace ai
+{
+    class DpsAssistAction : public AttackAction
+    {
+    public:
+        DpsAssistAction(PlayerbotAI* ai) : AttackAction(ai, "dps assist") {}
+
+        virtual string GetTargetName() { return "dps target"; }
+    };
+
+    class TankAssistAction : public AttackAction
+    {
+    public:
+        TankAssistAction(PlayerbotAI* ai) : AttackAction(ai, "tank assist") {}
+        virtual string GetTargetName() { return "tank target"; }
+    };
+
+    class AttackAnythingAction : public AttackAction
+    {
+    public:
+        AttackAnythingAction(PlayerbotAI* ai) : AttackAction(ai, "attack anything") {}
+        virtual string GetTargetName() { return "grind target"; }
+        virtual bool Execute(Event event)
+        {
+            return AttackAction::Execute(event);
+        }
+        virtual bool isUseful() {
+            return GetTarget() &&
+                (AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.mediumHealth &&
+                (!AI_VALUE2(uint8, "mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumMana)) || AI_VALUE2(bool, "combat", "self target");
+        }
+        virtual bool isPossible()
+        {
+            return AttackAction::isPossible() && GetTarget();
+        }
+    };
+
+    class AttackLeastHpTargetAction : public AttackAction
+    {
+    public:
+        AttackLeastHpTargetAction(PlayerbotAI* ai) : AttackAction(ai, "attack least hp target") {}
+        virtual string GetTargetName() { return "least hp target"; }
+    };
+
+    class AttackEnemyPlayerAction : public AttackAction
+    {
+    public:
+        AttackEnemyPlayerAction(PlayerbotAI* ai) : AttackAction(ai, "attack enemy player") {}
+        virtual string GetTargetName() { return "enemy player target"; }
+    };
+
+    class AttackRtiTargetAction : public AttackAction
+    {
+    public:
+        AttackRtiTargetAction(PlayerbotAI* ai) : AttackAction(ai, "attack rti target") {}
+        virtual string GetTargetName() { return "rti target"; }
+    };
+
+    class DropTargetAction : public Action
+    {
+    public:
+        DropTargetAction(PlayerbotAI* ai) : Action(ai, "drop target") {}
+
+        virtual bool Execute(Event event)
+        {
+            context->GetValue<Unit*>("current target")->Set(NULL);
+            bot->SetSelection(ObjectGuid());
+            ai->ChangeEngine(BOT_STATE_NON_COMBAT);
+            ai->InterruptSpell();
+			return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp b/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
new file mode 100644
index 0000000..9167182
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DestroyItemAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool DestroyItemAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        DestroyItem(&visitor);
+    }
+
+    return true;
+}
+
+void DestroyItemAction::DestroyItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+	for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+		Item* item = *i;
+        bot->DestroyItem(item->GetBagSlot(),item->GetSlot(), true);
+        ostringstream out; out << chat->formatItem(item->GetTemplate()) << " destroyed";
+        ai->TellMaster(out);
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/DestroyItemAction.h b/src/plugins/playerbot/strategy/actions/DestroyItemAction.h
new file mode 100644
index 0000000..ad1ab05
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DestroyItemAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class DestroyItemAction : public InventoryAction {
+    public:
+        DestroyItemAction(PlayerbotAI* ai) : InventoryAction(ai, "destroy") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void DestroyItem(FindItemVisitor* visitor);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp b/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
new file mode 100644
index 0000000..e94e779
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DropQuestAction.h"
+
+
+using namespace ai;
+
+bool DropQuestAction::Execute(Event event)
+{
+    string link = event.getParam();
+    if (!GetMaster())
+        return false;
+
+    PlayerbotChatHandler handler(GetMaster());
+    uint32 entry = handler.extractQuestId(link);
+    if (!entry)
+        return false;
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(entry);
+    if (!quest)
+        return false;
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 logQuest = bot->GetQuestSlotQuestId(slot);
+        if (logQuest == entry)
+        {
+            bot->SetQuestSlot(slot, 0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            bot->TakeQuestSourceItem(logQuest, false);
+
+            if (quest->HasFlag(QUEST_FLAGS_FLAGS_PVP))
+            {
+                bot->pvpInfo.IsHostile = bot->pvpInfo.IsInHostileArea || bot->HasPvPForcingQuest();
+                bot->UpdatePvPState();
+            }
+        }
+    }
+
+    bot->RemoveActiveQuest(entry, false);
+    bot->RemoveRewardedQuest(entry);
+
+    ai->TellMaster("Quest removed");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/DropQuestAction.h b/src/plugins/playerbot/strategy/actions/DropQuestAction.h
new file mode 100644
index 0000000..af5d4ca
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DropQuestAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class DropQuestAction : public Action {
+    public:
+        DropQuestAction(PlayerbotAI* ai) : Action(ai, "drop quest") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/EmoteAction.cpp b/src/plugins/playerbot/strategy/actions/EmoteAction.cpp
new file mode 100644
index 0000000..02076f9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EmoteAction.cpp
@@ -0,0 +1,366 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EmoteAction.h"
+
+using namespace ai;
+
+map<string, uint32> EmoteAction::emotes;
+map<string, uint32> EmoteAction::textEmotes;
+
+bool EmoteAction::Execute(Event event)
+{
+    if (emotes.empty())
+        InitEmotes();
+
+    uint32 emote = 0;
+
+    time_t lastEmote = AI_VALUE2(time_t, "last emote", qualifier);
+    ai->GetAiObjectContext()->GetValue<time_t>("last emote", qualifier)->Set(time(0) + urand(1, 60));
+
+    string param = event.getParam();
+    if (param.empty()) param = qualifier;
+
+    if (!param.empty() && textEmotes.find(param) != emotes.end())
+    {
+        return ai->PlaySound(textEmotes[param]);
+    }
+    else if (param.empty() || emotes.find(param) == emotes.end())
+    {
+        int index = rand() % emotes.size();
+		for (map<string, uint32>::iterator i = emotes.begin(); i != emotes.end() && index; ++i, --index)
+			emote = i->second;
+    }
+    else
+    {
+        emote = emotes[param];
+    }
+
+    Player* master = GetMaster();
+	if (master)
+	{
+        Unit* masterSelection = master->GetSelectedUnit();
+        if (masterSelection)
+        {
+            Unit* oldSelection = bot->GetSelectedUnit();
+            bot->SetSelection(masterSelection->GetGUID());
+            bot->HandleEmoteCommand(emote);
+            if (oldSelection)
+                bot->SetSelection(oldSelection->GetGUID());
+            return true;
+        }
+	}
+
+    bot->HandleEmoteCommand(emote);
+    return true;
+}
+
+void EmoteAction::InitEmotes()
+{
+    emotes["cower"] = EMOTE_ONESHOT_COWER;
+    emotes["dance"] = EMOTE_ONESHOT_DANCE;
+    emotes["drown"] = EMOTE_ONESHOT_DROWN;
+    emotes["emerge"] = EMOTE_ONESHOT_EMERGE;
+    emotes["land"] = EMOTE_ONESHOT_LAND;
+    emotes["laugh_nosheathe"] = EMOTE_ONESHOT_LAUGH_NO_SHEATHE;
+    emotes["liftoff"] = EMOTE_ONESHOT_LIFTOFF;
+    emotes["loot"] = EMOTE_ONESHOT_LOOT;
+    emotes["no"] = EMOTE_ONESHOT_NO;
+    emotes["one_shot_stun"] = EMOTE_ONESHOT_STUN;
+    emotes["point_nosheathe"] = EMOTE_ONESHOT_POINT_NO_SHEATHE;
+    emotes["roar"] = EMOTE_STATE_ROAR;
+    emotes["salute"] = EMOTE_ONESHOT_SALUTE;
+    emotes["stomp"] = EMOTE_ONESHOT_STOMP;
+    emotes["train"] = EMOTE_ONESHOT_TRAIN;
+    emotes["yes"] = EMOTE_ONESHOT_YES;
+    emotes["applaud"] = EMOTE_ONESHOT_APPLAUD;
+    emotes["battleroar"] = EMOTE_ONESHOT_BATTLE_ROAR;
+    emotes["beg"] = EMOTE_ONESHOT_BEG;
+    emotes["bow"] = EMOTE_ONESHOT_BOW;
+    emotes["cheer"] = EMOTE_ONESHOT_CHEER;
+    emotes["chicken"] = EMOTE_ONESHOT_CHICKEN;
+    emotes["cry"] = EMOTE_ONESHOT_CRY;
+    emotes["dance"] = EMOTE_STATE_DANCE;
+    emotes["eat"] = EMOTE_ONESHOT_EAT;
+    emotes["exclamation"] = EMOTE_ONESHOT_EXCLAMATION;
+    emotes["flex"] = EMOTE_ONESHOT_FLEX;
+    emotes["kick"] = EMOTE_ONESHOT_KICK;
+    emotes["kiss"] = EMOTE_ONESHOT_KISS;
+    emotes["kneel"] = EMOTE_ONESHOT_KNEEL;
+    emotes["laugh"] = EMOTE_ONESHOT_LAUGH;
+    emotes["parryshield"] = EMOTE_ONESHOT_PARRY_SHIELD;
+    emotes["parryunarmed"] = EMOTE_ONESHOT_PARRY_UNARMED;
+    emotes["point"] = EMOTE_ONESHOT_POINT;
+    emotes["question"] = EMOTE_ONESHOT_QUESTION;
+    emotes["ready1h"] = EMOTE_ONESHOT_READY1H;
+    emotes["readybow"] = EMOTE_ONESHOT_READY_BOW;
+    emotes["readyunarmed"] = EMOTE_ONESHOT_READY_UNARMED;
+    emotes["roar"] = EMOTE_ONESHOT_ROAR;
+    emotes["rude"] = EMOTE_ONESHOT_RUDE;
+    emotes["shout"] = EMOTE_ONESHOT_SHOUT;
+    emotes["shy"] = EMOTE_ONESHOT_SHY;
+    emotes["sleep"] = EMOTE_STATE_SLEEP;
+    emotes["talk"] = EMOTE_ONESHOT_TALK;
+    emotes["wave"] = EMOTE_ONESHOT_WAVE;
+    emotes["woundcritical"] = EMOTE_ONESHOT_WOUND_CRITICAL;
+    emotes["wound"] = EMOTE_ONESHOT_WOUND;
+
+    textEmotes["agree"] = TEXT_EMOTE_AGREE;
+    textEmotes["amaze"] = TEXT_EMOTE_AMAZE;
+    textEmotes["angry"] = TEXT_EMOTE_ANGRY;
+    textEmotes["apologize"] = TEXT_EMOTE_APOLOGIZE;
+    textEmotes["applaud"] = TEXT_EMOTE_APPLAUD;
+    textEmotes["bashful"] = TEXT_EMOTE_BASHFUL;
+    textEmotes["beckon"] = TEXT_EMOTE_BECKON;
+    textEmotes["beg"] = TEXT_EMOTE_BEG;
+    textEmotes["bite"] = TEXT_EMOTE_BITE;
+    textEmotes["bleed"] = TEXT_EMOTE_BLEED;
+    textEmotes["blink"] = TEXT_EMOTE_BLINK;
+    textEmotes["blush"] = TEXT_EMOTE_BLUSH;
+    textEmotes["bonk"] = TEXT_EMOTE_BONK;
+    textEmotes["bored"] = TEXT_EMOTE_BORED;
+    textEmotes["bounce"] = TEXT_EMOTE_BOUNCE;
+    textEmotes["brb"] = TEXT_EMOTE_BRB;
+    textEmotes["bow"] = TEXT_EMOTE_BOW;
+    textEmotes["burp"] = TEXT_EMOTE_BURP;
+    textEmotes["bye"] = TEXT_EMOTE_BYE;
+    textEmotes["cackle"] = TEXT_EMOTE_CACKLE;
+    textEmotes["cheer"] = TEXT_EMOTE_CHEER;
+    textEmotes["chicken"] = TEXT_EMOTE_CHICKEN;
+    textEmotes["chuckle"] = TEXT_EMOTE_CHUCKLE;
+    textEmotes["clap"] = TEXT_EMOTE_CLAP;
+    textEmotes["confused"] = TEXT_EMOTE_CONFUSED;
+    textEmotes["congratulate"] = TEXT_EMOTE_CONGRATULATE;
+    textEmotes["cough"] = TEXT_EMOTE_COUGH;
+    textEmotes["cower"] = TEXT_EMOTE_COWER;
+    textEmotes["crack"] = TEXT_EMOTE_CRACK;
+    textEmotes["cringe"] = TEXT_EMOTE_CRINGE;
+    textEmotes["cry"] = TEXT_EMOTE_CRY;
+    textEmotes["curious"] = TEXT_EMOTE_CURIOUS;
+    textEmotes["curtsey"] = TEXT_EMOTE_CURTSEY;
+    textEmotes["dance"] = TEXT_EMOTE_DANCE;
+    textEmotes["drink"] = TEXT_EMOTE_DRINK;
+    textEmotes["drool"] = TEXT_EMOTE_DROOL;
+    textEmotes["eat"] = TEXT_EMOTE_EAT;
+    textEmotes["eye"] = TEXT_EMOTE_EYE;
+    textEmotes["fart"] = TEXT_EMOTE_FART;
+    textEmotes["fidget"] = TEXT_EMOTE_FIDGET;
+    textEmotes["flex"] = TEXT_EMOTE_FLEX;
+    textEmotes["frown"] = TEXT_EMOTE_FROWN;
+    textEmotes["gasp"] = TEXT_EMOTE_GASP;
+    textEmotes["gaze"] = TEXT_EMOTE_GAZE;
+    textEmotes["giggle"] = TEXT_EMOTE_GIGGLE;
+    textEmotes["glare"] = TEXT_EMOTE_GLARE;
+    textEmotes["gloat"] = TEXT_EMOTE_GLOAT;
+    textEmotes["greet"] = TEXT_EMOTE_GREET;
+    textEmotes["grin"] = TEXT_EMOTE_GRIN;
+    textEmotes["groan"] = TEXT_EMOTE_GROAN;
+    textEmotes["grovel"] = TEXT_EMOTE_GROVEL;
+    textEmotes["guffaw"] = TEXT_EMOTE_GUFFAW;
+    textEmotes["hail"] = TEXT_EMOTE_HAIL;
+    textEmotes["happy"] = TEXT_EMOTE_HAPPY;
+    textEmotes["hello"] = TEXT_EMOTE_HELLO;
+    textEmotes["hug"] = TEXT_EMOTE_HUG;
+    textEmotes["hungry"] = TEXT_EMOTE_HUNGRY;
+    textEmotes["kiss"] = TEXT_EMOTE_KISS;
+    textEmotes["kneel"] = TEXT_EMOTE_KNEEL;
+    textEmotes["laugh"] = TEXT_EMOTE_LAUGH;
+    textEmotes["laydown"] = TEXT_EMOTE_LAYDOWN;
+    textEmotes["message"] = TEXT_EMOTE_MESSAGE;
+    textEmotes["moan"] = TEXT_EMOTE_MOAN;
+    textEmotes["moon"] = TEXT_EMOTE_MOON;
+    textEmotes["mourn"] = TEXT_EMOTE_MOURN;
+    textEmotes["no"] = TEXT_EMOTE_NO;
+    textEmotes["nod"] = TEXT_EMOTE_NOD;
+    textEmotes["nosepick"] = TEXT_EMOTE_NOSEPICK;
+    textEmotes["panic"] = TEXT_EMOTE_PANIC;
+    textEmotes["peer"] = TEXT_EMOTE_PEER;
+    textEmotes["plead"] = TEXT_EMOTE_PLEAD;
+    textEmotes["point"] = TEXT_EMOTE_POINT;
+    textEmotes["poke"] = TEXT_EMOTE_POKE;
+    textEmotes["pray"] = TEXT_EMOTE_PRAY;
+    textEmotes["roar"] = TEXT_EMOTE_ROAR;
+    textEmotes["rofl"] = TEXT_EMOTE_ROFL;
+    textEmotes["rude"] = TEXT_EMOTE_RUDE;
+    textEmotes["salute"] = TEXT_EMOTE_SALUTE;
+    textEmotes["scratch"] = TEXT_EMOTE_SCRATCH;
+    textEmotes["sexy"] = TEXT_EMOTE_SEXY;
+    textEmotes["shake"] = TEXT_EMOTE_SHAKE;
+    textEmotes["shout"] = TEXT_EMOTE_SHOUT;
+    textEmotes["shrug"] = TEXT_EMOTE_SHRUG;
+    textEmotes["shy"] = TEXT_EMOTE_SHY;
+    textEmotes["sigh"] = TEXT_EMOTE_SIGH;
+    textEmotes["sit"] = TEXT_EMOTE_SIT;
+    textEmotes["sleep"] = TEXT_EMOTE_SLEEP;
+    textEmotes["snarl"] = TEXT_EMOTE_SNARL;
+    textEmotes["spit"] = TEXT_EMOTE_SPIT;
+    textEmotes["stare"] = TEXT_EMOTE_STARE;
+    textEmotes["surprised"] = TEXT_EMOTE_SURPRISED;
+    textEmotes["surrender"] = TEXT_EMOTE_SURRENDER;
+    textEmotes["talk"] = TEXT_EMOTE_TALK;
+    textEmotes["talkex"] = TEXT_EMOTE_TALKEX;
+    textEmotes["talkq"] = TEXT_EMOTE_TALKQ;
+    textEmotes["tap"] = TEXT_EMOTE_TAP;
+    textEmotes["thank"] = TEXT_EMOTE_THANK;
+    textEmotes["threaten"] = TEXT_EMOTE_THREATEN;
+    textEmotes["tired"] = TEXT_EMOTE_TIRED;
+    textEmotes["victory"] = TEXT_EMOTE_VICTORY;
+    textEmotes["wave"] = TEXT_EMOTE_WAVE;
+    textEmotes["welcome"] = TEXT_EMOTE_WELCOME;
+    textEmotes["whine"] = TEXT_EMOTE_WHINE;
+    textEmotes["whistle"] = TEXT_EMOTE_WHISTLE;
+    textEmotes["work"] = TEXT_EMOTE_WORK;
+    textEmotes["yawn"] = TEXT_EMOTE_YAWN;
+    textEmotes["boggle"] = TEXT_EMOTE_BOGGLE;
+    textEmotes["calm"] = TEXT_EMOTE_CALM;
+    textEmotes["cold"] = TEXT_EMOTE_COLD;
+    textEmotes["comfort"] = TEXT_EMOTE_COMFORT;
+    textEmotes["cuddle"] = TEXT_EMOTE_CUDDLE;
+    textEmotes["duck"] = TEXT_EMOTE_DUCK;
+    textEmotes["insult"] = TEXT_EMOTE_INSULT;
+    textEmotes["introduce"] = TEXT_EMOTE_INTRODUCE;
+    textEmotes["jk"] = TEXT_EMOTE_JK;
+    textEmotes["lick"] = TEXT_EMOTE_LICK;
+    textEmotes["listen"] = TEXT_EMOTE_LISTEN;
+    textEmotes["lost"] = TEXT_EMOTE_LOST;
+    textEmotes["mock"] = TEXT_EMOTE_MOCK;
+    textEmotes["ponder"] = TEXT_EMOTE_PONDER;
+    textEmotes["pounce"] = TEXT_EMOTE_POUNCE;
+    textEmotes["praise"] = TEXT_EMOTE_PRAISE;
+    textEmotes["purr"] = TEXT_EMOTE_PURR;
+    textEmotes["puzzle"] = TEXT_EMOTE_PUZZLE;
+    textEmotes["raise"] = TEXT_EMOTE_RAISE;
+    textEmotes["ready"] = TEXT_EMOTE_READY;
+    textEmotes["shimmy"] = TEXT_EMOTE_SHIMMY;
+    textEmotes["shiver"] = TEXT_EMOTE_SHIVER;
+    textEmotes["shoo"] = TEXT_EMOTE_SHOO;
+    textEmotes["slap"] = TEXT_EMOTE_SLAP;
+    textEmotes["smirk"] = TEXT_EMOTE_SMIRK;
+    textEmotes["sniff"] = TEXT_EMOTE_SNIFF;
+    textEmotes["snub"] = TEXT_EMOTE_SNUB;
+    textEmotes["soothe"] = TEXT_EMOTE_SOOTHE;
+    textEmotes["stink"] = TEXT_EMOTE_STINK;
+    textEmotes["taunt"] = TEXT_EMOTE_TAUNT;
+    textEmotes["tease"] = TEXT_EMOTE_TEASE;
+    textEmotes["thirsty"] = TEXT_EMOTE_THIRSTY;
+    textEmotes["veto"] = TEXT_EMOTE_VETO;
+    textEmotes["snicker"] = TEXT_EMOTE_SNICKER;
+    textEmotes["stand"] = TEXT_EMOTE_STAND;
+    textEmotes["tickle"] = TEXT_EMOTE_TICKLE;
+    textEmotes["violin"] = TEXT_EMOTE_VIOLIN;
+    textEmotes["smile"] = TEXT_EMOTE_SMILE;
+    textEmotes["rasp"] = TEXT_EMOTE_RASP;
+    textEmotes["pity"] = TEXT_EMOTE_PITY;
+    textEmotes["growl"] = TEXT_EMOTE_GROWL;
+    textEmotes["bark"] = TEXT_EMOTE_BARK;
+    textEmotes["scared"] = TEXT_EMOTE_SCARED;
+    textEmotes["flop"] = TEXT_EMOTE_FLOP;
+    textEmotes["love"] = TEXT_EMOTE_LOVE;
+    textEmotes["moo"] = TEXT_EMOTE_MOO;
+    textEmotes["commend"] = TEXT_EMOTE_COMMEND;
+    textEmotes["train"] = TEXT_EMOTE_TRAIN;
+    textEmotes["helpme"] = TEXT_EMOTE_HELPME;
+    textEmotes["incoming"] = TEXT_EMOTE_INCOMING;
+    textEmotes["charge"] = TEXT_EMOTE_CHARGE;
+    textEmotes["flee"] = TEXT_EMOTE_FLEE;
+    textEmotes["attackmytarget"] = TEXT_EMOTE_ATTACKMYTARGET;
+    textEmotes["oom"] = TEXT_EMOTE_OOM;
+    textEmotes["follow"] = TEXT_EMOTE_FOLLOW;
+    textEmotes["wait"] = TEXT_EMOTE_WAIT;
+    textEmotes["healme"] = TEXT_EMOTE_HEALME;
+    textEmotes["openfire"] = TEXT_EMOTE_OPENFIRE;
+    textEmotes["flirt"] = TEXT_EMOTE_FLIRT;
+    textEmotes["joke"] = TEXT_EMOTE_JOKE;
+    textEmotes["golfclap"] = TEXT_EMOTE_GOLFCLAP;
+    textEmotes["wink"] = TEXT_EMOTE_WINK;
+    textEmotes["pat"] = TEXT_EMOTE_PAT;
+    textEmotes["serious"] = TEXT_EMOTE_SERIOUS;
+    textEmotes["mount_special"] = TEXT_EMOTE_MOUNT_SPECIAL;
+    textEmotes["goodluck"] = TEXT_EMOTE_GOODLUCK;
+    textEmotes["blame"] = TEXT_EMOTE_BLAME;
+    textEmotes["blank"] = TEXT_EMOTE_BLANK;
+    textEmotes["brandish"] = TEXT_EMOTE_BRANDISH;
+    textEmotes["breath"] = TEXT_EMOTE_BREATH;
+    textEmotes["disagree"] = TEXT_EMOTE_DISAGREE;
+    textEmotes["doubt"] = TEXT_EMOTE_DOUBT;
+    textEmotes["embarrass"] = TEXT_EMOTE_EMBARRASS;
+    textEmotes["encourage"] = TEXT_EMOTE_ENCOURAGE;
+    textEmotes["enemy"] = TEXT_EMOTE_ENEMY;
+    textEmotes["eyebrow"] = TEXT_EMOTE_EYEBROW;
+    textEmotes["toast"] = TEXT_EMOTE_TOAST;
+    textEmotes["fail"] = TEXT_EMOTE_FAIL;
+    textEmotes["highfive"] = TEXT_EMOTE_HIGHFIVE;
+    textEmotes["absent"] = TEXT_EMOTE_ABSENT;
+    textEmotes["arm"] = TEXT_EMOTE_ARM;
+    textEmotes["awe"] = TEXT_EMOTE_AWE;
+    textEmotes["backpack"] = TEXT_EMOTE_BACKPACK;
+    textEmotes["badfeeling"] = TEXT_EMOTE_BADFEELING;
+    textEmotes["challenge"] = TEXT_EMOTE_CHALLENGE;
+    textEmotes["chug"] = TEXT_EMOTE_CHUG;
+    textEmotes["ding"] = TEXT_EMOTE_DING;
+    textEmotes["facepalm"] = TEXT_EMOTE_FACEPALM;
+    textEmotes["faint"] = TEXT_EMOTE_FAINT;
+    textEmotes["go"] = TEXT_EMOTE_GO;
+    textEmotes["going"] = TEXT_EMOTE_GOING;
+    textEmotes["glower"] = TEXT_EMOTE_GLOWER;
+    textEmotes["headache"] = TEXT_EMOTE_HEADACHE;
+    textEmotes["hiccup"] = TEXT_EMOTE_HICCUP;
+    textEmotes["hiss"] = TEXT_EMOTE_HISS;
+    textEmotes["holdhand"] = TEXT_EMOTE_HOLDHAND;
+    textEmotes["hurry"] = TEXT_EMOTE_HURRY;
+    textEmotes["idea"] = TEXT_EMOTE_IDEA;
+    textEmotes["jealous"] = TEXT_EMOTE_JEALOUS;
+    textEmotes["luck"] = TEXT_EMOTE_LUCK;
+    textEmotes["map"] = TEXT_EMOTE_MAP;
+    textEmotes["mercy"] = TEXT_EMOTE_MERCY;
+    textEmotes["mutter"] = TEXT_EMOTE_MUTTER;
+    textEmotes["nervous"] = TEXT_EMOTE_NERVOUS;
+    textEmotes["offer"] = TEXT_EMOTE_OFFER;
+    textEmotes["pet"] = TEXT_EMOTE_PET;
+    textEmotes["pinch"] = TEXT_EMOTE_PINCH;
+    textEmotes["proud"] = TEXT_EMOTE_PROUD;
+    textEmotes["promise"] = TEXT_EMOTE_PROMISE;
+    textEmotes["pulse"] = TEXT_EMOTE_PULSE;
+    textEmotes["punch"] = TEXT_EMOTE_PUNCH;
+    textEmotes["pout"] = TEXT_EMOTE_POUT;
+    textEmotes["regret"] = TEXT_EMOTE_REGRET;
+    textEmotes["revenge"] = TEXT_EMOTE_REVENGE;
+    textEmotes["rolleyes"] = TEXT_EMOTE_ROLLEYES;
+    textEmotes["ruffle"] = TEXT_EMOTE_RUFFLE;
+    textEmotes["sad"] = TEXT_EMOTE_SAD;
+    textEmotes["scoff"] = TEXT_EMOTE_SCOFF;
+    textEmotes["scold"] = TEXT_EMOTE_SCOLD;
+    textEmotes["scowl"] = TEXT_EMOTE_SCOWL;
+    textEmotes["search"] = TEXT_EMOTE_SEARCH;
+    textEmotes["shakefist"] = TEXT_EMOTE_SHAKEFIST;
+    textEmotes["shifty"] = TEXT_EMOTE_SHIFTY;
+    textEmotes["shudder"] = TEXT_EMOTE_SHUDDER;
+    textEmotes["signal"] = TEXT_EMOTE_SIGNAL;
+    textEmotes["silence"] = TEXT_EMOTE_SILENCE;
+    textEmotes["sing"] = TEXT_EMOTE_SING;
+    textEmotes["smack"] = TEXT_EMOTE_SMACK;
+    textEmotes["sneak"] = TEXT_EMOTE_SNEAK;
+    textEmotes["sneeze"] = TEXT_EMOTE_SNEEZE;
+    textEmotes["snort"] = TEXT_EMOTE_SNORT;
+    textEmotes["squeal"] = TEXT_EMOTE_SQUEAL;
+    textEmotes["stopattack"] = TEXT_EMOTE_STOPATTACK;
+    textEmotes["suspicious"] = TEXT_EMOTE_SUSPICIOUS;
+    textEmotes["think"] = TEXT_EMOTE_THINK;
+    textEmotes["truce"] = TEXT_EMOTE_TRUCE;
+    textEmotes["twiddle"] = TEXT_EMOTE_TWIDDLE;
+    textEmotes["warn"] = TEXT_EMOTE_WARN;
+    textEmotes["snap"] = TEXT_EMOTE_SNAP;
+    textEmotes["charm"] = TEXT_EMOTE_CHARM;
+    textEmotes["coverears"] = TEXT_EMOTE_COVEREARS;
+    textEmotes["crossarms"] = TEXT_EMOTE_CROSSARMS;
+    textEmotes["look"] = TEXT_EMOTE_LOOK;
+    textEmotes["object"] = TEXT_EMOTE_OBJECT;
+    textEmotes["sweat"] = TEXT_EMOTE_SWEAT;
+    textEmotes["yw"] = TEXT_EMOTE_YW;
+}
+
+
+bool EmoteAction::isUseful()
+{
+    time_t lastEmote = AI_VALUE2(time_t, "last emote", qualifier);
+    return (time(0) - lastEmote) > 30;
+}
diff --git a/src/plugins/playerbot/strategy/actions/EmoteAction.h b/src/plugins/playerbot/strategy/actions/EmoteAction.h
new file mode 100644
index 0000000..43f3456
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EmoteAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class EmoteAction : public Action, public Qualified
+    {
+    public:
+        EmoteAction(PlayerbotAI* ai) : Action(ai, "emote"), Qualified() {}
+        virtual bool Execute(Event event);
+        bool isUseful();
+
+    private:
+        void InitEmotes();
+        static map<string, uint32> emotes;
+        static map<string, uint32> textEmotes;
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/EquipAction.cpp b/src/plugins/playerbot/strategy/actions/EquipAction.cpp
new file mode 100644
index 0000000..1f8de55
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EquipAction.cpp
@@ -0,0 +1,105 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EquipAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool EquipAction::Execute(Event event)
+{
+    string text = event.getParam();
+    if (text == "?")
+    {
+        TellEquipmentSets();
+        return true;
+    }
+
+    if (UseEquipmentSet(text))
+        return true;
+
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        EquipItem(&visitor);
+    }
+
+    return true;
+}
+
+bool EquipAction::UseEquipmentSet(string& name)
+{
+    EquipmentSets &sets = bot->GetEquipmentSets();
+    for (EquipmentSets::iterator i = sets.begin(); i != sets.end(); i++)
+    {
+        if (i->second.state == EQUIPMENT_SET_DELETED || i->second.Name != name)
+            continue;
+
+        UseEquipmentSet(i->second);
+
+        ostringstream out; out << name << " set equipped";
+        ai->TellMaster(out);
+        return true;
+    }
+    return false;
+}
+
+bool EquipAction::UseEquipmentSet(EquipmentSet& set)
+{
+    WorldPacket* p = new WorldPacket(CMSG_EQUIPMENT_SET_USE);
+    uint8 srcbag = 0;
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        ObjectGuid guid;
+        uint32 itemId = set.Items[slot];
+        if (set.IgnoreMask & (1 << slot))
+            p->appendPackGUID((uint64(1)));
+        else
+            p->appendPackGUID(itemId);
+        *p << srcbag << slot;
+    }
+    bot->GetSession()->QueuePacket(p);
+    return true;
+}
+
+void EquipAction::TellEquipmentSets()
+{
+    ai->TellMaster("=== Equipment sets ===");
+    EquipmentSets &sets = bot->GetEquipmentSets();
+    for (EquipmentSets::iterator i = sets.begin(); i != sets.end(); i++)
+    {
+        if (i->second.state != EQUIPMENT_SET_DELETED)
+            ai->TellMaster(i->second.Name);
+    }
+}
+
+void EquipAction::EquipItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+	if (!items.empty()) EquipItem(**items.begin());
+}
+
+
+void EquipAction::EquipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint32 itemId = item.GetTemplate()->ItemId;
+
+    if (item.GetTemplate()->InventoryType == INVTYPE_AMMO)
+    {
+        bot->SetAmmo(itemId);
+    }
+    else
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+            *packet << bagIndex << slot;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    ostringstream out; out << "equipping " << chat->formatItem(item.GetTemplate());
+    ai->TellMaster(out);
+}
diff --git a/src/plugins/playerbot/strategy/actions/EquipAction.h b/src/plugins/playerbot/strategy/actions/EquipAction.h
new file mode 100644
index 0000000..d23223c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EquipAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class EquipAction : public InventoryAction {
+    public:
+        EquipAction(PlayerbotAI* ai) : InventoryAction(ai, "equip") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void EquipItem(FindItemVisitor* visitor);
+        void EquipItem(Item& item);
+        void TellEquipmentSets();
+        bool UseEquipmentSet(string& name);
+        bool UseEquipmentSet(EquipmentSet& set);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/FollowActions.cpp b/src/plugins/playerbot/strategy/actions/FollowActions.cpp
new file mode 100644
index 0000000..dfa115f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/FollowActions.cpp
@@ -0,0 +1,49 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FollowActions.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../values/Formations.h"
+
+using namespace ai;
+
+bool FollowAction::Execute(Event event)
+{
+    Formation* formation = AI_VALUE(Formation*, "formation");
+    string target = formation->GetTargetName();
+    if (!target.empty())
+    {
+        return Follow(AI_VALUE(Unit*, target));
+    }
+    else
+    {
+        WorldLocation loc = formation->GetLocation();
+        if (loc == Formation::NullLocation || loc.GetMapId() == -1)
+            return false;
+
+        return MoveTo(loc.GetMapId(), loc.m_positionX, loc.m_positionY, loc.m_positionZ);
+    }
+}
+
+bool FollowAction::isUseful()
+{
+    Formation* formation = AI_VALUE(Formation*, "formation");
+    float distance = 0;
+    string target = formation->GetTargetName();
+
+    if (!target.empty())
+    {
+        distance = AI_VALUE2(float, "distance", target);
+    }
+    else
+    {
+        WorldLocation loc = formation->GetLocation();
+        if (loc == Formation::NullLocation || bot->GetMapId() != loc.GetMapId())
+            return false;
+
+        distance = bot->GetDistance(loc);
+    }
+
+    return distance > formation->GetMaxDistance() &&
+            !AI_VALUE(bool, "can loot");
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/FollowActions.h b/src/plugins/playerbot/strategy/actions/FollowActions.h
new file mode 100644
index 0000000..971ca99
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/FollowActions.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class FollowAction : public MovementAction {
+	public:
+		FollowAction(PlayerbotAI* ai) : MovementAction(ai, "follow") {}
+		virtual bool Execute(Event event);
+        virtual bool isUseful();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/actions/GenericActions.cpp b/src/plugins/playerbot/strategy/actions/GenericActions.cpp
new file mode 100644
index 0000000..22285f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/actions/GenericActions.h b/src/plugins/playerbot/strategy/actions/GenericActions.h
new file mode 100644
index 0000000..b32a8e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericActions.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "GenericSpellActions.h"
+#include "ReachTargetActions.h"
+#include "ChooseTargetActions.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class MeleeAction : public AttackAction 
+    {
+    public:
+        MeleeAction(PlayerbotAI* ai) : AttackAction(ai, "melee") {}
+
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp b/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
new file mode 100644
index 0000000..c911c0f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
@@ -0,0 +1,55 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericActions.h"
+
+using namespace ai;
+
+bool CastSpellAction::Execute(Event event)
+{
+	return ai->CastSpell(spell, GetTarget());
+}
+
+bool CastSpellAction::isPossible()
+{
+	return ai->CanCastSpell(spell, GetTarget());
+}
+
+bool CastSpellAction::isUseful()
+{
+	return GetTarget() && AI_VALUE2(bool, "spell cast useful", spell);
+}
+
+bool CastAuraSpellAction::isUseful()
+{
+	return CastSpellAction::isUseful() && !ai->HasAura(spell, GetTarget());
+}
+
+bool CastEnchantItemAction::isUseful()
+{
+    if (!CastSpellAction::isUseful())
+        return false;
+
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    return spellId && AI_VALUE2(Item*, "item for spell", spellId);
+}
+
+bool CastHealingSpellAction::isUseful()
+{
+	return CastAuraSpellAction::isUseful() && AI_VALUE2(uint8, "health", GetTargetName()) < (100 - estAmount);
+}
+
+bool CastAoeHealSpellAction::isUseful()
+{
+	return CastSpellAction::isUseful() && AI_VALUE2(uint8, "aoe heal", "medium") > 0;
+}
+
+
+Value<Unit*>* CurePartyMemberAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("party member to dispel", dispelType);
+}
+
+Value<Unit*>* BuffOnPartyAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("party member without aura", spell);
+}
diff --git a/src/plugins/playerbot/strategy/actions/GenericSpellActions.h b/src/plugins/playerbot/strategy/actions/GenericSpellActions.h
new file mode 100644
index 0000000..e286a17
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericSpellActions.h
@@ -0,0 +1,271 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../PlayerbotAIConfig.h"
+
+#define BEGIN_SPELL_ACTION(clazz, name) \
+class clazz : public CastSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastSpellAction(ai, name) {} \
+
+
+#define END_SPELL_ACTION() \
+    };
+
+#define BEGIN_DEBUFF_ACTION(clazz, name) \
+class clazz : public CastDebuffSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastDebuffSpellAction(ai, name) {} \
+
+#define BEGIN_RANGED_SPELL_ACTION(clazz, name) \
+class clazz : public CastSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastSpellAction(ai, name) {} \
+
+#define BEGIN_MELEE_SPELL_ACTION(clazz, name) \
+class clazz : public CastMeleeSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastMeleeSpellAction(ai, name) {} \
+
+
+#define END_RANGED_SPELL_ACTION() \
+    };
+
+
+#define BEGIN_BUFF_ON_PARTY_ACTION(clazz, name) \
+class clazz : public BuffOnPartyAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : BuffOnPartyAction(ai, name) {}
+
+namespace ai
+{
+    class CastSpellAction : public Action
+    {
+    public:
+        CastSpellAction(PlayerbotAI* ai, string spell) : Action(ai, spell),
+			range(sPlayerbotAIConfig.spellDistance)
+        {
+            this->spell = spell;
+        }
+
+		virtual string GetTargetName() { return "current target"; };
+        virtual bool Execute(Event event);
+        virtual bool isPossible();
+		virtual bool isUseful();
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_SINGLE; }
+
+		virtual NextAction** getPrerequisites()
+		{
+			if (range > sPlayerbotAIConfig.spellDistance)
+				return NULL;
+			else if (range > ATTACK_DISTANCE)
+				return NextAction::merge( NextAction::array(0, new NextAction("reach spell"), NULL), Action::getPrerequisites());
+			else
+				return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), Action::getPrerequisites());
+		}
+
+    protected:
+        string spell;
+		float range;
+    };
+
+	//---------------------------------------------------------------------------------------------------------------------
+	class CastAuraSpellAction : public CastSpellAction
+	{
+	public:
+		CastAuraSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+
+		virtual bool isUseful();
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+    class CastMeleeSpellAction : public CastSpellAction
+    {
+    public:
+        CastMeleeSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {
+			range = ATTACK_DISTANCE;
+		}
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+    class CastDebuffSpellAction : public CastAuraSpellAction
+    {
+    public:
+        CastDebuffSpellAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell) {}
+    };
+
+    class CastDebuffSpellOnAttackerAction : public CastAuraSpellAction
+    {
+    public:
+        CastDebuffSpellOnAttackerAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell) {}
+        Value<Unit*>* GetTargetValue()
+        {
+            return context->GetValue<Unit*>("attacker without aura", spell);
+        }
+        virtual string getName() { return spell + " on attacker"; }
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_AOE; }
+    };
+
+	class CastBuffSpellAction : public CastAuraSpellAction
+	{
+	public:
+		CastBuffSpellAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+        virtual string GetTargetName() { return "self target"; }
+	};
+
+	class CastEnchantItemAction : public CastSpellAction
+	{
+	public:
+	    CastEnchantItemAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+        virtual bool isUseful();
+        virtual string GetTargetName() { return "self target"; }
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CastHealingSpellAction : public CastAuraSpellAction
+    {
+    public:
+        CastHealingSpellAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) : CastAuraSpellAction(ai, spell)
+		{
+            this->estAmount = estAmount;
+			range = sPlayerbotAIConfig.spellDistance;
+        }
+		virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful();
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_AOE; }
+
+    protected:
+        uint8 estAmount;
+    };
+
+    class CastAoeHealSpellAction : public CastHealingSpellAction
+    {
+    public:
+    	CastAoeHealSpellAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) : CastHealingSpellAction(ai, spell, estAmount) {}
+		virtual string GetTargetName() { return "party member to heal"; }
+        virtual bool isUseful();
+    };
+
+	class CastCureSpellAction : public CastSpellAction
+	{
+	public:
+		CastCureSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+		virtual string GetTargetName() { return "self target"; }
+	};
+
+	class PartyMemberActionNameSupport {
+	public:
+		PartyMemberActionNameSupport(string spell)
+		{
+			name = string(spell) + " on party";
+		}
+
+		virtual string getName() { return name; }
+
+	private:
+		string name;
+	};
+
+    class HealPartyMemberAction : public CastHealingSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        HealPartyMemberAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) :
+			CastHealingSpellAction(ai, spell, estAmount), PartyMemberActionNameSupport(spell) {}
+
+		virtual string GetTargetName() { return "party member to heal"; }
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+    };
+
+	class ResurrectPartyMemberAction : public CastSpellAction
+	{
+	public:
+		ResurrectPartyMemberAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+
+		virtual string GetTargetName() { return "party member to resurrect"; }
+	};
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CurePartyMemberAction : public CastSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        CurePartyMemberAction(PlayerbotAI* ai, string spell, uint32 dispelType) :
+			CastSpellAction(ai, spell), PartyMemberActionNameSupport(spell)
+        {
+            this->dispelType = dispelType;
+        }
+
+		virtual Value<Unit*>* GetTargetValue();
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+
+    protected:
+        uint32 dispelType;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class BuffOnPartyAction : public CastBuffSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        BuffOnPartyAction(PlayerbotAI* ai, string spell) :
+			CastBuffSpellAction(ai, spell), PartyMemberActionNameSupport(spell) {}
+    public:
+		virtual Value<Unit*>* GetTargetValue();
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CastShootAction : public CastSpellAction
+    {
+    public:
+        CastShootAction(PlayerbotAI* ai) : CastSpellAction(ai, "shoot") {}
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_NONE; }
+    };
+
+	class CastLifeBloodAction : public CastHealingSpellAction
+	{
+	public:
+		CastLifeBloodAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lifeblood") {}
+	};
+
+	class CastGiftOfTheNaaruAction : public CastHealingSpellAction
+	{
+	public:
+		CastGiftOfTheNaaruAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "gift of the naaru") {}
+	};
+
+    class CastArcaneTorrentAction : public CastBuffSpellAction
+    {
+    public:
+        CastArcaneTorrentAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane torrent") {}
+    };
+
+    class CastSpellOnEnemyHealerAction : public CastSpellAction
+    {
+    public:
+        CastSpellOnEnemyHealerAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+        Value<Unit*>* GetTargetValue()
+        {
+            return context->GetValue<Unit*>("enemy healer target", spell);
+        }
+        virtual string getName() { return spell + " on enemy healer"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp b/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
new file mode 100644
index 0000000..c5000cd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
@@ -0,0 +1,71 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GossipHelloAction.h"
+
+
+using namespace ai;
+
+bool GossipHelloAction::Execute(Event event)
+{
+    ObjectGuid guid;
+
+    WorldPacket &p = event.getPacket();
+    if (p.empty())
+    {
+        Player* master = GetMaster();
+        if (master && master->GetSelectedUnit())
+            guid = master->GetSelectedUnit()->GetGUID();
+    }
+    else
+    {
+        p.rpos(0);
+        p >> guid;
+    }
+
+    if (!guid)
+        return false;
+
+    Creature *pCreature = bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+    if (!pCreature)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO %d not found or you can't interact with him.", guid.GetRawValue());
+        return false;
+    }
+
+    GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(pCreature->GetCreatureTemplate()->GossipMenuId);
+    if (pMenuItemBounds.first == pMenuItemBounds.second)
+        return false;
+
+    WorldPacket p1;
+    p1 << guid;
+    bot->GetSession()->HandleGossipHelloOpcode(p1);
+    bot->SetFacingToObject(pCreature);
+
+    ostringstream out; out << "--- " << pCreature->GetName() << " ---";
+    ai->TellMasterNoFacing(out.str());
+
+    GossipMenu& menu = bot->PlayerTalkClass->GetGossipMenu();
+    int i = 0, loops = 0;
+    set<uint32> alreadyTalked;
+    while (i < menu.GetMenuItemCount() && loops++ < 100)
+    {
+        GossipMenuItem const* item = menu.GetItem(i);
+        ai->TellMasterNoFacing(item->Message);
+
+        if (item->OptionType < 1000 && item->OptionType != GOSSIP_OPTION_GOSSIP)
+        {
+            i++;
+            continue;
+        }
+
+        WorldPacket p1;
+        std::string code;
+        p1 << guid << menu.GetMenuId() << i << code;
+        bot->GetSession()->HandleGossipSelectOptionOpcode(p1);
+
+        i = 0;
+    }
+
+    bot->TalkedToCreature(pCreature->GetEntry(), pCreature->GetGUID());
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GossipHelloAction.h b/src/plugins/playerbot/strategy/actions/GossipHelloAction.h
new file mode 100644
index 0000000..603737c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GossipHelloAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class GossipHelloAction : public Action {
+    public:
+        GossipHelloAction(PlayerbotAI* ai) : Action(ai, "gossip hello") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
new file mode 100644
index 0000000..49d71cc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuildAcceptAction.h"
+
+using namespace std;
+using namespace ai;
+
+bool GuildAcceptAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    bool accept = true;
+    uint32 guildId = master->GetGuildId();
+    if (!guildId)
+    {
+        ai->TellMaster("You are not in a guild");
+        accept = false;
+    }
+    else if (bot->GetGuildId())
+    {
+        ai->TellMaster("Sorry, I am in a guild already");
+        accept = false;
+    }
+    else if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, false, master, true))
+    {
+        accept = false;
+    }
+
+    WorldPacket packet;
+    if (accept)
+    {
+        bot->SetGuildIdInvited(guildId);
+        bot->GetSession()->HandleGuildAcceptOpcode(packet);
+    }
+    else
+    {
+        bot->GetSession()->HandleGuildDeclineOpcode(packet);
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
new file mode 100644
index 0000000..ab8910c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class GuildAcceptAction : public Action {
+    public:
+        GuildAcceptAction(PlayerbotAI* ai) : Action(ai, "guild accept") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp b/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
new file mode 100644
index 0000000..849b1b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
@@ -0,0 +1,61 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuildBankAction.h"
+
+#include "../values/ItemCountValue.h"
+#include "../../../Guilds/Guild.h"
+#include "../../../Guilds/GuildMgr.h"
+
+using namespace std;
+using namespace ai;
+
+bool GuildBankAction::Execute(Event event)
+{
+    string text = event.getParam();
+    if (text.empty())
+        return false;
+
+    list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (!go || !bot->GetGameObjectIfCanInteractWith(go->GetGUID(), GAMEOBJECT_TYPE_GUILD_BANK))
+            continue;
+
+        return Execute(text, go);
+    }
+
+    ai->TellMaster("Cannot find the guild bank nearby");
+    return false;
+}
+
+bool GuildBankAction::Execute(string text, GameObject* bank)
+{
+    bool result = true;
+
+    list<Item*> found = parseItems(text);
+    if (found.empty())
+        return false;
+
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+    {
+        Item* item = *i;
+        if (item)
+            result &= MoveFromCharToBank(item, bank);
+    }
+
+    return result;
+}
+
+bool GuildBankAction::MoveFromCharToBank(Item* item, GameObject* bank)
+{
+    uint32 playerSlot = item->GetSlot();
+    uint32 playerBag = item->GetBagSlot();
+
+    Guild* guild = sGuildMgr->GetGuildById(bot->GetGuildId());
+    guild->SwapItems(bot, 0, playerSlot, 0, INVENTORY_SLOT_BAG_0, 0);
+
+    ostringstream out; out << chat->formatItem(item->GetTemplate()) << " put to guild bank";
+    ai->TellMaster(out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildBankAction.h b/src/plugins/playerbot/strategy/actions/GuildBankAction.h
new file mode 100644
index 0000000..374fc0f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildBankAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class GuildBankAction : public InventoryAction {
+    public:
+        GuildBankAction(PlayerbotAI* ai) : InventoryAction(ai, "guild bank") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Execute(string text, GameObject* bank);
+        bool MoveFromCharToBank(Item* item, GameObject* bank);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/HelpAction.cpp b/src/plugins/playerbot/strategy/actions/HelpAction.cpp
new file mode 100644
index 0000000..6e7b776
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/HelpAction.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HelpAction.h"
+#include "ChatActionContext.h"
+
+using namespace ai;
+
+HelpAction::HelpAction(PlayerbotAI* ai) : Action(ai, "help")
+{
+    chatContext = new ChatActionContext();
+}
+
+HelpAction::~HelpAction()
+{
+    delete chatContext;
+}
+
+bool HelpAction::Execute(Event event)
+{
+    TellChatCommands();
+    TellStrategies();
+    return true;
+}
+
+void HelpAction::TellChatCommands()
+{
+    ostringstream out;
+    out << "Whisper any of: ";
+    out << CombineSupported(chatContext->supports());
+    out << ", [item], [quest] or [object] link";
+    ai->TellMaster(out);
+}
+
+void HelpAction::TellStrategies()
+{
+    ostringstream out;
+    out << "Possible strategies (co/nc/dead commands): ";
+    out << CombineSupported(ai->GetAiObjectContext()->GetSupportedStrategies());
+    ai->TellMaster(out);
+}
+
+string HelpAction::CombineSupported(set<string> commands)
+{
+    ostringstream out;
+
+    for (set<string>::iterator i = commands.begin(); i != commands.end(); )
+	{
+        out << *i;
+		if (++i != commands.end())
+			out << ", ";
+	}
+
+    return out.str();
+}
diff --git a/src/plugins/playerbot/strategy/actions/HelpAction.h b/src/plugins/playerbot/strategy/actions/HelpAction.h
new file mode 100644
index 0000000..c0bc5e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/HelpAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class HelpAction : public Action {
+    public:
+        HelpAction(PlayerbotAI* ai);
+        virtual ~HelpAction();
+        virtual bool Execute(Event event);
+
+    private:
+        void TellChatCommands();
+        void TellStrategies();
+        string CombineSupported(set<string> commands);
+
+    private:
+        NamedObjectContext<Action>* chatContext;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryAction.cpp b/src/plugins/playerbot/strategy/actions/InventoryAction.cpp
new file mode 100644
index 0000000..896466c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryAction.cpp
@@ -0,0 +1,288 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InventoryAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+
+class FindPotionVisitor : public FindUsableItemVisitor
+{
+public:
+    FindPotionVisitor(Player* bot, uint32 effectId) : FindUsableItemVisitor(bot), effectId(effectId) {}
+
+    virtual bool Accept(const ItemTemplate* proto)
+    {
+        if (proto->Class == ITEM_CLASS_CONSUMABLE &&
+            proto->SubClass == ITEM_SUBCLASS_POTION &&
+            proto->Spells[0].SpellCategory == 4)
+        {
+            for (int j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+            {
+                const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[j].SpellId);
+                if (!spellInfo)
+                    return false;
+
+                for (int i = 0 ; i < 3; i++)
+                {
+                    if (spellInfo->Effects[i].Effect == effectId)
+                        return true;
+                }
+            }
+        }
+        return false;
+    }
+
+private:
+    uint32 effectId;
+};
+
+class FindFoodVisitor : public FindUsableItemVisitor
+{
+public:
+    FindFoodVisitor(Player* bot, uint32 spellCategory) : FindUsableItemVisitor(bot)
+    {
+        this->spellCategory = spellCategory;
+    }
+
+    virtual bool Accept(const ItemTemplate* proto)
+    {
+        return proto->Class == ITEM_CLASS_CONSUMABLE &&
+            proto->SubClass == ITEM_SUBCLASS_FOOD &&
+            proto->Spells[0].SpellCategory == spellCategory;
+    }
+
+private:
+    uint32 spellCategory;
+};
+
+void InventoryAction::IterateItems(IterateItemsVisitor* visitor, IterateItemsMask mask)
+{
+    if (mask & ITERATE_ITEMS_IN_BAGS)
+        IterateItemsInBags(visitor);
+
+    if (mask & ITERATE_ITEMS_IN_EQUIP)
+        IterateItemsInEquip(visitor);
+}
+
+void InventoryAction::IterateItemsInBags(IterateItemsVisitor* visitor)
+{
+
+
+    for(int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item *pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!visitor->Visit(pItem))
+                return;
+
+    for(int i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item *pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!visitor->Visit(pItem))
+                return;
+
+    for(int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag *pBag = (Bag*)bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            for(uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (!visitor->Visit(pItem))
+                        return;
+}
+
+void InventoryAction::IterateItemsInEquip(IterateItemsVisitor* visitor)
+{
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem)
+            continue;
+
+        if (!visitor->Visit(pItem))
+            return;
+    }
+}
+
+bool compare_items(const ItemTemplate *proto1, const ItemTemplate *proto2)
+{
+    if (proto1->Class != proto2->Class)
+        return proto1->Class > proto2->Class;
+
+    if (proto1->SubClass != proto2->SubClass)
+        return proto1->SubClass < proto2->SubClass;
+
+    if (proto1->Quality != proto2->Quality)
+        return proto1->Quality < proto2->Quality;
+
+    if (proto1->ItemLevel != proto2->ItemLevel)
+        return proto1->ItemLevel > proto2->ItemLevel;
+
+    return false;
+}
+
+bool compare_items_by_level(const Item* item1, const Item* item2)
+{
+    return compare_items(item1->GetTemplate(), item2->GetTemplate());
+}
+
+void InventoryAction::TellItems(map<uint32, int> itemMap)
+{
+    list<ItemTemplate const*> items;
+    for (map<uint32, int>::iterator i = itemMap.begin(); i != itemMap.end(); i++)
+    {
+        items.push_back(sObjectMgr->GetItemTemplate(i->first));
+    }
+
+    items.sort(compare_items);
+
+    uint32 oldClass = -1;
+    for (list<ItemTemplate const*>::iterator i = items.begin(); i != items.end(); i++)
+    {
+        ItemTemplate const *proto = *i;
+
+        if (proto->Class != oldClass)
+        {
+            oldClass = proto->Class;
+            switch (proto->Class)
+            {
+            case ITEM_CLASS_CONSUMABLE:
+                ai->TellMaster("--- consumable ---");
+                break;
+            case ITEM_CLASS_CONTAINER:
+                ai->TellMaster("--- container ---");
+                break;
+            case ITEM_CLASS_WEAPON:
+                ai->TellMaster("--- weapon ---");
+                break;
+            case ITEM_CLASS_GEM:
+                ai->TellMaster("--- gem ---");
+                break;
+            case ITEM_CLASS_ARMOR:
+                ai->TellMaster("--- armor ---");
+                break;
+            case ITEM_CLASS_REAGENT:
+                ai->TellMaster("--- reagent ---");
+                break;
+            case ITEM_CLASS_PROJECTILE:
+                ai->TellMaster("--- projectile ---");
+                break;
+            case ITEM_CLASS_TRADE_GOODS:
+                ai->TellMaster("--- trade goods ---");
+                break;
+            case ITEM_CLASS_GENERIC:
+                ai->TellMaster("--- generic ---");
+                break;
+            case ITEM_CLASS_RECIPE:
+                ai->TellMaster("--- recipe ---");
+                break;
+            case ITEM_CLASS_MONEY:
+                ai->TellMaster("--- money ---");
+                break;
+            case ITEM_CLASS_QUIVER:
+                ai->TellMaster("--- quiver ---");
+                break;
+            case ITEM_CLASS_QUEST:
+                ai->TellMaster("--- quest items ---");
+                break;
+            case ITEM_CLASS_KEY:
+                ai->TellMaster("--- keys ---");
+                break;
+            case ITEM_CLASS_PERMANENT:
+                ai->TellMaster("--- permanent ---");
+                break;
+            case ITEM_CLASS_MISC:
+                ai->TellMaster("--- other ---");
+                break;
+            case ITEM_CLASS_GLYPH:
+                ai->TellMaster("--- glyph ---");
+                break;
+            }
+        }
+
+        TellItem(proto, itemMap[proto->ItemId]);
+    }
+}
+
+void InventoryAction::TellItem(ItemTemplate const * proto, int count)
+{
+    ai->TellMaster(chat->formatItem(proto, count));
+}
+
+list<Item*> InventoryAction::parseItems(string text)
+{
+    set<Item*> found;
+    size_t pos = text.find(" ");
+    int count = pos!=string::npos ? atoi(text.substr(pos + 1).c_str()) : TRADE_SLOT_TRADED_COUNT;
+    if (count < 1) count = 1;
+    else if (count > TRADE_SLOT_TRADED_COUNT) count = TRADE_SLOT_TRADED_COUNT;
+
+    if (text == "food")
+    {
+        FindFoodVisitor visitor(bot, 11);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "drink")
+    {
+        FindFoodVisitor visitor(bot, 59);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "mana potion")
+    {
+        FindPotionVisitor visitor(bot, SPELL_EFFECT_ENERGIZE);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "healing potion")
+    {
+        FindPotionVisitor visitor(bot, SPELL_EFFECT_HEAL);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    FindUsableNamedItemVisitor visitor(bot, text);
+    IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+    found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+
+    uint32 quality = chat->parseItemQuality(text);
+    if (quality != MAX_ITEM_QUALITY)
+    {
+        FindItemsToTradeByQualityVisitor visitor(quality, count);
+        IterateItems(&visitor);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    uint32 itemClass = MAX_ITEM_CLASS, itemSubClass = 0;
+    if (chat->parseItemClass(text, &itemClass, &itemSubClass))
+    {
+        FindItemsToTradeByClassVisitor visitor(itemClass, itemSubClass, count);
+        IterateItems(&visitor);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    uint32 fromSlot = chat->parseSlot(text);
+    if (fromSlot != EQUIPMENT_SLOT_END)
+    {
+        Item* item = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, fromSlot);
+        if (item)
+            found.insert(item);
+    }
+
+    ItemIds ids = chat->parseItems(text);
+    for (ItemIds::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        IterateItems(&visitor, ITERATE_ALL_ITEMS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    list<Item*> result;
+    for (set<Item*>::iterator i = found.begin(); i != found.end(); ++i)
+        result.push_back(*i);
+
+    result.sort(compare_items_by_level);
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryAction.h b/src/plugins/playerbot/strategy/actions/InventoryAction.h
new file mode 100644
index 0000000..a1f1af7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryAction.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "../Action.h"
+#include "../ItemVisitors.h"
+
+namespace ai
+{
+
+
+    class InventoryAction : public Action {
+    public:
+        InventoryAction(PlayerbotAI* ai, string name) : Action(ai, name) {}
+
+    protected:
+        void IterateItems(IterateItemsVisitor* visitor, IterateItemsMask mask = ITERATE_ITEMS_IN_BAGS);
+        void TellItems(map<uint32, int> items);
+        void TellItem(ItemTemplate const * proto, int count);
+        list<Item*> parseItems(string text);
+
+    private:
+        void IterateItemsInBags(IterateItemsVisitor* visitor);
+        void IterateItemsInEquip(IterateItemsVisitor* visitor);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
new file mode 100644
index 0000000..5933a19
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
@@ -0,0 +1,55 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InventoryChangeFailureAction.h"
+
+
+using namespace ai;
+
+bool InventoryChangeFailureAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint8 err;
+    p >> err;
+    if (err == EQUIP_ERR_OK)
+        return false;
+
+    switch (err)
+    {
+    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
+        ai->TellMaster("I can't carry anymore of those.");
+        break;
+    case EQUIP_ERR_MISSING_REAGENT:
+        ai->TellMaster("I'm missing some reagents for that.");
+        break;
+    case EQUIP_ERR_ITEM_LOCKED:
+        ai->TellMaster("That item is locked.");
+        break;
+    case EQUIP_ERR_ALREADY_LOOTED:
+        break;
+    case EQUIP_ERR_INVENTORY_FULL:
+        ai->TellMaster("My inventory is full.");
+        break;
+    case EQUIP_ERR_NOT_IN_COMBAT:
+        ai->TellMaster("I can't use that in combat.");
+        break;
+    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
+        ai->TellMaster("I can't get that now.");
+        break;
+    case EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE:
+        ai->TellMaster("I can only have one of those equipped.");
+        break;
+    case EQUIP_ERR_BANK_FULL:
+        ai->TellMaster("My bank is full.");
+        break;
+    case EQUIP_ERR_ITEM_NOT_FOUND:
+        ai->TellMaster("I can't find the item.");
+        break;
+    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
+        ai->TellMaster("I'm too far from the bank.");
+        break;
+    default:
+        ai->TellMaster("I can't use that.");
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
new file mode 100644
index 0000000..4125cd2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class InventoryChangeFailureAction : public Action {
+    public:
+        InventoryChangeFailureAction(PlayerbotAI* ai) : Action(ai, "inventory change failure") {}
+        virtual bool Execute(Event event);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h b/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
new file mode 100644
index 0000000..d57ee50
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class InviteToGroupAction : public Action
+    {
+    public:
+        InviteToGroupAction(PlayerbotAI* ai) : Action(ai, "invite") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = event.getOwner();
+            if (!master)
+                return false;
+
+            WorldPacket p;
+            uint32 roles_mask = 0;
+            p << master->GetName();
+            p << roles_mask;
+            bot->GetSession()->HandleGroupInviteOpcode(p);
+
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h b/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
new file mode 100644
index 0000000..90c0fff
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
@@ -0,0 +1,79 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../RandomPlayerbotMgr.h"
+
+namespace ai
+{
+    class LeaveGroupAction : public Action {
+    public:
+        LeaveGroupAction(PlayerbotAI* ai, string name = "leave") : Action(ai, name) {}
+
+        virtual bool Execute(Event event)
+        {
+            if (!bot->GetGroup())
+                return false;
+
+            ai->TellMaster("Goodbye!", PLAYERBOT_SECURITY_TALK);
+
+            WorldPacket p;
+            string member = bot->GetName();
+            p << uint32(PARTY_OP_LEAVE) << member << uint32(0);
+            bot->GetSession()->HandleGroupDisbandOpcode(p);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+            {
+                bot->GetPlayerbotAI()->SetMaster(NULL);
+                sRandomPlayerbotMgr.ScheduleTeleport(bot->GetGUID().GetCounter());
+                sRandomPlayerbotMgr.SetLootAmount(bot, 0);
+            }
+
+            ai->ResetStrategies();
+            return true;
+        }
+    };
+
+    class PartyCommandAction : public LeaveGroupAction {
+    public:
+        PartyCommandAction(PlayerbotAI* ai) : LeaveGroupAction(ai, "party command") {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket& p = event.getPacket();
+            p.rpos(0);
+            uint32 operation;
+            string member;
+
+            p >> operation >> member;
+
+            if (operation != PARTY_OP_LEAVE)
+                return false;
+
+            Player* master = GetMaster();
+            if (master && member == master->GetName())
+                return LeaveGroupAction::Execute(event);
+
+            return false;
+        }
+    };
+
+    class UninviteAction : public LeaveGroupAction {
+    public:
+        UninviteAction(PlayerbotAI* ai) : LeaveGroupAction(ai, "party command") {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket& p = event.getPacket();
+            p.rpos(0);
+            ObjectGuid guid;
+
+            p >> guid;
+
+            if (bot->GetGUID() == guid)
+                return LeaveGroupAction::Execute(event);
+
+            return false;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LfgActions.cpp b/src/plugins/playerbot/strategy/actions/LfgActions.cpp
new file mode 100644
index 0000000..2e947ae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LfgActions.cpp
@@ -0,0 +1,250 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LfgActions.h"
+#include "../../AiFactory.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../ItemVisitors.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../../../DungeonFinding/LFGMgr.h"
+#include "../../../DungeonFinding/LFG.h"
+
+using namespace ai;
+using namespace lfg;
+
+bool LfgJoinAction::Execute(Event event)
+{
+    if (!sPlayerbotAIConfig.randomBotJoinLfg)
+        return false;
+
+    if (bot->isDead())
+        return false;
+
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return false;
+
+    if (sLFGMgr->GetState(bot->GetGUID()) != LFG_STATE_NONE)
+        return false;
+
+    if (bot->IsBeingTeleported())
+        return false;
+
+    Map* map = bot->GetMap();
+    if (map && map->Instanceable())
+        return false;
+
+    return JoinProposal();
+}
+
+uint8 LfgJoinAction::GetRoles()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+    {
+        if (ai->IsTank(bot))
+            return PLAYER_ROLE_TANK;
+        if (ai->IsHeal(bot))
+            return PLAYER_ROLE_HEALER;
+        else return PLAYER_ROLE_DAMAGE;
+    }
+
+    int spec = AiFactory::GetPlayerSpecTab(bot);
+    switch (bot->getClass())
+    {
+    case CLASS_DRUID:
+        if (spec == 2)
+            return PLAYER_ROLE_HEALER;
+        else if (spec == 1 && bot->getLevel() >= 40)
+            return PLAYER_ROLE_TANK;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_PALADIN:
+        if (spec == 1)
+            return PLAYER_ROLE_TANK;
+        else if (spec == 0)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_PRIEST:
+        if (spec != 2)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_SHAMAN:
+        if (spec == 2)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_WARRIOR:
+        if (spec == 2)
+            return PLAYER_ROLE_TANK;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    default:
+        return PLAYER_ROLE_DAMAGE;
+        break;
+    }
+
+    return PLAYER_ROLE_DAMAGE;
+}
+
+bool LfgJoinAction::SetRoles()
+{
+    sLFGMgr->SetRoles(bot->GetGUID(), GetRoles());
+	return true;
+}
+
+bool LfgJoinAction::JoinProposal()
+{
+    ItemCountByQuality visitor;
+    IterateItems(&visitor, ITERATE_ITEMS_IN_EQUIP);
+	bool heroic = urand(0, 100) < 50 && (visitor.count[ITEM_QUALITY_EPIC] >= 3 || visitor.count[ITEM_QUALITY_RARE] >= 10) && bot->getLevel() >= 70;
+    bool random = urand(0, 100) < 25;
+    bool raid = !heroic && (urand(0, 100) < 50 && visitor.count[ITEM_QUALITY_EPIC] >= 5 && (bot->getLevel() == 60 || bot->getLevel() == 70 || bot->getLevel() == 80));
+
+    LfgDungeonSet list;
+    vector<uint32> idx;
+    for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
+    {
+        LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(i);
+        if (!dungeon || (dungeon->type != LFG_TYPE_RANDOM && dungeon->type != LFG_TYPE_DUNGEON && dungeon->type != LFG_TYPE_HEROIC &&
+                dungeon->type != LFG_TYPE_RAID))
+            continue;
+
+        int botLevel = (int)bot->getLevel();
+        if (dungeon->minlevel && botLevel < (int)dungeon->minlevel)
+            continue;
+
+        if (dungeon->minlevel && botLevel > (int)dungeon->minlevel + 10)
+            continue;
+
+        if (dungeon->maxlevel && botLevel > (int)dungeon->maxlevel)
+            continue;
+
+        if (heroic && !dungeon->difficulty)
+            continue;
+
+        if (raid && dungeon->type != LFG_TYPE_RAID)
+            continue;
+
+        if (random && dungeon->type != LFG_TYPE_RANDOM)
+            continue;
+
+        if (!random && !raid && !heroic && dungeon->type != LFG_TYPE_DUNGEON)
+            continue;
+
+        if (!random)
+            list.insert(dungeon->ID);
+        else
+            idx.push_back(dungeon->ID);
+    }
+
+    if (list.empty())
+        return false;
+
+    uint8 roles = GetRoles();
+    if (random)
+	{
+        list.insert(idx[urand(0, idx.size() - 1)]);
+        sLFGMgr->JoinLfg(bot, roles, list, "bot");
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_RANDOM as %d", bot->GetName().c_str(), (uint32)roles);
+		return true;
+	}
+    else if (heroic)
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_HEROIC_DUNGEON as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+    else if (raid)
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_RAID as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+    else
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_DUNGEON as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+
+    sLFGMgr->JoinLfg(bot, roles, list, "bot");
+    return true;
+}
+
+bool LfgRoleCheckAction::Execute(Event event)
+{
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        uint8 currentRoles = sLFGMgr->GetRoles(bot->GetGUID());
+        uint8 newRoles = GetRoles();
+        if (currentRoles == newRoles) return false;
+
+        sLFGMgr->UpdateRoleCheck(group->GetGUID(), bot->GetGUID(), newRoles);
+        return true;
+    }
+
+    return false;
+}
+
+bool LfgAcceptAction::Execute(Event event)
+{
+    uint32 id = AI_VALUE(uint32, "lfg proposal");
+    if (id)
+    {
+        if (urand(0, 1 + 10 / sPlayerbotAIConfig.randomChangeMultiplier))
+            return false;
+
+        if (bot->IsInCombat() || bot->isDead() || bot->IsFalling())
+        {
+            sLFGMgr->UpdateProposal(id, bot->GetGUID(), false);
+            return true;
+        }
+
+        ai->ChangeStrategy("-grind", BOT_STATE_NON_COMBAT);
+
+        if (sRandomPlayerbotMgr.IsRandomBot(bot) && !bot->GetGroup())
+            ai->ChangeStrategy("-grind", BOT_STATE_NON_COMBAT);
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s updated proposal %d", bot->GetName().c_str(), id);
+        ai->GetAiObjectContext()->GetValue<uint32>("lfg proposal")->Set(0);
+        bot->ClearUnitState(UNIT_STATE_ALL_STATE_SUPPORTED);
+        sLFGMgr->UpdateProposal(id, bot->GetGUID(), true);
+
+        return true;
+    }
+
+    WorldPacket p(event.getPacket());
+
+    uint32 dungeon;
+    uint8 state;
+    p >> dungeon >> state >> id;
+
+    ai->GetAiObjectContext()->GetValue<uint32>("lfg proposal")->Set(id);
+    return true;
+}
+
+bool LfgLeaveAction::Execute(Event event)
+{
+    if (sLFGMgr->GetState(bot->GetGUID()) != LFG_STATE_QUEUED)
+        return false;
+
+    sLFGMgr->LeaveLfg(bot->GetGUID());
+	return true;
+}
+
+bool LfgTeleportAction::Execute(Event event)
+{
+    bool out = false;
+
+    WorldPacket p(event.getPacket());
+    if (!p.empty())
+    {
+        p.rpos(0);
+        p >> out;
+    }
+
+    bot->ClearUnitState(UNIT_STATE_ALL_STATE_SUPPORTED);
+    sLFGMgr->TeleportPlayer(bot, out);
+	return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LfgActions.h b/src/plugins/playerbot/strategy/actions/LfgActions.h
new file mode 100644
index 0000000..052cdcc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LfgActions.h
@@ -0,0 +1,48 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class LfgJoinAction : public InventoryAction
+    {
+    public:
+        LfgJoinAction(PlayerbotAI* ai, string name = "lfg join") : InventoryAction(ai, name) {}
+        virtual bool Execute(Event event);
+
+    protected:
+        bool JoinProposal();
+        bool SetRoles();
+        uint8 GetRoles();
+    };
+
+    class LfgAcceptAction : public LfgJoinAction
+    {
+    public:
+        LfgAcceptAction(PlayerbotAI* ai) : LfgJoinAction(ai, "lfg accept") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgRoleCheckAction : public LfgJoinAction
+    {
+    public:
+        LfgRoleCheckAction(PlayerbotAI* ai) : LfgJoinAction(ai, "lfg role check") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgLeaveAction : public Action
+    {
+    public:
+        LfgLeaveAction(PlayerbotAI* ai) : Action(ai, "lfg leave") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgTeleportAction : public Action
+    {
+    public:
+        LfgTeleportAction(PlayerbotAI* ai) : Action(ai, "lfg teleport") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp b/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
new file mode 100644
index 0000000..d9249ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
@@ -0,0 +1,71 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ListQuestsActions.h"
+
+
+using namespace ai;
+
+bool ListQuestsAction::Execute(Event event)
+{
+    if (event.getParam() == "completed")
+    {
+        ListQuests(QUEST_LIST_FILTER_COMPLETED);
+    }
+    else if (event.getParam() == "incompleted")
+    {
+        ListQuests(QUEST_LIST_FILTER_INCOMPLETED);
+    }
+    else if (event.getParam() == "all")
+    {
+        ListQuests(QUEST_LIST_FILTER_ALL);
+    }
+    else
+    {
+        ListQuests(QUEST_LIST_FILTER_SUMMARY);
+    }
+    return true;
+}
+
+void ListQuestsAction::ListQuests(QuestListFilter filter)
+{
+    bool showIncompleted = filter & QUEST_LIST_FILTER_INCOMPLETED;
+    bool showCompleted = filter & QUEST_LIST_FILTER_COMPLETED;
+
+    if (showIncompleted)
+        ai->TellMaster("--- Incomplete quests ---");
+    int incompleteCount = ListQuests(false, !showIncompleted);
+
+    if (showCompleted)
+        ai->TellMaster("--- Complete quests ---");
+    int completeCount = ListQuests(true, !showCompleted);
+
+    ai->TellMaster("--- Summary ---");
+    std::ostringstream out;
+    out << "Total: " << (completeCount + incompleteCount) << " / 25 (incomplete: " << incompleteCount << ", complete: " << completeCount << ")";
+    ai->TellMaster(out);
+}
+
+int ListQuestsAction::ListQuests(bool completed, bool silent)
+{
+    int count = 0;
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 questId = bot->GetQuestSlotQuestId(slot);
+        if (!questId)
+            continue;
+
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questId);
+        bool isCompletedQuest = bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE;
+        if (completed != isCompletedQuest)
+            continue;
+
+        count++;
+
+        if (silent)
+            continue;
+
+        ai->TellMaster(chat->formatQuest(pQuest));
+    }
+
+    return count;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ListQuestsActions.h b/src/plugins/playerbot/strategy/actions/ListQuestsActions.h
new file mode 100644
index 0000000..961acb8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListQuestsActions.h
@@ -0,0 +1,25 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    enum QuestListFilter {
+        QUEST_LIST_FILTER_SUMMARY = 0,
+        QUEST_LIST_FILTER_COMPLETED = 1,
+        QUEST_LIST_FILTER_INCOMPLETED = 2,
+        QUEST_LIST_FILTER_ALL = QUEST_LIST_FILTER_COMPLETED | QUEST_LIST_FILTER_INCOMPLETED
+    };
+
+    class ListQuestsAction : public Action {
+    public:
+        ListQuestsAction(PlayerbotAI* ai) : Action(ai, "quests") {}
+        virtual bool Execute(Event event);
+
+    private:
+        int ListQuests(bool completed, bool silent);
+        void ListQuests(QuestListFilter filter);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp b/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
new file mode 100644
index 0000000..4602fb8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ListSpellsAction.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+bool ListSpellsAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    int loc = master->GetSession()->GetSessionDbcLocale();
+
+    std::ostringstream posOut;
+    std::ostringstream negOut;
+
+    string filter = event.getParam();
+
+    const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+    std::string alreadySeenList = ",";
+
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr) {
+        const uint32 spellId = itr->first;
+
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        //|| name.find("Teleport") != -1
+
+        std::string comp = ",";
+        comp.append(pSpellInfo->SpellName[loc]);
+        comp.append(",");
+
+        if (!(ignoreList.find(comp) == std::string::npos && alreadySeenList.find(comp) == std::string::npos))
+            continue;
+
+        if (!filter.empty() && !strstri(pSpellInfo->SpellName[loc], filter.c_str()))
+            continue;
+
+        alreadySeenList += pSpellInfo->SpellName[loc];
+        alreadySeenList += ",";
+
+        if (pSpellInfo->IsPositive())
+            posOut << " |cffffffff|Hspell:" << spellId << "|h["
+            << pSpellInfo->SpellName[loc] << "]|h|r";
+        else
+            negOut << " |cffffffff|Hspell:" << spellId << "|h["
+            << pSpellInfo->SpellName[loc] << "]|h|r";
+    }
+
+    ai->TellMaster("here's my non-attack spells:");
+    ai->TellMaster(posOut);
+
+    ai->TellMaster("here's my attack spells:");
+    ai->TellMaster(negOut);
+
+    return true;
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/ListSpellsAction.h b/src/plugins/playerbot/strategy/actions/ListSpellsAction.h
new file mode 100644
index 0000000..2447055
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListSpellsAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+
+namespace ai
+{
+    class ListSpellsAction : public Action {
+    public:
+        ListSpellsAction(PlayerbotAI* ai) : Action(ai, "spells") {}
+
+        virtual bool Execute(Event event);
+  
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp b/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
new file mode 100644
index 0000000..92005a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
@@ -0,0 +1,43 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LogLevelAction.h"
+
+
+using namespace ai;
+
+bool LogLevelAction::Execute(Event event)
+{
+    string param = event.getParam();
+    Value<LogLevel> *value = ai->GetAiObjectContext()->GetValue<LogLevel>("log level");
+
+    ostringstream out;
+    if (param != "?")
+    {
+        value->Set(string2logLevel(param));
+        out << "My log level set to " << logLevel2string(value->Get());
+    }
+    else
+    {
+        out << "My log level is " << logLevel2string(value->Get());
+    }
+    ai->TellMaster(out);
+    return true;
+}
+
+string LogLevelAction::logLevel2string(LogLevel level)
+{
+    switch (level)
+    {
+    case LOG_LEVEL_INFO:
+        return "info";
+    default:
+        return "debug";
+    }
+}
+LogLevel LogLevelAction::string2logLevel(string level)
+{
+    if (level == "debug")
+        return LOG_LEVEL_DEBUG;
+    else
+        return LOG_LEVEL_INFO;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LogLevelAction.h b/src/plugins/playerbot/strategy/actions/LogLevelAction.h
new file mode 100644
index 0000000..4ad2a33
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LogLevelAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class LogLevelAction : public Action {
+    public:
+        LogLevelAction(PlayerbotAI* ai) : Action(ai, "log") {}
+        virtual bool Execute(Event event);
+
+    public:
+        static string logLevel2string(LogLevel level);
+        static LogLevel string2logLevel(string level);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/LootAction.cpp b/src/plugins/playerbot/strategy/actions/LootAction.cpp
new file mode 100644
index 0000000..41c17aa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootAction.cpp
@@ -0,0 +1,338 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootAction.h"
+
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../values/ItemUsageValue.h"
+#include "../../GuildTaskMgr.h"
+
+using namespace ai;
+
+bool LootAction::Execute(Event event)
+{
+    if (!AI_VALUE(bool, "has available loot"))
+        return false;
+
+    LootObject const& lootObject = AI_VALUE(LootObjectStack*, "available loot")->GetLoot(sPlayerbotAIConfig.lootDistance);
+    context->GetValue<LootObject>("loot target")->Set(lootObject);
+    return true;
+}
+
+enum ProfessionSpells
+{
+    ALCHEMY                      = 2259,
+    BLACKSMITHING                = 2018,
+    COOKING                      = 2550,
+    ENCHANTING                   = 7411,
+    ENGINEERING                  = 49383,
+    FIRST_AID                    = 3273,
+    FISHING                      = 7620,
+    HERB_GATHERING               = 2366,
+    INSCRIPTION                  = 45357,
+    JEWELCRAFTING                = 25229,
+    MINING                       = 2575,
+    SKINNING                     = 8613,
+    TAILORING                    = 3908
+};
+
+bool OpenLootAction::Execute(Event event)
+{
+    LootObject lootObject = AI_VALUE(LootObject, "loot target");
+    bool result = DoLoot(lootObject);
+    if (result)
+    {
+        AI_VALUE(LootObjectStack*, "available loot")->Remove(lootObject.guid);
+        context->GetValue<LootObject>("loot target")->Set(LootObject());
+    }
+    return result;
+}
+
+bool OpenLootAction::DoLoot(LootObject& lootObject)
+{
+    if (lootObject.IsEmpty())
+        return false;
+
+    Creature* creature = ai->GetCreature(lootObject.guid);
+    if (creature && bot->GetDistance(creature) > INTERACTION_DISTANCE)
+        return false;
+
+    if (creature && creature->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+    {
+        bot->GetMotionMaster()->Clear();
+        WorldPacket* const packet = new WorldPacket(CMSG_LOOT, 8);
+        *packet << lootObject.guid;
+        bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+
+    if (creature)
+    {
+        SkillType skill = creature->GetCreatureTemplate()->GetRequiredLootSkill();
+        if (!CanOpenLock(skill, lootObject.reqSkillValue))
+            return false;
+
+        bot->GetMotionMaster()->Clear();
+        switch (skill)
+        {
+        case SKILL_ENGINEERING:
+            return bot->HasSkill(SKILL_ENGINEERING) ? ai->CastSpell(ENGINEERING, creature) : false;
+        case SKILL_HERBALISM:
+            return bot->HasSkill(SKILL_HERBALISM) ? ai->CastSpell(32605, creature) : false;
+        case SKILL_MINING:
+            return bot->HasSkill(SKILL_MINING) ? ai->CastSpell(32606, creature) : false;
+        default:
+            return bot->HasSkill(SKILL_SKINNING) ? ai->CastSpell(SKINNING, creature) : false;
+        }
+    }
+
+    GameObject* go = ai->GetGameObject(lootObject.guid);
+    if (go && bot->GetDistance(go) > INTERACTION_DISTANCE)
+        return false;
+
+    bot->GetMotionMaster()->Clear();
+    if (lootObject.skillId == SKILL_MINING)
+        return bot->HasSkill(SKILL_MINING) ? ai->CastSpell(MINING, bot) : false;
+
+    if (lootObject.skillId == SKILL_HERBALISM)
+        return bot->HasSkill(SKILL_HERBALISM) ? ai->CastSpell(HERB_GATHERING, bot) : false;
+
+    uint32 spellId = GetOpeningSpell(lootObject);
+    if (!spellId)
+        return false;
+
+    return ai->CastSpell(spellId, bot);
+}
+
+uint32 OpenLootAction::GetOpeningSpell(LootObject& lootObject)
+{
+    GameObject* go = ai->GetGameObject(lootObject.guid);
+    if (go && go->isSpawned())
+        return GetOpeningSpell(lootObject, go);
+
+    return 0;
+}
+
+uint32 OpenLootAction::GetOpeningSpell(LootObject& lootObject, GameObject* go)
+{
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        if (spellId == MINING || spellId == HERB_GATHERING)
+            continue;
+
+        if (CanOpenLock(lootObject, pSpellInfo, go))
+            return spellId;
+    }
+
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); spellId++)
+    {
+        if (spellId == MINING || spellId == HERB_GATHERING)
+            continue;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (CanOpenLock(lootObject, pSpellInfo, go))
+            return spellId;
+    }
+
+    return 0; //Spell 3365 = Opening?
+}
+
+bool OpenLootAction::CanOpenLock(LootObject& lootObject, const SpellInfo* pSpellInfo, GameObject* go)
+{
+    for (int effIndex = 0; effIndex <= EFFECT_2; effIndex++)
+    {
+        if (pSpellInfo->Effects[effIndex].Effect != SPELL_EFFECT_OPEN_LOCK && pSpellInfo->Effects[effIndex].Effect != SPELL_EFFECT_SKINNING)
+            return false;
+
+        uint32 lockId = go->GetGOInfo()->GetLockId();
+        if (!lockId)
+            return false;
+
+        LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+        if (!lockInfo)
+            return false;
+
+        bool reqKey = false;                                    // some locks not have reqs
+
+        for(int j = 0; j < 8; ++j)
+        {
+            switch(lockInfo->Type[j])
+            {
+            /*
+            case LOCK_KEY_ITEM:
+                return true;
+            */
+            case LOCK_KEY_SKILL:
+                {
+                    if(uint32(pSpellInfo->Effects[effIndex].MiscValue) != lockInfo->Index[j])
+                        continue;
+
+                    uint32 skillId = SkillByLockType(LockType(lockInfo->Index[j]));
+                    if (skillId == SKILL_NONE)
+                        return true;
+
+                    if (CanOpenLock(skillId, lockInfo->Skill[j]))
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+bool OpenLootAction::CanOpenLock(uint32 skillId, uint32 reqSkillValue)
+{
+    uint32 skillValue = bot->GetSkillValue(skillId);
+    return skillValue >= reqSkillValue || !reqSkillValue;
+}
+
+bool StoreLootAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket()); // (8+1+4+1+1+4+4+4+4+4+1)
+    ObjectGuid guid;
+    uint8 loot_type;
+    uint32 gold = 0;
+    uint8 items = 0;
+
+    p.rpos(0);
+    p >> guid;      // 8 corpse guid
+    p >> loot_type; // 1 loot type
+
+    if (p.size() > 10)
+    {
+        p >> gold;      // 4 money on corpse
+        p >> items;     // 1 number of items on corpse
+    }
+
+    if (gold > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_LOOT_MONEY, 0);
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    for (uint8 i = 0; i < items; ++i)
+    {
+        uint32 itemid;
+        uint32 itemcount;
+        uint8 lootslot_type;
+        uint8 itemindex;
+        bool grab = false;
+
+        p >> itemindex;
+        p >> itemid;
+        p >> itemcount;
+        p.read_skip<uint32>();  // display id
+        p.read_skip<uint32>();  // randomSuffix
+        p.read_skip<uint32>();  // randomPropertyId
+        p >> lootslot_type;     // 0 = can get, 1 = look only, 2 = master get
+
+        if (lootslot_type != LOOT_SLOT_TYPE_ALLOW_LOOT && lootslot_type != LOOT_SLOT_TYPE_OWNER)
+            continue;
+
+        if (loot_type != LOOT_SKINNING && !IsLootAllowed(itemid))
+            continue;
+
+        if (sRandomPlayerbotMgr.IsRandomBot(bot))
+        {
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemid);
+            if (proto)
+            {
+                uint32 price = itemcount * auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot) + gold;
+                uint32 lootAmount = sRandomPlayerbotMgr.GetLootAmount(bot);
+                if (bot->GetGroup() && price)
+                {
+                    sRandomPlayerbotMgr.SetLootAmount(bot, lootAmount + price);
+                }
+                else if (lootAmount)
+                {
+                    sRandomPlayerbotMgr.SetLootAmount(bot, 0);
+                }
+
+                Group* group = bot->GetGroup();
+                if (group)
+                {
+                    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+                    {
+                        if( ref->GetSource() != bot)
+                            sGuildTaskMgr.CheckItemTask(itemid, itemcount, ref->GetSource(), bot);
+                    }
+                }
+            }
+        }
+
+        WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_LOOT_ITEM, 1);
+        *packet << itemindex;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    AI_VALUE(LootObjectStack*, "available loot")->Remove(guid);
+
+    // release loot
+    WorldPacket* const packet = new WorldPacket(CMSG_LOOT_RELEASE, 8);
+    *packet << guid;
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+bool StoreLootAction::IsLootAllowed(uint32 itemid)
+{
+    LootStrategy lootStrategy = AI_VALUE(LootStrategy, "loot strategy");
+
+    if (lootStrategy == LOOTSTRATEGY_ALL)
+        return true;
+
+    set<uint32>& lootItems = AI_VALUE(set<uint32>&, "always loot list");
+    if (lootItems.find(itemid) != lootItems.end())
+        return true;
+
+    ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemid);
+    if (!proto)
+        return false;
+
+    uint32 max = proto->MaxCount;
+    if (max > 0 && bot->HasItemCount(itemid, max, true))
+        return false;
+
+    if (proto->StartQuest ||
+        proto->Bonding == BIND_QUEST_ITEM ||
+        proto->Bonding == BIND_QUEST_ITEM1 ||
+        proto->Class == ITEM_CLASS_QUEST)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_QUEST)
+        return false;
+
+    ostringstream out; out << itemid;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    if (usage == ITEM_USAGE_SKILL || usage == ITEM_USAGE_USE || usage == ITEM_USAGE_GUILD_TASK)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_SKILL)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_MONEY || proto->Quality == ITEM_QUALITY_POOR)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_GRAY)
+        return true;
+
+    if (proto->Bonding == BIND_WHEN_PICKED_UP)
+        return false;
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootAction.h b/src/plugins/playerbot/strategy/actions/LootAction.h
new file mode 100644
index 0000000..c18fbb2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootAction.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../LootObjectStack.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class LootAction : public MovementAction
+    {
+    public:
+        LootAction(PlayerbotAI* ai) : MovementAction(ai, "loot") {}
+        virtual bool Execute(Event event);
+    };
+
+    class OpenLootAction : public MovementAction
+    {
+    public:
+        OpenLootAction(PlayerbotAI* ai) : MovementAction(ai, "open loot") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool DoLoot(LootObject& lootObject);
+        uint32 GetOpeningSpell(LootObject& lootObject);
+        uint32 GetOpeningSpell(LootObject& lootObject, GameObject* go);
+        bool CanOpenLock(LootObject& lootObject, const SpellInfo* pSpellInfo, GameObject* go);
+        bool CanOpenLock(uint32 skillId, uint32 reqSkillValue);
+    };
+
+    class StoreLootAction : public MovementAction
+    {
+    public:
+        StoreLootAction(PlayerbotAI* ai) : MovementAction(ai, "store loot") {}
+        virtual bool Execute(Event event);
+
+    protected:
+        bool IsLootAllowed(uint32 itemid);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootRollAction.cpp b/src/plugins/playerbot/strategy/actions/LootRollAction.cpp
new file mode 100644
index 0000000..498cb42
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootRollAction.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootRollAction.h"
+#include "../../../Groups/Group.h"
+
+
+using namespace ai;
+
+bool LootRollAction::Execute(Event event)
+{
+    Player *bot = QueryItemUsageAction::ai->GetBot();
+
+    WorldPacket p(event.getPacket()); //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+    ObjectGuid guid;
+    uint32 slot;
+    uint8 rollType;
+    p.rpos(0); //reset packet pointer
+    p >> guid; //guid of the item rolled
+    p >> slot; //number of players invited to roll
+    p >> rollType; //need,greed or pass on roll
+
+    Group* group = bot->GetGroup();
+    if(!group)
+        return false;
+
+    RollVote vote = PASS;
+    for (vector<Roll*>::iterator i = group->GetRolls()->begin(); i != group->GetRolls()->end(); ++i)
+    {
+        if ((*i)->isValid() && (*i)->itemGUID == guid && (*i)->itemSlot == slot)
+        {
+            uint32 itemId = (*i)->itemid;
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemId);
+            if (!proto)
+                continue;
+
+            switch (proto->Class)
+            {
+            case ITEM_CLASS_WEAPON:
+            case ITEM_CLASS_ARMOR:
+                if (QueryItemUsage(proto))
+                    vote = NEED;
+                else if (bot->HasSkill(SKILL_ENCHANTING))
+                    vote = DISENCHANT;
+                break;
+            default:
+                if (IsLootAllowed(itemId))
+                    vote = NEED;
+                break;
+            }
+            break;
+        }
+    }
+
+    switch (group->GetLootMethod())
+    {
+    case MASTER_LOOT:
+    case FREE_FOR_ALL:
+        group->CountRollVote(bot->GetGUID(), guid, PASS);
+        break;
+    default:
+        group->CountRollVote(bot->GetGUID(), guid, vote);
+        break;
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootRollAction.h b/src/plugins/playerbot/strategy/actions/LootRollAction.h
new file mode 100644
index 0000000..05651a4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootRollAction.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include "../Action.h"
+#include "QueryItemUsageAction.h"
+#include "LootAction.h"
+
+namespace ai
+{
+    class LootRollAction : public QueryItemUsageAction, public StoreLootAction {
+    public:
+        LootRollAction(PlayerbotAI* ai) : QueryItemUsageAction(ai, "loot roll"), StoreLootAction(ai) {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp b/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
new file mode 100644
index 0000000..633429e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
@@ -0,0 +1,100 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootStrategyAction.h"
+
+
+using namespace ai;
+
+
+bool LootStrategyAction::Execute(Event event)
+{
+    string strategy = event.getParam();
+
+    LootObjectStack* lootItems = AI_VALUE(LootObjectStack*, "available loot");
+    set<uint32>& alwaysLootItems = AI_VALUE(set<uint32>&, "always loot list");
+    Value<LootStrategy>* lootStrategy = context->GetValue<LootStrategy>("loot strategy");
+
+    if (strategy == "?")
+    {
+        ostringstream out;
+        out << "Loot strategy: ";
+        out << LootStrategy2string(lootStrategy->Get());
+        out << ", always loot items: ";
+
+        for (set<uint32>::iterator i = alwaysLootItems.begin(); i != alwaysLootItems.end(); i++)
+        {
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(*i);
+            if (!proto)
+                continue;
+
+            out << chat->formatItem(proto);
+        }
+        ai->TellMaster(out);
+    }
+    else
+    {
+        ItemIds items = chat->parseItems(strategy);
+
+        if (items.size() == 0)
+        {
+            lootStrategy->Set(String2LootStrategy(strategy));
+            ostringstream out;
+            out << "Loot strategy set to " << LootStrategy2string(lootStrategy->Get());
+            ai->TellMaster(out);
+            return true;
+        }
+
+        bool remove = strategy.size() > 1 && strategy.substr(0, 1) == "-";
+        for (ItemIds::iterator i = items.begin(); i != items.end(); i++)
+        {
+            uint32 itemid = *i;
+            if (remove)
+            {
+                set<uint32>::iterator j = alwaysLootItems.find(itemid);
+                if (j != alwaysLootItems.end())
+                    alwaysLootItems.erase(j);
+
+                ai->TellMaster("Item(s) removed from always loot list");
+            }
+            else
+            {
+                alwaysLootItems.insert(itemid);
+                ai->TellMaster("Item(s) added to always loot list");
+            }
+        }
+    }
+
+    return true;
+}
+
+
+LootStrategy LootStrategyAction::String2LootStrategy(string strategy)
+{
+    if (strategy == "*" || strategy == "all")
+        return LOOTSTRATEGY_ALL;
+    else if (strategy == "q" || strategy == "quest")
+        return LOOTSTRATEGY_QUEST;
+    else if (strategy == "s" || strategy == "skill")
+        return LOOTSTRATEGY_SKILL;
+    else if (strategy == "g" || strategy == "gray")
+        return LOOTSTRATEGY_GRAY;
+    else
+        return LOOTSTRATEGY_NORMAL;
+}
+
+string LootStrategyAction::LootStrategy2string(LootStrategy lootStrategy)
+{
+    switch (lootStrategy)
+    {
+    case LOOTSTRATEGY_ALL:
+        return "all";
+    case LOOTSTRATEGY_QUEST:
+        return "quest";
+    case LOOTSTRATEGY_SKILL:
+        return "skill";
+    case LOOTSTRATEGY_GRAY:
+        return "gray";
+    default:
+        return "normal";
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootStrategyAction.h b/src/plugins/playerbot/strategy/actions/LootStrategyAction.h
new file mode 100644
index 0000000..51e1f23
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootStrategyAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class LootStrategyAction : public Action {
+    public:
+        LootStrategyAction(PlayerbotAI* ai) : Action(ai, "ll") {}
+        virtual bool Execute(Event event);
+
+    private:
+        static LootStrategy String2LootStrategy(string strategy);
+        static string LootStrategy2string(LootStrategy lootStrategy);
+   
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/MovementActions.cpp b/src/plugins/playerbot/strategy/actions/MovementActions.cpp
new file mode 100644
index 0000000..65905c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/MovementActions.cpp
@@ -0,0 +1,376 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../values/LastMovementValue.h"
+#include "MovementActions.h"
+#include "../../../Movement/MotionMaster.h"
+#include "../../../Movement/MovementGenerator.h"
+#include "../../FleeManager.h"
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool MovementAction::MoveNear(uint32 mapId, float x, float y, float z, float distance)
+{
+    float angle = GetFollowAngle();
+    return MoveTo(mapId, x + cos(angle) * distance, y + sin(angle) * distance, z);
+}
+
+bool MovementAction::MoveNear(WorldObject* target, float distance)
+{
+    if (!target)
+        return false;
+
+    distance += target->GetObjectSize() / 2.0f;
+
+    float followAngle = GetFollowAngle();
+    for (float angle = followAngle; angle <= followAngle + 2 * M_PI; angle += M_PI / 4)
+    {
+        bool moved = MoveTo(target->GetMapId(),
+            target->GetPositionX() + cos(angle) * distance,
+            target->GetPositionY()+ sin(angle) * distance,
+            target->GetPositionZ());
+        if (moved)
+            return true;
+    }
+    return false;
+}
+
+bool MovementAction::MoveTo(uint32 mapId, float x, float y, float z)
+{
+    bot->UpdateGroundPositionZ(x, y, z);
+    if (!IsMovingAllowed(mapId, x, y, z))
+        return false;
+
+    float distance = bot->GetDistance2d(x, y);
+    if (distance > sPlayerbotAIConfig.contactDistance)
+    {
+        WaitForReach(distance);
+
+        if (bot->IsSitState())
+            bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+        if (bot->IsNonMeleeSpellCast(true))
+        {
+            bot->CastStop();
+            ai->InterruptSpell();
+        }
+
+        bool generatePath = bot->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) &&
+                !bot->IsFlying() && !bot->IsUnderWater();
+        MotionMaster &mm = *bot->GetMotionMaster();
+        mm.Clear();
+
+        float botZ = bot->GetPositionZ();
+        if (z - botZ > 0.5f && bot->GetDistance2d(x, y) <= 5.0f)
+        {
+            float speed = bot->GetSpeed(MOVE_RUN);
+            mm.MoveJump(x, y, botZ + 0.5f, speed, speed, 1);
+        }
+        else
+            mm.MovePoint(mapId, x, y, z, generatePath);
+
+        AI_VALUE(LastMovement&, "last movement").Set(x, y, z, bot->GetOrientation());
+        return true;
+    }
+
+    return false;
+}
+
+bool MovementAction::MoveTo(Unit* target, float distance)
+{
+    if (!IsMovingAllowed(target))
+        return false;
+
+    float bx = bot->GetPositionX();
+    float by = bot->GetPositionY();
+    float bz = bot->GetPositionZ();
+
+    float tx = target->GetPositionX();
+    float ty = target->GetPositionY();
+    float tz = target->GetPositionZ();
+
+    float distanceToTarget = bot->GetDistance2d(target);
+    float angle = bot->GetAngle(target);
+    float needToGo = distanceToTarget - distance;
+
+    float maxDistance = sPlayerbotAIConfig.spellDistance;
+    if (needToGo > 0 && needToGo > maxDistance)
+        needToGo = maxDistance;
+    else if (needToGo < 0 && needToGo < -maxDistance)
+        needToGo = -maxDistance;
+
+    float dx = cos(angle) * needToGo + bx;
+    float dy = sin(angle) * needToGo + by;
+
+    return MoveTo(target->GetMapId(), dx, dy, tz);
+}
+
+float MovementAction::GetFollowAngle()
+{
+    Player* master = GetMaster();
+    Group* group = master ? master->GetGroup() : bot->GetGroup();
+    if (!group)
+        return 0.0f;
+
+    int index = 1;
+    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+    {
+        if( ref->GetSource() == master)
+            continue;
+
+        if( ref->GetSource() == bot)
+            return 2 * M_PI / (group->GetMembersCount() -1) * index;
+
+        index++;
+    }
+    return 0;
+}
+
+bool MovementAction::IsMovingAllowed(Unit* target)
+{
+    if (!target)
+        return false;
+
+    if (bot->GetMapId() != target->GetMapId())
+        return false;
+
+    float distance = bot->GetDistance(target);
+    if (distance > sPlayerbotAIConfig.reactDistance)
+        return false;
+
+    return IsMovingAllowed();
+}
+
+bool MovementAction::IsMovingAllowed(uint32 mapId, float x, float y, float z)
+{
+    float distance = bot->GetDistance(x, y, z);
+    if (distance > sPlayerbotAIConfig.reactDistance)
+        return false;
+
+    return IsMovingAllowed();
+}
+
+bool MovementAction::IsMovingAllowed()
+{
+    if (bot->isFrozen() || bot->IsPolymorphed() ||
+			(bot->isDead() && !bot->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST)) ||
+            bot->IsBeingTeleported() ||
+            bot->isInRoots() ||
+            bot->HasAuraType(SPELL_AURA_MOD_CONFUSE) || bot->IsCharmed() ||
+            bot->HasAuraType(SPELL_AURA_MOD_STUN) || bot->IsFlying())
+        return false;
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    return mm.GetCurrentMovementGeneratorType() != FLIGHT_MOTION_TYPE;
+}
+
+bool MovementAction::Follow(Unit* target, float distance)
+{
+    return Follow(target, distance, GetFollowAngle());
+}
+
+bool MovementAction::Follow(Unit* target, float distance, float angle)
+{
+    MotionMaster &mm = *bot->GetMotionMaster();
+
+    if (!target)
+        return false;
+
+    if (bot->GetDistance2d(target->GetPositionX(), target->GetPositionY()) <= sPlayerbotAIConfig.sightDistance &&
+            abs(bot->GetPositionZ() - target->GetPositionZ()) >= sPlayerbotAIConfig.spellDistance)
+    {
+        mm.Clear();
+        float x = bot->GetPositionX(), y = bot->GetPositionY(), z = target->GetPositionZ();
+        if (target->GetMapId() && bot->GetMapId() != target->GetMapId())
+        {
+            bot->TeleportTo(target->GetMapId(), x, y, z, bot->GetOrientation());
+        }
+        else
+        {
+            bot->Relocate(x, y, z, bot->GetOrientation());
+        }
+        AI_VALUE(LastMovement&, "last movement").Set(target);
+        return true;
+    }
+
+    if (!IsMovingAllowed(target))
+        return false;
+
+    if (target->IsFriendlyTo(bot) && bot->IsMounted() && AI_VALUE(list<ObjectGuid>, "possible targets").empty())
+        distance += angle;
+
+    if (bot->GetDistance2d(target) <= sPlayerbotAIConfig.followDistance)
+        return false;
+
+    if (bot->IsSitState())
+        bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (bot->IsNonMeleeSpellCast(true))
+    {
+        bot->CastStop();
+        ai->InterruptSpell();
+    }
+
+    mm.MoveFollow(target, distance, angle);
+
+    AI_VALUE(LastMovement&, "last movement").Set(target);
+    return true;
+}
+
+void MovementAction::WaitForReach(float distance)
+{
+    float delay = 1000.0f * distance / bot->GetSpeed(MOVE_RUN) + sPlayerbotAIConfig.reactDelay;
+
+    if (delay > sPlayerbotAIConfig.maxWaitForMove)
+        delay = sPlayerbotAIConfig.maxWaitForMove;
+
+    Unit* target = *ai->GetAiObjectContext()->GetValue<Unit*>("current target");
+    Unit* player = *ai->GetAiObjectContext()->GetValue<Unit*>("enemy player target");
+    if ((player || target) && delay > sPlayerbotAIConfig.globalCoolDown)
+        delay = sPlayerbotAIConfig.globalCoolDown;
+
+    ai->SetNextCheckDelay((uint32)delay);
+}
+
+bool MovementAction::Flee(Unit *target)
+{
+    Player* master = GetMaster();
+    if (!target)
+        target = master;
+
+    if (!target)
+        return false;
+
+    if (!sPlayerbotAIConfig.fleeingEnabled)
+        return false;
+
+    if (!IsMovingAllowed())
+        return false;
+
+    FleeManager manager(bot, sPlayerbotAIConfig.fleeDistance, bot->GetAngle(target) + M_PI);
+
+    float rx, ry, rz;
+    if (!manager.CalculateDestination(&rx, &ry, &rz))
+        return false;
+
+    return MoveTo(target->GetMapId(), rx, ry, rz);
+}
+
+bool FleeAction::Execute(Event event)
+{
+    return Flee(AI_VALUE(Unit*, "current target"));
+}
+
+bool FleeAction::isUseful()
+{
+    return AI_VALUE(uint8, "attacker count") > 0 &&
+            AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.tooCloseDistance &&
+            AI_VALUE2(uint8, "speed", "current target") < 100;
+}
+
+bool RunAwayAction::Execute(Event event)
+{
+    return Flee(AI_VALUE(Unit*, "master target"));
+}
+
+bool MoveRandomAction::Execute(Event event)
+{
+    WorldObject* target = NULL;
+
+    if (!(rand() % 3))
+    {
+        list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+        for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+        {
+            target = ai->GetUnit(*i);
+
+            if (target && bot->GetDistance(target) > sPlayerbotAIConfig.tooCloseDistance)
+                break;
+        }
+    }
+
+    if (!target || !(rand() % 3))
+    {
+        list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+        for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+        {
+            target = ai->GetGameObject(*i);
+
+            if (target && bot->GetDistance(target) > sPlayerbotAIConfig.tooCloseDistance)
+                break;
+        }
+    }
+
+    float distance = sPlayerbotAIConfig.tooCloseDistance + sPlayerbotAIConfig.grindDistance * urand(3, 10) / 10.0f;
+
+    Map* map = bot->GetMap();
+    if (target)
+    {
+        float x = target->GetPositionX();
+        float y = target->GetPositionY();
+        float z = target->GetPositionZ();
+        if (!map->IsInWater(x, y, z))
+        {
+            return MoveNear(target);
+        }
+    }
+
+    for (int i = 0; i < 10; ++i)
+    {
+        float x = bot->GetPositionX();
+        float y = bot->GetPositionY();
+        float z = bot->GetPositionZ();
+        x += urand(0, distance) - distance / 2;
+        y += urand(0, distance) - distance / 2;
+        bot->UpdateGroundPositionZ(x, y, z);
+
+        if (map->IsInWater(x, y, z))
+            continue;
+
+        bool moved = MoveNear(bot->GetMapId(), x, y, z);
+        if (moved)
+            return true;
+    }
+
+    return false;
+}
+
+bool MoveToLootAction::Execute(Event event)
+{
+    LootObject loot = AI_VALUE(LootObject, "loot target");
+    if (!loot.IsLootPossible(bot))
+        return false;
+
+    return MoveNear(loot.GetWorldObject(bot));
+}
+
+bool MoveOutOfEnemyContactAction::Execute(Event event)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    if (!target)
+        return false;
+
+    return MoveNear(target, sPlayerbotAIConfig.meleeDistance);
+}
+
+bool MoveOutOfEnemyContactAction::isUseful()
+{
+    return AI_VALUE2(float, "distance", "current target") < (sPlayerbotAIConfig.meleeDistance + sPlayerbotAIConfig.contactDistance);
+}
+
+bool SetFacingTargetAction::Execute(Event event)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    if (!target)
+        return false;
+
+    bot->SetFacingTo(bot->GetAngle(target));
+    ai->SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+    return true;
+}
+
+bool SetFacingTargetAction::isUseful()
+{
+    return !AI_VALUE2(bool, "facing", "current target");
+}
diff --git a/src/plugins/playerbot/strategy/actions/MovementActions.h b/src/plugins/playerbot/strategy/actions/MovementActions.h
new file mode 100644
index 0000000..dc27b92
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/MovementActions.h
@@ -0,0 +1,92 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class MovementAction : public Action {
+    public:
+        MovementAction(PlayerbotAI* ai, string name) : Action(ai, name)
+        {
+            bot = ai->GetBot();
+        }
+
+    protected:
+        bool MoveNear(uint32 mapId, float x, float y, float z, float distance = sPlayerbotAIConfig.followDistance);
+        bool MoveTo(uint32 mapId, float x, float y, float z);
+        bool MoveTo(Unit* target, float distance = 0.0f);
+        bool MoveNear(WorldObject* target, float distance = sPlayerbotAIConfig.followDistance);
+        float GetFollowAngle();
+        bool Follow(Unit* target, float distance = sPlayerbotAIConfig.followDistance);
+        bool Follow(Unit* target, float distance, float angle);
+        void WaitForReach(float distance);
+        bool IsMovingAllowed(Unit* target);
+        bool IsMovingAllowed(uint32 mapId, float x, float y, float z);
+        bool IsMovingAllowed();
+        bool Flee(Unit *target);
+
+    protected:
+        Player* bot;
+    };
+
+    class FleeAction : public MovementAction
+    {
+    public:
+        FleeAction(PlayerbotAI* ai, float distance = sPlayerbotAIConfig.spellDistance) : MovementAction(ai, "flee")
+        {
+			this->distance = distance;
+		}
+
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+
+	private:
+		float distance;
+    };
+
+
+    class RunAwayAction : public MovementAction
+    {
+    public:
+        RunAwayAction(PlayerbotAI* ai) : MovementAction(ai, "runaway") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MoveRandomAction : public MovementAction
+    {
+    public:
+        MoveRandomAction(PlayerbotAI* ai) : MovementAction(ai, "move random") {}
+        virtual bool Execute(Event event);
+        virtual bool isPossible()
+        {
+            return MovementAction::isPossible() &&
+                    AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.mediumHealth &&
+                    (!AI_VALUE2(uint8, "mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumMana);
+        }
+    };
+
+    class MoveToLootAction : public MovementAction
+    {
+    public:
+        MoveToLootAction(PlayerbotAI* ai) : MovementAction(ai, "move to loot") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MoveOutOfEnemyContactAction : public MovementAction
+    {
+    public:
+        MoveOutOfEnemyContactAction(PlayerbotAI* ai) : MovementAction(ai, "move out of enemy contact") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+    class SetFacingTargetAction : public MovementAction
+    {
+    public:
+        SetFacingTargetAction(PlayerbotAI* ai) : MovementAction(ai, "set facing") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp b/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
new file mode 100644
index 0000000..56961c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NonCombatActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/actions/NonCombatActions.h b/src/plugins/playerbot/strategy/actions/NonCombatActions.h
new file mode 100644
index 0000000..d66e92c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/NonCombatActions.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+#include "UseItemAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class DrinkAction : public UseItemAction
+    {
+    public:
+        DrinkAction(PlayerbotAI* ai) : UseItemAction(ai, "drink") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsInCombat())
+                return false;
+
+            return UseItemAction::Execute(event);
+        }
+
+        virtual bool isUseful()
+        {
+            return UseItemAction::isUseful() && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana;
+        }
+    };
+
+    class EatAction : public UseItemAction
+    {
+    public:
+        EatAction(PlayerbotAI* ai) : UseItemAction(ai, "food") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsInCombat())
+                return false;
+
+            return UseItemAction::Execute(event);
+        }
+
+        virtual bool isUseful()
+        {
+            return UseItemAction::isUseful() && AI_VALUE2(uint8, "health", "self target") < sPlayerbotAIConfig.lowHealth;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h b/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
new file mode 100644
index 0000000..fb558df
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class PassLeadershipToMasterAction : public Action {
+    public:
+        PassLeadershipToMasterAction(PlayerbotAI* ai) : Action(ai, "leader") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = GetMaster();
+            if (master && bot->GetGroup() && bot->GetGroup()->IsMember(master->GetGUID()))
+            {
+                WorldPacket p(SMSG_GROUP_SET_LEADER, 8);
+                p << master->GetGUID();
+                bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                return true;
+            }
+
+            return false;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/PositionAction.cpp b/src/plugins/playerbot/strategy/actions/PositionAction.cpp
new file mode 100644
index 0000000..242c7fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PositionAction.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PositionAction.h"
+#include "../values/PositionValue.h"
+
+using namespace ai;
+
+bool PositionAction::Execute(Event event)
+{
+	string qualifier = event.getParam();
+	if (qualifier.empty())
+		return false;
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+	ai::Position& pos = context->GetValue<ai::Position&>("position", qualifier)->Get();
+    pos.Set( master->GetPositionX(), master->GetPositionY(), master->GetPositionZ());
+
+    ostringstream out; out << "Position " << qualifier << " is set";
+    ai->TellMaster(out);
+    return true;
+}
+
+bool MoveToPositionAction::Execute(Event event)
+{
+	ai::Position& pos = context->GetValue<ai::Position&>("position", qualifier)->Get();
+    if (!pos.isSet())
+    {
+        ostringstream out; out << "Position " << qualifier << " is not set";
+        ai->TellMaster(out);
+        return false;
+    }
+
+    return MoveTo(bot->GetMapId(), pos.x, pos.y, pos.z);
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/PositionAction.h b/src/plugins/playerbot/strategy/actions/PositionAction.h
new file mode 100644
index 0000000..f96553b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PositionAction.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class PositionAction : public Action
+    {
+    public:
+        PositionAction(PlayerbotAI* ai) : Action(ai, "position")
+        {}
+
+        virtual bool Execute(Event event);
+
+    };
+
+    class MoveToPositionAction : public MovementAction
+    {
+    public:
+        MoveToPositionAction(PlayerbotAI* ai, string qualifier) : MovementAction(ai, "move to position"), qualifier(qualifier)
+        {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        string qualifier;
+    };
+
+    class GuardAction : public MoveToPositionAction
+    {
+    public:
+        GuardAction(PlayerbotAI* ai) : MoveToPositionAction(ai, "guard")
+        {}
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
new file mode 100644
index 0000000..4cbd973
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
@@ -0,0 +1,172 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QueryItemUsageAction.h"
+#include "../values/ItemUsageValue.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+
+using namespace ai;
+
+
+bool QueryItemUsageAction::Execute(Event event)
+{
+    WorldPacket& data = event.getPacket();
+    if (!data.empty())
+    {
+        data.rpos(0);
+
+        ObjectGuid guid;
+        data >> guid;
+        if (guid.GetRawValue() != bot->GetGUID())
+            return false;
+
+        uint32 received, created, isShowChatMessage, notUsed, itemId,
+            suffixFactor, itemRandomPropertyId, count, invCount;
+        uint8 bagSlot;
+
+        data >> received;                               // 0=looted, 1=from npc
+        data >> created;                                // 0=received, 1=created
+        data >> isShowChatMessage;                                      // IsShowChatMessage
+        data >> bagSlot;
+                                                                // item slot, but when added to stack: 0xFFFFFFFF
+        data >> notUsed;
+        data >> itemId;
+        data >> suffixFactor;
+        data >> itemRandomPropertyId;
+        data >> count;
+        data >> invCount;
+
+        ItemTemplate const *item = sObjectMgr->GetItemTemplate(itemId);
+        if (!item)
+            return false;
+
+        ostringstream out; out << chat->formatItem(item, count);
+        if (created)
+            out << " created";
+        else if (received)
+            out << " received";
+        ai->TellMaster(out);
+
+        QueryItemUsage(item);
+        QueryQuestItem(itemId);
+        return true;
+    }
+
+    string text = event.getParam();
+
+    ItemIds items = chat->parseItems(text);
+    QueryItemsUsage(items);
+    return true;
+}
+
+bool QueryItemUsageAction::QueryItemUsage(ItemTemplate const *item)
+{
+    ostringstream out; out << item->ItemId;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    switch (usage)
+    {
+    case ITEM_USAGE_EQUIP:
+        ai->TellMaster("Equip");
+        return true;
+    case ITEM_USAGE_REPLACE:
+        ai->TellMaster("Equip (replace)");
+        return true;
+    case ITEM_USAGE_SKILL:
+        ai->TellMaster("Tradeskill");
+        return true;
+    case ITEM_USAGE_USE:
+        ai->TellMaster("Use");
+        return true;
+    case ITEM_USAGE_GUILD_TASK:
+        ai->TellMaster("Guild task");
+        return true;
+    }
+
+    return false;
+}
+
+void QueryItemUsageAction::QueryItemPrice(ItemTemplate const *item)
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return;
+
+    if (item->Bonding == BIND_WHEN_PICKED_UP)
+        return;
+
+    list<Item*> items = InventoryAction::parseItems(item->Name1);
+    if (!items.empty())
+    {
+        for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+        {
+            Item* sell = *i;
+            int32 sellPrice = sell->GetCount() * auctionbot.GetSellPrice(sell->GetTemplate()) * sRandomPlayerbotMgr.GetSellMultiplier(bot);
+            ostringstream out;
+            out << "Selling " << chat->formatItem(sell->GetTemplate(), sell->GetCount()) << " for " << chat->formatMoney(sellPrice);
+            ai->TellMaster(out.str());
+        }
+    }
+
+    ostringstream out; out << item->ItemId;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    if (usage == ITEM_USAGE_NONE)
+        return;
+
+    int32 buyPrice = auctionbot.GetBuyPrice(item) * sRandomPlayerbotMgr.GetBuyMultiplier(bot);
+    if (buyPrice)
+    {
+        ostringstream out;
+        out << "Will buy for " << chat->formatMoney(buyPrice);
+        ai->TellMaster(out.str());
+    }
+}
+
+void QueryItemUsageAction::QueryItemsUsage(ItemIds items)
+{
+    for (ItemIds::iterator i = items.begin(); i != items.end(); i++)
+    {
+        ItemTemplate const *item = sObjectMgr->GetItemTemplate(*i);
+        QueryItemUsage(item);
+        QueryQuestItem(*i);
+        QueryItemPrice(item);
+    }
+}
+
+void QueryItemUsageAction::QueryQuestItem(uint32 itemId)
+{
+    Player *bot = ai->GetBot();
+    QuestStatusMap const& questMap = bot->getQuestStatusMap();
+    for (QuestStatusMap::const_iterator i = questMap.begin(); i != questMap.end(); i++)
+    {
+        const Quest *questTemplate = sObjectMgr->GetQuestTemplate( i->first );
+        if( !questTemplate )
+            continue;
+
+        uint32 questId = questTemplate->GetQuestId();
+        QuestStatus status = bot->GetQuestStatus(questId);
+        if (status == QUEST_STATUS_INCOMPLETE || (status == QUEST_STATE_COMPLETE && !bot->GetQuestRewardStatus(questId)))
+        {
+            QuestStatusData const& questStatus = i->second;
+            QueryQuestItem(itemId, questTemplate, &questStatus);
+        }
+    }
+}
+
+
+void QueryItemUsageAction::QueryQuestItem(uint32 itemId, const Quest *questTemplate, const QuestStatusData *questStatus)
+{
+    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+    {
+        if (questTemplate->RequiredItemId[i] != itemId)
+            continue;
+
+        int required = questTemplate->RequiredItemCount[i];
+        int available = questStatus->ItemCount[i];
+
+        if (!required)
+            continue;
+
+        ai->TellMaster(chat->formatQuestObjective(chat->formatQuest(questTemplate), available, required));
+    }
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
new file mode 100644
index 0000000..643ae96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class QueryItemUsageAction : public InventoryAction {
+    public:
+        QueryItemUsageAction(PlayerbotAI* ai, string name = "query item usage") : InventoryAction(ai, name) {}
+        virtual bool Execute(Event event);
+
+    protected:
+        void QueryItemsUsage(ItemIds items);
+        bool QueryItemUsage(ItemTemplate const *item);
+        void QueryItemPrice(ItemTemplate const *item);
+        void QueryQuestItem(uint32 itemId, const Quest *questTemplate, const QuestStatusData *questStatus);
+        void QueryQuestItem(uint32 itemId);
+
+    private:
+        ostringstream out;
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp b/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
new file mode 100644
index 0000000..33eddca
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
@@ -0,0 +1,89 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QueryQuestAction.h"
+
+
+using namespace ai;
+
+void QueryQuestAction::TellObjective(string name, int available, int required)
+{
+    ai->TellMaster(chat->formatQuestObjective(name, available, required));
+}
+
+
+bool QueryQuestAction::Execute(Event event)
+{
+
+    Player *bot = ai->GetBot();
+    string text = event.getParam();
+
+    PlayerbotChatHandler ch(bot);
+    uint32 questId = ch.extractQuestId(text);
+    if (!questId)
+        return false;
+
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        if(questId != bot->GetQuestSlotQuestId(slot))
+            continue;
+
+        ostringstream out;
+        out << "--- " << chat->formatQuest(sObjectMgr->GetQuestTemplate(questId)) << " ";
+        if (bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+        {
+            out << "|c0000FF00completed|r ---";
+            ai->TellMaster(out);
+        }
+        else
+        {
+            out << "|c00FF0000not completed|r ---";
+            ai->TellMaster(out);
+            TellObjectives(questId);
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+void QueryQuestAction::TellObjectives(uint32 questId)
+{
+    Quest const* questTemplate = sObjectMgr->GetQuestTemplate(questId);
+    QuestStatusMap &questMap = bot->getQuestStatusMap();
+    QuestStatusData questStatus = questMap[questId];
+
+    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+    {
+        if (!questTemplate->ObjectiveText[i].empty())
+            ai->TellMaster(questTemplate->ObjectiveText[i]);
+
+        if (questTemplate->RequiredItemId[i])
+        {
+            int required = questTemplate->RequiredItemCount[i];
+            int available = questStatus.ItemCount[i];
+            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(questTemplate->RequiredItemId[i]);
+            TellObjective(chat->formatItem(proto), available, required);
+        }
+
+        if (questTemplate->RequiredNpcOrGo[i])
+        {
+            int required = questTemplate->RequiredNpcOrGoCount[i];
+            int available = questStatus.CreatureOrGOCount[i];
+
+            if (questTemplate->RequiredNpcOrGo[i] < 0)
+            {
+                GameObjectTemplate const* info = sObjectMgr->GetGameObjectTemplate(questTemplate->RequiredNpcOrGo[i]);
+                if (info)
+                    TellObjective(info->name, available, required);
+            }
+            else
+            {
+
+                CreatureTemplate const* info = sObjectMgr->GetCreatureTemplate(questTemplate->RequiredNpcOrGo[i]);
+                if (info)
+                    TellObjective(info->Name, available, required);
+            }
+        }
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryQuestAction.h b/src/plugins/playerbot/strategy/actions/QueryQuestAction.h
new file mode 100644
index 0000000..1822293
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryQuestAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class QueryQuestAction : public Action {
+    public:
+        QueryQuestAction(PlayerbotAI* ai) : Action(ai, "query quest") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void TellObjectives(uint32 questId);
+        void TellObjective(string name, int available, int required);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/QuestAction.cpp b/src/plugins/playerbot/strategy/actions/QuestAction.cpp
new file mode 100644
index 0000000..2b1cfbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QuestAction.cpp
@@ -0,0 +1,137 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QuestAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool QuestAction::Execute(Event event)
+{
+    ObjectGuid guid = event.getObject();
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!guid)
+    {
+        Unit* target = master->GetSelectedUnit();
+        if (target)
+            guid = target->GetGUID();
+    }
+
+    if (!guid)
+        return false;
+
+    return ProcessQuests(guid);
+}
+
+bool QuestAction::ProcessQuests(ObjectGuid questGiver)
+{
+    GameObject *gameObject = ai->GetGameObject(questGiver);
+    if (gameObject && gameObject->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+        return ProcessQuests(gameObject);
+
+    Creature* creature = ai->GetCreature(questGiver);
+    if (creature)
+        return ProcessQuests(creature);
+
+    return false;
+}
+
+bool QuestAction::ProcessQuests(WorldObject* questGiver)
+{
+    ObjectGuid guid = questGiver->GetGUID();
+
+    if (bot->GetDistance(questGiver) > INTERACTION_DISTANCE)
+    {
+        ai->TellMaster("Cannot talk to quest giver");
+        return false;
+    }
+
+    if (!bot->isInFront(questGiver, M_PI / 2))
+        bot->SetFacingTo(bot->GetAngle(questGiver));
+
+    bot->SetSelection(guid);
+    bot->PrepareQuestMenu(guid);
+    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+    for (uint32 i = 0; i < questMenu.GetMenuItemCount(); ++i)
+    {
+        QuestMenuItem const& menuItem = questMenu.GetItem(i);
+        uint32 questID = menuItem.QuestId;
+        Quest const* quest = sObjectMgr->GetQuestTemplate(questID);
+        if (!quest)
+            continue;
+
+        ProcessQuest(quest, questGiver);
+    }
+
+    return true;
+}
+
+bool QuestAction::AcceptQuest(Quest const* quest, uint64 questGiver)
+{
+    std::ostringstream out;
+
+    uint32 questId = quest->GetQuestId();
+
+    if (bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+        out << "Already completed";
+    else if (! bot->CanTakeQuest(quest, false))
+    {
+        if (! bot->SatisfyQuestStatus(quest, false))
+            out << "Already on";
+        else
+            out << "Can't take";
+    }
+    else if (! bot->SatisfyQuestLog(false))
+        out << "Quest log is full";
+    else if (! bot->CanAddQuest(quest, false))
+        out << "Bags are full";
+
+    else
+    {
+        WorldPacket p(CMSG_QUESTGIVER_ACCEPT_QUEST);
+        uint32 unk1 = 0;
+        p << questGiver << questId << unk1;
+        p.rpos(0);
+        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+
+        if (bot->GetQuestStatus(questId) != QUEST_STATUS_NONE)
+        {
+            out << "Accepted " << chat->formatQuest(quest);
+            ai->TellMaster(out);
+            return true;
+        }
+    }
+
+    out << " " << chat->formatQuest(quest);
+    ai->TellMaster(out);
+    return false;
+}
+
+bool QuestObjectiveCompletedAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+
+    uint32 entry, questId, available, required;
+    ObjectGuid guid;
+    p >> questId >> entry >> available >> required >> guid;
+
+    if (entry & 0x80000000)
+    {
+        entry &= 0x7FFFFFFF;
+        GameObjectTemplate const* info = sObjectMgr->GetGameObjectTemplate(entry);
+        if (info)
+            ai->TellMaster(chat->formatQuestObjective(info->name, available, required));
+    }
+    else
+    {
+        CreatureTemplate const* info = sObjectMgr->GetCreatureTemplate(entry);
+        if (info)
+            ai->TellMaster(chat->formatQuestObjective(info->Name, available, required));
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/QuestAction.h b/src/plugins/playerbot/strategy/actions/QuestAction.h
new file mode 100644
index 0000000..97010ed
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QuestAction.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../../Quests/QuestDef.h"
+
+namespace ai
+{
+    class QuestAction : public Action
+    {
+    public:
+        QuestAction(PlayerbotAI* ai, string name) : Action(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver) = 0;
+
+    protected:
+        bool AcceptQuest(Quest const* quest, uint64 questGiver);
+        bool ProcessQuests(ObjectGuid questGiver);
+        bool ProcessQuests(WorldObject* questGiver);
+    };
+
+    class QuestObjectiveCompletedAction : public Action
+    {
+    public:
+        QuestObjectiveCompletedAction(PlayerbotAI* ai) : Action(ai, "quest objective completed") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReachTargetActions.h b/src/plugins/playerbot/strategy/actions/ReachTargetActions.h
new file mode 100644
index 0000000..2640969
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReachTargetActions.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class ReachTargetAction : public MovementAction
+    {
+    public:
+        ReachTargetAction(PlayerbotAI* ai, string name, float distance) : MovementAction(ai, name)
+		{
+            this->distance = distance;
+        }
+        virtual bool Execute(Event event)
+		{
+			return MoveTo(AI_VALUE(Unit*, "current target"), distance);
+        }
+        virtual bool isUseful()
+		{
+            return AI_VALUE2(float, "distance", "current target") > (distance + sPlayerbotAIConfig.contactDistance);
+        }
+        virtual string GetTargetName() { return "current target"; }
+
+    protected:
+        float distance;
+    };
+
+    class CastReachTargetSpellAction : public CastSpellAction
+    {
+    public:
+        CastReachTargetSpellAction(PlayerbotAI* ai, string spell, float distance) : CastSpellAction(ai, spell)
+		{
+            this->distance = distance;
+        }
+		virtual bool isUseful()
+		{
+			return AI_VALUE2(float, "distance", "current target") > (distance + sPlayerbotAIConfig.contactDistance);
+		}
+
+    protected:
+        float distance;
+    };
+
+    class ReachMeleeAction : public ReachTargetAction
+	{
+    public:
+        ReachMeleeAction(PlayerbotAI* ai) : ReachTargetAction(ai, "reach melee", sPlayerbotAIConfig.meleeDistance) {}
+    };
+
+    class ReachSpellAction : public ReachTargetAction
+	{
+    public:
+        ReachSpellAction(PlayerbotAI* ai, float distance = sPlayerbotAIConfig.spellDistance) : ReachTargetAction(ai, "reach spell", distance) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
new file mode 100644
index 0000000..98f8c4b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
@@ -0,0 +1,84 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ReadyCheckAction.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+bool ReadyCheckAction::Execute(Event event)
+{
+    WorldPacket &p = event.getPacket();
+	ObjectGuid player;
+	p.rpos(0);
+    if (!p.empty())
+        p >> player;
+
+	if (player.GetRawValue() == bot->GetGUID())
+        return false;
+
+	return ReadyCheck();
+}
+
+bool ReadyCheckAction::ReadyCheck()
+{
+    bool health = AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.almostFullHealth;
+    if (!health)
+    {
+        ai->TellMaster("Low health!");
+        return false;
+    }
+
+    bool mana = !AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumHealth;
+    if (!mana)
+    {
+        ai->TellMaster("Low mana!");
+        return false;
+    }
+
+    Player* master = GetMaster();
+    if (master)
+    {
+        bool distance = bot->GetDistance(master) <= sPlayerbotAIConfig.sightDistance;
+        if (!distance)
+        {
+            ai->TellMaster("Too far away!");
+            return false;
+        }
+    }
+
+    if (bot->getClass() == CLASS_HUNTER)
+    {
+        if (!bot->GetUInt32Value(PLAYER_AMMO_ID))
+        {
+            ai->TellMaster("Out of ammo!");
+            return false;
+        }
+
+        if (!bot->GetPet())
+        {
+            ai->TellMaster("No pet!");
+            return false;
+        }
+
+        if (bot->GetPet()->GetHappinessState() == UNHAPPY)
+        {
+            ai->TellMaster("Pet is unhappy!");
+            return false;
+        }
+    }
+
+    WorldPacket* const packet = new WorldPacket(MSG_RAID_READY_CHECK);
+    *packet << bot->GetGUID();
+    *packet << uint8(1);
+    bot->GetSession()->QueuePacket(packet);
+
+    ai->ChangeStrategy("-ready check", BOT_STATE_NON_COMBAT);
+
+    return true;
+}
+
+bool FinishReadyCheckAction::Execute(Event event)
+{
+    return ReadyCheck();
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
new file mode 100644
index 0000000..0e26b61
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class ReadyCheckAction : public Action
+    {
+    public:
+        ReadyCheckAction(PlayerbotAI* ai, string name = "ready check") : Action(ai, name) {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        bool ReadyCheck();
+    };
+
+    class FinishReadyCheckAction : public ReadyCheckAction
+    {
+    public:
+        FinishReadyCheckAction(PlayerbotAI* ai) : ReadyCheckAction(ai, "finish ready check") {}
+
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h b/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
new file mode 100644
index 0000000..47ce1e5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+	class ReleaseSpiritAction : public Action {
+	public:
+		ReleaseSpiritAction(PlayerbotAI* ai) : Action(ai, "release") {}
+
+    public:
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsAlive() || bot->GetCorpse())
+                return false;
+
+            ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+            bot->SetBotDeathTimer();
+            bot->BuildPlayerRepop();
+
+            bot->RepopAtGraveyard();
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
new file mode 100644
index 0000000..7b17096
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
@@ -0,0 +1,46 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RememberTaxiAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool RememberTaxiAction::Execute(Event event)
+{
+    
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+
+    switch (p.GetOpcode())
+    {
+    case CMSG_ACTIVATETAXI:
+        {
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            movement.taxiNodes.clear();
+            movement.taxiNodes.resize(2);
+
+            p >> movement.taxiMaster >> movement.taxiNodes[0] >> movement.taxiNodes[1];
+            return true;
+        }
+    case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            ObjectGuid guid;
+            uint32 node_count;
+            p >> guid >> node_count;
+
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            movement.taxiNodes.clear();
+            for (uint32 i = 0; i < node_count; ++i)
+            {
+                uint32 node;
+                p >> node;
+                movement.taxiNodes.push_back(node);
+            }
+
+            return true;
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
new file mode 100644
index 0000000..16c1f07
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+	class RememberTaxiAction : public Action {
+	public:
+		RememberTaxiAction(PlayerbotAI* ai) : Action(ai, "remember taxi") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp b/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
new file mode 100644
index 0000000..7104792
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
@@ -0,0 +1,30 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RepairAllAction.h"
+
+
+using namespace ai;
+
+bool RepairAllAction::Execute(Event event)
+{
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Creature *unit = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_REPAIR);
+        if (!unit)
+            continue;
+
+        bot->SetFacingToObject(unit);
+        float discountMod = bot->GetReputationPriceDiscount(unit);
+        uint32 totalCost = bot->DurabilityRepairAll(true, discountMod, false);
+
+        ostringstream out;
+        out << "Repair: " << chat->formatMoney(totalCost) << " (" << unit->GetName() << ")";
+        ai->TellMasterNoFacing(out.str());
+
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any npc to repair at");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RepairAllAction.h b/src/plugins/playerbot/strategy/actions/RepairAllAction.h
new file mode 100644
index 0000000..33c7abf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RepairAllAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class RepairAllAction : public Action 
+    {
+    public:
+        RepairAllAction(PlayerbotAI* ai) : Action(ai, "repair") {}
+        virtual bool Execute(Event event);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp b/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
new file mode 100644
index 0000000..995f241
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ResetAiAction.h"
+
+using namespace ai;
+
+bool ResetAiAction::Execute(Event event)
+{
+    ai->ResetStrategies();
+    ai->TellMaster("AI was reset to defaults");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ResetAiAction.h b/src/plugins/playerbot/strategy/actions/ResetAiAction.h
new file mode 100644
index 0000000..929abcb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ResetAiAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class ResetAiAction : public Action {
+    public:
+        ResetAiAction(PlayerbotAI* ai) : Action(ai, "reset ai") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
new file mode 100644
index 0000000..88e4a23
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ReviveFromCorpseAction.h"
+#include "../../PlayerbotFactory.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool ReviveFromCorpseAction::Execute(Event event)
+{
+    Corpse* corpse = bot->GetCorpse();
+    if (!corpse)
+        return false;
+
+    time_t reclaimTime = corpse->GetGhostTime() + bot->GetCorpseReclaimDelay( corpse->GetType()==CORPSE_RESURRECTABLE_PVP );
+    if (reclaimTime > time(0) || corpse->GetDistance(bot) > sPlayerbotAIConfig.spellDistance)
+        return false;
+
+    bot->ResurrectPlayer(0.5f);
+    bot->SpawnCorpseBones();
+    bot->SaveToDB();
+    context->GetValue<Unit*>("current target")->Set(NULL);
+    bot->SetSelection(ObjectGuid::Empty);
+    return true;
+}
+
+bool SpiritHealerAction::Execute(Event event)
+{
+    Corpse* corpse = bot->GetCorpse();
+    if (!corpse)
+        return false;
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (unit && unit->IsSpiritHealer())
+        {
+            PlayerbotChatHandler ch(bot);
+            bot->ResurrectPlayer(0.5f);
+            bot->SpawnCorpseBones();
+            bot->SaveToDB();
+            context->GetValue<Unit*>("current target")->Set(NULL);
+            bot->SetSelection(ObjectGuid::Empty);
+            return true;
+        }
+    }
+
+    ai->TellMaster("Cannot find any spirit healer nearby");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
new file mode 100644
index 0000000..0e3a8cb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+	class ReviveFromCorpseAction : public Action {
+	public:
+		ReviveFromCorpseAction(PlayerbotAI* ai) : Action(ai, "revive") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+	class SpiritHealerAction : public Action {
+	public:
+	    SpiritHealerAction(PlayerbotAI* ai) : Action(ai, "spirit healer") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/RewardAction.cpp b/src/plugins/playerbot/strategy/actions/RewardAction.cpp
new file mode 100644
index 0000000..c85db71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RewardAction.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RewardAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool RewardAction::Execute(Event event)
+{
+    string link = event.getParam();
+
+    ItemIds itemIds = chat->parseItems(link);
+    if (itemIds.empty())
+        return false;
+
+    uint32 itemId = *itemIds.begin();
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* npc = ai->GetUnit(*i);
+        if (npc && Reward(itemId, npc))
+            return true;
+    }
+
+    list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (go && Reward(itemId, go))
+            return true;
+    }
+
+    ai->TellMaster("Cannot talk to quest giver");
+    return false;
+}
+
+bool RewardAction::Reward(uint32 itemId, Object* questGiver)
+{
+    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+    {
+        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+        uint32 questID = qItem.QuestId;
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+        QuestStatus status = bot->GetQuestStatus(questID);
+
+        // if quest is complete, turn it in
+        if (status == QUEST_STATUS_COMPLETE &&
+            ! bot->GetQuestRewardStatus(questID) &&
+            pQuest->GetRewChoiceItemsCount() > 1 &&
+            bot->CanRewardQuest(pQuest, false))
+        {
+            for (uint8 rewardIdx=0; rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+            {
+                ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                if (itemId == pRewardItem->ItemId)
+                {
+                    bot->RewardQuest(pQuest, rewardIdx, questGiver, false);
+
+                    string questTitle  = pQuest->GetTitle();
+                    string itemName = pRewardItem->Name1;
+
+                    ostringstream out; out << chat->formatItem(pRewardItem) << " rewarded";
+                    ai->TellMaster(out);
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RewardAction.h b/src/plugins/playerbot/strategy/actions/RewardAction.h
new file mode 100644
index 0000000..f4eda13
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RewardAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class RewardAction : public InventoryAction {
+    public:
+        RewardAction(PlayerbotAI* ai) : InventoryAction(ai, "reward") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Reward(uint32 itemId, Object* pNpc);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/RtiAction.h b/src/plugins/playerbot/strategy/actions/RtiAction.h
new file mode 100644
index 0000000..f0cca94
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RtiAction.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class RtiAction : public Action
+    {
+    public:
+        RtiAction(PlayerbotAI* ai) : Action(ai, "rti")
+        {}
+
+        virtual bool Execute(Event event)
+        {
+            string text = event.getParam();
+            if (text.empty() || text == "?")
+            {
+                ostringstream out; out << "RTI: ";
+                AppendRti(out);
+                ai->TellMaster(out);
+                return true;
+            }
+
+            context->GetValue<string>("rti")->Set(text);
+            ostringstream out; out << "RTI set to: ";
+            AppendRti(out);
+            ai->TellMaster(out);
+            return true;
+        }
+
+    private:
+        void AppendRti(ostringstream & out)
+        {
+            out << AI_VALUE(string, "rti");
+
+            Unit* target = AI_VALUE(Unit*, "rti target");
+            if(target)
+                out << " (" << target->GetName() << ")";
+
+        }
+
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp b/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
new file mode 100644
index 0000000..c5d56a8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SaveManaAction.h"
+#include "../../AiFactory.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+bool SaveManaAction::Execute(Event event)
+{
+    string text = event.getParam();
+    double value = AI_VALUE(double, "mana save level");
+
+    if (text == "?")
+    {
+        ostringstream out; out << "Mana save level: " << format(value);
+        ai->TellMaster(out);
+        return true;
+    }
+
+    if (text == "*")
+    {
+        switch (bot->getClass())
+        {
+        case CLASS_HUNTER:
+        case CLASS_SHAMAN:
+        case CLASS_DRUID:
+            value = 5.0;
+            break;
+        case CLASS_MAGE:
+        case CLASS_PRIEST:
+        case CLASS_WARLOCK:
+            value = 2.0;
+            break;
+        default:
+            value = 3.0;
+        }
+    }
+    else if (text.empty())
+    {
+        value = 1.0;
+    }
+    else
+    {
+        value = atof(text.c_str());
+    }
+
+    value = min(10.0, value);
+    value = max(1.0, value);
+    value = floor(value * 100 + 0.5) / 100.0;
+
+    ai->GetAiObjectContext()->GetValue<double>("mana save level")->Set(value);
+
+    ostringstream out; out << "Mana save level set: " << format(value);
+    ai->TellMaster(out);
+
+    return true;
+}
+
+string SaveManaAction::format(double value)
+{
+    ostringstream out;
+    if (value <= 1.0)
+        out << "|cFF808080";
+    else if (value <= 5.0)
+        out << "|cFF00FF00";
+    else if (value <= 7.0)
+        out << "|cFFFFFF00";
+    else
+        out << "|cFFFF0000";
+    out << value << "|cffffffff";
+    return out.str();
+}
diff --git a/src/plugins/playerbot/strategy/actions/SaveManaAction.h b/src/plugins/playerbot/strategy/actions/SaveManaAction.h
new file mode 100644
index 0000000..3d9b3e0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SaveManaAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SaveManaAction : public Action
+    {
+    public:
+        SaveManaAction(PlayerbotAI* ai) : Action(ai, "save mana") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    private:
+        string format(double value);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SayAction.cpp b/src/plugins/playerbot/strategy/actions/SayAction.cpp
new file mode 100644
index 0000000..734df8b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SayAction.cpp
@@ -0,0 +1,102 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SayAction.h"
+
+using namespace ai;
+
+map<string, vector<string> > SayAction::stringTable;
+map<string, uint32 > SayAction::probabilityTable;
+
+SayAction::SayAction(PlayerbotAI* ai) : Action(ai, "say"), Qualified()
+{
+}
+
+void replaceAll(std::string& str, const std::string& from, const std::string& to) {
+    if(from.empty())
+        return;
+    size_t start_pos = 0;
+    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
+        str.replace(start_pos, from.length(), to);
+        start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
+    }
+}
+
+bool SayAction::Execute(Event event)
+{
+	if (stringTable.empty())
+	{
+		QueryResult results = CharacterDatabase.PQuery("SELECT name, text, type FROM ai_playerbot_speech");
+		if (results)
+		{
+            do
+            {
+                Field* fields = results->Fetch();
+                string name = fields[0].GetCString();
+                string text = fields[1].GetCString();
+                string type = fields[2].GetCString();
+
+                if (type == "yell") text = "/y " + text;
+                stringTable[name].push_back(text);
+            } while (results->NextRow());
+		}
+	}
+	if (probabilityTable.empty())
+	{
+        QueryResult results = CharacterDatabase.PQuery("SELECT name, probability FROM ai_playerbot_speech_probability");
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                string name = fields[0].GetCString();
+                uint32 probability = fields[1].GetUInt32();
+
+                probabilityTable[name] = probability;
+            } while (results->NextRow());
+        }
+	}
+
+    vector<string> &strings = stringTable[qualifier];
+    if (strings.empty()) return false;
+
+    time_t lastSaid = AI_VALUE2(time_t, "last said", qualifier);
+    ai->GetAiObjectContext()->GetValue<time_t>("last said", qualifier)->Set(time(0) + urand(1, 60));
+
+    uint32 probability = probabilityTable[qualifier];
+    if (!probability) probability = 100;
+    if (urand(0, 100) >= probability) return false;
+
+    uint32 idx = urand(0, strings.size() - 1);
+    string text = strings[idx];
+
+    Unit* target = AI_VALUE(Unit*, "tank target");
+    if (!target) target = AI_VALUE(Unit*, "current target");
+    if (target) replaceAll(text, "<target>", target->GetName());
+
+    replaceAll(text, "<randomfaction>", IsAlliance(bot->getRace()) ? "Alliance" : "Horde");
+
+    if (bot->GetMap())
+    {
+        uint32 areaId = bot->GetMap()->GetAreaId(bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ());
+        if (areaId)
+        {
+			AreaTableEntry const* area = sAreaTableStore.LookupEntry(areaId);
+            if (area)
+            {
+                replaceAll(text, "<subzone>", area->area_name[0]);
+            }
+        }
+    }
+
+    if (text.find("/y ") == 0)
+        bot->Yell(text.substr(3), LANG_UNIVERSAL);
+    else
+        bot->Say(text, LANG_UNIVERSAL);
+}
+
+
+bool SayAction::isUseful()
+{
+    time_t lastSaid = AI_VALUE2(time_t, "last said", qualifier);
+    return (time(0) - lastSaid) > 30;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SayAction.h b/src/plugins/playerbot/strategy/actions/SayAction.h
new file mode 100644
index 0000000..7caad21
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SayAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class SayAction : public Action, public Qualified
+    {
+    public:
+        SayAction(PlayerbotAI* ai);
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+        virtual string getName() { return "say::" + qualifier; }
+
+    private:
+        static map<string, vector<string> > stringTable;
+        static map<string, uint32 > probabilityTable;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
new file mode 100644
index 0000000..891b03c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "SecurityCheckAction.h"
+#include "../../../Groups/Group.h"
+
+using namespace ai;
+
+
+bool SecurityCheckAction::isUseful()
+{
+    return sRandomPlayerbotMgr.IsRandomBot(bot) && ai->GetMaster() && ai->GetMaster()->GetSession()->GetSecurity() < SEC_GAMEMASTER;
+}
+
+bool SecurityCheckAction::Execute(Event event)
+{
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        LootMethod method = group->GetLootMethod();
+        ItemQualities threshold = group->GetLootThreshold();
+        if (method == MASTER_LOOT || method == FREE_FOR_ALL || threshold > ITEM_QUALITY_UNCOMMON)
+        {
+            ai->TellMaster("I won't do anything until you change loot type to group loot with green threshold");
+            ai->ChangeStrategy("+passive,+stay", BOT_STATE_NON_COMBAT);
+            ai->ChangeStrategy("+passive,+stay", BOT_STATE_COMBAT);
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
new file mode 100644
index 0000000..4ae38f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class SecurityCheckAction : public Action
+    {
+    public:
+        SecurityCheckAction(PlayerbotAI* ai) : Action(ai, "security check") {}
+        virtual bool isUseful();
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/SellAction.cpp b/src/plugins/playerbot/strategy/actions/SellAction.cpp
new file mode 100644
index 0000000..1af725c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SellAction.cpp
@@ -0,0 +1,95 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SellAction.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+class SellItemsVisitor : public IterateItemsVisitor
+{
+public:
+    SellItemsVisitor(SellAction* action) : IterateItemsVisitor()
+    {
+        this->action = action;
+    }
+
+    virtual bool Visit(Item* item)
+    {
+        action->Sell(item);
+        return true;
+    }
+
+private:
+    SellAction* action;
+};
+
+class SellGrayItemsVisitor : public SellItemsVisitor
+{
+public:
+    SellGrayItemsVisitor(SellAction* action) : SellItemsVisitor(action) {}
+
+    virtual bool Visit(Item* item)
+    {
+        if (item->GetTemplate()->Quality != ITEM_QUALITY_POOR)
+            return true;
+
+        return SellItemsVisitor::Visit(item);
+    }
+};
+
+
+bool SellAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    string text = event.getParam();
+
+    if (text == "gray" || text == "*")
+    {
+        SellGrayItemsVisitor visitor(this);
+        IterateItems(&visitor);
+        return true;
+    }
+
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        Sell(&visitor);
+    }
+
+    return true;
+}
+
+
+void SellAction::Sell(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+        Sell(*i);
+}
+
+void SellAction::Sell(Item* item)
+{
+    Player* master = GetMaster();
+    Unit* vendor = master->GetSelectedUnit();
+    if (!vendor)
+    {
+        ai->TellMaster("Select a vendor first");
+        return;
+    }
+
+    ObjectGuid itemguid = item->GetGUID();
+    uint32 count = item->GetCount();
+
+    WorldPacket p;
+    p << vendor->GetGUID() << itemguid << count;
+    bot->GetSession()->HandleSellItemOpcode(p);
+
+    ostringstream out; out << chat->formatItem(item->GetTemplate()) << " sold";
+    ai->TellMaster(out);
+}
diff --git a/src/plugins/playerbot/strategy/actions/SellAction.h b/src/plugins/playerbot/strategy/actions/SellAction.h
new file mode 100644
index 0000000..c1f0915
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SellAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SellAction : public InventoryAction {
+    public:
+        SellAction(PlayerbotAI* ai) : InventoryAction(ai, "sell") {}
+        virtual bool Execute(Event event);
+
+        void Sell(FindItemVisitor* visitor);
+        void Sell(Item* item);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp b/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
new file mode 100644
index 0000000..1b2d22f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SetHomeAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+
+using namespace ai;
+
+bool SetHomeAction::Execute(Event event)
+{
+    Player* master = ai->GetMaster();
+    if (!master)
+        return false;
+
+    Unit* unit = master->GetSelectedUnit();
+    if (unit && unit->IsInnkeeper())
+    {
+        float angle = GetFollowAngle();
+        float x = unit->GetPositionX() + sPlayerbotAIConfig.followDistance * cos(angle);
+        float y = unit->GetPositionY() + sPlayerbotAIConfig.followDistance * sin(angle);
+        float z = unit->GetPositionZ();
+        WorldLocation loc(unit->GetMapId(), x, y, z);
+        bot->SetHomebind(loc, unit->GetAreaId());
+        ai->TellMaster("This inn is my new home");
+        return true;
+    }
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Creature *unit = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_INNKEEPER);
+        if (!unit)
+            continue;
+
+        bot->GetSession()->SendBindPoint(unit);
+        ai->TellMaster("This inn is my new home");
+        return true;
+    }
+
+    ai->TellMaster("Can't find any innkeeper around");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SetHomeAction.h b/src/plugins/playerbot/strategy/actions/SetHomeAction.h
new file mode 100644
index 0000000..b98a5b5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SetHomeAction.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "MovementActions.h"
+
+namespace ai
+{
+    class SetHomeAction : public MovementAction {
+    public:
+        SetHomeAction(PlayerbotAI* ai) : MovementAction(ai, "home") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/StatsAction.cpp b/src/plugins/playerbot/strategy/actions/StatsAction.cpp
new file mode 100644
index 0000000..50f6669
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StatsAction.cpp
@@ -0,0 +1,145 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StatsAction.h"
+
+
+using namespace ai;
+
+bool StatsAction::Execute(Event event)
+{
+    ostringstream out;
+
+    ListGold(out);
+
+    out << ", ";
+    ListBagSlots(out);
+
+    out << ", ";
+    ListRepairCost(out);
+
+    if (bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP))
+    {
+        out << ", ";
+        ListXP(out);
+    }
+
+    ai->TellMaster(out);
+    return true;
+}
+
+void StatsAction::ListGold(ostringstream &out)
+{
+    out << chat->formatMoney(bot->GetMoney());
+}
+
+void StatsAction::ListBagSlots(ostringstream &out)
+{
+    uint32 totalused = 0, total = 16;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+            {
+                total += pBag->GetBagSize();
+                totalfree += pBag->GetFreeSlots();
+            }
+        }
+
+    }
+
+	string color = "ff00ff00";
+	if (totalfree < total / 2)
+		color = "ffffff00";
+	if (totalfree < total / 4)
+		color = "ffff0000";
+    out << "|h|c" << color << (total - totalfree) << "/" << total << "|h|cffffffff Bag";
+}
+
+void StatsAction::ListXP( ostringstream &out )
+{
+    uint32 curXP = bot->GetUInt32Value(PLAYER_XP);
+    uint32 nextLevelXP = bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+    uint32 xpPercent = 0;
+    if (nextLevelXP)
+        xpPercent = 100 * curXP / nextLevelXP;
+
+    out << "|r|cff00ff00" << xpPercent << "|r|cffffd333%" << "|h|cffffffff XP";
+}
+
+void StatsAction::ListRepairCost(ostringstream &out)
+{
+    out << chat->formatMoney(EstRepairAll()) << " Repair";
+}
+
+uint32 StatsAction::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for(int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(( (INVENTORY_SLOT_BAG_0 << 8) | i ));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for(int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for(int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(( (j << 8) | i ));
+    return TotalCost;
+}
+
+uint32 StatsAction::EstRepair(uint16 pos)
+{
+    Item* item = bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if(!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if(!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if(LostDurability>0)
+    {
+        ItemTemplate const *ditemProto = item->GetTemplate();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if(!dcost)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality+1)*2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if(!dQualitymodEntry)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class,ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability*dmultiplier*double(dQualitymodEntry->quality_mod));
+
+        if (costs==0)                                   //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
diff --git a/src/plugins/playerbot/strategy/actions/StatsAction.h b/src/plugins/playerbot/strategy/actions/StatsAction.h
new file mode 100644
index 0000000..e30558c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StatsAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class StatsAction : public Action {
+    public:
+        StatsAction(PlayerbotAI* ai) : Action(ai, "stats") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ListBagSlots(ostringstream &out);
+        void ListXP(ostringstream &out);
+        void ListRepairCost(ostringstream &out);
+        void ListGold(ostringstream &out);
+        uint32 EstRepairAll();
+        uint32 EstRepair(uint16 pos);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/StayActions.cpp b/src/plugins/playerbot/strategy/actions/StayActions.cpp
new file mode 100644
index 0000000..32ebd0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StayActions.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StayActions.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+void StayActionBase::Stay()
+{
+    AI_VALUE(LastMovement&, "last movement").Set(NULL);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    if (mm.GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE || bot->IsFlying())
+        return;
+
+    mm.Clear();
+    mm.MoveIdle();
+    bot->ClearUnitState( UNIT_STATE_ALL_STATE_SUPPORTED );
+
+    if (!bot->IsStandState())
+        bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+bool StayAction::Execute(Event event)
+{
+    Stay();
+
+    return true;
+}
+
+bool StayAction::isUseful()
+{
+    return !AI_VALUE2(bool, "moving", "self target");
+}
diff --git a/src/plugins/playerbot/strategy/actions/StayActions.h b/src/plugins/playerbot/strategy/actions/StayActions.h
new file mode 100644
index 0000000..ccbe2e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StayActions.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class StayActionBase : public MovementAction {
+    public:
+        StayActionBase(PlayerbotAI* ai, string name) : MovementAction(ai, name) {}
+
+    protected:
+        void Stay();
+    };
+
+    class StayAction : public StayActionBase {
+    public:
+        StayAction(PlayerbotAI* ai) : StayActionBase(ai, "stay") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
new file mode 100644
index 0000000..3f46f77
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
@@ -0,0 +1,255 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SuggestWhatToDoAction.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+SuggestWhatToDoAction::SuggestWhatToDoAction(PlayerbotAI* ai) : InventoryAction(ai, "suggest what to do"), suggested(false)
+{
+    suggestions.push_back(&SuggestWhatToDoAction::instance);
+    suggestions.push_back(&SuggestWhatToDoAction::specificQuest);
+    suggestions.push_back(&SuggestWhatToDoAction::newQuest);
+    suggestions.push_back(&SuggestWhatToDoAction::grindMaterials);
+    suggestions.push_back(&SuggestWhatToDoAction::trade);
+    suggestions.push_back(&SuggestWhatToDoAction::grindReputation);
+    suggestions.push_back(&SuggestWhatToDoAction::nothing);
+    suggestions.push_back(&SuggestWhatToDoAction::relax);
+    suggestions.push_back(&SuggestWhatToDoAction::achievement);
+}
+
+bool SuggestWhatToDoAction::Execute(Event event)
+{
+    if (suggested)
+    {
+        trade();
+        return true;
+    }
+
+    if (bot->GetInstanceId() || suggested)
+        return false;
+
+    int index = rand() % suggestions.size();
+    (this->*suggestions[index])();
+
+    return suggested = true;
+}
+
+void SuggestWhatToDoAction::instance()
+{
+    uint32 level = bot->getLevel();
+    if (level > 15)
+    {
+        switch (urand(0, 5))
+        {
+        case 0:
+            spam("Need a tank for an instance run");
+            break;
+        case 1:
+            spam("Need a healer for an instance run");
+            break;
+        case 2:
+            spam("I would like to do an instance run. Would you like to join me?");
+            break;
+        case 3:
+            spam("Need better equipment. Why not do an instance run?");
+            break;
+        case 4:
+            spam("Have dungeon quests? Can join your group!");
+            break;
+        case 5:
+            spam("Have group quests? Invite me!");
+            break;
+        default:
+            spam("Hey, why not join Dungeon Finder?");
+        }
+    }
+}
+
+vector<uint32> SuggestWhatToDoAction::GetIncompletedQuests()
+{
+    vector<uint32> result;
+
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 questId = bot->GetQuestSlotQuestId(slot);
+        if (!questId)
+            continue;
+
+        QuestStatus status = bot->GetQuestStatus(questId);
+        if (status == QUEST_STATUS_INCOMPLETE || status == QUEST_STATUS_NONE)
+            result.push_back(questId);
+    }
+
+    return result;
+}
+
+void SuggestWhatToDoAction::specificQuest()
+{
+    vector<uint32> quests = GetIncompletedQuests();
+    if (quests.empty())
+        return;
+
+    int index = rand() % quests.size();
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(quests[index]);
+    ostringstream out; out << "We could do some quest, for instance " << chat->formatQuest(quest);
+    spam(out.str());
+}
+
+void SuggestWhatToDoAction::newQuest()
+{
+    vector<uint32> quests = GetIncompletedQuests();
+    if (quests.size() < MAX_QUEST_LOG_SIZE - 5)
+        spam("I would like to pick up and do a new quest. Just invite me!");
+}
+
+void SuggestWhatToDoAction::grindMaterials()
+{
+    if (bot->getLevel() <= 5)
+        return;
+
+    switch (urand(0, 5))
+    {
+    case 0:
+        spam("Need help for tradeskill?");
+        break;
+    case 1:
+        spam("Can we have some trade material grinding?");
+        break;
+    case 2:
+        spam("I have some trade materials for sell");
+        break;
+    default:
+        spam("I am going to grind some trade materials. Would you like to join me?");
+    }
+}
+
+void SuggestWhatToDoAction::grindReputation()
+{
+    if (bot->getLevel() > 15)
+        ai->TellMasterNoFacing("I think we should do something to improve our reputation", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::nothing()
+{
+    ai->TellMasterNoFacing("I don't want to do anything", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::relax()
+{
+    ai->TellMasterNoFacing("It is so boring... We could relax a bit", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::achievement()
+{
+    if (bot->getLevel() > 15)
+        spam("I would like to get some achievement. Would you like to join me?");
+}
+
+class FindTradeItemsVisitor : public IterateItemsVisitor
+{
+public:
+    FindTradeItemsVisitor(uint32 quality) : quality(quality), IterateItemsVisitor() {}
+
+    virtual bool Visit(Item* item)
+    {
+        ItemTemplate const* proto = item->GetTemplate();
+        if (proto->Quality != quality)
+            return true;
+
+        if (proto->Class == ITEM_CLASS_TRADE_GOODS && proto->Bonding == NO_BIND)
+        {
+            if(proto->Quality == ITEM_QUALITY_NORMAL && item->GetCount() > 1 && item->GetCount() == item->GetMaxStackCount())
+                stacks.push_back(proto->ItemId);
+
+            items.push_back(proto->ItemId);
+            count[proto->ItemId] += item->GetCount();
+        }
+
+        return true;
+    }
+
+    map<uint32, int > count;
+    vector<uint32> stacks;
+    vector<uint32> items;
+
+private:
+    uint32 quality;
+};
+
+
+void SuggestWhatToDoAction::trade()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return;
+
+    uint32 quality = urand(0, 100);
+    if (quality > 90)
+        quality = ITEM_QUALITY_EPIC;
+    else if (quality >75)
+        quality = ITEM_QUALITY_RARE;
+    else if (quality > 50)
+        quality = ITEM_QUALITY_UNCOMMON;
+    else
+        quality = ITEM_QUALITY_NORMAL;
+
+    uint32 item = 0, count = 0;
+    while (quality-- > ITEM_QUALITY_POOR)
+    {
+        FindTradeItemsVisitor visitor(quality);
+        IterateItems(&visitor);
+        if (!visitor.stacks.empty())
+        {
+            int index = urand(0, visitor.stacks.size() - 1);
+            item = visitor.stacks[index];
+        }
+
+        if (!item)
+        {
+            if (!visitor.items.empty())
+            {
+                int index = urand(0, visitor.items.size() - 1);
+                item = visitor.items[index];
+            }
+        }
+
+        if (item)
+        {
+            count = visitor.count[item];
+            break;
+        }
+    }
+
+    if (!item || !count)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item);
+    if (!proto)
+        return;
+
+    uint32 price = auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot) * count;
+    if (!price)
+        return;
+
+    ostringstream out; out << "Selling " << chat->formatItem(proto, count) << " for " << chat->formatMoney(price);
+    spam(out.str());
+}
+
+void SuggestWhatToDoAction::spam(string msg)
+{
+    Player* player = sRandomPlayerbotMgr.GetRandomPlayer();
+    if (!player || !player->IsInWorld())
+        return;
+
+    if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_TALK, true, player))
+        return;
+
+    if (sPlayerbotAIConfig.whisperDistance && !bot->GetGroup() && sRandomPlayerbotMgr.IsRandomBot(bot) &&
+            player->GetSession()->GetSecurity() < SEC_GAMEMASTER &&
+            (bot->GetMapId() != player->GetMapId() || bot->GetDistance(player) > sPlayerbotAIConfig.whisperDistance))
+        return;
+
+    bot->Whisper(msg, LANG_UNIVERSAL, player);
+}
diff --git a/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
new file mode 100644
index 0000000..750bb08
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SuggestWhatToDoAction : public InventoryAction
+    {
+    public:
+        SuggestWhatToDoAction(PlayerbotAI* ai);
+        virtual bool Execute(Event event);
+
+    private:
+        typedef void (SuggestWhatToDoAction::*Suggestion) ();
+        vector<Suggestion> suggestions;
+
+    private:
+        void instance();
+        void specificQuest();
+        void newQuest();
+        void grindMaterials();
+        void grindReputation();
+        void nothing();
+        void relax();
+        void achievement();
+        void trade();
+        void spam(string msg);
+
+        vector<uint32> GetIncompletedQuests();
+
+    private:
+        bool suggested;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
new file mode 100644
index 0000000..747abb2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TalkToQuestGiverAction.h"
+
+
+using namespace ai;
+
+void TalkToQuestGiverAction::ProcessQuest(Quest const* quest, WorldObject* questGiver)
+{
+    std::ostringstream out; out << "Quest ";
+
+    QuestStatus status = bot->GetQuestStatus(quest->GetQuestId());
+    switch (status)
+    {
+    case QUEST_STATUS_COMPLETE:
+        TurnInQuest(quest, questGiver, out);
+        break;
+    case QUEST_STATUS_INCOMPLETE:
+        out << "|cffff0000Incompleted|r";
+        break;
+    case QUEST_STATUS_NONE:
+        out << "|cff00ff00Available|r";
+        break;
+    case QUEST_STATUS_FAILED:
+        out << "|cffff0000Failed|r";
+        break;
+    }
+
+    out << ": " << chat->formatQuest(quest);
+    ai->TellMaster(out);
+}
+
+void TalkToQuestGiverAction::TurnInQuest(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    uint32 questID = quest->GetQuestId();
+
+    if (bot->GetQuestRewardStatus(questID))
+        return;
+
+    if (quest->GetRewChoiceItemsCount() == 0)
+        RewardNoItem(quest, questGiver, out);
+    else if (quest->GetRewChoiceItemsCount() == 1)
+        RewardSingleItem(quest, questGiver, out);
+    else {
+        AskToSelectReward(quest, out);
+    }
+}
+
+void TalkToQuestGiverAction::RewardNoItem(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    if (bot->CanRewardQuest(quest, false))
+    {
+        bot->RewardQuest(quest, 0, questGiver, false);
+        out << "Completed";
+    }
+    else
+    {
+        out << "|cffff0000Unable to turn in|r";
+    }
+}
+
+void TalkToQuestGiverAction::RewardSingleItem(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    int index = 0;
+    ItemTemplate const *item = sObjectMgr->GetItemTemplate(quest->RewardChoiceItemId[index]);
+    if (bot->CanRewardQuest(quest, index, false))
+    {
+        bot->RewardQuest(quest, index, questGiver, true);
+
+        out << "Rewarded " << chat->formatItem(item);
+    }
+    else
+    {
+        out << "|cffff0000Unable to turn in:|r, reward: " << chat->formatItem(item);
+    }
+}
+
+void TalkToQuestGiverAction::AskToSelectReward(Quest const* quest, ostringstream& out)
+{
+    ostringstream msg;
+    msg << "Choose reward: ";
+    for (uint8 i=0; i < quest->GetRewChoiceItemsCount(); ++i)
+    {
+        ItemTemplate const* item = sObjectMgr->GetItemTemplate(quest->RewardChoiceItemId[i]);
+        msg << chat->formatItem(item);
+    }
+    ai->TellMaster(msg);
+
+    out << "Reward pending";
+}
diff --git a/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
new file mode 100644
index 0000000..374dc69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class TalkToQuestGiverAction : public QuestAction {
+    public:
+        TalkToQuestGiverAction(PlayerbotAI* ai) : QuestAction(ai, "talk to quest giver") {}
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver);
+
+    private:
+        void TurnInQuest(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void RewardNoItem(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void RewardSingleItem(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void AskToSelectReward(Quest const* quest, ostringstream& out);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TaxiAction.cpp b/src/plugins/playerbot/strategy/actions/TaxiAction.cpp
new file mode 100644
index 0000000..8037679
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TaxiAction.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TaxiAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool TaxiAction::Execute(Event event)
+{
+    ai->RemoveShapeshift();
+
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+
+    WorldPacket& p = event.getPacket();
+	if (!p.empty() && p.GetOpcode() == CMSG_MOVE_SPLINE_DONE)
+    {
+        WorldPacket p1(p);
+        p1.rpos(0);
+        bot->GetSession()->HandleMoveSplineDoneOpcode(p1);
+        movement.taxiNodes.clear();
+        movement.Set(NULL);
+        return true;
+    }
+
+    list<ObjectGuid> units = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+    for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+    {
+        Creature *npc = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_FLIGHTMASTER);
+        if (!npc)
+            continue;
+
+        if (movement.taxiNodes.empty())
+        {
+            ostringstream out;
+            out << "I will order the taxi from " << npc->GetName() << ". Please start flying, then instruct me again";
+            ai->TellMaster(out);
+            return true;
+        }
+
+        if (!bot->ActivateTaxiPathTo(movement.taxiNodes, npc))
+        {
+            ai->TellMaster("I can't fly with you");
+            return false;
+        }
+
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any flightmaster to talk");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TaxiAction.h b/src/plugins/playerbot/strategy/actions/TaxiAction.h
new file mode 100644
index 0000000..84bbe4d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TaxiAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+	class TaxiAction : public Action {
+	public:
+		TaxiAction(PlayerbotAI* ai) : Action(ai, "taxi") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TeleportAction.cpp b/src/plugins/playerbot/strategy/actions/TeleportAction.cpp
new file mode 100644
index 0000000..ef82a7a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TeleportAction.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TeleportAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool TeleportAction::Execute(Event event)
+{
+    list<ObjectGuid> gos = *context->GetValue<list<ObjectGuid> >("nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (!go)
+            continue;
+
+        GameObjectTemplate const *goInfo = go->GetGOInfo();
+        if (goInfo->type != GAMEOBJECT_TYPE_SPELLCASTER)
+            continue;
+
+        uint32 spellId = goInfo->spellcaster.spellId;
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (pSpellInfo->Effects[0].Effect != SPELL_EFFECT_TELEPORT_UNITS && pSpellInfo->Effects[1].Effect != SPELL_EFFECT_TELEPORT_UNITS && pSpellInfo->Effects[2].Effect != SPELL_EFFECT_TELEPORT_UNITS)
+            continue;
+
+        ostringstream out; out << "Teleporting using " << goInfo->name;
+        ai->TellMasterNoFacing(out.str());
+
+        ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+        Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+        SpellCastTargets targets;
+        targets.SetUnitTarget(bot);
+        spell->prepare(&targets);
+        spell->cast(true);
+        return true;
+    }
+
+
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+    if (movement.lastAreaTrigger)
+    {
+        WorldPacket p(CMSG_AREATRIGGER);
+        p << movement.lastAreaTrigger;
+        p.rpos(0);
+
+        bot->GetSession()->HandleAreaTriggerOpcode(p);
+        movement.lastAreaTrigger = 0;
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any portal to teleport");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TeleportAction.h b/src/plugins/playerbot/strategy/actions/TeleportAction.h
new file mode 100644
index 0000000..96b5973
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TeleportAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class TeleportAction : public Action {
+	public:
+		TeleportAction(PlayerbotAI* ai) : Action(ai, "teleport") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
new file mode 100644
index 0000000..2469816
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellCastFailedAction.h"
+
+
+using namespace ai;
+
+bool TellCastFailedAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint8 castCount, result;
+    uint32 spellId;
+    p >> castCount >> spellId >> result;
+    ai->SpellInterrupted(spellId);
+
+    if (result == SPELL_CAST_OK)
+        return false;
+
+    const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+    ostringstream out; out << chat->formatSpell(pSpellInfo) << ": ";
+    switch (result)
+    {
+    case SPELL_FAILED_NOT_READY:
+        out << "not ready";
+        break;
+    case SPELL_FAILED_REQUIRES_SPELL_FOCUS:
+        out << "requires spell focus";
+        break;
+    case SPELL_FAILED_REQUIRES_AREA:
+        out << "cannot cast here";
+        break;
+    case SPELL_FAILED_TOTEMS:
+    case SPELL_FAILED_TOTEM_CATEGORY:
+        out << "requires totem";
+        break;
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS:
+        out << "requires item";
+        break;
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND:
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND:
+        out << "requires weapon";
+        break;
+    case SPELL_FAILED_PREVENTED_BY_MECHANIC:
+        out << "interrupted";
+        break;
+    default:
+        out << "cannot cast";
+    }
+    Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+    int32 castTime = spell->GetCastTime();
+    delete spell;
+
+    if (castTime >= 2000)
+        ai->TellMasterNoFacing(out.str());
+
+    return true;
+}
+
+
+bool TellSpellAction::Execute(Event event)
+{
+    string spell = event.getParam();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    if (!spellId)
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellId );
+    if (!spellInfo)
+        return false;
+
+    ostringstream out; out << chat->formatSpell(spellInfo);
+    ai->TellMaster(out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
new file mode 100644
index 0000000..e454596
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellSpellAction : public Action
+    {
+    public:
+        TellSpellAction(PlayerbotAI* ai) : Action(ai, "spell") {}
+
+        virtual bool Execute(Event event);
+    };
+
+    class TellCastFailedAction : public Action 
+    {
+    public:
+        TellCastFailedAction(PlayerbotAI* ai) : Action(ai, "tell cast failed") {}
+
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp b/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
new file mode 100644
index 0000000..fdbe0d3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellItemCountAction.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool TellItemCountAction::Execute(Event event)
+{
+    string text = event.getParam();
+    list<Item*> found = parseItems(text);
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        TellItem((*i)->GetTemplate(), (*i)->GetCount());
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellItemCountAction.h b/src/plugins/playerbot/strategy/actions/TellItemCountAction.h
new file mode 100644
index 0000000..093b0e0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellItemCountAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TellItemCountAction : public InventoryAction {
+    public:
+        TellItemCountAction(PlayerbotAI* ai) : InventoryAction(ai, "c") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellLosAction.cpp b/src/plugins/playerbot/strategy/actions/TellLosAction.cpp
new file mode 100644
index 0000000..02227f9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellLosAction.cpp
@@ -0,0 +1,61 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellLosAction.h"
+
+
+using namespace ai;
+
+bool TellLosAction::Execute(Event event)
+{
+    string param = event.getParam();
+
+    if (param.empty() || param == "targets")
+    {
+        list<ObjectGuid> targets = *context->GetValue<list<ObjectGuid> >("possible targets");
+        ListUnits("--- Targets ---", targets);
+    }
+
+    if (param.empty() || param == "npcs")
+    {
+        list<ObjectGuid> npcs = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+        ListUnits("--- NPCs ---", npcs);
+    }
+
+    if (param.empty() || param == "corpses")
+    {
+        list<ObjectGuid> corpses = *context->GetValue<list<ObjectGuid> >("nearest corpses");
+        ListUnits("--- Corpses ---", corpses);
+    }
+
+    if (param.empty() || param == "gos" || param == "game objects")
+    {
+        list<ObjectGuid> gos = *context->GetValue<list<ObjectGuid> >("nearest game objects");
+        ListGameObjects("--- Game objects ---", gos);
+    }
+
+    return true;
+}
+
+void TellLosAction::ListUnits(string title, list<ObjectGuid> units)
+{
+    ai->TellMaster(title);
+
+    for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (unit)
+            ai->TellMaster(unit->GetName());
+    }
+
+}
+void TellLosAction::ListGameObjects(string title, list<ObjectGuid> gos)
+{
+    ai->TellMaster(title);
+
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (go)
+            ai->TellMaster(chat->formatGameobject(go));
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellLosAction.h b/src/plugins/playerbot/strategy/actions/TellLosAction.h
new file mode 100644
index 0000000..15d83fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellLosAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellLosAction : public Action {
+    public:
+        TellLosAction(PlayerbotAI* ai) : Action(ai, "los") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ListUnits(string title, list<ObjectGuid> units);
+        void ListGameObjects(string title, list<ObjectGuid> gos);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellMasterAction.h b/src/plugins/playerbot/strategy/actions/TellMasterAction.h
new file mode 100644
index 0000000..4174708
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellMasterAction.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellMasterAction : public Action {
+    public:
+        TellMasterAction(PlayerbotAI* ai, string text) : Action(ai, "tell master"), text(text) {}
+
+        virtual bool Execute(Event event)
+        {
+            ai->TellMaster(text);
+            return true;
+        }
+
+    private:
+        string text;
+    };
+
+    class OutOfReactRangeAction : public MovementAction {
+    public:
+        OutOfReactRangeAction(PlayerbotAI* ai) : MovementAction(ai, "tell out of react range") {}
+
+        virtual bool Execute(Event event)
+        {
+            bool canFollow = Follow(AI_VALUE(Unit*, "master target"));
+            if (!canFollow)
+            {
+                ai->SetNextCheckDelay(5000);
+                return false;
+            }
+
+            ai->TellMaster("Wait for me!");
+            return true;
+        }
+   };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp b/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
new file mode 100644
index 0000000..f1bd104
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
@@ -0,0 +1,68 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellReputationAction.h"
+#include "../../../Reputation/ReputationMgr.h"
+
+
+using namespace ai;
+
+bool TellReputationAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* unit = master->GetSelectedUnit();
+    if (!unit)
+        return false;
+
+    const FactionTemplateEntry *factionTemplate = unit->GetFactionTemplateEntry();
+    uint32 faction = factionTemplate->faction;
+    const FactionEntry* entry = sFactionStore.LookupEntry(faction);
+    int32 reputation = bot->GetReputationMgr().GetReputation(faction);
+
+    ostringstream out;
+    out << entry->name[0] << ": ";
+    out << "|cff";
+    ReputationRank rank = bot->GetReputationMgr().GetRank(entry);
+    switch (rank) {
+        case REP_HATED:
+            out << "cc2222hated";
+            break;
+        case REP_HOSTILE:
+            out << "ff0000hostile";
+            break;
+        case REP_UNFRIENDLY:
+            out << "ee6622unfriendly";
+            break;
+        case REP_NEUTRAL:
+            out << "ffff00neutral";
+            break;
+        case REP_FRIENDLY:
+            out << "00ff00friendly";
+            break;
+        case REP_HONORED:
+            out << "00ff88honored";
+            break;
+        case REP_REVERED:
+            out << "00ffccrevered";
+            break;
+        case REP_EXALTED:
+            out << "00ffffexalted";
+            break;
+        default:
+            out << "808080unknown";
+            break;
+    }
+
+    out << "|cffffffff";
+
+    int32 base = ReputationMgr::Reputation_Cap + 1;
+    for (int i = MAX_REPUTATION_RANK - 1; i >= rank; --i)
+        base -= ReputationMgr::PointsInRank[i];
+
+    out << " (" << (reputation - base) << "/" << ReputationMgr::PointsInRank[rank] << ")";
+    ai->TellMaster(out);
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellReputationAction.h b/src/plugins/playerbot/strategy/actions/TellReputationAction.h
new file mode 100644
index 0000000..449e67f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellReputationAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellReputationAction : public Action {
+    public:
+        TellReputationAction(PlayerbotAI* ai) : Action(ai, "reputation") {}
+        virtual bool Execute(Event event);
+
+    private:
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp b/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
new file mode 100644
index 0000000..a302772
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
@@ -0,0 +1,53 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellTargetAction.h"
+
+
+using namespace ai;
+
+bool TellTargetAction::Execute(Event event)
+{
+    Unit* target = context->GetValue<Unit*>("current target")->Get();
+    if (target)
+    {
+        ostringstream out;
+		out << "Attacking " << target->GetName();
+        ai->TellMaster(out);
+
+        context->GetValue<Unit*>("old target")->Set(target);
+    }
+    return true;
+}
+
+bool TellAttackersAction::Execute(Event event)
+{
+    ai->TellMaster("--- Attackers ---");
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        ai->TellMaster(unit->GetName());
+    }
+
+    ai->TellMaster("--- Threat ---");
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    if (!ref)
+        return true;
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *unit = threatManager->GetOwner();
+        float threat = ref->getThreat();
+
+        ostringstream out; out << unit->GetName() << " (" << threat << ")";
+        ai->TellMaster(out);
+
+        ref = ref->next();
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellTargetAction.h b/src/plugins/playerbot/strategy/actions/TellTargetAction.h
new file mode 100644
index 0000000..7995100
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellTargetAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellTargetAction : public Action
+    {
+    public:
+        TellTargetAction(PlayerbotAI* ai) : Action(ai, "tell target") {}
+        virtual bool Execute(Event event);
+    };
+
+    class TellAttackersAction : public Action
+    {
+    public:
+        TellAttackersAction(PlayerbotAI* ai) : Action(ai, "tell attackers") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeAction.cpp b/src/plugins/playerbot/strategy/actions/TradeAction.cpp
new file mode 100644
index 0000000..62f1c45
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeAction.cpp
@@ -0,0 +1,83 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TradeAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool TradeAction::Execute(Event event)
+{
+    string text = event.getParam();
+    uint32 copper = chat->parseMoney(text);
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    int8 slot = -1;
+
+    list<Item*> found = parseItems(text);
+    if (found.empty())
+        return false;
+
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        TradeItem(**i, slot);
+
+    return true;
+}
+
+bool TradeAction::TradeItem(const Item& item, int8 slot)
+{
+    if (!bot->GetTrader() || item.IsInTrade())
+        return false;
+
+    if (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED)
+        slot = TRADE_SLOT_NONTRADED;
+
+    int8 tradeSlot = -1;
+    Item* itemPtr = const_cast<Item*>(&item);
+
+    TradeData* pTrade = bot->GetTradeData();
+    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == NULL)
+        tradeSlot = slot;
+
+    if (slot == TRADE_SLOT_NONTRADED)
+        pTrade->SetItem(TRADE_SLOT_NONTRADED, itemPtr);
+    else
+    {
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == itemPtr)
+            {
+                tradeSlot = i;
+
+                WorldPacket* const packet = new WorldPacket(CMSG_CLEAR_TRADE_ITEM, 1);
+                *packet << (uint8) tradeSlot;
+                bot->GetSession()->QueuePacket(packet);
+                pTrade->SetItem(TradeSlots(i), NULL);
+                return true;
+            }
+        }
+
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == NULL)
+            {
+                pTrade->SetItem(TradeSlots(i), itemPtr);
+                tradeSlot = i;
+            }
+        }
+    }
+
+    if (tradeSlot == -1) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+        << (uint8) item.GetSlot();
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/TradeAction.h b/src/plugins/playerbot/strategy/actions/TradeAction.h
new file mode 100644
index 0000000..050a583
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TradeAction : public InventoryAction {
+    public:
+        TradeAction(PlayerbotAI* ai) : InventoryAction(ai, "trade") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool TradeItem(const Item& item, int8 slot);
+
+        static map<string, uint32> slots;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp b/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
new file mode 100644
index 0000000..df30a5c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
@@ -0,0 +1,216 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TradeStatusAction.h"
+
+#include "../ItemVisitors.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../../GuildTaskMgr.h"
+#include "../values/ItemUsageValue.h"
+
+using namespace ai;
+
+
+
+bool TradeStatusAction::Execute(Event event)
+{
+    Player* trader = bot->GetTrader();
+    Player* master = GetMaster();
+    if (!trader)
+        return false;
+
+    if (trader != master)
+    {
+		bot->Whisper("I'm kind of busy now", LANG_UNIVERSAL, trader);
+    }
+
+    if (trader != master || !ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_ALLOW_ALL, true, master))
+    {
+        WorldPacket p;
+        uint32 status = 0;
+        p << status;
+        bot->GetSession()->HandleCancelTradeOpcode(p);
+        return false;
+    }
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint32 status;
+    p >> status;
+
+    if (status == TRADE_STATUS_TRADE_ACCEPT)
+    {
+        WorldPacket p;
+        uint32 status = 0;
+        p << status;
+
+        if (CheckTrade())
+        {
+            int32 botMoney = CalculateCost(bot->GetTradeData(), true);
+
+            map<uint32, uint32> itemIds;
+            for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+            {
+                Item* item = master->GetTradeData()->GetItem((TradeSlots)slot);
+                if (item)
+                    itemIds[item->GetTemplate()->ItemId] += item->GetCount();
+            }
+
+            bot->GetSession()->HandleAcceptTradeOpcode(p);
+            if (bot->GetTradeData())
+                return false;
+
+            for (map<uint32, uint32>::iterator i = itemIds.begin(); i != itemIds.end(); ++i)
+                sGuildTaskMgr.CheckItemTask(i->first, i->second, master, bot);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+            {
+                int32 lootAmount = sRandomPlayerbotMgr.GetLootAmount(bot);
+                sRandomPlayerbotMgr.SetLootAmount(bot, max(0, lootAmount - botMoney * 10));
+            }
+            return true;
+        }
+    }
+    else if (status == TRADE_STATUS_BEGIN_TRADE)
+    {
+        if (!bot->isInFront(trader, M_PI / 2))
+            bot->SetFacingToObject(trader);
+        BeginTrade();
+        return true;
+    }
+
+    return false;
+}
+
+
+void TradeStatusAction::BeginTrade()
+{
+    WorldPacket p;
+    bot->GetSession()->HandleBeginTradeOpcode(p);
+
+    ListItemsVisitor visitor;
+    IterateItems(&visitor);
+
+    ai->TellMaster("=== Trade ===");
+    TellItems(visitor.items);
+
+    if (sRandomPlayerbotMgr.IsRandomBot(bot))
+    {
+        uint32 discount = sRandomPlayerbotMgr.GetTradeDiscount(bot);
+        if (discount)
+        {
+            ostringstream out; out << "Discount up to: " << chat->formatMoney(discount);
+            ai->TellMaster(out);
+        }
+    }
+}
+
+bool TradeStatusAction::CheckTrade()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return true;
+
+    Player* master = GetMaster();
+    if (!bot->GetTradeData() || !master->GetTradeData())
+        return false;
+
+    for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+    {
+        Item* item = bot->GetTradeData()->GetItem((TradeSlots)slot);
+        if (item && !auctionbot.GetSellPrice(item->GetTemplate()))
+        {
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate()) << " - This is not for sale";
+            ai->TellMaster(out);
+            return false;
+        }
+
+        item = master->GetTradeData()->GetItem((TradeSlots)slot);
+        if (item)
+        {
+            ostringstream out; out << item->GetTemplate()->ItemId;
+            ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+            if (!auctionbot.GetBuyPrice(item->GetTemplate()) || usage == ITEM_USAGE_NONE)
+            {
+                ostringstream out;
+                out << chat->formatItem(item->GetTemplate()) << " - I don't need this";
+                ai->TellMaster(out);
+                return false;
+            }
+        }
+    }
+
+    int32 botItemsMoney = CalculateCost(bot->GetTradeData(), true);
+    int32 botMoney = bot->GetTradeData()->GetMoney() + botItemsMoney;
+    int32 playerItemsMoney = CalculateCost(master->GetTradeData(), false);
+    int32 playerMoney = master->GetTradeData()->GetMoney() + playerItemsMoney;
+
+    if (!botMoney && !playerMoney)
+        return true;
+
+    if (!botItemsMoney && !playerItemsMoney)
+    {
+        ai->TellMaster("There are no items to trade");
+        return false;
+    }
+
+    int32 discount = min(botItemsMoney, (int32)sRandomPlayerbotMgr.GetTradeDiscount(bot));
+    botMoney = max(0, botMoney - discount);
+
+    if (playerMoney >= botMoney)
+    {
+        switch (urand(0, 4)) {
+        case 0:
+            ai->TellMaster("A pleasure doing business with you");
+            break;
+        case 1:
+            ai->TellMaster("Fair trade");
+            break;
+        case 2:
+            ai->TellMaster("Thanks");
+            break;
+        case 3:
+            ai->TellMaster("Off with you");
+            break;
+        }
+        return true;
+    }
+
+    ostringstream out;
+    out << "I want " << chat->formatMoney(botMoney - playerMoney) << " for this";
+    ai->TellMaster(out);
+    return false;
+}
+
+int32 TradeStatusAction::CalculateCost(TradeData* data, bool sell)
+{
+    if (!data)
+        return 0;
+
+    uint32 sum = 0;
+    for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+    {
+        Item* item = data->GetItem((TradeSlots)slot);
+        if (!item)
+            continue;
+
+        ItemTemplate const* proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        if (proto->Quality < ITEM_QUALITY_NORMAL)
+            return 0;
+
+        if (sell)
+        {
+            sum += item->GetCount() * auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot);
+        }
+        else
+        {
+            sum += item->GetCount() * auctionbot.GetBuyPrice(proto) * sRandomPlayerbotMgr.GetBuyMultiplier(bot);
+        }
+    }
+
+    return sum;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeStatusAction.h b/src/plugins/playerbot/strategy/actions/TradeStatusAction.h
new file mode 100644
index 0000000..7500a64
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeStatusAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+#include "QueryItemUsageAction.h"
+
+namespace ai
+{
+    class TradeStatusAction : public QueryItemUsageAction
+    {
+    public:
+        TradeStatusAction(PlayerbotAI* ai) : QueryItemUsageAction(ai, "accept trade") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void BeginTrade();
+        bool CheckTrade();
+        int32 CalculateCost(TradeData* data, bool sell);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TrainerAction.cpp b/src/plugins/playerbot/strategy/actions/TrainerAction.cpp
new file mode 100644
index 0000000..e261a2b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TrainerAction.cpp
@@ -0,0 +1,114 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TrainerAction.h"
+
+using namespace ai;
+
+void TrainerAction::Learn(uint32 cost, TrainerSpell const* tSpell, ostringstream& msg)
+{
+    if (bot->GetMoney() < cost)
+        return;
+
+    bot->ModifyMoney(-int32(cost));
+    if (tSpell->IsCastable())
+        bot->CastSpell(bot, tSpell->spell, true);
+    else
+        bot->LearnSpell(tSpell->learnedSpell[0], false, false);
+
+    msg << " - learned";
+}
+
+void TrainerAction::List(Creature* creature, TrainerSpellAction action, SpellIds& spells)
+{
+    TellHeader(creature);
+
+    TrainerSpellData const* trainer_spells = creature->GetTrainerSpells();
+    float fDiscountMod =  bot->GetReputationPriceDiscount(creature);
+    uint32 totalCost = 0;
+
+    for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+    {
+        TrainerSpell const* tSpell = &itr->second;
+
+        if (!tSpell)
+            continue;
+
+        if (!tSpell->learnedSpell && !bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+            continue;
+
+        TrainerSpellState state = bot->GetTrainerSpellState(tSpell);
+        if (state != TRAINER_SPELL_GREEN)
+            continue;
+
+        uint32 spellId = tSpell->spell;
+        const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+        totalCost += cost;
+
+        ostringstream out;
+        out << chat->formatSpell(pSpellInfo) << chat->formatMoney(cost);
+
+        if (action && (spells.empty() || spells.find(tSpell->spell) != spells.end() || spells.find(tSpell->learnedSpell[0]) != spells.end()))
+            (this->*action)(cost, tSpell, out);
+
+        ai->TellMaster(out);
+    }
+
+    TellFooter(totalCost);
+}
+
+
+bool TrainerAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* target = master->GetSelectedUnit();
+    if (!target)
+        return false;
+
+    Creature *creature = ai->GetCreature(target->GetGUID());
+    if (!creature)
+        return false;
+
+    // check present spell in trainer spell list
+    TrainerSpellData const* cSpells = creature->GetTrainerSpells();
+    if (!cSpells)
+    {
+        ai->TellMaster("No spells can be learned from this trainer");
+        return false;
+    }
+
+    uint32 spell = chat->parseSpell(text);
+    SpellIds spells;
+    if (spell)
+        spells.insert(spell);
+
+    if (text == "learn")
+        List(creature, &TrainerAction::Learn, spells);
+    else
+        List(creature, NULL, spells);
+
+    return true;
+}
+
+void TrainerAction::TellHeader(Creature* creature)
+{
+    ostringstream out; out << "--- can learn from " << creature->GetName() << " ---";
+    ai->TellMaster(out);
+}
+
+void TrainerAction::TellFooter(uint32 totalCost)
+{
+    if (totalCost)
+    {
+        ostringstream out; out << "Total cost: " << chat->formatMoney(totalCost);
+        ai->TellMaster(out);
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/TrainerAction.h b/src/plugins/playerbot/strategy/actions/TrainerAction.h
new file mode 100644
index 0000000..3dbe18f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TrainerAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class TrainerAction : public Action {
+	public:
+		TrainerAction(PlayerbotAI* ai) : Action(ai, "trainer") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    private:
+        typedef void (TrainerAction::*TrainerSpellAction)(uint32, TrainerSpell const*, ostringstream& msg);
+        void List(Creature* creature, TrainerSpellAction action, SpellIds& spells);
+        void Learn(uint32 cost, TrainerSpell const* tSpell, ostringstream& msg);
+        void TellHeader(Creature* creature);
+        void TellFooter(uint32 totalCost);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/UnequipAction.cpp b/src/plugins/playerbot/strategy/actions/UnequipAction.cpp
new file mode 100644
index 0000000..cf70f80
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UnequipAction.cpp
@@ -0,0 +1,45 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UnequipAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool UnequipAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    ItemIds ids = chat->parseItems(text);
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        UnequipItem(&visitor);
+    }
+
+    return true;
+}
+
+
+void UnequipAction::UnequipItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor, ITERATE_ALL_ITEMS);
+    list<Item*> items = visitor->GetResult();
+	if (!items.empty()) UnequipItem(**items.begin());
+}
+
+void UnequipAction::UnequipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 dstBag = NULL_BAG;
+
+
+    WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_BAG_ITEM, 3);
+    *packet << bagIndex << slot << dstBag;
+    bot->GetSession()->QueuePacket(packet);
+
+    ostringstream out; out << chat->formatItem(item.GetTemplate()) << " unequipped";
+    ai->TellMaster(out);
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/UnequipAction.h b/src/plugins/playerbot/strategy/actions/UnequipAction.h
new file mode 100644
index 0000000..fdf7ebb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UnequipAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class UnequipAction : public InventoryAction {
+    public:
+        UnequipAction(PlayerbotAI* ai) : InventoryAction(ai, "unequip") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void UnequipItem(Item& item);
+        void UnequipItem(FindItemVisitor* visitor);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/UseItemAction.cpp b/src/plugins/playerbot/strategy/actions/UseItemAction.cpp
new file mode 100644
index 0000000..1ec05bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseItemAction.cpp
@@ -0,0 +1,302 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseItemAction.h"
+
+using namespace ai;
+
+bool UseItemAction::Execute(Event event)
+{
+    string name = event.getParam();
+    if (name.empty())
+        name = getName();
+
+    list<Item*> items = AI_VALUE2(list<Item*>, "inventory items", name);
+    list<ObjectGuid> gos = chat->parseGameobjects(name);
+
+    if (gos.empty())
+    {
+        if (items.size() > 1)
+        {
+            list<Item*>::iterator i = items.begin();
+            Item* itemTarget = *i++;
+            Item* item = *i;
+            return UseItemOnItem(item, itemTarget);
+        }
+        else if (!items.empty())
+            return UseItemAuto(*items.begin());
+    }
+    else
+    {
+        if (items.empty())
+            return UseGameObject(*gos.begin());
+        else
+            return UseItemOnGameObject(*items.begin(), *gos.begin());
+    }
+
+    ai->TellMaster("No items (or game objects) available");
+    return false;
+}
+
+bool UseItemAction::UseGameObject(ObjectGuid guid)
+{
+    GameObject* go = ai->GetGameObject(guid);
+    if (!go || !go->isSpawned())
+        return false;
+
+    go->Use(bot);
+    ostringstream out; out << "Using " << chat->formatGameobject(go);
+    ai->TellMasterNoFacing(out.str());
+    return true;
+}
+
+bool UseItemAction::UseItemAuto(Item* item)
+{
+    return UseItem(item, ObjectGuid(), NULL);
+}
+
+bool UseItemAction::UseItemOnGameObject(Item* item, ObjectGuid go)
+{
+    return UseItem(item, go, NULL);
+}
+
+bool UseItemAction::UseItemOnItem(Item* item, Item* itemTarget)
+{
+    return UseItem(item, ObjectGuid(), itemTarget);
+}
+
+bool UseItemAction::UseItem(Item* item, ObjectGuid goGuid, Item* itemTarget)
+{
+    if (bot->CanUseItem(item) != EQUIP_ERR_OK)
+        return false;
+
+    if (bot->IsNonMeleeSpellCast(true))
+        return false;
+
+    if (bot->IsInCombat() && item->IsPotion() && bot->GetLastPotionId())
+        return false;
+
+    uint8 bagIndex = item->GetBagSlot();
+    uint8 slot = item->GetSlot();
+    uint8 cast_count = 1;
+    uint64 item_guid = item->GetGUID();
+    uint32 glyphIndex = 0;
+    uint8 unk_flags = 0;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1 + 8 + 1);
+    *packet << bagIndex << slot << cast_count << uint32(0) << item_guid
+        << glyphIndex << unk_flags;
+
+    bool targetSelected = false;
+    ostringstream out; out << "Using " << chat->formatItem(item->GetTemplate());
+    if (item->GetTemplate()->Stackable)
+    {
+        uint32 count = item->GetCount();
+        if (count > 1)
+            out << " (" << count << " available) ";
+        else
+            out << " (the last one!)";
+    }
+
+    if (goGuid)
+    {
+        GameObject* go = ai->GetGameObject(goGuid);
+        if (go && go->isSpawned())
+        {
+            uint32 targetFlag = TARGET_FLAG_UNIT_ENEMY;
+            *packet << targetFlag;
+            packet->appendPackGUID(goGuid.GetRawValue());
+            out << " on " << chat->formatGameobject(go);
+            targetSelected = true;
+        }
+    }
+
+    if (itemTarget)
+    {
+        if (item->GetTemplate()->Class == ITEM_CLASS_GEM)
+        {
+            bool fit = SocketItem(itemTarget, item) || SocketItem(itemTarget, item, true);
+            if (!fit)
+                ai->TellMaster("Socket does not fit");
+            return fit;
+        }
+        else
+        {
+            uint32 targetFlag = TARGET_FLAG_ITEM;
+            *packet << targetFlag;
+            packet->appendPackGUID(itemTarget->GetGUID());
+            out << " on " << chat->formatItem(itemTarget->GetTemplate());
+            targetSelected = true;
+        }
+    }
+
+    Player* master = GetMaster();
+    if (!targetSelected && item->GetTemplate()->Class != ITEM_CLASS_CONSUMABLE && master)
+    {
+        Unit* masterSelection = master->GetSelectedUnit();
+        if (masterSelection)
+        {
+            uint32 targetFlag = TARGET_FLAG_UNIT;
+            *packet << targetFlag;
+            packet->appendPackGUID(masterSelection->GetGUID());
+            out << " on " << masterSelection->GetName();
+            targetSelected = true;
+        }
+    }
+
+    if(uint32 questid = item->GetTemplate()->StartQuest)
+    {
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (qInfo)
+        {
+            WorldPacket* const packet = new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8+4+4);
+            *packet << item_guid;
+            *packet << questid;
+            *packet << uint32(0);
+            bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+            ostringstream out; out << "Got quest " << chat->formatQuest(qInfo);
+            ai->TellMasterNoFacing(out.str());
+            return true;
+        }
+    }
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+    bot->ClearUnitState( UNIT_STATE_CHASE );
+    bot->ClearUnitState( UNIT_STATE_FOLLOW );
+
+    if (bot->isMoving())
+        return false;
+
+    for (int i=0; i<MAX_ITEM_PROTO_SPELLS; i++)
+    {
+        uint32 spellId = item->GetTemplate()->Spells[i].SpellId;
+        if (!spellId)
+            continue;
+
+        if (!ai->CanCastSpell(spellId, bot, false))
+            continue;
+
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (pSpellInfo->Targets & TARGET_FLAG_ITEM)
+        {
+            Item* itemForSpell = AI_VALUE2(Item*, "item for spell", spellId);
+            if (!itemForSpell)
+                continue;
+
+            if (itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                continue;
+
+            if (bot->GetTrader())
+            {
+                if (selfOnly)
+                    return false;
+
+                *packet << TARGET_FLAG_TRADE_ITEM << (uint8)1 << (uint64)TRADE_SLOT_NONTRADED;
+                targetSelected = true;
+                out << " on traded item";
+            }
+            else
+            {
+                *packet << TARGET_FLAG_ITEM;
+                packet->appendPackGUID(itemForSpell->GetGUID());
+                targetSelected = true;
+                out << " on "<< chat->formatItem(itemForSpell->GetTemplate());
+            }
+
+            Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE, ObjectGuid::Empty, true);
+            ai->WaitForSpellCast(spell);
+            delete spell;
+        }
+        else
+        {
+            *packet << TARGET_FLAG_NONE;
+            targetSelected = true;
+            out << " on self";
+        }
+        break;
+    }
+
+    if (!targetSelected)
+        return false;
+
+    if (item->GetTemplate()->Class == ITEM_CLASS_CONSUMABLE && item->GetTemplate()->SubClass == ITEM_SUBCLASS_FOOD)
+    {
+        if (bot->IsInCombat())
+            return false;
+
+        ai->InterruptSpell();
+        ai->SetNextCheckDelay(30000);
+    }
+
+    ai->TellMasterNoFacing(out.str());
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+bool UseItemAction::SocketItem(Item* item, Item* gem, bool replace)
+{
+    WorldPacket* const packet = new WorldPacket(CMSG_SOCKET_GEMS);
+    *packet << item->GetGUID();
+
+    bool fits = false;
+    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++enchant_slot)
+    {
+        uint8 SocketColor = item->GetTemplate()->Socket[enchant_slot-SOCK_ENCHANTMENT_SLOT].Color;
+        GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gem->GetTemplate()->GemProperties);
+        if (gemProperty && (gemProperty->color & SocketColor))
+        {
+            if (fits)
+            {
+                *packet << ObjectGuid();
+                continue;
+            }
+
+            uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+            if (!enchant_id)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchantEntry || !enchantEntry->GemID)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+			if (replace && enchantEntry->GemID != gem->GetTemplate()->ItemId)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+        }
+
+        *packet << ObjectGuid();
+    }
+
+    if (fits)
+    {
+        ostringstream out; out << "Socketing " << chat->formatItem(item->GetTemplate());
+        out << " with "<< chat->formatItem(gem->GetTemplate());
+        ai->TellMasterNoFacing(out.str());
+
+        bot->GetSession()->QueuePacket(packet);
+    }
+    return fits;
+}
+
+
+bool UseItemAction::isPossible()
+{
+    return getName() == "use" || AI_VALUE2(uint8, "item count", getName()) > 0;
+}
+
+bool UseSpellItemAction::isUseful()
+{
+    return AI_VALUE2(bool, "spell cast useful", getName());
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseItemAction.h b/src/plugins/playerbot/strategy/actions/UseItemAction.h
new file mode 100644
index 0000000..ef65561
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseItemAction.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class UseItemAction : public Action {
+	public:
+		UseItemAction(PlayerbotAI* ai, string name = "use", bool selfOnly = false) : Action(ai, name), selfOnly(selfOnly) {}
+
+    public:
+        virtual bool Execute(Event event);
+        virtual bool isPossible();
+
+    private:
+        bool UseItemAuto(Item* item);
+        bool UseItemOnGameObject(Item* item, ObjectGuid go);
+        bool UseItemOnItem(Item* item, Item* itemTarget);
+        bool UseItem(Item* item, ObjectGuid go, Item* itemTarget);
+        bool UseGameObject(ObjectGuid guid);
+        bool SocketItem(Item* item, Item* gem, bool replace = false);
+
+    private:
+        bool selfOnly;
+    };
+
+    class UseSpellItemAction : public UseItemAction {
+    public:
+        UseSpellItemAction(PlayerbotAI* ai, string name, bool selfOnly = false) : UseItemAction(ai, name, selfOnly) {}
+
+    public:
+        virtual bool isUseful();
+    };
+
+    class UseHealingPotion : public UseItemAction {
+    public:
+        UseHealingPotion(PlayerbotAI* ai) : UseItemAction(ai, "healing potion") {}
+        virtual bool isUseful() { return AI_VALUE2(bool, "combat", "self target"); }
+    };
+
+    class UseManaPotion : public UseItemAction
+    {
+    public:
+        UseManaPotion(PlayerbotAI* ai) : UseItemAction(ai, "mana potion") {}
+        virtual bool isUseful() { return AI_VALUE2(bool, "combat", "self target"); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
new file mode 100644
index 0000000..f7d959c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
@@ -0,0 +1,86 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseMeetingStoneAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+bool UseMeetingStoneAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    ObjectGuid guid;
+    p >> guid;
+
+    if (master->GetSelectedPlayer() && master->GetSelectedPlayer() != bot)
+        return false;
+
+    if (!master->GetSelectedPlayer() && master->GetGroup() != bot->GetGroup())
+        return false;
+
+    if (master->IsBeingTeleported())
+        return false;
+
+    if (bot->IsInCombat())
+    {
+        ai->TellMasterNoFacing("I am in combat");
+        return false;
+    }
+
+    Map* map = master->GetMap();
+    if (!map)
+        return NULL;
+
+    GameObject *gameObject = map->GetGameObject(guid);
+    if (!gameObject)
+        return false;
+
+    const GameObjectTemplate* goInfo = gameObject->GetGOInfo();
+    if (!goInfo || goInfo->type != GAMEOBJECT_TYPE_SUMMONING_RITUAL)
+        return false;
+
+    return Teleport();
+}
+
+
+bool SummonAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (master->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+    {
+        ai->TellMasterNoFacing("You cannot summon me");
+        return false;
+    }
+
+    return Teleport();
+}
+
+bool SummonAction::Teleport()
+{
+    Player* master = GetMaster();
+    if (!master->IsBeingTeleported())
+    {
+        float followAngle = GetFollowAngle();
+        for (float angle = followAngle - M_PI; angle <= followAngle + M_PI; angle += M_PI / 4)
+        {
+            uint32 mapId = master->GetMapId();
+            float x = master->GetPositionX() + cos(angle) * sPlayerbotAIConfig.followDistance;
+            float y = master->GetPositionY()+ sin(angle) * sPlayerbotAIConfig.followDistance;
+            float z = master->GetPositionZ();
+            if (master->IsWithinLOS(x, y, z))
+            {
+                bot->GetMotionMaster()->Clear();
+                bot->TeleportTo(mapId, x, y, z, 0);
+                return true;
+            }
+        }
+    }
+
+    ai->TellMasterNoFacing("There is not enough place to summon me");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
new file mode 100644
index 0000000..e787d24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class SummonAction : public MovementAction
+    {
+    public:
+        SummonAction(PlayerbotAI* ai, string name = "summon") : MovementAction(ai, name) {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        bool Teleport();
+    };
+
+    class UseMeetingStoneAction : public SummonAction
+    {
+    public:
+        UseMeetingStoneAction(PlayerbotAI* ai) : SummonAction(ai, "use meeting stone") {}
+
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/WhoAction.cpp b/src/plugins/playerbot/strategy/actions/WhoAction.cpp
new file mode 100644
index 0000000..9dd7f95
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WhoAction.cpp
@@ -0,0 +1,160 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WhoAction.h"
+#include "../../AiFactory.h"
+#include "../ItemVisitors.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+map<uint32, string> WhoAction::skills;
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+bool WhoAction::Execute(Event event)
+{
+    Player* owner = event.getOwner();
+    if (!owner)
+        return false;
+
+    string tell = "";
+    string text = event.getParam();
+    if (!text.empty())
+    {
+        if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+            return false;
+
+        tell = QuerySkill(text);
+        if (tell.empty())
+        {
+            tell = QueryTrade(text);
+        }
+    }
+    else
+    {
+        tell = QuerySpec(text);
+    }
+
+    if (tell.empty())
+        return false;
+
+    // ignore random bot chat filter
+	bot->Whisper(tell, LANG_UNIVERSAL, owner);
+    return true;
+}
+
+
+string WhoAction::QueryTrade(string text)
+{
+    ostringstream out;
+
+    list<Item*> items = InventoryAction::parseItems(text);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        Item* sell = *i;
+        int32 sellPrice = auctionbot.GetSellPrice(sell->GetTemplate()) * sRandomPlayerbotMgr.GetSellMultiplier(bot) * sell->GetCount();
+        if (!sellPrice)
+            continue;
+
+        out << "Selling " << chat->formatItem(sell->GetTemplate(), sell->GetCount()) << " for " << chat->formatMoney(sellPrice);
+        return out.str();
+    }
+
+    return "";
+}
+
+string WhoAction::QuerySkill(string text)
+{
+    ostringstream out;
+    InitSkills();
+
+    for (map<uint32, string>::iterator i = skills.begin(); i != skills.end(); ++i)
+    {
+        string name = i->second;
+        uint16 skill = i->first;
+        if (!strcmpi(text.c_str(), name.c_str()) && bot->HasSkill(skill))
+        {
+            string skillName = i->second;
+            uint32 spellId = AI_VALUE2(uint32, "spell id", skillName);
+            uint16 value = bot->GetSkillValue(skill);
+            uint16 maxSkill = bot->GetMaxSkillValue(skill);
+            ObjectGuid guid = bot->GetGUID();
+            string data = "0";
+            out << "|cFFFFFF00|Htrade:" << spellId << ":" << value << ":" << maxSkill << ":"
+                    << std::hex << std::uppercase << guid.GetRawValue()
+                    << std::nouppercase << std::dec << ":" << data
+                    << "|h[" << skills[skill] << "]|h|r"
+                    << " |h|cff00ff00" << value << "|h|cffffffff/"
+                    << "|h|cff00ff00" << maxSkill << "|h|cffffffff ";
+        }
+    }
+
+    return out.str();
+}
+
+string WhoAction::QuerySpec(string text)
+{
+    ostringstream out;
+
+    int spec = AiFactory::GetPlayerSpecTab(bot);
+    out << "|h|cffffffff" << chat->formatClass(bot, spec);
+    out << " (|h|cff00ff00" << (uint32)bot->getLevel() << "|h|cffffffff lvl), ";
+    out << "|h|cff00ff00" << ai->GetEquipGearScore(bot, false, false) << "|h|cffffffff GS (";
+
+    ItemCountByQuality visitor;
+    IterateItems(&visitor, ITERATE_ITEMS_IN_EQUIP);
+
+    bool needSlash = false;
+    if (visitor.count[ITEM_QUALITY_EPIC])
+    {
+        out << "|h|cffff00ff" << visitor.count[ITEM_QUALITY_EPIC] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    if (visitor.count[ITEM_QUALITY_RARE])
+    {
+        if (needSlash) out << "/";
+        out << "|h|cff8080ff" << visitor.count[ITEM_QUALITY_RARE] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    if (visitor.count[ITEM_QUALITY_UNCOMMON])
+    {
+        if (needSlash) out << "/";
+        out << "|h|cff00ff00" << visitor.count[ITEM_QUALITY_UNCOMMON] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    out << ")";
+
+    return out.str();
+}
+
+
+void WhoAction::InitSkills()
+{
+    if (!skills.empty())
+        return;
+
+    skills[SKILL_ALCHEMY] = "Alchemy";
+    skills[SKILL_ENCHANTING] = "Enchanting";
+    skills[SKILL_SKINNING] = "Skinning";
+    skills[SKILL_JEWELCRAFTING] = "Jewelcrafting";
+    skills[SKILL_INSCRIPTION] = "Inscription";
+    skills[SKILL_TAILORING] = "Tailoring";
+    skills[SKILL_LEATHERWORKING] = "Leatherworking";
+    skills[SKILL_ENGINEERING] = "Engineering";
+    skills[SKILL_HERBALISM] = "Herbalism";
+    skills[SKILL_MINING] = "Mining";
+    skills[SKILL_BLACKSMITHING] = "Blacksmithing";
+    skills[SKILL_COOKING] = "Cooking";
+    skills[SKILL_FIRST_AID] = "First Aid";
+    skills[SKILL_FISHING] = "Fishing";
+}
diff --git a/src/plugins/playerbot/strategy/actions/WhoAction.h b/src/plugins/playerbot/strategy/actions/WhoAction.h
new file mode 100644
index 0000000..92ed834
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WhoAction.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class WhoAction : public InventoryAction {
+    public:
+        WhoAction(PlayerbotAI* ai) : InventoryAction(ai, "who") {}
+
+    public:
+        virtual bool Execute(Event event);
+        static map<uint32, string> skills;
+
+    private:
+        void InitSkills();
+        string QueryTrade(string text);
+        string QuerySkill(string text);
+        string QuerySpec(string text);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h b/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
new file mode 100644
index 0000000..268f2d6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
@@ -0,0 +1,108 @@
+#pragma once
+
+#include "AcceptInvitationAction.h"
+#include "PassLeadershipToMasterAction.h"
+#include "TellMasterAction.h"
+#include "TalkToQuestGiverAction.h"
+#include "AcceptQuestAction.h"
+#include "LootRollAction.h"
+#include "ReviveFromCorpseAction.h"
+#include "AcceptResurrectAction.h"
+#include "UseMeetingStoneAction.h"
+#include "AreaTriggerAction.h"
+#include "CheckMountStateAction.h"
+#include "RememberTaxiAction.h"
+#include "TradeStatusAction.h"
+#include "InventoryChangeFailureAction.h"
+#include "LootAction.h"
+#include "QuestAction.h"
+#include "LeaveGroupAction.h"
+#include "TellCastFailedAction.h"
+#include "AcceptDuelAction.h"
+#include "ReadyCheckAction.h"
+#include "LfgActions.h"
+#include "SecurityCheckAction.h"
+#include "GuildAcceptAction.h"
+
+namespace ai
+{
+    class WorldPacketActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        WorldPacketActionContext()
+        {
+            creators["accept invitation"] = &WorldPacketActionContext::accept_invitation;
+            creators["leader"] = &WorldPacketActionContext::pass_leadership_to_master;
+            creators["tell not enough money"] = &WorldPacketActionContext::tell_not_enough_money;
+            creators["tell not enough reputation"] = &WorldPacketActionContext::tell_not_enough_reputation;
+            creators["tell cannot equip"] = &WorldPacketActionContext::tell_cannot_equip;
+            creators["talk to quest giver"] = &WorldPacketActionContext::turn_in_quest;
+            creators["accept quest"] = &WorldPacketActionContext::accept_quest;
+            creators["accept all quests"] = &WorldPacketActionContext::accept_all_quests;
+            creators["accept quest share"] = &WorldPacketActionContext::accept_quest_share;
+            creators["loot roll"] = &WorldPacketActionContext::loot_roll;
+            creators["revive from corpse"] = &WorldPacketActionContext::revive_from_corpse;
+            creators["accept resurrect"] = &WorldPacketActionContext::accept_resurrect;
+            creators["use meeting stone"] = &WorldPacketActionContext::use_meeting_stone;
+            creators["area trigger"] = &WorldPacketActionContext::area_trigger;
+            creators["reach area trigger"] = &WorldPacketActionContext::reach_area_trigger;
+            creators["check mount state"] = &WorldPacketActionContext::check_mount_state;
+            creators["remember taxi"] = &WorldPacketActionContext::remember_taxi;
+            creators["accept trade"] = &WorldPacketActionContext::accept_trade;
+            creators["store loot"] = &WorldPacketActionContext::store_loot;
+            creators["tell out of react range"] = &WorldPacketActionContext::tell_out_of_react_range;
+            creators["quest objective completed"] = &WorldPacketActionContext::quest_objective_completed;
+            creators["party command"] = &WorldPacketActionContext::party_command;
+            creators["tell cast failed"] = &WorldPacketActionContext::tell_cast_failed;
+            creators["accept duel"] = &WorldPacketActionContext::accept_duel;
+            creators["ready check"] = &WorldPacketActionContext::ready_check;
+            creators["ready check finished"] = &WorldPacketActionContext::ready_check_finished;
+            creators["uninvite"] = &WorldPacketActionContext::uninvite;
+            creators["lfg join"] = &WorldPacketActionContext::lfg_join;
+            creators["lfg accept"] = &WorldPacketActionContext::lfg_accept;
+            creators["lfg role check"] = &WorldPacketActionContext::lfg_role_check;
+            creators["lfg leave"] = &WorldPacketActionContext::lfg_leave;
+            creators["lfg teleport"] = &WorldPacketActionContext::lfg_teleport;
+            creators["security check"] = &WorldPacketActionContext::security_check;
+            creators["guild accept"] = &WorldPacketActionContext::guild_accept;
+        }
+
+    private:
+        static Action* guild_accept(PlayerbotAI* ai) { return new GuildAcceptAction(ai); }
+        static Action* security_check(PlayerbotAI* ai) { return new SecurityCheckAction(ai); }
+        static Action* lfg_teleport(PlayerbotAI* ai) { return new LfgTeleportAction(ai); }
+        static Action* lfg_leave(PlayerbotAI* ai) { return new LfgLeaveAction(ai); }
+        static Action* lfg_accept(PlayerbotAI* ai) { return new LfgAcceptAction(ai); }
+        static Action* lfg_role_check(PlayerbotAI* ai) { return new LfgRoleCheckAction(ai); }
+        static Action* lfg_join(PlayerbotAI* ai) { return new LfgJoinAction(ai); }
+        static Action* uninvite(PlayerbotAI* ai) { return new UninviteAction(ai); }
+        static Action* ready_check_finished(PlayerbotAI* ai) { return new FinishReadyCheckAction(ai); }
+        static Action* ready_check(PlayerbotAI* ai) { return new ReadyCheckAction(ai); }
+        static Action* accept_duel(PlayerbotAI* ai) { return new AcceptDuelAction(ai); }
+        static Action* tell_cast_failed(PlayerbotAI* ai) { return new TellCastFailedAction(ai); }
+        static Action* party_command(PlayerbotAI* ai) { return new PartyCommandAction(ai); }
+        static Action* quest_objective_completed(PlayerbotAI* ai) { return new QuestObjectiveCompletedAction(ai); }
+        static Action* store_loot(PlayerbotAI* ai) { return new StoreLootAction(ai); }
+        static Action* tell_out_of_react_range(PlayerbotAI* ai) { return new OutOfReactRangeAction(ai); }
+        static Action* accept_trade(PlayerbotAI* ai) { return new TradeStatusAction(ai); }
+        static Action* remember_taxi(PlayerbotAI* ai) { return new RememberTaxiAction(ai); }
+        static Action* check_mount_state(PlayerbotAI* ai) { return new CheckMountStateAction(ai); }
+        static Action* area_trigger(PlayerbotAI* ai) { return new AreaTriggerAction(ai); }
+        static Action* reach_area_trigger(PlayerbotAI* ai) { return new ReachAreaTriggerAction(ai); }
+        static Action* use_meeting_stone(PlayerbotAI* ai) { return new UseMeetingStoneAction(ai); }
+        static Action* accept_resurrect(PlayerbotAI* ai) { return new AcceptResurrectAction(ai); }
+        static Action* revive_from_corpse(PlayerbotAI* ai) { return new ReviveFromCorpseAction(ai); }
+        static Action* accept_invitation(PlayerbotAI* ai) { return new AcceptInvitationAction(ai); }
+        static Action* pass_leadership_to_master(PlayerbotAI* ai) { return new PassLeadershipToMasterAction(ai); }
+        static Action* tell_not_enough_money(PlayerbotAI* ai) { return new TellMasterAction(ai, "Not enough money"); }
+        static Action* tell_not_enough_reputation(PlayerbotAI* ai) { return new TellMasterAction(ai, "Not enough reputation"); }
+        static Action* tell_cannot_equip(PlayerbotAI* ai) { return new InventoryChangeFailureAction(ai); }
+        static Action* turn_in_quest(PlayerbotAI* ai) { return new TalkToQuestGiverAction(ai); }
+        static Action* accept_quest(PlayerbotAI* ai) { return new AcceptQuestAction(ai); }
+        static Action* accept_all_quests(PlayerbotAI* ai) { return new AcceptAllQuestsAction(ai); }
+        static Action* accept_quest_share(PlayerbotAI* ai) { return new AcceptQuestShareAction(ai); }
+        static Action* loot_roll(PlayerbotAI* ai) { return (QueryItemUsageAction*)new LootRollAction(ai); }
+    };
+
+
+};
diff --git a/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
new file mode 100644
index 0000000..4bb8004
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
@@ -0,0 +1,172 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "BearTankDruidStrategy.h"
+
+using namespace ai;
+
+class BearTankDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    BearTankDruidStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["feral charge - bear"] = &feral_charge_bear;
+        creators["swipe (bear)"] = &swipe_bear;
+        creators["faerie fire (feral)"] = &faerie_fire_feral;
+        creators["bear form"] = &bear_form;
+        creators["dire bear form"] = &dire_bear_form;
+        creators["mangle (bear)"] = &mangle_bear;
+        creators["maul"] = &maul;
+        creators["bash"] = &bash;
+        creators["swipe"] = &swipe;
+        creators["lacerate"] = &lacerate;
+        creators["demoralizing roar"] = &demoralizing_roar;
+    }
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - bear"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* feral_charge_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feral charge - bear",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* swipe_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("swipe (bear)",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* faerie_fire_feral(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire (feral)",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - bear"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* bear_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bear form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* dire_bear_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("dire bear form",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("bear form"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mangle_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mangle (bear)",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lacerate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* maul(PlayerbotAI* ai)
+    {
+        return new ActionNode ("maul",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* bash(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bash",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* swipe(PlayerbotAI* ai)
+    {
+        return new ActionNode ("swipe",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lacerate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lacerate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("maul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* growl(PlayerbotAI* ai)
+    {
+        return new ActionNode ("growl",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* demoralizing_roar(PlayerbotAI* ai)
+    {
+        return new ActionNode ("demoralizing roar",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+BearTankDruidStrategy::BearTankDruidStrategy(PlayerbotAI* ai) : FeralDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new BearTankDruidStrategyActionNodeFactory());
+}
+
+NextAction** BearTankDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0,
+            new NextAction("lacerate", ACTION_NORMAL + 4),
+            new NextAction("mangle (bear)", ACTION_NORMAL + 3),
+            new NextAction("maul", ACTION_NORMAL + 2),
+            new NextAction("faerie fire (feral)", ACTION_NORMAL + 1),
+            new NextAction("melee", ACTION_NORMAL),
+            NULL);
+}
+
+void BearTankDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    FeralDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "thorns",
+        NextAction::array(0, new NextAction("thorns", ACTION_HIGH + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bear form",
+        NextAction::array(0, new NextAction("dire bear form", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "faerie fire (feral)",
+        NextAction::array(0, new NextAction("faerie fire (feral)", ACTION_HIGH + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("growl", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("demoralizing roar", ACTION_HIGH + 6), new NextAction("swipe (bear)", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("swipe (bear)", ACTION_HIGH + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bash",
+        NextAction::array(0, new NextAction("bash", ACTION_INTERRUPT + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bash on enemy healer",
+        NextAction::array(0, new NextAction("bash on enemy healer", ACTION_INTERRUPT + 1), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
new file mode 100644
index 0000000..1e8a3f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "FeralDruidStrategy.h"
+
+namespace ai
+{
+    class BearTankDruidStrategy : public FeralDruidStrategy
+    {
+    public:
+        BearTankDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bear"; }
+        virtual NextAction** getDefaultActions();
+		virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
new file mode 100644
index 0000000..bb07940
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
@@ -0,0 +1,177 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "CasterDruidStrategy.h"
+#include "FeralDruidStrategy.h"
+
+using namespace ai;
+
+class CasterDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CasterDruidStrategyActionNodeFactory()
+    {
+        creators["faerie fire"] = &faerie_fire;
+        creators["hibernate"] = &hibernate;
+        creators["entangling roots"] = &entangling_roots;
+        creators["entangling roots on cc"] = &entangling_roots_on_cc;
+        creators["wrath"] = &wrath;
+        creators["starfall"] = &starfall;
+        creators["insect swarm"] = &insect_swarm;
+        creators["moonfire"] = &moonfire;
+        creators["starfire"] = &starfire;
+        creators["nature's grasp"] = &natures_grasp;
+    }
+private:
+    static ActionNode* faerie_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* hibernate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("hibernate",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("entangling roots"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flee", 49.0f), NULL));
+    }
+    static ActionNode* entangling_roots(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("flee", 49.0f), NULL));
+    }
+    static ActionNode* entangling_roots_on_cc(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots on cc",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* wrath(PlayerbotAI* ai)
+    {
+        return new ActionNode ("wrath",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* starfall(PlayerbotAI* ai)
+    {
+        return new ActionNode ("starfall",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("hurricane"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* insect_swarm(PlayerbotAI* ai)
+    {
+        return new ActionNode ("insect swarm",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* moonfire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("moonfire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* starfire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("starfire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* natures_grasp(PlayerbotAI* ai)
+    {
+        return new ActionNode ("nature's grasp",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+CasterDruidStrategy::CasterDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new CasterDruidStrategyActionNodeFactory());
+    actionNodeFactories.Add(new ShapeshiftDruidStrategyActionNodeFactory());
+}
+
+NextAction** CasterDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("starfire", ACTION_NORMAL + 2), new NextAction("wrath", ACTION_NORMAL + 1), NULL);
+}
+
+void CasterDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_MOVE), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("rejuvenation", ACTION_LIGHT_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("rejuvenation on party", ACTION_LIGHT_HEAL + 1), NULL)));
+
+
+	triggers.push_back(new TriggerNode(
+		"insect swarm",
+		NextAction::array(0, new NextAction("insect swarm", ACTION_NORMAL + 5), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"moonfire",
+		NextAction::array(0, new NextAction("moonfire", ACTION_NORMAL + 4), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "eclipse (solar)",
+        NextAction::array(0, new NextAction("wrath", ACTION_NORMAL + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "eclipse (lunar)",
+        NextAction::array(0, new NextAction("starfire", ACTION_NORMAL + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "moonfire",
+        NextAction::array(0, new NextAction("moonfire", ACTION_NORMAL + 4), NULL)));
+
+
+
+	triggers.push_back(new TriggerNode(
+		"nature's grasp",
+		NextAction::array(0, new NextAction("nature's grasp", ACTION_EMERGENCY), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 2), NULL)));
+}
+
+void CasterDruidAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("starfall", ACTION_HIGH + 1), NULL)));
+}
+
+void CasterDruidDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "faerie fire",
+        NextAction::array(0, new NextAction("faerie fire", ACTION_HIGH), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
new file mode 100644
index 0000000..66ac838
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class CasterDruidStrategy : public GenericDruidStrategy
+    {
+    public:
+        CasterDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_RANGED; }
+    };
+
+    class CasterDruidAoeStrategy : public CombatStrategy
+    {
+    public:
+        CasterDruidAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster aoe"; }
+    };
+
+    class CasterDruidDebuffStrategy : public CombatStrategy
+    {
+    public:
+        CasterDruidDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
new file mode 100644
index 0000000..67515b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
@@ -0,0 +1,139 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "CatDpsDruidStrategy.h"
+
+using namespace ai;
+
+class CatDpsDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CatDpsDruidStrategyActionNodeFactory()
+    {
+        creators["faerie fire (feral)"] = &faerie_fire_feral;
+        creators["melee"] = &melee;
+        creators["feral charge - cat"] = &feral_charge_cat;
+        creators["cat form"] = &cat_form;
+        creators["claw"] = &claw;
+        creators["mangle (cat)"] = &mangle_cat;
+        creators["rake"] = &rake;
+        creators["ferocious bite"] = &ferocious_bite;
+        creators["rip"] = &rip;
+    }
+private:
+    static ActionNode* faerie_fire_feral(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire (feral)",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - cat"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* feral_charge_cat(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feral charge - cat",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* cat_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cat form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* claw(PlayerbotAI* ai)
+    {
+        return new ActionNode ("claw",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mangle_cat(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mangle (cat)",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("claw"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rake(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rake",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* ferocious_bite(PlayerbotAI* ai)
+    {
+        return new ActionNode ("ferocious bite",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rip"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rip(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rip",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+CatDpsDruidStrategy::CatDpsDruidStrategy(PlayerbotAI* ai) : FeralDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new CatDpsDruidStrategyActionNodeFactory());
+}
+
+NextAction** CatDpsDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("mangle (cat)", ACTION_NORMAL + 1), NULL);
+}
+
+void CatDpsDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    FeralDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "cat form",
+        NextAction::array(0, new NextAction("cat form", ACTION_MOVE + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rake",
+        NextAction::array(0, new NextAction("rake", ACTION_NORMAL + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "combo points available",
+        NextAction::array(0, new NextAction("ferocious bite", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("cower", ACTION_EMERGENCY + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "faerie fire (feral)",
+        NextAction::array(0, new NextAction("faerie fire (feral)", ACTION_HIGH + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"tiger's fury",
+		NextAction::array(0, new NextAction("tiger's fury", ACTION_EMERGENCY + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 1), NULL)));
+
+}
+
+void CatAoeDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("swipe (cat)", ACTION_HIGH + 2), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
new file mode 100644
index 0000000..397f0b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "FeralDruidStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class CatDpsDruidStrategy : public FeralDruidStrategy
+    {
+    public:
+        CatDpsDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "cat"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+    class CatAoeDruidStrategy : public CombatStrategy
+    {
+    public:
+        CatAoeDruidStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "cat aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidActions.cpp b/src/plugins/playerbot/strategy/druid/DruidActions.cpp
new file mode 100644
index 0000000..fc49e68
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidActions.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidActions.h"
+
+using namespace ai;
+
+bool CastCasterFormAction::Execute(Event event)
+{
+    ai->RemoveShapeshift();
+    return true;
+}
+
+NextAction** CastAbolishPoisonAction::getAlternatives()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("cure poison"), NULL), CastSpellAction::getPrerequisites());
+}
+
+NextAction** CastAbolishPoisonOnPartyAction::getAlternatives()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("cure poison on party"), NULL), CastSpellAction::getPrerequisites());
+}
+
+Value<Unit*>* CastEntanglingRootsCcAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", "entangling roots");
+}
+
+bool CastEntanglingRootsCcAction::Execute(Event event)
+{
+    return ai->CastSpell("entangling roots", GetTarget()); 
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidActions.h b/src/plugins/playerbot/strategy/druid/DruidActions.h
new file mode 100644
index 0000000..965f454
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidActions.h
@@ -0,0 +1,205 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+#include "DruidShapeshiftActions.h"
+#include "DruidBearActions.h"
+#include "DruidCatActions.h"
+
+namespace ai
+{
+	class CastFaerieFireAction : public CastSpellAction
+	{
+	public:
+		CastFaerieFireAction(PlayerbotAI* ai) : CastSpellAction(ai, "faerie fire") {}
+	};
+
+    class CastFaerieFireFeralAction : public CastSpellAction
+    {
+    public:
+        CastFaerieFireFeralAction(PlayerbotAI* ai) : CastSpellAction(ai, "faerie fire (feral)") {}
+    };
+
+	class CastRejuvenationAction : public CastHealingSpellAction {
+	public:
+		CastRejuvenationAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "rejuvenation") {}
+	};
+
+	class CastRegrowthAction : public CastHealingSpellAction {
+	public:
+		CastRegrowthAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "regrowth") {}
+
+	};
+
+    class CastHealingTouchAction : public CastHealingSpellAction {
+    public:
+        CastHealingTouchAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "healing touch") {}
+
+    };
+
+    class CastRejuvenationOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRejuvenationOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "rejuvenation") {}
+    };
+
+    class CastRegrowthOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRegrowthOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "regrowth") {}
+    };
+
+    class CastHealingTouchOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealingTouchOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "healing touch") {}
+    };
+
+	class CastReviveAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastReviveAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "revive") {}
+
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("caster form"), NULL), ResurrectPartyMemberAction::getPrerequisites());
+		}
+	};
+
+	class CastRebirthAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastRebirthAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "rebirth") {}
+
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("caster form"), NULL), ResurrectPartyMemberAction::getPrerequisites());
+		}
+	};
+
+	class CastMarkOfTheWildAction : public CastBuffSpellAction {
+	public:
+		CastMarkOfTheWildAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "mark of the wild") {}
+	};
+
+	class CastMarkOfTheWildOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastMarkOfTheWildOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "mark of the wild") {}
+	};
+
+	class CastSurvivalInstinctsAction : public CastBuffSpellAction {
+	public:
+		CastSurvivalInstinctsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "survival instincts") {}
+	};
+
+	class CastThornsAction : public CastBuffSpellAction {
+	public:
+		CastThornsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "thorns") {}
+	};
+
+	class CastWrathAction : public CastSpellAction
+	{
+	public:
+		CastWrathAction(PlayerbotAI* ai) : CastSpellAction(ai, "wrath") {}
+	};
+
+	class CastStarfallAction : public CastSpellAction
+	{
+	public:
+		CastStarfallAction(PlayerbotAI* ai) : CastSpellAction(ai, "starfall") {}
+	};
+
+	class CastHurricaneAction : public CastSpellAction
+	{
+	public:
+	    CastHurricaneAction(PlayerbotAI* ai) : CastSpellAction(ai, "hurricane") {}
+	};
+
+	class CastMoonfireAction : public CastDebuffSpellAction
+	{
+	public:
+		CastMoonfireAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "moonfire") {}
+	};
+
+	class CastInsectSwarmAction : public CastDebuffSpellAction
+	{
+	public:
+		CastInsectSwarmAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "insect swarm") {}
+	};
+
+	class CastStarfireAction : public CastSpellAction
+	{
+	public:
+		CastStarfireAction(PlayerbotAI* ai) : CastSpellAction(ai, "starfire") {}
+	};
+
+	class CastEntanglingRootsAction : public CastSpellAction
+	{
+	public:
+		CastEntanglingRootsAction(PlayerbotAI* ai) : CastSpellAction(ai, "entangling roots") {}
+	};
+
+    class CastEntanglingRootsCcAction : public CastSpellAction
+    {
+    public:
+        CastEntanglingRootsCcAction(PlayerbotAI* ai) : CastSpellAction(ai, "entangling roots on cc") {}
+        virtual Value<Unit*>* GetTargetValue();
+        virtual bool Execute(Event event);
+    };
+
+	class CastNaturesGraspAction : public CastBuffSpellAction
+	{
+	public:
+		CastNaturesGraspAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "nature's grasp") {}
+	};
+
+	class CastHibernateAction : public CastSpellAction
+	{
+	public:
+		CastHibernateAction(PlayerbotAI* ai) : CastSpellAction(ai, "hibernate") {}
+	};
+
+	class CastCurePoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastCurePoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cure poison") {}
+	};
+
+    class CastCurePoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCurePoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+	class CastAbolishPoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastAbolishPoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "abolish poison") {}
+		virtual NextAction** getAlternatives();
+	};
+
+    class CastAbolishPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastAbolishPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "abolish poison", DISPEL_POISON) {}
+
+        virtual NextAction** getAlternatives();
+    };
+
+    class CastBarskinAction : public CastBuffSpellAction
+    {
+    public:
+        CastBarskinAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "barskin") {}
+    };
+
+    class CastInnervateAction : public CastSpellAction
+    {
+    public:
+        CastInnervateAction(PlayerbotAI* ai) : CastSpellAction(ai, "innervate") {}
+
+        virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CastTranquilityAction : public CastAoeHealSpellAction
+    {
+    public:
+        CastTranquilityAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "tranquility") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
new file mode 100644
index 0000000..65c9fc9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
@@ -0,0 +1,258 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidActions.h"
+#include "DruidAiObjectContext.h"
+#include "BearTankDruidStrategy.h"
+#include "CatDpsDruidStrategy.h"
+#include "CasterDruidStrategy.h"
+#include "GenericDruidNonCombatStrategy.h"
+#include "../NamedObjectContext.h"
+#include "DruidTriggers.h"
+#include "HealDruidStrategy.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &druid::StrategyFactoryInternal::nc;
+                creators["cat aoe"] = &druid::StrategyFactoryInternal::cat_aoe;
+                creators["caster aoe"] = &druid::StrategyFactoryInternal::caster_aoe;
+                creators["caster debuff"] = &druid::StrategyFactoryInternal::caster_debuff;
+                creators["dps debuff"] = &druid::StrategyFactoryInternal::caster_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericDruidNonCombatStrategy(ai); }
+            static Strategy* cat_aoe(PlayerbotAI* ai) { return new CatAoeDruidStrategy(ai); }
+            static Strategy* caster_aoe(PlayerbotAI* ai) { return new CasterDruidAoeStrategy(ai); }
+            static Strategy* caster_debuff(PlayerbotAI* ai) { return new CasterDruidDebuffStrategy(ai); }
+        };
+
+        class DruidStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            DruidStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bear"] = &druid::DruidStrategyFactoryInternal::bear;
+                creators["tank"] = &druid::DruidStrategyFactoryInternal::bear;
+                creators["cat"] = &druid::DruidStrategyFactoryInternal::cat;
+                creators["caster"] = &druid::DruidStrategyFactoryInternal::caster;
+                creators["dps"] = &druid::DruidStrategyFactoryInternal::cat;
+                creators["heal"] = &druid::DruidStrategyFactoryInternal::heal;
+            }
+
+        private:
+            static Strategy* bear(PlayerbotAI* ai) { return new BearTankDruidStrategy(ai); }
+            static Strategy* cat(PlayerbotAI* ai) { return new CatDpsDruidStrategy(ai); }
+            static Strategy* caster(PlayerbotAI* ai) { return new CasterDruidStrategy(ai); }
+            static Strategy* heal(PlayerbotAI* ai) { return new HealDruidStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["thorns"] = &TriggerFactoryInternal::Thorns;
+                creators["bash"] = &TriggerFactoryInternal::bash;
+                creators["faerie fire (feral)"] = &TriggerFactoryInternal::faerie_fire_feral;
+                creators["faerie fire"] = &TriggerFactoryInternal::faerie_fire;
+                creators["insect swarm"] = &TriggerFactoryInternal::insect_swarm;
+                creators["moonfire"] = &TriggerFactoryInternal::moonfire;
+                creators["nature's grasp"] = &TriggerFactoryInternal::natures_grasp;
+                creators["tiger's fury"] = &TriggerFactoryInternal::tigers_fury;
+                creators["rake"] = &TriggerFactoryInternal::rake;
+                creators["mark of the wild"] = &TriggerFactoryInternal::mark_of_the_wild;
+                creators["mark of the wild on party"] = &TriggerFactoryInternal::mark_of_the_wild_on_party;
+                creators["cure poison"] = &TriggerFactoryInternal::cure_poison;
+                creators["party member cure poison"] = &TriggerFactoryInternal::party_member_cure_poison;
+                creators["entangling roots"] = &TriggerFactoryInternal::entangling_roots;
+                creators["bear form"] = &TriggerFactoryInternal::bear_form;
+                creators["cat form"] = &TriggerFactoryInternal::cat_form;
+                creators["tree form"] = &TriggerFactoryInternal::tree_form;
+                creators["eclipse (solar)"] = &TriggerFactoryInternal::eclipse_solar;
+                creators["eclipse (lunar)"] = &TriggerFactoryInternal::eclipse_lunar;
+                creators["bash on enemy healer"] = &TriggerFactoryInternal::bash_on_enemy_healer;
+            }
+
+        private:
+            static Trigger* eclipse_solar(PlayerbotAI* ai) { return new EclipseSolarTrigger(ai); }
+            static Trigger* eclipse_lunar(PlayerbotAI* ai) { return new EclipseLunarTrigger(ai); }
+            static Trigger* Thorns(PlayerbotAI* ai) { return new ThornsTrigger(ai); }
+            static Trigger* bash(PlayerbotAI* ai) { return new BashInterruptSpellTrigger(ai); }
+            static Trigger* faerie_fire_feral(PlayerbotAI* ai) { return new FaerieFireFeralTrigger(ai); }
+            static Trigger* insect_swarm(PlayerbotAI* ai) { return new InsectSwarmTrigger(ai); }
+            static Trigger* moonfire(PlayerbotAI* ai) { return new MoonfireTrigger(ai); }
+            static Trigger* faerie_fire(PlayerbotAI* ai) { return new FaerieFireTrigger(ai); }
+            static Trigger* natures_grasp(PlayerbotAI* ai) { return new NaturesGraspTrigger(ai); }
+            static Trigger* tigers_fury(PlayerbotAI* ai) { return new TigersFuryTrigger(ai); }
+            static Trigger* rake(PlayerbotAI* ai) { return new RakeTrigger(ai); }
+            static Trigger* mark_of_the_wild(PlayerbotAI* ai) { return new MarkOfTheWildTrigger(ai); }
+            static Trigger* mark_of_the_wild_on_party(PlayerbotAI* ai) { return new MarkOfTheWildOnPartyTrigger(ai); }
+            static Trigger* cure_poison(PlayerbotAI* ai) { return new CurePoisonTrigger(ai); }
+            static Trigger* party_member_cure_poison(PlayerbotAI* ai) { return new PartyMemberCurePoisonTrigger(ai); }
+            static Trigger* entangling_roots(PlayerbotAI* ai) { return new EntanglingRootsTrigger(ai); }
+            static Trigger* bear_form(PlayerbotAI* ai) { return new BearFormTrigger(ai); }
+            static Trigger* cat_form(PlayerbotAI* ai) { return new CatFormTrigger(ai); }
+            static Trigger* tree_form(PlayerbotAI* ai) { return new TreeFormTrigger(ai); }
+            static Trigger* bash_on_enemy_healer(PlayerbotAI* ai) { return new BashInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["feral charge - bear"] = &AiObjectContextInternal::feral_charge_bear;
+                creators["feral charge - cat"] = &AiObjectContextInternal::feral_charge_cat;
+                creators["swipe (bear)"] = &AiObjectContextInternal::swipe_bear;
+                creators["faerie fire (feral)"] = &AiObjectContextInternal::faerie_fire_feral;
+                creators["faerie fire"] = &AiObjectContextInternal::faerie_fire;
+                creators["bear form"] = &AiObjectContextInternal::bear_form;
+                creators["dire bear form"] = &AiObjectContextInternal::dire_bear_form;
+                creators["moonkin form"] = &AiObjectContextInternal::moonkin_form;
+                creators["cat form"] = &AiObjectContextInternal::cat_form;
+                creators["tree form"] = &AiObjectContextInternal::tree_form;
+                creators["caster form"] = &AiObjectContextInternal::caster_form;
+                creators["mangle (bear)"] = &AiObjectContextInternal::mangle_bear;
+                creators["maul"] = &AiObjectContextInternal::maul;
+                creators["bash"] = &AiObjectContextInternal::bash;
+                creators["swipe"] = &AiObjectContextInternal::swipe;
+                creators["growl"] = &AiObjectContextInternal::growl;
+                creators["demoralizing roar"] = &AiObjectContextInternal::demoralizing_roar;
+                creators["hibernate"] = &AiObjectContextInternal::hibernate;
+                creators["entangling roots"] = &AiObjectContextInternal::entangling_roots;
+                creators["entangling roots on cc"] = &AiObjectContextInternal::entangling_roots_on_cc;
+                creators["wrath"] = &AiObjectContextInternal::wrath;
+                creators["starfall"] = &AiObjectContextInternal::starfall;
+                creators["insect swarm"] = &AiObjectContextInternal::insect_swarm;
+                creators["moonfire"] = &AiObjectContextInternal::moonfire;
+                creators["starfire"] = &AiObjectContextInternal::starfire;
+                creators["nature's grasp"] = &AiObjectContextInternal::natures_grasp;
+                creators["claw"] = &AiObjectContextInternal::claw;
+                creators["mangle (cat)"] = &AiObjectContextInternal::mangle_cat;
+                creators["swipe (cat)"] = &AiObjectContextInternal::swipe_cat;
+                creators["rake"] = &AiObjectContextInternal::rake;
+                creators["ferocious bite"] = &AiObjectContextInternal::ferocious_bite;
+                creators["rip"] = &AiObjectContextInternal::rip;
+                creators["cower"] = &AiObjectContextInternal::cower;
+                creators["survival instincts"] = &AiObjectContextInternal::survival_instincts;
+                creators["thorns"] = &AiObjectContextInternal::thorns;
+                creators["cure poison"] = &AiObjectContextInternal::cure_poison;
+                creators["cure poison on party"] = &AiObjectContextInternal::cure_poison_on_party;
+                creators["abolish poison"] = &AiObjectContextInternal::abolish_poison;
+                creators["abolish poison on party"] = &AiObjectContextInternal::abolish_poison_on_party;
+                creators["berserk"] = &AiObjectContextInternal::berserk;
+                creators["tiger's fury"] = &AiObjectContextInternal::tigers_fury;
+                creators["mark of the wild"] = &AiObjectContextInternal::mark_of_the_wild;
+                creators["mark of the wild on party"] = &AiObjectContextInternal::mark_of_the_wild_on_party;
+                creators["regrowth"] = &AiObjectContextInternal::regrowth;
+                creators["rejuvenation"] = &AiObjectContextInternal::rejuvenation;
+                creators["healing touch"] = &AiObjectContextInternal::healing_touch;
+                creators["regrowth on party"] = &AiObjectContextInternal::regrowth_on_party;
+                creators["rejuvenation on party"] = &AiObjectContextInternal::rejuvenation_on_party;
+                creators["healing touch on party"] = &AiObjectContextInternal::healing_touch_on_party;
+                creators["rebirth"] = &AiObjectContextInternal::rebirth;
+                creators["revive"] = &AiObjectContextInternal::revive;
+                creators["barskin"] = &AiObjectContextInternal::barskin;
+                creators["lacerate"] = &AiObjectContextInternal::lacerate;
+                creators["hurricane"] = &AiObjectContextInternal::hurricane;
+                creators["innervate"] = &AiObjectContextInternal::innervate;
+                creators["tranquility"] = &AiObjectContextInternal::tranquility;
+                creators["bash on enemy healer"] = &AiObjectContextInternal::bash_on_enemy_healer;
+            }
+
+        private:
+            static Action* tranquility(PlayerbotAI* ai) { return new CastTranquilityAction(ai); }
+            static Action* feral_charge_bear(PlayerbotAI* ai) { return new CastFeralChargeBearAction(ai); }
+            static Action* feral_charge_cat(PlayerbotAI* ai) { return new CastFeralChargeCatAction(ai); }
+            static Action* swipe_bear(PlayerbotAI* ai) { return new CastSwipeBearAction(ai); }
+            static Action* faerie_fire_feral(PlayerbotAI* ai) { return new CastFaerieFireFeralAction(ai); }
+            static Action* faerie_fire(PlayerbotAI* ai) { return new CastFaerieFireAction(ai); }
+            static Action* bear_form(PlayerbotAI* ai) { return new CastBearFormAction(ai); }
+            static Action* dire_bear_form(PlayerbotAI* ai) { return new CastDireBearFormAction(ai); }
+            static Action* cat_form(PlayerbotAI* ai) { return new CastCatFormAction(ai); }
+            static Action* tree_form(PlayerbotAI* ai) { return new CastTreeFormAction(ai); }
+            static Action* caster_form(PlayerbotAI* ai) { return new CastCasterFormAction(ai); }
+            static Action* mangle_bear(PlayerbotAI* ai) { return new CastMangleBearAction(ai); }
+            static Action* maul(PlayerbotAI* ai) { return new CastMaulAction(ai); }
+            static Action* bash(PlayerbotAI* ai) { return new CastBashAction(ai); }
+            static Action* swipe(PlayerbotAI* ai) { return new CastSwipeAction(ai); }
+            static Action* growl(PlayerbotAI* ai) { return new CastGrowlAction(ai); }
+            static Action* demoralizing_roar(PlayerbotAI* ai) { return new CastDemoralizingRoarAction(ai); }
+            static Action* moonkin_form(PlayerbotAI* ai) { return new CastMoonkinFormAction(ai); }
+            static Action* hibernate(PlayerbotAI* ai) { return new CastHibernateAction(ai); }
+            static Action* entangling_roots(PlayerbotAI* ai) { return new CastEntanglingRootsAction(ai); }
+            static Action* entangling_roots_on_cc(PlayerbotAI* ai) { return new CastEntanglingRootsCcAction(ai); }
+            static Action* wrath(PlayerbotAI* ai) { return new CastWrathAction(ai); }
+            static Action* starfall(PlayerbotAI* ai) { return new CastStarfallAction(ai); }
+            static Action* insect_swarm(PlayerbotAI* ai) { return new CastInsectSwarmAction(ai); }
+            static Action* moonfire(PlayerbotAI* ai) { return new CastMoonfireAction(ai); }
+            static Action* starfire(PlayerbotAI* ai) { return new CastStarfireAction(ai); }
+            static Action* natures_grasp(PlayerbotAI* ai) { return new CastNaturesGraspAction(ai); }
+            static Action* claw(PlayerbotAI* ai) { return new CastClawAction(ai); }
+            static Action* mangle_cat(PlayerbotAI* ai) { return new CastMangleCatAction(ai); }
+            static Action* swipe_cat(PlayerbotAI* ai) { return new CastSwipeCatAction(ai); }
+            static Action* rake(PlayerbotAI* ai) { return new CastRakeAction(ai); }
+            static Action* ferocious_bite(PlayerbotAI* ai) { return new CastFerociousBiteAction(ai); }
+            static Action* rip(PlayerbotAI* ai) { return new CastRipAction(ai); }
+            static Action* cower(PlayerbotAI* ai) { return new CastCowerAction(ai); }
+            static Action* survival_instincts(PlayerbotAI* ai) { return new CastSurvivalInstinctsAction(ai); }
+            static Action* thorns(PlayerbotAI* ai) { return new CastThornsAction(ai); }
+            static Action* cure_poison(PlayerbotAI* ai) { return new CastCurePoisonAction(ai); }
+            static Action* cure_poison_on_party(PlayerbotAI* ai) { return new CastCurePoisonOnPartyAction(ai); }
+            static Action* abolish_poison(PlayerbotAI* ai) { return new CastAbolishPoisonAction(ai); }
+            static Action* abolish_poison_on_party(PlayerbotAI* ai) { return new CastAbolishPoisonOnPartyAction(ai); }
+            static Action* berserk(PlayerbotAI* ai) { return new CastBerserkAction(ai); }
+            static Action* tigers_fury(PlayerbotAI* ai) { return new CastTigersFuryAction(ai); }
+            static Action* mark_of_the_wild(PlayerbotAI* ai) { return new CastMarkOfTheWildAction(ai); }
+            static Action* mark_of_the_wild_on_party(PlayerbotAI* ai) { return new CastMarkOfTheWildOnPartyAction(ai); }
+            static Action* regrowth(PlayerbotAI* ai) { return new CastRegrowthAction(ai); }
+            static Action* rejuvenation(PlayerbotAI* ai) { return new CastRejuvenationAction(ai); }
+            static Action* healing_touch(PlayerbotAI* ai) { return new CastHealingTouchAction(ai); }
+            static Action* regrowth_on_party(PlayerbotAI* ai) { return new CastRegrowthOnPartyAction(ai); }
+            static Action* rejuvenation_on_party(PlayerbotAI* ai) { return new CastRejuvenationOnPartyAction(ai); }
+            static Action* healing_touch_on_party(PlayerbotAI* ai) { return new CastHealingTouchOnPartyAction(ai); }
+            static Action* rebirth(PlayerbotAI* ai) { return new CastRebirthAction(ai); }
+            static Action* revive(PlayerbotAI* ai) { return new CastReviveAction(ai); }
+            static Action* barskin(PlayerbotAI* ai) { return new CastBarskinAction(ai); }
+            static Action* lacerate(PlayerbotAI* ai) { return new CastLacerateAction(ai); }
+            static Action* hurricane(PlayerbotAI* ai) { return new CastHurricaneAction(ai); }
+            static Action* innervate(PlayerbotAI* ai) { return new CastInnervateAction(ai); }
+            static Action* bash_on_enemy_healer(PlayerbotAI* ai) { return new CastBashOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+DruidAiObjectContext::DruidAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::druid::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::druid::DruidStrategyFactoryInternal());
+    actionContexts.Add(new ai::druid::AiObjectContextInternal());
+    triggerContexts.Add(new ai::druid::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
new file mode 100644
index 0000000..b5d7a2c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class DruidAiObjectContext : public AiObjectContext
+    {
+    public:
+        DruidAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidBearActions.h b/src/plugins/playerbot/strategy/druid/DruidBearActions.h
new file mode 100644
index 0000000..81bc8ab
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidBearActions.h
@@ -0,0 +1,64 @@
+#pragma once
+
+namespace ai {
+	class CastFeralChargeBearAction : public CastReachTargetSpellAction
+	{
+	public:
+		CastFeralChargeBearAction(PlayerbotAI* ai) : CastReachTargetSpellAction(ai, "feral charge - bear", 1.5f) {}
+	};
+
+	class CastGrowlAction : public CastSpellAction
+	{
+	public:
+		CastGrowlAction(PlayerbotAI* ai) : CastSpellAction(ai, "growl") {}
+	};
+
+	class CastMaulAction : public CastMeleeSpellAction
+	{
+	public:
+		CastMaulAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "maul") {}
+		virtual bool isUseful() { return CastMeleeSpellAction::isUseful() && AI_VALUE2(uint8, "rage", "self target") >= 45; }
+	};
+
+	class CastBashAction : public CastMeleeSpellAction
+	{
+	public:
+		CastBashAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "bash") {}
+	};
+
+	class CastSwipeAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSwipeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe") {}
+	};
+
+	class CastDemoralizingRoarAction : public CastDebuffSpellAction
+	{
+	public:
+		CastDemoralizingRoarAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "demoralizing roar") {}
+	};
+
+	class CastMangleBearAction : public CastMeleeSpellAction
+	{
+	public:
+		CastMangleBearAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mangle (bear)") {}
+	};
+
+	class CastSwipeBearAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSwipeBearAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe (bear)") {}
+	};
+
+    class CastLacerateAction : public CastMeleeSpellAction
+    {
+    public:
+        CastLacerateAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "lacerate") {}
+    };
+
+    class CastBashOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastBashOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidCatActions.h b/src/plugins/playerbot/strategy/druid/DruidCatActions.h
new file mode 100644
index 0000000..89a3e66
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidCatActions.h
@@ -0,0 +1,64 @@
+#pragma once
+
+namespace ai {
+	class CastFeralChargeCatAction : public CastReachTargetSpellAction
+	{
+	public:
+		CastFeralChargeCatAction(PlayerbotAI* ai) : CastReachTargetSpellAction(ai, "feral charge - cat", 1.5f) {}
+	};
+
+	class CastCowerAction : public CastBuffSpellAction
+	{
+	public:
+		CastCowerAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "cower") {}
+	};
+
+
+	class CastBerserkAction : public CastBuffSpellAction
+	{
+	public:
+		CastBerserkAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "berserk") {}
+	};
+
+	class CastTigersFuryAction : public CastBuffSpellAction
+	{
+	public:
+		CastTigersFuryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "tiger's fury") {}
+	};
+
+	class CastRakeAction : public CastDebuffSpellAction
+	{
+	public:
+		CastRakeAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "rake") {}
+	};
+
+
+	class CastClawAction : public CastMeleeSpellAction {
+	public:
+		CastClawAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "claw") {}
+	};
+
+	class CastMangleCatAction : public CastMeleeSpellAction {
+	public:
+		CastMangleCatAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mangle (cat)") {}
+	};
+
+	class CastSwipeCatAction : public CastMeleeSpellAction {
+	public:
+		CastSwipeCatAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe (cat)") {}
+	};
+
+	class CastFerociousBiteAction : public CastMeleeSpellAction {
+	public:
+		CastFerociousBiteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "ferocious bite") {}
+	};
+
+
+	class CastRipAction : public CastMeleeSpellAction {
+	public:
+		CastRipAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "rip") {}
+	};
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp b/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
new file mode 100644
index 0000000..d273c7c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "DruidActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidMultipliers.h b/src/plugins/playerbot/strategy/druid/DruidMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h b/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
new file mode 100644
index 0000000..746c635
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
@@ -0,0 +1,53 @@
+#pragma once
+
+namespace ai {
+	class CastBearFormAction : public CastBuffSpellAction { 
+	public: 
+		CastBearFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bear form") {} 
+
+        virtual bool isPossible() {
+			return CastBuffSpellAction::isPossible() && !ai->HasAura("dire bear form", GetTarget());
+		}
+        virtual bool isUseful() {
+			return CastBuffSpellAction::isUseful() && !ai->HasAura("dire bear form", GetTarget());
+		}
+	};
+
+	class CastDireBearFormAction : public CastBuffSpellAction { 
+	public: 
+		CastDireBearFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "dire bear form") {} 
+        
+        virtual NextAction** getAlternatives() {
+			return NextAction::merge(NextAction::array(0, new NextAction("bear form"), NULL), CastSpellAction::getAlternatives());
+		}
+	};
+
+	class CastCatFormAction : public CastBuffSpellAction { 
+	public: 
+		CastCatFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "cat form") {} 
+	};
+
+	class CastTreeFormAction : public CastBuffSpellAction {
+	public:
+		CastTreeFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "tree of life") {}
+	};
+
+	class CastMoonkinFormAction : public CastBuffSpellAction { 
+	public: 
+		CastMoonkinFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "moonkin form") {} 
+	};
+
+	class CastCasterFormAction : public CastBuffSpellAction { 
+	public: 
+		CastCasterFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "caster form") {} 
+
+		virtual bool isUseful() {
+			return ai->HasAnyAuraOf(GetTarget(), "dire bear form", "bear form", "cat form", "travel form", "aquatic form", 
+				"flight form", "swift flight form", "moonkin form", "tree of life", NULL);
+		}
+		virtual bool isPossible() { return true; }
+		
+		virtual bool Execute(Event event);
+	};
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp b/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
new file mode 100644
index 0000000..963c9fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidTriggers.h"
+#include "DruidActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/druid/DruidTriggers.h b/src/plugins/playerbot/strategy/druid/DruidTriggers.h
new file mode 100644
index 0000000..1c0d4d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidTriggers.h
@@ -0,0 +1,127 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai {
+    class MarkOfTheWildOnPartyTrigger : public BuffOnPartyTrigger
+    {
+    public:
+        MarkOfTheWildOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "mark of the wild") {}
+    };
+
+    class MarkOfTheWildTrigger : public BuffTrigger
+    {
+    public:
+        MarkOfTheWildTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "mark of the wild") {}
+    };
+
+    class ThornsTrigger : public BuffTrigger
+    {
+    public:
+        ThornsTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "thorns") {}
+    };
+
+    class RakeTrigger : public DebuffTrigger
+    {
+    public:
+        RakeTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "rake") {}
+    };
+
+    class InsectSwarmTrigger : public DebuffTrigger
+    {
+    public:
+        InsectSwarmTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "insect swarm") {}
+    };
+
+    class MoonfireTrigger : public DebuffTrigger
+    {
+    public:
+        MoonfireTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "moonfire") {}
+    };
+
+    class FaerieFireTrigger : public DebuffTrigger
+    {
+    public:
+        FaerieFireTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "faerie fire") {}
+    };
+
+    class FaerieFireFeralTrigger : public DebuffTrigger
+    {
+    public:
+        FaerieFireFeralTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "faerie fire (feral)") {}
+    };
+
+    class BashInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        BashInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "bash") {}
+    };
+
+    class TigersFuryTrigger : public BoostTrigger
+    {
+    public:
+        TigersFuryTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "tiger's fury") {}
+    };
+
+    class NaturesGraspTrigger : public BoostTrigger
+    {
+    public:
+        NaturesGraspTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "nature's grasp") {}
+    };
+
+    class EntanglingRootsTrigger : public HasCcTargetTrigger
+    {
+    public:
+        EntanglingRootsTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "entangling roots") {}
+    };
+
+    class CurePoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CurePoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+    class PartyMemberCurePoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCurePoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+    class BearFormTrigger : public BuffTrigger
+    {
+    public:
+        BearFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "bear form") {}
+        virtual bool IsActive() { return !ai->HasAnyAuraOf(bot, "bear form", "dire bear form", NULL); }
+    };
+
+    class TreeFormTrigger : public BuffTrigger
+    {
+    public:
+        TreeFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "tree of life") {}
+        virtual bool IsActive() { return !ai->HasAura("tree of life", bot); }
+    };
+
+    class CatFormTrigger : public BuffTrigger
+    {
+    public:
+        CatFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "cat form") {}
+        virtual bool IsActive() { return !ai->HasAura("cat form", bot); }
+    };
+
+    class EclipseSolarTrigger : public HasAuraTrigger
+    {
+    public:
+        EclipseSolarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "eclipse (solar)") {}
+    };
+
+    class EclipseLunarTrigger : public HasAuraTrigger
+    {
+    public:
+        EclipseLunarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "eclipse (lunar)") {}
+    };
+
+    class BashInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        BashInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
new file mode 100644
index 0000000..1956573
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FeralDruidStrategy.h"
+
+using namespace ai;
+
+class FeralDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    FeralDruidStrategyActionNodeFactory()
+    {
+        creators["survival instincts"] = &survival_instincts;
+        creators["thorns"] = &thorns;
+        creators["cure poison"] = &cure_poison;
+        creators["cure poison on party"] = &cure_poison_on_party;
+        creators["abolish poison"] = &abolish_poison;
+        creators["abolish poison on party"] = &abolish_poison_on_party;
+    }
+private:
+    static ActionNode* survival_instincts(PlayerbotAI* ai)
+    {
+        return new ActionNode ("survival instincts",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("barskin"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* thorns(PlayerbotAI* ai)
+    {
+        return new ActionNode ("thorns",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+FeralDruidStrategy::FeralDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new FeralDruidStrategyActionNodeFactory());
+    actionNodeFactories.Add(new ShapeshiftDruidStrategyActionNodeFactory());
+}
+
+void FeralDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("survival instincts", ACTION_EMERGENCY + 1), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
new file mode 100644
index 0000000..0ee4a8c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
@@ -0,0 +1,75 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+#include "DruidAiObjectContext.h"
+
+namespace ai
+{
+    class ShapeshiftDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        ShapeshiftDruidStrategyActionNodeFactory()
+        {
+            creators["rejuvenation"] = &rejuvenation;
+            creators["regrowth"] = &regrowth;
+            creators["healing touch"] = &healing_touch;
+            creators["rejuvenation on party"] = &rejuvenation_on_party;
+            creators["regrowth on party"] = &regrowth_on_party;
+            creators["healing touch on party"] = &healing_touch_on_party;
+        }
+    private:
+        static ActionNode* regrowth(PlayerbotAI* ai)
+        {
+            return new ActionNode ("regrowth",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("healing touch"), NULL),
+                /*C*/ NextAction::array(0, new NextAction("melee", 10.0f), NULL));
+        }
+        static ActionNode* rejuvenation(PlayerbotAI* ai)
+        {
+            return new ActionNode ("rejuvenation",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* healing_touch(PlayerbotAI* ai)
+        {
+            return new ActionNode ("healing touch",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* regrowth_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("regrowth on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("healing touch on party"), NULL),
+                /*C*/ NextAction::array(0, new NextAction("melee", 10.0f), NULL));
+        }
+        static ActionNode* rejuvenation_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("rejuvenation on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* healing_touch_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("healing touch on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+    };
+
+    class FeralDruidStrategy : public GenericDruidStrategy
+    {
+    protected:
+        FeralDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
new file mode 100644
index 0000000..e6377da
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "GenericDruidNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericDruidNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericDruidNonCombatStrategyActionNodeFactory()
+    {
+        creators["mark of the wild"] = &mark_of_the_wild;
+        creators["mark of the wild on party"] = &mark_of_the_wild_on_party;
+        creators["innervate"] = &innervate;
+    }
+private:
+    static ActionNode* mark_of_the_wild(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mark of the wild",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mark_of_the_wild_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mark of the wild on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* innervate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("innervate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drink"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericDruidNonCombatStrategy::GenericDruidNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericDruidNonCombatStrategyActionNodeFactory());
+}
+
+void GenericDruidNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "mark of the wild",
+        NextAction::array(0, new NextAction("mark of the wild", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "mark of the wild on party",
+        NextAction::array(0, new NextAction("mark of the wild on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cure poison",
+        NextAction::array(0, new NextAction("abolish poison", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure poison",
+        NextAction::array(0, new NextAction("abolish poison on party", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("revive", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("innervate", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
new file mode 100644
index 0000000..82cba15
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericDruidNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericDruidNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
new file mode 100644
index 0000000..3ba9308
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
@@ -0,0 +1,132 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericDruidStrategy.h"
+#include "DruidAiObjectContext.h"
+
+using namespace ai;
+
+class GenericDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericDruidStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["caster form"] = &caster_form;
+        creators["cure poison"] = &cure_poison;
+        creators["cure poison on party"] = &cure_poison_on_party;
+        creators["abolish poison"] = &abolish_poison;
+        creators["abolish poison on party"] = &abolish_poison_on_party;
+        creators["rebirth"] = &rebirth;
+        creators["entangling roots on cc"] = &entangling_roots_on_cc;
+        creators["innervate"] = &innervate;
+    }
+
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* caster_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("caster form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison on party",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison on party",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* rebirth(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rebirth",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* entangling_roots_on_cc(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots on cc",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* innervate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("innervate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericDruidStrategy::GenericDruidStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericDruidStrategyActionNodeFactory());
+}
+
+void GenericDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_CRITICAL_HEAL + 2), new NextAction("healing touch", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0,  new NextAction("regrowth on party", ACTION_CRITICAL_HEAL + 1), new NextAction("healing touch on party", ACTION_CRITICAL_HEAL + 1), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure poison",
+        NextAction::array(0, new NextAction("abolish poison", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure poison",
+        NextAction::array(0, new NextAction("abolish poison on party", ACTION_DISPEL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("rebirth", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("innervate", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
new file mode 100644
index 0000000..dc12a85
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericDruidStrategy : public CombatStrategy
+    {
+    protected:
+        GenericDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
new file mode 100644
index 0000000..5b1cfb3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
@@ -0,0 +1,57 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "HealDruidStrategy.h"
+
+using namespace ai;
+
+class HealDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    HealDruidStrategyActionNodeFactory()
+    {
+    }
+private:
+};
+
+HealDruidStrategy::HealDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new HealDruidStrategyActionNodeFactory());
+}
+
+void HealDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tree form",
+        NextAction::array(0, new NextAction("tree form", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("rejuvenation", ACTION_LIGHT_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("rejuvenation on party", ACTION_LIGHT_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("tranquility", ACTION_MEDIUM_HEAL + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 1), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
new file mode 100644
index 0000000..a0440ba
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+
+namespace ai
+{
+    class HealDruidStrategy : public GenericDruidStrategy
+    {
+    public:
+        HealDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "heal"; }
+        virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
new file mode 100644
index 0000000..43db065
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackEnemyPlayersStrategy.h"
+
+using namespace ai;
+
+void AttackEnemyPlayersStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy player is attacking",
+        NextAction::array(0, new NextAction("attack enemy player", 61.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
new file mode 100644
index 0000000..cd9ce7c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackEnemyPlayersStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackEnemyPlayersStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "pvp"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
new file mode 100644
index 0000000..d33bb74
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
@@ -0,0 +1,14 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackRtiStrategy.h"
+
+using namespace ai;
+
+
+void AttackRtiStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("attack rti target", 60.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
new file mode 100644
index 0000000..ad9662a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackRtiStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackRtiStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "attack rti"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
new file mode 100644
index 0000000..d3a832a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackWeakStrategy.h"
+
+using namespace ai;
+
+void AttackWeakStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "not least hp target active",
+        NextAction::array(0, new NextAction("attack least hp target", 60.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
new file mode 100644
index 0000000..c6c20c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackWeakStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackWeakStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "attack weak"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
new file mode 100644
index 0000000..7d1a483
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CastTimeStrategy.h"
+#include "../actions/GenericSpellActions.h"
+
+using namespace ai;
+
+float CastTimeMultiplier::GetValue(Action* action)
+{
+    if (action == NULL) return 1.0f;
+
+    uint8 targetHealth = AI_VALUE2(uint8, "health", "current target");
+    string name = action->getName();
+
+    if (action->GetTarget() != AI_VALUE(Unit*, "current target"))
+        return 1.0f;
+
+    if (targetHealth < sPlayerbotAIConfig.lowHealth && dynamic_cast<CastSpellAction*>(action))
+    {
+        uint32 spellId = AI_VALUE2(uint32, "spell id", name);
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            return 1.0f;
+
+        Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+        int32 castTime = spell->GetCastTime();
+        delete spell;
+
+        if (spellId && castTime >= 3000)
+            return 0.0f;
+        else if (spellId && castTime >= 1500)
+            return 0.5f;
+    }
+
+    return 1.0f;
+}
+
+
+void CastTimeStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new CastTimeMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
new file mode 100644
index 0000000..a483fc0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
@@ -0,0 +1,26 @@
+#pragma once
+
+namespace ai
+{
+
+    class CastTimeMultiplier : public Multiplier
+    {
+    public:
+        CastTimeMultiplier(PlayerbotAI* ai) : Multiplier(ai, "cast time") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class CastTimeStrategy : public Strategy
+    {
+    public:
+        CastTimeStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "cast time"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
new file mode 100644
index 0000000..991551e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
@@ -0,0 +1,177 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+class ChatCommandActionNodeFactoryInternal : public NamedObjectFactory<ActionNode>
+{
+public:
+    ChatCommandActionNodeFactoryInternal()
+    {
+        creators["tank attack chat shortcut"] = &tank_attack_chat_shortcut;
+    }
+
+private:
+    static ActionNode* tank_attack_chat_shortcut(PlayerbotAI* ai)
+    {
+        return new ActionNode ("tank attack chat shortcut",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("attack my target", 100.0f), NULL));
+    }
+};
+
+void ChatCommandHandlerStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "rep",
+        NextAction::array(0, new NextAction("reputation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "q",
+        NextAction::array(0,
+            new NextAction("query quest", relevance),
+            new NextAction("query item usage", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "add all loot",
+        NextAction::array(0, new NextAction("add all loot", relevance), new NextAction("loot", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "u",
+        NextAction::array(0, new NextAction("use", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "c",
+        NextAction::array(0, new NextAction("item count", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "e",
+        NextAction::array(0, new NextAction("equip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "ue",
+        NextAction::array(0, new NextAction("unequip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "t",
+        NextAction::array(0, new NextAction("trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "nt",
+        NextAction::array(0, new NextAction("trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "s",
+        NextAction::array(0, new NextAction("sell", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "b",
+        NextAction::array(0, new NextAction("buy", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "r",
+        NextAction::array(0, new NextAction("reward", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "attack",
+        NextAction::array(0, new NextAction("attack my target", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "accept",
+        NextAction::array(0, new NextAction("accept quest", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "follow",
+        NextAction::array(0, new NextAction("follow chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "stay",
+        NextAction::array(0, new NextAction("stay chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "flee",
+        NextAction::array(0, new NextAction("flee chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tank attack",
+        NextAction::array(0, new NextAction("tank attack chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "grind",
+        NextAction::array(0, new NextAction("grind chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "talk",
+        NextAction::array(0, new NextAction("gossip hello", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cast",
+        NextAction::array(0, new NextAction("cast custom spell", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "revive",
+        NextAction::array(0, new NextAction("spirit healer", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "runaway",
+        NextAction::array(0, new NextAction("runaway chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "warning",
+        NextAction::array(0, new NextAction("runaway chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "max dps",
+        NextAction::array(0, new NextAction("max dps chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "attackers",
+        NextAction::array(0, new NextAction("tell attackers", relevance), NULL)));
+}
+
+
+
+ChatCommandHandlerStrategy::ChatCommandHandlerStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    actionNodeFactories.Add(new ChatCommandActionNodeFactoryInternal());
+
+    supported.push_back("quests");
+    supported.push_back("stats");
+    supported.push_back("leave");
+    supported.push_back("reputation");
+    supported.push_back("log");
+    supported.push_back("los");
+    supported.push_back("drop");
+    supported.push_back("ll");
+    supported.push_back("release");
+    supported.push_back("teleport");
+    supported.push_back("taxi");
+    supported.push_back("repair");
+    supported.push_back("talents");
+    supported.push_back("spells");
+    supported.push_back("co");
+    supported.push_back("nc");
+    supported.push_back("dead");
+    supported.push_back("trainer");
+    supported.push_back("chat");
+    supported.push_back("home");
+    supported.push_back("destroy");
+    supported.push_back("reset ai");
+    supported.push_back("emote");
+    supported.push_back("buff");
+    supported.push_back("help");
+    supported.push_back("gb");
+    supported.push_back("bank");
+    supported.push_back("invite");
+    supported.push_back("spell");
+    supported.push_back("rti");
+    supported.push_back("position");
+    supported.push_back("summon");
+    supported.push_back("who");
+    supported.push_back("save mana");
+    supported.push_back("formation");
+}
diff --git a/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
new file mode 100644
index 0000000..c8c93b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class ChatCommandHandlerStrategy : public PassTroughStrategy
+    {
+    public:
+        ChatCommandHandlerStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "chat"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
new file mode 100644
index 0000000..4ef95b1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CombatStrategy.h"
+
+using namespace ai;
+
+void CombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "invalid target",
+        NextAction::array(0, new NextAction("drop target", ACTION_HIGH + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/CombatStrategy.h b/src/plugins/playerbot/strategy/generic/CombatStrategy.h
new file mode 100644
index 0000000..475922f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CombatStrategy.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+    class CombatStrategy : public Strategy
+    {
+    public:
+        CombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
new file mode 100644
index 0000000..b1c13fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
@@ -0,0 +1,88 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ConserveManaStrategy.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../actions/GenericSpellActions.h"
+#include "../values/LastSpellCastValue.h"
+
+using namespace ai;
+
+float ConserveManaMultiplier::GetValue(Action* action)
+{
+    if (action == NULL) return 1.0f;
+
+    uint8 health = AI_VALUE2(uint8, "health", "self target");
+    uint8 targetHealth = AI_VALUE2(uint8, "health", "current target");
+    uint8 mana = AI_VALUE2(uint8, "mana", "self target");
+    bool hasMana = AI_VALUE2(bool, "has mana", "self target");
+    bool mediumMana = hasMana && mana < sPlayerbotAIConfig.mediumMana;
+
+    string name = action->getName();
+
+    if (health < sPlayerbotAIConfig.lowHealth)
+        return 1.0f;
+
+    if (name == "melee" || name == "reach melee" || name == "reach spell")
+        return 1.0f;
+
+    if (mediumMana && dynamic_cast<CastBuffSpellAction*>(action))
+        return 0.0f;
+
+    if (action->GetTarget() != AI_VALUE(Unit*, "current target"))
+        return 1.0f;
+
+    if (AI_VALUE(uint8, "balance") <= 50)
+        return 1.0f;
+
+    if (targetHealth < sPlayerbotAIConfig.lowHealth && dynamic_cast<CastDebuffSpellAction*>(action))
+        return 0.0f;
+
+    if (mediumMana && dynamic_cast<CastDebuffSpellAction*>(action))
+        return 0.0f;
+
+    return 1.0f;
+}
+
+float SaveManaMultiplier::GetValue(Action* action)
+{
+    if (action == NULL)
+        return 1.0f;
+
+    double saveLevel = AI_VALUE(double, "mana save level");
+    if (saveLevel <= 1.0)
+        return 1.0f;
+
+    CastSpellAction* spellAction = dynamic_cast<CastSpellAction*>(action);
+    if (!spellAction)
+        return 1.0f;
+
+    string spell = spellAction->getName();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo || spellInfo->PowerType != POWER_MANA)
+        return 1.0f;
+
+    int32 cost = spellInfo->ManaCost;
+    if (spellInfo->ManaCostPercentage)
+        cost += spellInfo->ManaCostPercentage * bot->GetCreateMana() / 100;
+
+    uint32 mana = bot->GetMaxPower(POWER_MANA);
+    double percent = (double)cost / (double)mana * 100.0f;
+
+    time_t lastCastTime = AI_VALUE2(time_t, "last spell cast time", spell);
+    if (!lastCastTime)
+        return 1.0f;
+
+    time_t elapsed = time(0) - lastCastTime;
+    if ((double)elapsed < 10 + pow(saveLevel, sqrt(percent)))
+        return 0.0f;
+
+    return 1.0f;
+}
+
+
+void ConserveManaStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new ConserveManaMultiplier(ai));
+    multipliers.push_back(new SaveManaMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
new file mode 100644
index 0000000..a206934
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
@@ -0,0 +1,32 @@
+#pragma once
+
+namespace ai
+{
+    class ConserveManaMultiplier : public Multiplier
+    {
+    public:
+        ConserveManaMultiplier(PlayerbotAI* ai) : Multiplier(ai, "conserve mana") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class SaveManaMultiplier : public Multiplier
+    {
+    public:
+        SaveManaMultiplier(PlayerbotAI* ai) : Multiplier(ai, "save mana") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class ConserveManaStrategy : public Strategy
+    {
+    public:
+        ConserveManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "conserve mana"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp b/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
new file mode 100644
index 0000000..1c31adb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../Strategy.h"
+#include "DeadStrategy.h"
+
+using namespace ai;
+
+void DeadStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "dead",
+        NextAction::array(0, new NextAction("revive from corpse", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "resurrect request",
+        NextAction::array(0, new NextAction("accept resurrect", relevance), NULL)));
+}
+
+DeadStrategy::DeadStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/DeadStrategy.h b/src/plugins/playerbot/strategy/generic/DeadStrategy.h
new file mode 100644
index 0000000..4008570
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DeadStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class DeadStrategy : public PassTroughStrategy
+    {
+    public:
+        DeadStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dead"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
new file mode 100644
index 0000000..40fa703
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsAoeStrategy.h"
+
+using namespace ai;
+
+void DpsAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("dps assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
new file mode 100644
index 0000000..61ac9b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
@@ -0,0 +1,18 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class DpsAoeStrategy : public NonCombatStrategy
+    {
+    public:
+        DpsAoeStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "dps aoe"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
new file mode 100644
index 0000000..c38860d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsAssistStrategy.h"
+
+using namespace ai;
+
+void DpsAssistStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("dps assist", 50.0f), NULL)));
+}
+
+
+
diff --git a/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
new file mode 100644
index 0000000..4368d7b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class DpsAssistStrategy : public NonCombatStrategy
+    {
+    public:
+        DpsAssistStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "dps assist"; }
+		virtual int GetType() { return STRATEGY_TYPE_DPS; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp b/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
new file mode 100644
index 0000000..92e9049
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
@@ -0,0 +1,24 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DuelStrategy.h"
+
+using namespace ai;
+
+void DuelStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "duel requested",
+        NextAction::array(0, new NextAction("accept duel", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("attack duel opponent", 70.0f), NULL)));
+}
+
+
+
+DuelStrategy::DuelStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/DuelStrategy.h b/src/plugins/playerbot/strategy/generic/DuelStrategy.h
new file mode 100644
index 0000000..5828406
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DuelStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class DuelStrategy : public PassTroughStrategy
+    {
+    public:
+        DuelStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "duel"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp b/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
new file mode 100644
index 0000000..408ecd1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EmoteStrategy.h"
+
+using namespace ai;
+
+
+void EmoteStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "random",
+        NextAction::array(0, new NextAction("emote", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "seldom",
+        NextAction::array(0, new NextAction("suggest what to do", 1.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/EmoteStrategy.h b/src/plugins/playerbot/strategy/generic/EmoteStrategy.h
new file mode 100644
index 0000000..7acbc70
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/EmoteStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class EmoteStrategy : public Strategy
+    {
+    public:
+        EmoteStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "emote"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp b/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
new file mode 100644
index 0000000..4b16bc2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FleeStrategy.h"
+
+using namespace ai;
+
+void FleeStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "panic",
+        NextAction::array(0, new NextAction("flee", ACTION_EMERGENCY + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+       "critical health",
+       NextAction::array(0, new NextAction("flee", ACTION_MOVE + 9), NULL)));
+
+   triggers.push_back(new TriggerNode(
+       "low mana",
+       NextAction::array(0,  new NextAction("flee", ACTION_MOVE + 9), NULL)));}
+
+void FleeFromAddsStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "has nearest adds",
+        NextAction::array(0, new NextAction("runaway", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/FleeStrategy.h b/src/plugins/playerbot/strategy/generic/FleeStrategy.h
new file mode 100644
index 0000000..4aa96b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FleeStrategy.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+    class FleeStrategy : public Strategy
+    {
+    public:
+        FleeStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "flee"; };
+    };
+
+    class FleeFromAddsStrategy : public Strategy
+    {
+    public:
+        FleeFromAddsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "flee from adds"; };
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
new file mode 100644
index 0000000..753811b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FollowMasterStrategy.h"
+
+using namespace ai;
+
+NextAction** FollowMasterStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("follow", 1.0f), NULL);
+}
+
+void FollowMasterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "out of react range",
+        NextAction::array(0, new NextAction("tell out of react range", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
new file mode 100644
index 0000000..a43e330
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class FollowMasterStrategy : public NonCombatStrategy
+    {
+    public:
+        FollowMasterStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "follow"; }
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp b/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
new file mode 100644
index 0000000..259cc96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
@@ -0,0 +1,20 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GrindingStrategy.h"
+
+using namespace ai;
+
+
+NextAction** GrindingStrategy::getDefaultActions()
+{
+    return NULL;
+}
+
+void GrindingStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no target",
+        NextAction::array(0,
+        new NextAction("attack anything", 5.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/GrindingStrategy.h b/src/plugins/playerbot/strategy/generic/GrindingStrategy.h
new file mode 100644
index 0000000..ce42140
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GrindingStrategy.h
@@ -0,0 +1,20 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class GrindingStrategy : public NonCombatStrategy
+    {
+    public:
+        GrindingStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "grind"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS; }
+        NextAction** getDefaultActions();
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp b/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
new file mode 100644
index 0000000..301322c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuardStrategy.h"
+
+using namespace ai;
+
+
+NextAction** GuardStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("guard", 4.0f), NULL);
+}
+
+void GuardStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/GuardStrategy.h b/src/plugins/playerbot/strategy/generic/GuardStrategy.h
new file mode 100644
index 0000000..8705ba3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GuardStrategy.h
@@ -0,0 +1,19 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class GuardStrategy : public NonCombatStrategy
+    {
+    public:
+        GuardStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "guard"; }
+        NextAction** getDefaultActions();
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp b/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
new file mode 100644
index 0000000..e329162
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "KiteStrategy.h"
+
+using namespace ai;
+
+KiteStrategy::KiteStrategy(PlayerbotAI* ai) : Strategy(ai)
+{
+}
+
+void KiteStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "has aggro",
+        NextAction::array(0, new NextAction("runaway", 51.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/KiteStrategy.h b/src/plugins/playerbot/strategy/generic/KiteStrategy.h
new file mode 100644
index 0000000..2436a3d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/KiteStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class KiteStrategy : public Strategy
+    {
+    public:
+        KiteStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "kite"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
new file mode 100644
index 0000000..0701cf5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootNonCombatStrategy.h"
+
+using namespace ai;
+
+void LootNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "loot available",
+        NextAction::array(0, new NextAction("loot", 6.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "far from loot target",
+        NextAction::array(0, new NextAction("move to loot", 7.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "can loot",
+        NextAction::array(0, new NextAction("open loot", 8.0f), NULL)));
+}
+
+void GatherStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no possible targets",
+        NextAction::array(0, new NextAction("add gathering loot", 2.0f), NULL)));
+}
+
+
diff --git a/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
new file mode 100644
index 0000000..5eecd63
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
@@ -0,0 +1,24 @@
+#pragma once
+
+namespace ai
+{
+    class LootNonCombatStrategy : public Strategy
+    {
+    public:
+        LootNonCombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "loot"; }
+    };
+
+    class GatherStrategy : public Strategy
+    {
+    public:
+        GatherStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "gather"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
new file mode 100644
index 0000000..6bc8267
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MeleeCombatStrategy.h"
+
+using namespace ai;
+
+
+void MeleeCombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
new file mode 100644
index 0000000..eeeb90a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
@@ -0,0 +1,16 @@
+#include "CombatStrategy.h"
+#include "../generic/CombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class MeleeCombatStrategy : public CombatStrategy
+    {
+    public:
+        MeleeCombatStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
new file mode 100644
index 0000000..0c7de2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MoveRandomStrategy.h"
+
+using namespace ai;
+
+void MoveRandomStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "often",
+        NextAction::array(0, new NextAction("move random", 1.5f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
new file mode 100644
index 0000000..ff453bf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class MoveRandomStrategy : public NonCombatStrategy
+    {
+    public:
+        MoveRandomStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "move random"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
new file mode 100644
index 0000000..38b8227
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
@@ -0,0 +1,28 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NonCombatStrategy.h"
+
+using namespace ai;
+
+void NonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("check mount state", 1.0f), NULL)));
+}
+
+
+void LfgStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no possible targets",
+        NextAction::array(0, new NextAction("lfg join", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lfg proposal",
+        NextAction::array(0, new NextAction("lfg accept", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lfg proposal active",
+        NextAction::array(0, new NextAction("lfg accept", 1.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
new file mode 100644
index 0000000..5216679
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+    class NonCombatStrategy : public Strategy
+    {
+    public:
+        NonCombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+		virtual int GetType() { return STRATEGY_TYPE_NONCOMBAT; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class LfgStrategy : public Strategy
+    {
+    public:
+        LfgStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+		virtual int GetType() { return STRATEGY_TYPE_NONCOMBAT; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "lfg"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h b/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
new file mode 100644
index 0000000..eddb031
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
@@ -0,0 +1,26 @@
+#pragma once
+
+namespace ai
+{
+    class PassTroughStrategy : public Strategy
+    {
+    public:
+        PassTroughStrategy(PlayerbotAI* ai, float relevance = 100.0f) : Strategy(ai), relevance(relevance) {}
+
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers)
+        {
+            for (list<string>::iterator i = supported.begin(); i != supported.end(); i++)
+            {
+                string s = i->c_str();
+
+                triggers.push_back(new TriggerNode(
+                    s, 
+                    NextAction::array(0, new NextAction(s, relevance), NULL)));
+            }
+        }
+
+    protected:
+        list<string> supported;
+        float relevance;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp b/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
new file mode 100644
index 0000000..a4bb3fa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PassiveStrategy.h"
+#include "../PassiveMultiplier.h"
+
+using namespace ai;
+
+
+void PassiveStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new PassiveMultiplier(ai));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/PassiveStrategy.h b/src/plugins/playerbot/strategy/generic/PassiveStrategy.h
new file mode 100644
index 0000000..8e96388
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassiveStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class PassiveStrategy : public Strategy
+    {
+    public:
+        PassiveStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "passive"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/PullStrategy.cpp b/src/plugins/playerbot/strategy/generic/PullStrategy.cpp
new file mode 100644
index 0000000..5d82db3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PullStrategy.cpp
@@ -0,0 +1,52 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../PassiveMultiplier.h"
+#include "PullStrategy.h"
+
+using namespace ai;
+
+class MagePullMultiplier : public PassiveMultiplier
+{
+public:
+    MagePullMultiplier(PlayerbotAI* ai, string action) : PassiveMultiplier(ai)
+    {
+        this->action = action;
+    }
+
+public:
+    virtual float GetValue(Action* action);
+
+private:
+    string action;
+};
+
+float MagePullMultiplier::GetValue(Action* action) 
+{
+    if (!action) 
+        return 1.0f;
+
+    string name = action->getName();
+    if (this->action == name ||
+        name == "reach spell" ||
+        name == "change strategy")
+        return 1.0f;
+
+    return PassiveMultiplier::GetValue(action);
+}
+
+NextAction** PullStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction(action, 105.0f), new NextAction("follow", 104.0f), new NextAction("end pull", 103.0f), NULL);
+}
+
+void PullStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+}
+
+void PullStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new MagePullMultiplier(ai, action));
+    RangedCombatStrategy::InitMultipliers(multipliers);
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/PullStrategy.h b/src/plugins/playerbot/strategy/generic/PullStrategy.h
new file mode 100644
index 0000000..b19210a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PullStrategy.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "RangedCombatStrategy.h"
+
+namespace ai
+{
+    class PullStrategy : public RangedCombatStrategy
+    {
+    public:
+        PullStrategy(PlayerbotAI* ai, string action) : RangedCombatStrategy(ai) 
+        {
+            this->action = action;
+        }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "pull"; }
+        virtual NextAction** getDefaultActions();
+
+    private:
+        string action;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp b/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
new file mode 100644
index 0000000..62b3e43
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
@@ -0,0 +1,69 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QuestStrategies.h"
+
+using namespace ai;
+
+QuestStrategy::QuestStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    supported.push_back("accept quest");
+}
+
+void QuestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "quest share",
+        NextAction::array(0, new NextAction("accept quest share", relevance), NULL)));
+}
+
+
+void DefaultQuestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    QuestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "complete quest",
+        NextAction::array(0, new NextAction("talk to quest giver", relevance), NULL)));
+}
+
+DefaultQuestStrategy::DefaultQuestStrategy(PlayerbotAI* ai) : QuestStrategy(ai)
+{
+}
+
+
+
+void AcceptAllQuestsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    QuestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "complete quest",
+        NextAction::array(0, 
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+}
+
+AcceptAllQuestsStrategy::AcceptAllQuestsStrategy(PlayerbotAI* ai) : QuestStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/QuestStrategies.h b/src/plugins/playerbot/strategy/generic/QuestStrategies.h
new file mode 100644
index 0000000..08423dd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/QuestStrategies.h
@@ -0,0 +1,34 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class QuestStrategy : public PassTroughStrategy
+    {
+    public:
+        QuestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class DefaultQuestStrategy : public QuestStrategy
+    {
+    public:
+        DefaultQuestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "quest"; }
+    };
+
+    class AcceptAllQuestsStrategy : public QuestStrategy
+    {
+    public:
+        AcceptAllQuestsStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "accept all quests"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp b/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
new file mode 100644
index 0000000..58fa904
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
@@ -0,0 +1,39 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RacialsStrategy.h"
+
+using namespace ai;
+
+
+class RacialsStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    RacialsStrategyActionNodeFactory()
+    {
+        creators["lifeblood"] = &lifeblood;
+    }
+private:
+    static ActionNode* lifeblood(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lifeblood",  
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("gift of the naaru"), NULL), 
+            /*C*/ NULL);
+    }
+};
+
+void RacialsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"low health", 
+		NextAction::array(0, new NextAction("lifeblood", 71.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana", 
+        NextAction::array(0, new NextAction("arcane torrent", ACTION_EMERGENCY + 6), NULL)));
+}
+
+RacialsStrategy::RacialsStrategy(PlayerbotAI* ai) : Strategy(ai)
+{
+    actionNodeFactories.Add(new RacialsStrategyActionNodeFactory());
+}
diff --git a/src/plugins/playerbot/strategy/generic/RacialsStrategy.h b/src/plugins/playerbot/strategy/generic/RacialsStrategy.h
new file mode 100644
index 0000000..6802178
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RacialsStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class RacialsStrategy : public Strategy
+    {
+    public:
+        RacialsStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "racials"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
new file mode 100644
index 0000000..9fd6ad9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RangedCombatStrategy.h"
+
+using namespace ai;
+
+
+void RangedCombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
new file mode 100644
index 0000000..a00cbc1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
@@ -0,0 +1,15 @@
+#include "CombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class RangedCombatStrategy : public CombatStrategy
+    {
+    public:
+        RangedCombatStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_RANGED; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp b/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
new file mode 100644
index 0000000..5ac877b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RunawayStrategy.h"
+
+using namespace ai;
+
+
+NextAction** RunawayStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("runaway", 50.0f), NULL);
+}
+
+void RunawayStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("runaway", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/RunawayStrategy.h b/src/plugins/playerbot/strategy/generic/RunawayStrategy.h
new file mode 100644
index 0000000..d1c3ef5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RunawayStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class RunawayStrategy : public NonCombatStrategy
+       {
+       public:
+           RunawayStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+           virtual string getName() { return "runaway"; }
+           virtual NextAction** getDefaultActions();
+           virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+       };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/SayStrategy.cpp b/src/plugins/playerbot/strategy/generic/SayStrategy.cpp
new file mode 100644
index 0000000..4a78afa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/SayStrategy.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SayStrategy.h"
+
+using namespace ai;
+
+
+void SayStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("say::critical health", 99.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("say::low health", 99.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("say::low mana", 99.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tank aoe",
+        NextAction::array(0, new NextAction("say::taunt", 99.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("say::aoe", 99.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/SayStrategy.h b/src/plugins/playerbot/strategy/generic/SayStrategy.h
new file mode 100644
index 0000000..396b39b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/SayStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class SayStrategy : public Strategy
+    {
+    public:
+        SayStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "say"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/StayStrategy.cpp b/src/plugins/playerbot/strategy/generic/StayStrategy.cpp
new file mode 100644
index 0000000..f8cbf96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/StayStrategy.cpp
@@ -0,0 +1,11 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StayStrategy.h"
+
+using namespace ai;
+
+NextAction** StayStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("stay", 1.0f), NULL);
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/StayStrategy.h b/src/plugins/playerbot/strategy/generic/StayStrategy.h
new file mode 100644
index 0000000..d9f4229
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/StayStrategy.h
@@ -0,0 +1,14 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class StayStrategy : public NonCombatStrategy
+    {
+    public:
+        StayStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "stay"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
new file mode 100644
index 0000000..29afdec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankAoeStrategy.h"
+
+using namespace ai;
+
+void TankAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "tank aoe",
+        NextAction::array(0, new NextAction("tank assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
new file mode 100644
index 0000000..f9ed2fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
@@ -0,0 +1,18 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class TankAoeStrategy : public NonCombatStrategy
+    {
+    public:
+        TankAoeStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "tank aoe"; }
+        virtual int GetType() { return STRATEGY_TYPE_TANK; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
new file mode 100644
index 0000000..d54b8ef
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankAssistStrategy.h"
+
+using namespace ai;
+
+
+void TankAssistStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("tank assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
new file mode 100644
index 0000000..3ecbbb9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
@@ -0,0 +1,17 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class TankAssistStrategy : public NonCombatStrategy
+    {
+    public:
+        TankAssistStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "tank assist"; }
+        virtual int GetType() { return STRATEGY_TYPE_TANK; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
new file mode 100644
index 0000000..ce1340d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellTargetStrategy.h"
+
+using namespace ai;
+
+
+void TellTargetStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "target changed",
+        NextAction::array(0, new NextAction("tell target", 51.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
new file mode 100644
index 0000000..22b2e2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class TellTargetStrategy : public Strategy
+    {
+    public:
+        TellTargetStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "TellTarget"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp b/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
new file mode 100644
index 0000000..155dc24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
@@ -0,0 +1,32 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ThreatStrategy.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../actions/GenericSpellActions.h"
+
+using namespace ai;
+
+float ThreatMultiplier::GetValue(Action* action)
+{
+    if (action == NULL || action->getThreatType() == ACTION_THREAT_NONE)
+        return 1.0f;
+
+    if (action->getThreatType() == ACTION_THREAT_AOE)
+    {
+        uint8 threat = AI_VALUE2(uint8, "threat", "aoe");
+        if (threat >= 90)
+            return 0.0f;
+    }
+
+    uint8 threat = AI_VALUE2(uint8, "threat", "current target");
+
+    if (threat >= 90)
+        return 0.0f;
+
+    return 1.0f;
+}
+
+void ThreatStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new ThreatMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/ThreatStrategy.h b/src/plugins/playerbot/strategy/generic/ThreatStrategy.h
new file mode 100644
index 0000000..406f433
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ThreatStrategy.h
@@ -0,0 +1,25 @@
+#pragma once
+
+namespace ai
+{
+    class ThreatMultiplier : public Multiplier
+    {
+    public:
+        ThreatMultiplier(PlayerbotAI* ai) : Multiplier(ai, "threat") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class ThreatStrategy : public Strategy
+    {
+    public:
+        ThreatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "threat"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
new file mode 100644
index 0000000..b141a46
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseFoodStrategy.h"
+
+using namespace ai;
+
+void UseFoodStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    Strategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("food", 2.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("drink", 2.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
new file mode 100644
index 0000000..b68ab35
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class UseFoodStrategy : public Strategy
+    {
+    public:
+        UseFoodStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "food"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
new file mode 100644
index 0000000..09616bb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UsePotionsStrategy.h"
+
+using namespace ai;
+
+void UsePotionsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    Strategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("healing potion", ACTION_MEDIUM_HEAL), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0,  new NextAction("mana potion", ACTION_EMERGENCY), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
new file mode 100644
index 0000000..b48f89f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class UsePotionsStrategy : public Strategy
+    {
+    public:
+        UsePotionsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "potions"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
new file mode 100644
index 0000000..e05fec5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
@@ -0,0 +1,106 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WorldPacketHandlerStrategy.h"
+
+using namespace ai;
+
+void WorldPacketHandlerStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "group invite",
+        NextAction::array(0, new NextAction("accept invitation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "group set leader",
+        NextAction::array(0, new NextAction("leader", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not enough money",
+        NextAction::array(0, new NextAction("tell not enough money", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not enough reputation",
+        NextAction::array(0, new NextAction("tell not enough reputation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cannot equip",
+        NextAction::array(0, new NextAction("tell cannot equip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("add loot", relevance),
+            new NextAction("use meeting stone", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("trainer", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "activate taxi",
+        NextAction::array(0, new NextAction("remember taxi", relevance), new NextAction("taxi", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "taxi done",
+        NextAction::array(0, new NextAction("taxi", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "trade status",
+        NextAction::array(0, new NextAction("accept trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "area trigger",
+        NextAction::array(0, new NextAction("reach area trigger", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "within area trigger",
+        NextAction::array(0, new NextAction("area trigger", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "loot response",
+        NextAction::array(0, new NextAction("store loot", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "item push result",
+        NextAction::array(0, new NextAction("query item usage", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "ready check finished",
+        NextAction::array(0, new NextAction("finish ready check", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "often",
+        NextAction::array(0, new NextAction("security check", relevance), new NextAction("check mail", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "guild invite",
+        NextAction::array(0, new NextAction("guild accept", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "seldom",
+        NextAction::array(0, new NextAction("lfg leave", relevance), NULL)));
+
+}
+
+WorldPacketHandlerStrategy::WorldPacketHandlerStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    supported.push_back("loot roll");
+    supported.push_back("check mount state");
+    supported.push_back("quest objective completed");
+    supported.push_back("party command");
+    supported.push_back("ready check");
+    supported.push_back("uninvite");
+    supported.push_back("lfg role check");
+    supported.push_back("lfg teleport");
+}
+
+
+void ReadyCheckStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("ready check", relevance), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
new file mode 100644
index 0000000..6a5a44d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class WorldPacketHandlerStrategy : public PassTroughStrategy
+    {
+    public:
+        WorldPacketHandlerStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "default"; }
+    };
+
+    class ReadyCheckStrategy : public PassTroughStrategy
+    {
+    public:
+        ReadyCheckStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "ready check"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
new file mode 100644
index 0000000..bb6c477
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
@@ -0,0 +1,118 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+
+#include "HunterMultipliers.h"
+#include "DpsHunterStrategy.h"
+
+using namespace ai;
+
+class DpsHunterStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsHunterStrategyActionNodeFactory()
+    {
+        creators["aimed shot"] = &aimed_shot;
+        creators["chimera shot"] = &chimera_shot;
+        creators["explosive shot"] = &explosive_shot;
+        creators["concussive shot"] = &concussive_shot;
+        creators["viper sting"] = &viper_sting;
+    }
+private:
+    static ActionNode* viper_sting(PlayerbotAI* ai)
+    {
+        return new ActionNode ("viper sting",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aimed_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aimed shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("chimera shot", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chimera_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chimera shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane shot", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* explosive_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("explosive shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aimed shot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* concussive_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("concussive shot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("wyvern sting", 11.0f), NULL));
+    }
+
+};
+
+DpsHunterStrategy::DpsHunterStrategy(PlayerbotAI* ai) : GenericHunterStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsHunterStrategyActionNodeFactory());
+}
+
+NextAction** DpsHunterStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("explosive shot", 11.0f), new NextAction("auto shot", 10.0f), NULL);
+}
+
+void DpsHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericHunterStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "black arrow",
+        NextAction::array(0, new NextAction("black arrow", 51.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("viper sting", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("call pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunter's mark",
+        NextAction::array(0, new NextAction("hunter's mark", 52.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "freezing trap",
+        NextAction::array(0, new NextAction("freezing trap", 83.0f), NULL)));
+}
+
+void DpsAoeHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("multi-shot", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("volley", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"serpent sting on attacker",
+		NextAction::array(0, new NextAction("serpent sting on attacker", 49.0f), NULL)));
+}
+
+void DpsHunterDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no stings",
+        NextAction::array(0, new NextAction("serpent sting", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
new file mode 100644
index 0000000..4992e0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericHunterStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class DpsHunterStrategy : public GenericHunterStrategy
+    {
+    public:
+        DpsHunterStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+
+    };
+
+    class DpsAoeHunterStrategy : public CombatStrategy
+    {
+    public:
+        DpsAoeHunterStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+
+    class DpsHunterDebuffStrategy : public CombatStrategy
+    {
+    public:
+        DpsHunterDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
new file mode 100644
index 0000000..6fab572
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
@@ -0,0 +1,58 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+#include "GenericHunterNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericHunterNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericHunterNonCombatStrategyActionNodeFactory()
+    {
+        creators["rapid fire"] = &rapid_fire;
+        creators["boost"] = &rapid_fire;
+        creators["aspect of the pack"] = &aspect_of_the_pack;
+    }
+private:
+    static ActionNode* rapid_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rapid fire",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("readiness"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aspect_of_the_pack(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aspect of the pack",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aspect of the cheetah"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericHunterNonCombatStrategy::GenericHunterNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericHunterNonCombatStrategyActionNodeFactory());
+}
+
+void GenericHunterNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "trueshot aura",
+        NextAction::array(0, new NextAction("trueshot aura", 2.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("call pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet dead",
+        NextAction::array(0, new NextAction("revive pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
new file mode 100644
index 0000000..d01486d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericHunterNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericHunterNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
new file mode 100644
index 0000000..e4c5d45
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericHunterStrategy.h"
+#include "HunterAiObjectContext.h"
+
+using namespace ai;
+
+class GenericHunterStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericHunterStrategyActionNodeFactory()
+    {
+        creators["rapid fire"] = &rapid_fire;
+        creators["boost"] = &rapid_fire;
+        creators["aspect of the pack"] = &aspect_of_the_pack;
+        creators["feign death"] = &feign_death;
+    }
+private:
+    static ActionNode* rapid_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rapid fire",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("readiness"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aspect_of_the_pack(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aspect of the pack",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aspect of the cheetah"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* feign_death(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feign death",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericHunterStrategy::GenericHunterStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericHunterStrategyActionNodeFactory());
+}
+
+void GenericHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("wing clip", 50.0f), new NextAction("flee",49.0f), new NextAction("concussive shot", 48.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("feign death", 52.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rapid fire",
+        NextAction::array(0, new NextAction("rapid fire", 55.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
new file mode 100644
index 0000000..f2db28c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericHunterStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericHunterStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "hunter"; }
+    };
+}
+
diff --git a/src/plugins/playerbot/strategy/hunter/HunterActions.cpp b/src/plugins/playerbot/strategy/hunter/HunterActions.cpp
new file mode 100644
index 0000000..bdf6761
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterActions.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../actions/GenericActions.h"
+#include "HunterActions.h"
+
+using namespace ai;
+
+bool CastSerpentStingAction::isUseful()
+{
+    return AI_VALUE2(uint8, "health", "current target") > 50;
+}
+
+bool CastViperStingAction::isUseful()
+{
+    return AI_VALUE2(uint8, "mana", "self target") < 50 && AI_VALUE2(uint8, "mana", "current target") >= 30;
+}
+
+bool CastAspectOfTheCheetahAction::isUseful() 
+{
+    return !ai->HasAnyAuraOf(GetTarget(), "aspect of the cheetah", "aspect of the pack", NULL);
+}
+
+Value<Unit*>* CastFreezingTrap::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", "freezing trap");
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterActions.h b/src/plugins/playerbot/strategy/hunter/HunterActions.h
new file mode 100644
index 0000000..9a1072f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterActions.h
@@ -0,0 +1,158 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    BEGIN_RANGED_SPELL_ACTION(CastHuntersMarkAction, "hunter's mark")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastAutoShotAction, "auto shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastArcaneShotAction, "arcane shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastExplosiveShotAction, "explosive shot")
+    END_SPELL_ACTION()
+
+
+    BEGIN_RANGED_SPELL_ACTION(CastAimedShotAction, "aimed shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastChimeraShotAction, "chimera shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastConcussiveShotAction, "concussive shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastDistractingShotAction, "distracting shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMultiShotAction, "multi-shot")
+    END_SPELL_ACTION()
+
+	BEGIN_RANGED_SPELL_ACTION(CastVolleyAction, "volley")
+	END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastSerpentStingAction, "serpent sting")
+    virtual bool isUseful();
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastWyvernStingAction, "wyvern sting")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastViperStingAction, "viper sting")
+    virtual bool isUseful();
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastScorpidStingAction, "scorpid sting")
+    END_SPELL_ACTION()
+
+	class CastAspectOfTheHawkAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheHawkAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the hawk") {}
+	};
+
+	class CastAspectOfTheWildAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheWildAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the wild") {}
+	};
+
+	class CastAspectOfTheCheetahAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheCheetahAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the cheetah") {}
+		virtual bool isUseful();
+	};
+
+	class CastAspectOfThePackAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfThePackAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the pack") {}
+	};
+
+	class CastAspectOfTheViperAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheViperAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the viper") {}
+	};
+
+	class CastCallPetAction : public CastBuffSpellAction
+	{
+	public:
+		CastCallPetAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "call pet") {}
+	};
+
+	class CastMendPetAction : public CastAuraSpellAction
+	{
+	public:
+		CastMendPetAction(PlayerbotAI* ai) : CastAuraSpellAction(ai, "mend pet") {}
+		virtual string GetTargetName() { return "pet target"; }
+	};
+
+	class CastRevivePetAction : public CastBuffSpellAction
+	{
+	public:
+		CastRevivePetAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "revive pet") {}
+	};
+
+    class CastTrueshotAuraAction : public CastBuffSpellAction
+    {
+    public:
+        CastTrueshotAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "trueshot aura") {}
+    };
+
+    class CastFeignDeathAction : public CastBuffSpellAction
+    {
+    public:
+        CastFeignDeathAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "feign death") {}
+    };
+
+	class CastRapidFireAction : public CastBuffSpellAction
+	{
+	public:
+		CastRapidFireAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "rapid fire") {}
+	};
+
+	class CastReadinessAction : public CastBuffSpellAction
+	{
+	public:
+		CastReadinessAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "readiness") {}
+	};
+
+	class CastBlackArrow : public CastDebuffSpellAction
+	{
+	public:
+		CastBlackArrow(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "black arrow") {}
+	};
+
+    class CastFreezingTrap : public CastDebuffSpellAction
+    {
+    public:
+        CastFreezingTrap(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "freezing trap") {}
+        virtual Value<Unit*>* GetTargetValue();
+    };
+
+    class CastWingClipAction : public CastMeleeSpellAction
+    {
+    public:
+        CastWingClipAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "wing clip") {}
+        virtual bool isUseful()
+        {
+            return CastMeleeSpellAction::isUseful() && !ai->HasAura(spell, GetTarget());
+        }
+        virtual NextAction** getPrerequisites()
+        {
+            return NULL;
+        }
+    };
+
+    class CastSerpentStingOnAttackerAction : public CastDebuffSpellOnAttackerAction
+    {
+    public:
+        CastSerpentStingOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "serpent sting") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
new file mode 100644
index 0000000..dd62523
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
@@ -0,0 +1,191 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterActions.h"
+#include "HunterTriggers.h"
+#include "HunterAiObjectContext.h"
+#include "DpsHunterStrategy.h"
+#include "GenericHunterNonCombatStrategy.h"
+#include "HunterBuffStrategies.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["dps"] = &hunter::StrategyFactoryInternal::dps;
+                creators["nc"] = &hunter::StrategyFactoryInternal::nc;
+                creators["aoe"] = &hunter::StrategyFactoryInternal::aoe;
+                creators["dps debuff"] = &hunter::StrategyFactoryInternal::dps_debuff;
+            }
+
+        private:
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsAoeHunterStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsHunterStrategy(ai); }
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericHunterNonCombatStrategy(ai); }
+            static Strategy* dps_debuff(PlayerbotAI* ai) { return new DpsHunterDebuffStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bspeed"] = &hunter::BuffStrategyFactoryInternal::bspeed;
+                creators["bdps"] = &hunter::BuffStrategyFactoryInternal::bdps;
+                creators["bmana"] = &hunter::BuffStrategyFactoryInternal::bmana;
+                creators["rnature"] = &hunter::BuffStrategyFactoryInternal::rnature;
+            }
+
+        private:
+            static Strategy* bspeed(PlayerbotAI* ai) { return new HunterBuffSpeedStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new HunterBuffDpsStrategy(ai); }
+            static Strategy* bmana(PlayerbotAI* ai) { return new HunterBuffManaStrategy(ai); }
+            static Strategy* rnature(PlayerbotAI* ai) { return new HunterNatureResistanceStrategy(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["aspect of the viper"] = &TriggerFactoryInternal::aspect_of_the_viper;
+                creators["black arrow"] = &TriggerFactoryInternal::black_arrow;
+                creators["no stings"] = &TriggerFactoryInternal::NoStings;
+                creators["hunters pet dead"] = &TriggerFactoryInternal::hunters_pet_dead;
+                creators["hunters pet low health"] = &TriggerFactoryInternal::hunters_pet_low_health;
+                creators["hunter's mark"] = &TriggerFactoryInternal::hunters_mark;
+                creators["freezing trap"] = &TriggerFactoryInternal::freezing_trap;
+                creators["aspect of the pack"] = &TriggerFactoryInternal::aspect_of_the_pack;
+                creators["rapid fire"] = &TriggerFactoryInternal::rapid_fire;
+                creators["aspect of the hawk"] = &TriggerFactoryInternal::aspect_of_the_hawk;
+                creators["aspect of the wild"] = &TriggerFactoryInternal::aspect_of_the_wild;
+                creators["aspect of the viper"] = &TriggerFactoryInternal::aspect_of_the_viper;
+                creators["trueshot aura"] = &TriggerFactoryInternal::trueshot_aura;
+                creators["serpent sting on attacker"] = &TriggerFactoryInternal::serpent_sting_on_attacker;
+            }
+
+        private:
+            static Trigger* serpent_sting_on_attacker(PlayerbotAI* ai) { return new SerpentStingOnAttackerTrigger(ai); }
+            static Trigger* trueshot_aura(PlayerbotAI* ai) { return new TrueshotAuraTrigger(ai); }
+            static Trigger* aspect_of_the_viper(PlayerbotAI* ai) { return new HunterAspectOfTheViperTrigger(ai); }
+            static Trigger* black_arrow(PlayerbotAI* ai) { return new BlackArrowTrigger(ai); }
+            static Trigger* NoStings(PlayerbotAI* ai) { return new HunterNoStingsActiveTrigger(ai); }
+            static Trigger* hunters_pet_dead(PlayerbotAI* ai) { return new HuntersPetDeadTrigger(ai); }
+            static Trigger* hunters_pet_low_health(PlayerbotAI* ai) { return new HuntersPetLowHealthTrigger(ai); }
+            static Trigger* hunters_mark(PlayerbotAI* ai) { return new HuntersMarkTrigger(ai); }
+            static Trigger* freezing_trap(PlayerbotAI* ai) { return new FreezingTrapTrigger(ai); }
+            static Trigger* aspect_of_the_pack(PlayerbotAI* ai) { return new HunterAspectOfThePackTrigger(ai); }
+            static Trigger* rapid_fire(PlayerbotAI* ai) { return new RapidFireTrigger(ai); }
+            static Trigger* aspect_of_the_hawk(PlayerbotAI* ai) { return new HunterAspectOfTheHawkTrigger(ai); }
+            static Trigger* aspect_of_the_wild(PlayerbotAI* ai) { return new HunterAspectOfTheWildTrigger(ai); }
+        };
+    };
+};
+
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["auto shot"] = &AiObjectContextInternal::auto_shot;
+                creators["aimed shot"] = &AiObjectContextInternal::aimed_shot;
+                creators["chimera shot"] = &AiObjectContextInternal::chimera_shot;
+                creators["explosive shot"] = &AiObjectContextInternal::explosive_shot;
+                creators["arcane shot"] = &AiObjectContextInternal::arcane_shot;
+                creators["concussive shot"] = &AiObjectContextInternal::concussive_shot;
+                creators["distracting shot"] = &AiObjectContextInternal::distracting_shot;
+                creators["multi-shot"] = &AiObjectContextInternal::multi_shot;
+                creators["volley"] = &AiObjectContextInternal::volley;
+                creators["serpent sting"] = &AiObjectContextInternal::serpent_sting;
+                creators["serpent sting on attacker"] = &AiObjectContextInternal::serpent_sting_on_attacker;
+                creators["wyvern sting"] = &AiObjectContextInternal::wyvern_sting;
+                creators["viper sting"] = &AiObjectContextInternal::viper_sting;
+                creators["scorpid sting"] = &AiObjectContextInternal::scorpid_sting;
+                creators["hunter's mark"] = &AiObjectContextInternal::hunters_mark;
+                creators["mend pet"] = &AiObjectContextInternal::mend_pet;
+                creators["revive pet"] = &AiObjectContextInternal::revive_pet;
+                creators["call pet"] = &AiObjectContextInternal::call_pet;
+                creators["black arrow"] = &AiObjectContextInternal::black_arrow;
+                creators["freezing trap"] = &AiObjectContextInternal::freezing_trap;
+                creators["rapid fire"] = &AiObjectContextInternal::rapid_fire;
+                creators["boost"] = &AiObjectContextInternal::rapid_fire;
+                creators["readiness"] = &AiObjectContextInternal::readiness;
+                creators["aspect of the hawk"] = &AiObjectContextInternal::aspect_of_the_hawk;
+                creators["aspect of the wild"] = &AiObjectContextInternal::aspect_of_the_wild;
+                creators["aspect of the viper"] = &AiObjectContextInternal::aspect_of_the_viper;
+                creators["aspect of the pack"] = &AiObjectContextInternal::aspect_of_the_pack;
+                creators["aspect of the cheetah"] = &AiObjectContextInternal::aspect_of_the_cheetah;
+                creators["trueshot aura"] = &AiObjectContextInternal::trueshot_aura;
+                creators["feign death"] = &AiObjectContextInternal::feign_death;
+                creators["wing clip"] = &AiObjectContextInternal::wing_clip;
+            }
+
+        private:
+            static Action* feign_death(PlayerbotAI* ai) { return new CastFeignDeathAction(ai); }
+            static Action* trueshot_aura(PlayerbotAI* ai) { return new CastTrueshotAuraAction(ai); }
+            static Action* auto_shot(PlayerbotAI* ai) { return new CastAutoShotAction(ai); }
+            static Action* aimed_shot(PlayerbotAI* ai) { return new CastAimedShotAction(ai); }
+            static Action* chimera_shot(PlayerbotAI* ai) { return new CastChimeraShotAction(ai); }
+            static Action* explosive_shot(PlayerbotAI* ai) { return new CastExplosiveShotAction(ai); }
+            static Action* arcane_shot(PlayerbotAI* ai) { return new CastArcaneShotAction(ai); }
+            static Action* concussive_shot(PlayerbotAI* ai) { return new CastConcussiveShotAction(ai); }
+            static Action* distracting_shot(PlayerbotAI* ai) { return new CastDistractingShotAction(ai); }
+            static Action* multi_shot(PlayerbotAI* ai) { return new CastMultiShotAction(ai); }
+            static Action* volley(PlayerbotAI* ai) { return new CastVolleyAction(ai); }
+            static Action* serpent_sting(PlayerbotAI* ai) { return new CastSerpentStingAction(ai); }
+            static Action* serpent_sting_on_attacker(PlayerbotAI* ai) { return new CastSerpentStingOnAttackerAction(ai); }
+            static Action* wyvern_sting(PlayerbotAI* ai) { return new CastWyvernStingAction(ai); }
+            static Action* viper_sting(PlayerbotAI* ai) { return new CastViperStingAction(ai); }
+            static Action* scorpid_sting(PlayerbotAI* ai) { return new CastScorpidStingAction(ai); }
+            static Action* hunters_mark(PlayerbotAI* ai) { return new CastHuntersMarkAction(ai); }
+            static Action* mend_pet(PlayerbotAI* ai) { return new CastMendPetAction(ai); }
+            static Action* revive_pet(PlayerbotAI* ai) { return new CastRevivePetAction(ai); }
+            static Action* call_pet(PlayerbotAI* ai) { return new CastCallPetAction(ai); }
+            static Action* black_arrow(PlayerbotAI* ai) { return new CastBlackArrow(ai); }
+            static Action* freezing_trap(PlayerbotAI* ai) { return new CastFreezingTrap(ai); }
+            static Action* rapid_fire(PlayerbotAI* ai) { return new CastRapidFireAction(ai); }
+            static Action* readiness(PlayerbotAI* ai) { return new CastReadinessAction(ai); }
+            static Action* aspect_of_the_hawk(PlayerbotAI* ai) { return new CastAspectOfTheHawkAction(ai); }
+            static Action* aspect_of_the_wild(PlayerbotAI* ai) { return new CastAspectOfTheWildAction(ai); }
+            static Action* aspect_of_the_viper(PlayerbotAI* ai) { return new CastAspectOfTheViperAction(ai); }
+            static Action* aspect_of_the_pack(PlayerbotAI* ai) { return new CastAspectOfThePackAction(ai); }
+            static Action* aspect_of_the_cheetah(PlayerbotAI* ai) { return new CastAspectOfTheCheetahAction(ai); }
+            static Action* wing_clip(PlayerbotAI* ai) { return new CastWingClipAction(ai); }
+        };
+    };
+};
+
+HunterAiObjectContext::HunterAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::hunter::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::hunter::BuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::hunter::AiObjectContextInternal());
+    triggerContexts.Add(new ai::hunter::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
new file mode 100644
index 0000000..8891a54
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class HunterAiObjectContext : public AiObjectContext
+    {
+    public:
+        HunterAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
new file mode 100644
index 0000000..33f7612
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
@@ -0,0 +1,35 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+#include "HunterBuffStrategies.h"
+
+using namespace ai;
+
+void HunterBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"aspect of the hawk", 
+		NextAction::array(0, new NextAction("aspect of the hawk", 90.0f), NULL)));
+}
+
+void HunterNatureResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"aspect of the wild", 
+		NextAction::array(0, new NextAction("aspect of the wild", 90.0f), NULL)));
+}
+
+
+void HunterBuffSpeedStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "aspect of the pack",
+        NextAction::array(0, new NextAction("aspect of the pack", 10.0f), NULL)));
+}
+
+void HunterBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "aspect of the viper",
+        NextAction::array(0, new NextAction("aspect of the viper", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
new file mode 100644
index 0000000..d59f245
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "GenericHunterStrategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class HunterBuffSpeedStrategy : public NonCombatStrategy
+    {
+    public:
+        HunterBuffSpeedStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "bspeed"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class HunterBuffManaStrategy : public NonCombatStrategy
+    {
+    public:
+        HunterBuffManaStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "bmana"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+	class HunterBuffDpsStrategy : public NonCombatStrategy
+	{
+	public:
+		HunterBuffDpsStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+		virtual string getName() { return "bdps"; }
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+	};
+
+	class HunterNatureResistanceStrategy : public NonCombatStrategy
+	{
+	public:
+		HunterNatureResistanceStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+		virtual string getName() { return "rnature"; }
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
new file mode 100644
index 0000000..9d0bdec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp b/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
new file mode 100644
index 0000000..c356a0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterTriggers.h"
+#include "HunterActions.h"
+
+using namespace ai;
+
+bool HunterNoStingsActiveTrigger::IsActive()
+{
+	Unit* target = AI_VALUE(Unit*, "current target");
+    return target && AI_VALUE2(uint8, "health", "current target") > 40 &&
+        !ai->HasAura("serpent sting", target) &&
+        !ai->HasAura("scorpid sting", target) &&
+        !ai->HasAura("viper sting", target);
+}
+
+bool HuntersPetDeadTrigger::IsActive()
+{
+    Unit* pet = AI_VALUE(Unit*, "pet target");
+    return pet && AI_VALUE2(bool, "dead", "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+}
+
+
+bool HuntersPetLowHealthTrigger::IsActive()
+{
+    Unit* pet = AI_VALUE(Unit*, "pet target");
+    return pet && AI_VALUE2(uint8, "health", "pet target") < 40 &&
+        !AI_VALUE2(bool, "dead", "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterTriggers.h b/src/plugins/playerbot/strategy/hunter/HunterTriggers.h
new file mode 100644
index 0000000..9466218
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterTriggers.h
@@ -0,0 +1,86 @@
+#pragma once
+
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BEGIN_TRIGGER(HunterNoStingsActiveTrigger, Trigger)
+    END_TRIGGER()
+
+    class HunterAspectOfTheHawkTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfTheHawkTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the hawk") {
+			checkInterval = 1;
+		}
+    };
+
+	class HunterAspectOfTheWildTrigger : public BuffTrigger
+	{
+	public:
+		HunterAspectOfTheWildTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the wild") {
+			checkInterval = 1;
+		}
+	};
+
+    class HunterAspectOfTheViperTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfTheViperTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the viper") {}
+        virtual bool IsActive()
+        {
+            return SpellTrigger::IsActive() && !ai->HasAura(spell, GetTarget());
+        }
+    };
+
+    class HunterAspectOfThePackTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfThePackTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the pack") {}
+        virtual bool IsActive() {
+			return BuffTrigger::IsActive() && !ai->HasAura("aspect of the cheetah", GetTarget());
+        };
+    };
+
+    BEGIN_TRIGGER(HuntersPetDeadTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(HuntersPetLowHealthTrigger, Trigger)
+    END_TRIGGER()
+
+    class BlackArrowTrigger : public DebuffTrigger
+    {
+    public:
+        BlackArrowTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "black arrow") {}
+    };
+
+    class HuntersMarkTrigger : public DebuffTrigger
+    {
+    public:
+        HuntersMarkTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "hunter's mark") {}
+    };
+
+    class FreezingTrapTrigger : public HasCcTargetTrigger
+    {
+    public:
+        FreezingTrapTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "freezing trap") {}
+    };
+
+    class RapidFireTrigger : public BoostTrigger
+    {
+    public:
+        RapidFireTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "rapid fire") {}
+    };
+
+    class TrueshotAuraTrigger : public BuffTrigger
+    {
+    public:
+        TrueshotAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "trueshot aura") {}
+    };
+
+    class SerpentStingOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        SerpentStingOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "serpent sting") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
new file mode 100644
index 0000000..0779477
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
@@ -0,0 +1,64 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "ArcaneMageStrategy.h"
+
+using namespace ai;
+
+class ArcaneMageStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    ArcaneMageStrategyActionNodeFactory()
+    {
+        creators["arcane blast"] = &arcane_blast;
+        creators["arcane barrage"] = &arcane_barrage;
+        creators["arcane missiles"] = &arcane_missiles;
+    }
+private:
+    static ActionNode* arcane_blast(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane blast",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane missiles"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* arcane_barrage(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane barrage",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane missiles"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* arcane_missiles(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane missiles",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+ArcaneMageStrategy::ArcaneMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai)
+{
+    actionNodeFactories.Add(new ArcaneMageStrategyActionNodeFactory());
+}
+
+NextAction** ArcaneMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("arcane barrage", 10.0f), NULL);
+}
+
+void ArcaneMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "arcane blast",
+        NextAction::array(0, new NextAction("arcane blast", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "missile barrage",
+        NextAction::array(0, new NextAction("arcane missiles", 15.0f), NULL)));
+
+}
+
diff --git a/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
new file mode 100644
index 0000000..ac053a8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+
+namespace ai
+{
+    class ArcaneMageStrategy : public GenericMageStrategy
+    {
+    public:
+        ArcaneMageStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "arcane"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
new file mode 100644
index 0000000..47c4bc2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "FireMageStrategy.h"
+
+using namespace ai;
+
+NextAction** FireMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("scorch", 7.0f), new NextAction("fireball", 6.0f), new NextAction("fire blast", 5.0f), NULL);
+}
+
+void FireMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "pyroblast",
+        NextAction::array(0, new NextAction("pyroblast", 10.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hot streak",
+        NextAction::array(0, new NextAction("pyroblast", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "combustion",
+        NextAction::array(0, new NextAction("combustion", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("dragon's breath", 70.0f), NULL)));
+}
+
+void FireMageAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("flamestrike", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "living bomb",
+        NextAction::array(0, new NextAction("living bomb", 25.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/mage/FireMageStrategy.h b/src/plugins/playerbot/strategy/mage/FireMageStrategy.h
new file mode 100644
index 0000000..fc0cd7f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FireMageStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class FireMageStrategy : public GenericMageStrategy
+    {
+    public:
+        FireMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "fire"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+    class FireMageAoeStrategy : public CombatStrategy
+    {
+    public:
+        FireMageAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "fire aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
new file mode 100644
index 0000000..e6fb861
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
@@ -0,0 +1,32 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "FrostMageStrategy.h"
+
+using namespace ai;
+
+
+FrostMageStrategy::FrostMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai)
+{
+}
+
+NextAction** FrostMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("frostbolt", 7.0f), NULL);
+}
+
+void FrostMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "icy veins",
+        NextAction::array(0, new NextAction("icy veins", 50.0f), NULL)));
+}
+
+void FrostMageAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("blizzard", 40.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
new file mode 100644
index 0000000..15fac2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class FrostMageStrategy : public GenericMageStrategy
+    {
+    public:
+        FrostMageStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "frost"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+    class FrostMageAoeStrategy : public CombatStrategy
+    {
+    public:
+        FrostMageAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "frost aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
new file mode 100644
index 0000000..f4111de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
@@ -0,0 +1,87 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "GenericMageNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericMageNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericMageNonCombatStrategyActionNodeFactory()
+    {
+        creators["molten armor"] = &molten_armor;
+        creators["mage armor"] = &mage_armor;
+        creators["ice armor"] = &ice_armor;
+    }
+private:
+    static ActionNode* molten_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("molten armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mage armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mage_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mage armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("ice armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* ice_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("ice armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frost armor"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericMageNonCombatStrategy::GenericMageNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericMageNonCombatStrategyActionNodeFactory());
+}
+
+void GenericMageNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "arcane intellect",
+        NextAction::array(0, new NextAction("arcane intellect", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "arcane intellect on party",
+        NextAction::array(0, new NextAction("arcane intellect on party", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no drink",
+		NextAction::array(0, new NextAction("conjure water", 16.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no food",
+		NextAction::array(0, new NextAction("conjure food", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse",
+        NextAction::array(0, new NextAction("remove curse", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse on party",
+        NextAction::array(0, new NextAction("remove curse on party", 40.0f), NULL)));
+}
+
+void MageBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "mage armor",
+        NextAction::array(0, new NextAction("mage armor", 19.0f), NULL)));
+}
+
+void MageBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "mage armor",
+        NextAction::array(0, new NextAction("molten armor", 19.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
new file mode 100644
index 0000000..5319bf9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericMageNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericMageNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class MageBuffManaStrategy : public Strategy
+    {
+    public:
+        MageBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+    };
+
+    class MageBuffDpsStrategy : public Strategy
+    {
+    public:
+        MageBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
new file mode 100644
index 0000000..7f137c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
@@ -0,0 +1,137 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "GenericMageStrategy.h"
+
+using namespace ai;
+
+class GenericMageStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericMageStrategyActionNodeFactory()
+    {
+        creators["frostbolt"] = &frostbolt;
+        creators["fire blast"] = &fire_blast;
+        creators["scorch"] = &scorch;
+        creators["frost nova"] = &frost_nova;
+        creators["icy veins"] = &icy_veins;
+        creators["combustion"] = &combustion;
+        creators["evocation"] = &evocation;
+        creators["dragon's breath"] = &dragons_breath;
+        creators["blast wave"] = &blast_wave;
+    }
+private:
+    static ActionNode* frostbolt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frostbolt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* fire_blast(PlayerbotAI* ai)
+    {
+        return new ActionNode ("fire blast",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("scorch"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* scorch(PlayerbotAI* ai)
+    {
+        return new ActionNode ("scorch",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* frost_nova(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frost nova",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flee"), NULL));
+    }
+    static ActionNode* icy_veins(PlayerbotAI* ai)
+    {
+        return new ActionNode ("icy veins",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* combustion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("combustion",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* evocation(PlayerbotAI* ai)
+    {
+        return new ActionNode ("evocation",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* dragons_breath(PlayerbotAI* ai)
+    {
+        return new ActionNode ("dragon's breath",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blast wave"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flamestrike", 71.0f), NULL));
+    }
+    static ActionNode* blast_wave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blast wave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frost nova"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flamestrike", 71.0f), NULL));
+    }
+};
+
+GenericMageStrategy::GenericMageStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericMageStrategyActionNodeFactory());
+}
+
+void GenericMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "remove curse",
+        NextAction::array(0, new NextAction("remove curse", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse on party",
+        NextAction::array(0, new NextAction("remove curse on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("frost nova", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "counterspell",
+        NextAction::array(0, new NextAction("counterspell", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "counterspell on enemy healer",
+        NextAction::array(0, new NextAction("counterspell on enemy healer", 40.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("ice block", 80.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "polymorph",
+        NextAction::array(0, new NextAction("polymorph", 30.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"spellsteal",
+		NextAction::array(0, new NextAction("spellsteal", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("invisibility", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("evocation", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
new file mode 100644
index 0000000..4dcb9d9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class GenericMageStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericMageStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "mage"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageActions.cpp b/src/plugins/playerbot/strategy/mage/MageActions.cpp
new file mode 100644
index 0000000..ee4d6fc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageActions.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageActions.h"
+
+using namespace ai;
+
+Value<Unit*>* CastPolymorphAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", getName());
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageActions.h b/src/plugins/playerbot/strategy/mage/MageActions.h
new file mode 100644
index 0000000..ea541a9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageActions.h
@@ -0,0 +1,205 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastFireballAction : public CastSpellAction
+    {
+    public:
+        CastFireballAction(PlayerbotAI* ai) : CastSpellAction(ai, "fireball") {}
+    };
+
+    class CastScorchAction : public CastSpellAction
+    {
+    public:
+        CastScorchAction(PlayerbotAI* ai) : CastSpellAction(ai, "scorch") {}
+    };
+
+    class CastFireBlastAction : public CastSpellAction
+    {
+    public:
+        CastFireBlastAction(PlayerbotAI* ai) : CastSpellAction(ai, "fire blast") {}
+    };
+
+    class CastArcaneBlastAction : public CastBuffSpellAction
+    {
+    public:
+        CastArcaneBlastAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane blast") {}
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+    class CastArcaneBarrageAction : public CastSpellAction
+    {
+    public:
+        CastArcaneBarrageAction(PlayerbotAI* ai) : CastSpellAction(ai, "arcane barrage") {}
+    };
+
+    class CastArcaneMissilesAction : public CastSpellAction
+    {
+    public:
+        CastArcaneMissilesAction(PlayerbotAI* ai) : CastSpellAction(ai, "arcane missiles") {}
+    };
+
+    class CastPyroblastAction : public CastSpellAction
+    {
+    public:
+        CastPyroblastAction(PlayerbotAI* ai) : CastSpellAction(ai, "pyroblast") {}
+    };
+
+    class CastFlamestrikeAction : public CastSpellAction
+    {
+    public:
+        CastFlamestrikeAction(PlayerbotAI* ai) : CastSpellAction(ai, "flamestrike") {}
+    };
+
+    class CastFrostNovaAction : public CastSpellAction
+    {
+    public:
+        CastFrostNovaAction(PlayerbotAI* ai) : CastSpellAction(ai, "frost nova") {}
+        virtual bool isUseful() { return AI_VALUE2(float, "distance", GetTargetName()) <= sPlayerbotAIConfig.tooCloseDistance; }
+    };
+
+	class CastFrostboltAction : public CastSpellAction
+	{
+	public:
+		CastFrostboltAction(PlayerbotAI* ai) : CastSpellAction(ai, "frostbolt") {}
+	};
+
+	class CastBlizzardAction : public CastSpellAction
+	{
+	public:
+		CastBlizzardAction(PlayerbotAI* ai) : CastSpellAction(ai, "blizzard") {}
+	};
+
+	class CastArcaneIntellectAction : public CastBuffSpellAction
+    {
+	public:
+		CastArcaneIntellectAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane intellect") {}
+	};
+
+	class CastArcaneIntellectOnPartyAction : public BuffOnPartyAction
+    {
+	public:
+		CastArcaneIntellectOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "arcane intellect") {}
+	};
+
+	class CastRemoveCurseAction : public CastCureSpellAction
+    {
+	public:
+		CastRemoveCurseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "remove curse") {}
+	};
+
+	class CastIcyVeinsAction : public CastBuffSpellAction
+    {
+	public:
+		CastIcyVeinsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "icy veins") {}
+	};
+
+	class CastCombustionAction : public CastBuffSpellAction
+    {
+	public:
+		CastCombustionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "combustion") {}
+	};
+
+    BEGIN_SPELL_ACTION(CastCounterspellAction, "counterspell")
+    END_SPELL_ACTION()
+
+    class CastRemoveCurseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastRemoveCurseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+	class CastConjureFoodAction : public CastBuffSpellAction
+    {
+	public:
+		CastConjureFoodAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "conjure food") {}
+	};
+
+	class CastConjureWaterAction : public CastBuffSpellAction
+    {
+	public:
+		CastConjureWaterAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "conjure water") {}
+	};
+
+	class CastIceBlockAction : public CastBuffSpellAction
+    {
+	public:
+		CastIceBlockAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "ice block") {}
+	};
+
+    class CastMoltenArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastMoltenArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "molten armor") {}
+    };
+
+    class CastMageArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastMageArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "mage armor") {}
+    };
+
+    class CastIceArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastIceArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "ice armor") {}
+    };
+
+    class CastFrostArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastFrostArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "frost armor") {}
+    };
+
+    class CastPolymorphAction : public CastBuffSpellAction
+    {
+    public:
+        CastPolymorphAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "polymorph") {}
+        virtual Value<Unit*>* GetTargetValue();
+    };
+
+	class CastSpellstealAction : public CastSpellAction
+	{
+	public:
+		CastSpellstealAction(PlayerbotAI* ai) : CastSpellAction(ai, "spellsteal") {}
+	};
+
+	class CastLivingBombAction : public CastDebuffSpellAction
+	{
+	public:
+	    CastLivingBombAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "living bomb") {}
+	};
+
+	class CastDragonsBreathAction : public CastSpellAction
+	{
+	public:
+	    CastDragonsBreathAction(PlayerbotAI* ai) : CastSpellAction(ai, "dragon's breath") {}
+	};
+
+	class CastBlastWaveAction : public CastSpellAction
+	{
+	public:
+	    CastBlastWaveAction(PlayerbotAI* ai) : CastSpellAction(ai, "blast wave") {}
+	};
+
+	class CastInvisibilityAction : public CastBuffSpellAction
+	{
+	public:
+	    CastInvisibilityAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "invisibility") {}
+	};
+
+	class CastEvocationAction : public CastSpellAction
+	{
+	public:
+	    CastEvocationAction(PlayerbotAI* ai) : CastSpellAction(ai, "evocation") {}
+	    virtual string GetTargetName() { return "self target"; }
+	};
+
+    class CastCounterspellOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+	    CastCounterspellOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "counterspell") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
new file mode 100644
index 0000000..366ef77
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
@@ -0,0 +1,221 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../Strategy.h"
+#include "MageActions.h"
+#include "MageAiObjectContext.h"
+#include "FrostMageStrategy.h"
+#include "ArcaneMageStrategy.h"
+#include "GenericMageNonCombatStrategy.h"
+#include "FireMageStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "MageTriggers.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &mage::StrategyFactoryInternal::nc;
+                creators["pull"] = &mage::StrategyFactoryInternal::pull;
+                creators["fire aoe"] = &mage::StrategyFactoryInternal::fire_aoe;
+                creators["frost aoe"] = &mage::StrategyFactoryInternal::frost_aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericMageNonCombatStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+            static Strategy* fire_aoe(PlayerbotAI* ai) { return new FireMageAoeStrategy(ai); }
+            static Strategy* frost_aoe(PlayerbotAI* ai) { return new FrostMageAoeStrategy(ai); }
+        };
+
+        class MageStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            MageStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["frost"] = &mage::MageStrategyFactoryInternal::frost;
+                creators["fire"] = &mage::MageStrategyFactoryInternal::fire;
+                creators["arcane"] = &mage::MageStrategyFactoryInternal::arcane;
+            }
+
+        private:
+            static Strategy* frost(PlayerbotAI* ai) { return new FrostMageStrategy(ai); }
+            static Strategy* fire(PlayerbotAI* ai) { return new FireMageStrategy(ai); }
+            static Strategy* arcane(PlayerbotAI* ai) { return new ArcaneMageStrategy(ai); }
+        };
+
+        class MageBuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            MageBuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bmana"] = &mage::MageBuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &mage::MageBuffStrategyFactoryInternal::bdps;
+            }
+
+        private:
+            static Strategy* bmana(PlayerbotAI* ai) { return new MageBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new MageBuffDpsStrategy(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["fireball"] = &TriggerFactoryInternal::fireball;
+                creators["pyroblast"] = &TriggerFactoryInternal::pyroblast;
+                creators["combustion"] = &TriggerFactoryInternal::combustion;
+                creators["icy veins"] = &TriggerFactoryInternal::icy_veins;
+                creators["arcane intellect"] = &TriggerFactoryInternal::arcane_intellect;
+                creators["arcane intellect on party"] = &TriggerFactoryInternal::arcane_intellect_on_party;
+                creators["mage armor"] = &TriggerFactoryInternal::mage_armor;
+                creators["remove curse"] = &TriggerFactoryInternal::remove_curse;
+                creators["remove curse on party"] = &TriggerFactoryInternal::remove_curse_on_party;
+                creators["counterspell"] = &TriggerFactoryInternal::counterspell;
+                creators["polymorph"] = &TriggerFactoryInternal::polymorph;
+                creators["spellsteal"] = &TriggerFactoryInternal::spellsteal;
+                creators["hot streak"] = &TriggerFactoryInternal::hot_streak;
+                creators["living bomb"] = &TriggerFactoryInternal::living_bomb;
+                creators["missile barrage"] = &TriggerFactoryInternal::missile_barrage;
+                creators["arcane blast"] = &TriggerFactoryInternal::arcane_blast;
+                creators["counterspell on enemy healer"] = &TriggerFactoryInternal::counterspell_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* hot_streak(PlayerbotAI* ai) { return new HotStreakTrigger(ai); }
+            static Trigger* fireball(PlayerbotAI* ai) { return new FireballTrigger(ai); }
+            static Trigger* pyroblast(PlayerbotAI* ai) { return new PyroblastTrigger(ai); }
+            static Trigger* combustion(PlayerbotAI* ai) { return new CombustionTrigger(ai); }
+            static Trigger* icy_veins(PlayerbotAI* ai) { return new IcyVeinsTrigger(ai); }
+            static Trigger* arcane_intellect(PlayerbotAI* ai) { return new ArcaneIntellectTrigger(ai); }
+            static Trigger* arcane_intellect_on_party(PlayerbotAI* ai) { return new ArcaneIntellectOnPartyTrigger(ai); }
+            static Trigger* mage_armor(PlayerbotAI* ai) { return new MageArmorTrigger(ai); }
+            static Trigger* remove_curse(PlayerbotAI* ai) { return new RemoveCurseTrigger(ai); }
+            static Trigger* remove_curse_on_party(PlayerbotAI* ai) { return new PartyMemberRemoveCurseTrigger(ai); }
+            static Trigger* counterspell(PlayerbotAI* ai) { return new CounterspellInterruptSpellTrigger(ai); }
+            static Trigger* polymorph(PlayerbotAI* ai) { return new PolymorphTrigger(ai); }
+            static Trigger* spellsteal(PlayerbotAI* ai) { return new SpellstealTrigger(ai); }
+            static Trigger* living_bomb(PlayerbotAI* ai) { return new LivingBombTrigger(ai); }
+            static Trigger* missile_barrage(PlayerbotAI* ai) { return new MissileBarrageTrigger(ai); }
+            static Trigger* arcane_blast(PlayerbotAI* ai) { return new ArcaneBlastTrigger(ai); }
+            static Trigger* counterspell_enemy_healer(PlayerbotAI* ai) { return new CounterspellEnemyHealerTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["frostbolt"] = &AiObjectContextInternal::frostbolt;
+                creators["blizzard"] = &AiObjectContextInternal::blizzard;
+                creators["frost nova"] = &AiObjectContextInternal::frost_nova;
+                creators["arcane intellect"] = &AiObjectContextInternal::arcane_intellect;
+                creators["arcane intellect on party"] = &AiObjectContextInternal::arcane_intellect_on_party;
+                creators["conjure water"] = &AiObjectContextInternal::conjure_water;
+                creators["conjure food"] = &AiObjectContextInternal::conjure_food;
+                creators["molten armor"] = &AiObjectContextInternal::molten_armor;
+                creators["mage armor"] = &AiObjectContextInternal::mage_armor;
+                creators["ice armor"] = &AiObjectContextInternal::ice_armor;
+                creators["frost armor"] = &AiObjectContextInternal::frost_armor;
+                creators["fireball"] = &AiObjectContextInternal::fireball;
+                creators["pyroblast"] = &AiObjectContextInternal::pyroblast;
+                creators["flamestrike"] = &AiObjectContextInternal::flamestrike;
+                creators["fire blast"] = &AiObjectContextInternal::fire_blast;
+                creators["scorch"] = &AiObjectContextInternal::scorch;
+                creators["counterspell"] = &AiObjectContextInternal::counterspell;
+                creators["remove curse"] = &AiObjectContextInternal::remove_curse;
+                creators["remove curse on party"] = &AiObjectContextInternal::remove_curse_on_party;
+                creators["icy veins"] = &AiObjectContextInternal::icy_veins;
+                creators["combustion"] = &AiObjectContextInternal::combustion;
+                creators["ice block"] = &AiObjectContextInternal::ice_block;
+                creators["polymorph"] = &AiObjectContextInternal::polymorph;
+                creators["spellsteal"] = &AiObjectContextInternal::spellsteal;
+                creators["living bomb"] = &AiObjectContextInternal::living_bomb;
+                creators["dragon's breath"] = &AiObjectContextInternal::dragons_breath;
+                creators["blast wave"] = &AiObjectContextInternal::blast_wave;
+                creators["invisibility"] = &AiObjectContextInternal::invisibility;
+                creators["evocation"] = &AiObjectContextInternal::evocation;
+                creators["arcane blast"] = &AiObjectContextInternal::arcane_blast;
+                creators["arcane barrage"] = &AiObjectContextInternal::arcane_barrage;
+                creators["arcane missiles"] = &AiObjectContextInternal::arcane_missiles;
+                creators["counterspell on enemy healer"] = &AiObjectContextInternal::counterspell_on_enemy_healer;
+            }
+
+        private:
+            static Action* arcane_missiles(PlayerbotAI* ai) { return new CastArcaneMissilesAction(ai); }
+            static Action* arcane_barrage(PlayerbotAI* ai) { return new CastArcaneBarrageAction(ai); }
+            static Action* arcane_blast(PlayerbotAI* ai) { return new CastArcaneBlastAction(ai); }
+            static Action* frostbolt(PlayerbotAI* ai) { return new CastFrostboltAction(ai); }
+            static Action* blizzard(PlayerbotAI* ai) { return new CastBlizzardAction(ai); }
+            static Action* frost_nova(PlayerbotAI* ai) { return new CastFrostNovaAction(ai); }
+            static Action* arcane_intellect(PlayerbotAI* ai) { return new CastArcaneIntellectAction(ai); }
+            static Action* arcane_intellect_on_party(PlayerbotAI* ai) { return new CastArcaneIntellectOnPartyAction(ai); }
+            static Action* conjure_water(PlayerbotAI* ai) { return new CastConjureWaterAction(ai); }
+            static Action* conjure_food(PlayerbotAI* ai) { return new CastConjureFoodAction(ai); }
+            static Action* molten_armor(PlayerbotAI* ai) { return new CastMoltenArmorAction(ai); }
+            static Action* mage_armor(PlayerbotAI* ai) { return new CastMageArmorAction(ai); }
+            static Action* ice_armor(PlayerbotAI* ai) { return new CastIceArmorAction(ai); }
+            static Action* frost_armor(PlayerbotAI* ai) { return new CastFrostArmorAction(ai); }
+            static Action* fireball(PlayerbotAI* ai) { return new CastFireballAction(ai); }
+            static Action* pyroblast(PlayerbotAI* ai) { return new CastPyroblastAction(ai); }
+            static Action* flamestrike(PlayerbotAI* ai) { return new CastFlamestrikeAction(ai); }
+            static Action* fire_blast(PlayerbotAI* ai) { return new CastFireBlastAction(ai); }
+            static Action* scorch(PlayerbotAI* ai) { return new CastScorchAction(ai); }
+            static Action* counterspell(PlayerbotAI* ai) { return new CastCounterspellAction(ai); }
+            static Action* remove_curse(PlayerbotAI* ai) { return new CastRemoveCurseAction(ai); }
+            static Action* remove_curse_on_party(PlayerbotAI* ai) { return new CastRemoveCurseOnPartyAction(ai); }
+            static Action* icy_veins(PlayerbotAI* ai) { return new CastIcyVeinsAction(ai); }
+            static Action* combustion(PlayerbotAI* ai) { return new CastCombustionAction(ai); }
+            static Action* ice_block(PlayerbotAI* ai) { return new CastIceBlockAction(ai); }
+            static Action* polymorph(PlayerbotAI* ai) { return new CastPolymorphAction(ai); }
+            static Action* spellsteal(PlayerbotAI* ai) { return new CastSpellstealAction(ai); }
+            static Action* living_bomb(PlayerbotAI* ai) { return new CastLivingBombAction(ai); }
+            static Action* dragons_breath(PlayerbotAI* ai) { return new CastDragonsBreathAction(ai); }
+            static Action* blast_wave(PlayerbotAI* ai) { return new CastBlastWaveAction(ai); }
+            static Action* invisibility(PlayerbotAI* ai) { return new CastInvisibilityAction(ai); }
+            static Action* evocation(PlayerbotAI* ai) { return new CastEvocationAction(ai); }
+            static Action* counterspell_on_enemy_healer(PlayerbotAI* ai) { return new CastCounterspellOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+
+MageAiObjectContext::MageAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::mage::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::mage::MageStrategyFactoryInternal());
+    strategyContexts.Add(new ai::mage::MageBuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::mage::AiObjectContextInternal());
+    triggerContexts.Add(new ai::mage::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
new file mode 100644
index 0000000..0fe90e2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class MageAiObjectContext : public AiObjectContext
+    {
+    public:
+        MageAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp b/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
new file mode 100644
index 0000000..8ebe45f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "MageActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageMultipliers.h b/src/plugins/playerbot/strategy/mage/MageMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageTriggers.cpp b/src/plugins/playerbot/strategy/mage/MageTriggers.cpp
new file mode 100644
index 0000000..48750fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageTriggers.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageTriggers.h"
+#include "MageActions.h"
+
+using namespace ai;
+
+bool MageArmorTrigger::IsActive()
+{
+    Unit* target = GetTarget();
+    return !ai->HasAura("ice armor", target) &&
+        !ai->HasAura("frost armor", target) &&
+        !ai->HasAura("molten armor", target) &&
+        !ai->HasAura("mage armor", target);
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageTriggers.h b/src/plugins/playerbot/strategy/mage/MageTriggers.h
new file mode 100644
index 0000000..a07b4f2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageTriggers.h
@@ -0,0 +1,92 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_ON_PARTY_TRIGGER(ArcaneIntellectOnPartyTrigger, "arcane intellect", "arcane intellect on party")
+    BUFF_TRIGGER(ArcaneIntellectTrigger, "arcane intellect", "arcane intellect")
+
+    class MageArmorTrigger : public BuffTrigger {
+    public:
+        MageArmorTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "mage armor") {}
+        virtual bool IsActive();
+    };
+
+    class LivingBombTrigger : public DebuffTrigger {
+    public:
+        LivingBombTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "living bomb") {}
+	};
+
+    class FireballTrigger : public DebuffTrigger {
+    public:
+        FireballTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "fireball") {}
+	};
+
+    class PyroblastTrigger : public DebuffTrigger {
+    public:
+        PyroblastTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "pyroblast") {}
+    };
+
+    class HotStreakTrigger : public HasAuraTrigger {
+    public:
+        HotStreakTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "hot streak") {}
+    };
+
+    class MissileBarrageTrigger : public HasAuraTrigger {
+    public:
+        MissileBarrageTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "missile barrage") {}
+    };
+
+    class ArcaneBlastTrigger : public BuffTrigger {
+    public:
+        ArcaneBlastTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "arcane blast") {}
+    };
+
+    class CounterspellInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        CounterspellInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "counterspell") {}
+    };
+
+    class CombustionTrigger : public BoostTrigger
+    {
+    public:
+        CombustionTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "combustion") {}
+    };
+
+    class IcyVeinsTrigger : public BoostTrigger
+    {
+    public:
+        IcyVeinsTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "icy veins") {}
+    };
+
+    class PolymorphTrigger : public HasCcTargetTrigger
+    {
+    public:
+        PolymorphTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "polymorph") {}
+    };
+
+    class RemoveCurseTrigger : public NeedCureTrigger
+    {
+    public:
+        RemoveCurseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+    class PartyMemberRemoveCurseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberRemoveCurseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+    class SpellstealTrigger : public TargetAuraDispelTrigger
+    {
+    public:
+        SpellstealTrigger(PlayerbotAI* ai) : TargetAuraDispelTrigger(ai, "spellsteal", DISPEL_MAGIC) {}
+    };
+
+    class CounterspellEnemyHealerTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        CounterspellEnemyHealerTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "counterspell") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
new file mode 100644
index 0000000..02c4a57
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
@@ -0,0 +1,83 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "DpsPaladinStrategy.h"
+
+using namespace ai;
+
+class DpsPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsPaladinStrategyActionNodeFactory()
+    {
+        creators["seal of vengeance"] = &seal_of_vengeance;
+        creators["seal of command"] = &seal_of_command;
+        creators["blessing of might"] = &blessing_of_might;
+        creators["crusader strike"] = &crusader_strike;
+    }
+
+private:
+    static ActionNode* seal_of_vengeance(PlayerbotAI* ai)
+    {
+        return new ActionNode ("seal of vengeance",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("seal of command"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* seal_of_command(PlayerbotAI* ai)
+    {
+        return new ActionNode ("seal of command",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("seal of wisdom"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* blessing_of_might(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blessing of might",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blessing of kings"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* crusader_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("crusader strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsPaladinStrategy::DpsPaladinStrategy(PlayerbotAI* ai) : GenericPaladinStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsPaladinStrategyActionNodeFactory());
+}
+
+NextAction** DpsPaladinStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("crusader strike", ACTION_NORMAL + 1), NULL);
+}
+
+void DpsPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPaladinStrategy::InitTriggers(triggers);
+    
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("divine shield", ACTION_CRITICAL_HEAL + 2), new NextAction("holy light", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "judgement of wisdom",
+        NextAction::array(0, new NextAction("judgement of wisdom", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "blessing",
+        NextAction::array(0, new NextAction("blessing of might", ACTION_HIGH + 8), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe",
+		NextAction::array(0, new NextAction("divine storm", ACTION_HIGH + 1), new NextAction("consecration", ACTION_HIGH + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"art of war",
+		NextAction::array(0, new NextAction("exorcism", ACTION_HIGH + 2), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
new file mode 100644
index 0000000..cff5fd2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class DpsPaladinStrategy : public GenericPaladinStrategy
+    {
+    public:
+        DpsPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
new file mode 100644
index 0000000..fda1619
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "GenericPaladinNonCombatStrategy.h"
+#include "GenericPaladinStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+GenericPaladinNonCombatStrategy::GenericPaladinNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPaladinStrategyActionNodeFactory());
+}
+
+void GenericPaladinNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "blessing of kings on party",
+        NextAction::array(0, new NextAction("blessing of kings on party", 11.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("redemption", 30.0f), NULL)));
+
+	 triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash of light", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash of light on party", 26.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("holy light", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("holy light on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure disease",
+        NextAction::array(0, new NextAction("cleanse disease", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure disease",
+        NextAction::array(0, new NextAction("cleanse disease on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure poison",
+        NextAction::array(0, new NextAction("cleanse poison", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure poison",
+        NextAction::array(0, new NextAction("cleanse poison on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure magic",
+        NextAction::array(0, new NextAction("cleanse magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure magic",
+        NextAction::array(0, new NextAction("cleanse magic on party", 40.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
new file mode 100644
index 0000000..cf03f6d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericPaladinNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericPaladinNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+   };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
new file mode 100644
index 0000000..d218be1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
@@ -0,0 +1,77 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericPaladinStrategy.h"
+#include "GenericPaladinStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+
+GenericPaladinStrategy::GenericPaladinStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPaladinStrategyActionNodeFactory());
+}
+
+void GenericPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash of light", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash of light on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("divine protection", ACTION_CRITICAL_HEAL + 2), new NextAction("holy light", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("holy light on party", ACTION_CRITICAL_HEAL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hammer of justice interrupt",
+		NextAction::array(0, new NextAction("hammer of justice", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hammer of justice on enemy healer",
+		NextAction::array(0, new NextAction("hammer of justice on enemy healer", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("lay on hands", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member critical health",
+		NextAction::array(0, new NextAction("lay on hands on party", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"target critical health",
+		NextAction::array(0, new NextAction("hammer of wrath", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure disease",
+        NextAction::array(0, new NextAction("cleanse disease", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure disease",
+        NextAction::array(0, new NextAction("cleanse disease on party", ACTION_DISPEL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure poison",
+        NextAction::array(0, new NextAction("cleanse poison", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure poison",
+        NextAction::array(0, new NextAction("cleanse poison on party", ACTION_DISPEL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"cleanse cure magic",
+		NextAction::array(0, new NextAction("cleanse magic", ACTION_DISPEL + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"cleanse party member cure magic",
+		NextAction::array(0, new NextAction("cleanse magic on party", ACTION_DISPEL + 1), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
new file mode 100644
index 0000000..000f785
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "PaladinAiObjectContext.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class GenericPaladinStrategy : public MeleeCombatStrategy
+    {
+    public:
+        GenericPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "paladin"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
new file mode 100644
index 0000000..c2e1865
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
@@ -0,0 +1,150 @@
+#pragma once
+
+namespace ai
+{
+    class GenericPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        GenericPaladinStrategyActionNodeFactory()
+        {
+            creators["seal of light"] = &seal_of_light;
+            creators["cleanse poison"] = &cleanse_poison;
+            creators["cleanse disease"] = &cleanse_disease;
+            creators["cleanse magic"] = &cleanse_magic;
+            creators["cleanse poison on party"] = &cleanse_poison_on_party;
+            creators["cleanse disease on party"] = &cleanse_disease_on_party;
+            creators["seal of wisdom"] = &seal_of_wisdom;
+            creators["seal of justice"] = &seal_of_justice;
+            creators["hand of reckoning"] = &hand_of_reckoning;
+            creators["judgement of wisdom"] = &judgement_of_wisdom;
+            creators["divine shield"] = &divine_shield;
+            creators["flash of light"] = &flash_of_light;
+            creators["flash of light on party"] = &flash_of_light_on_party;
+            creators["holy wrath"] = &holy_wrath;
+            creators["lay on hands"] = &lay_on_hands;
+            creators["lay on hands on party"] = &lay_on_hands_on_party;
+            creators["hammer of wrath"] = &hammer_of_wrath;
+        }
+    private:
+        static ActionNode* lay_on_hands(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lay on hands",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("divine shield"), new NextAction("flash of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lay_on_hands_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lay on hands on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("flash of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_light(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of light",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_poison(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse poison",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify poison"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_magic(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse magic",
+                /*P*/ NULL,
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_disease(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse disease",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify disease"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_poison_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse poison on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify poison on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_disease_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse disease on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify disease on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_wisdom(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of wisdom",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_justice(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of justice",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of righteousness"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* hand_of_reckoning(PlayerbotAI* ai)
+        {
+            return new ActionNode ("hand of reckoning",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("judgement of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* judgement_of_wisdom(PlayerbotAI* ai)
+        {
+            return new ActionNode ("judgement of wisdom",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("judgement of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine shield",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("divine protection"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_of_light(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash of light",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("holy light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_of_light_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash of light on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("holy light on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* holy_wrath(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy wrath",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("consecration"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* hammer_of_wrath(PlayerbotAI* ai)
+        {
+            return new ActionNode ("hammer of wrath",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+                /*C*/ NULL);
+        }
+    };
+
+};
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp b/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
new file mode 100644
index 0000000..47def40
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinActions.h b/src/plugins/playerbot/strategy/paladin/PaladinActions.h
new file mode 100644
index 0000000..78f782c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinActions.h
@@ -0,0 +1,365 @@
+#pragma once
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastJudgementOfLightAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfLightAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of light") {}
+    };
+
+    class CastJudgementOfWisdomAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfWisdomAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of wisdom") {}
+    };
+
+    class CastJudgementOfJusticeAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfJusticeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of justice") {}
+    };
+
+	class CastRighteousFuryAction : public CastBuffSpellAction
+	{
+	public:
+		CastRighteousFuryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "righteous fury") {}
+	};
+
+	class CastDevotionAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastDevotionAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "devotion aura") {}
+	};
+
+	class CastRetributionAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastRetributionAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "retribution aura") {}
+	};
+
+	class CastConcentrationAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastConcentrationAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "concentration aura") {}
+	};
+
+	class CastDivineStormAction : public CastBuffSpellAction
+	{
+	public:
+		CastDivineStormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine storm") {}
+	};
+
+	class CastCrusaderStrikeAction : public CastMeleeSpellAction
+	{
+	public:
+		CastCrusaderStrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "crusader strike") {}
+	};
+
+	class CastShadowResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastShadowResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shadow resistance aura") {}
+	};
+
+	class CastFrostResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastFrostResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "frost resistance aura") {}
+	};
+
+	class CastFireResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastFireResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fire resistance aura") {}
+	};
+
+	class CastCrusaderAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastCrusaderAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "crusader aura") {}
+	};
+
+	class CastSealOfRighteousnessAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfRighteousnessAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of righteousness") {}
+	};
+
+	class CastSealOfJusticeAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfJusticeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of justice") {}
+	};
+
+
+	class CastSealOfLightAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfLightAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of light") {}
+	};
+
+	class CastSealOfWisdomAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfWisdomAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of wisdom") {}
+	};
+
+	class CastSealOfCommandAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfCommandAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of command") {}
+	};
+
+	class CastSealOfVengeanceAction : public CastBuffSpellAction
+	{
+	public:
+	    CastSealOfVengeanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of vengeance") {}
+	};
+
+
+	class CastBlessingOfMightAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfMightAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of might") {}
+	};
+
+	class CastBlessingOfMightOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfMightOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of might") {}
+        virtual string getName() { return "blessing of might on party";}
+	};
+
+	class CastBlessingOfWisdomAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfWisdomAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of wisdom") {}
+	};
+
+	class CastBlessingOfWisdomOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfWisdomOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of wisdom") {}
+        virtual string getName() { return "blessing of wisdom on party";}
+	};
+
+	class CastBlessingOfKingsAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfKingsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of kings") {}
+	};
+
+	class CastBlessingOfKingsOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfKingsOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of kings") {}
+        virtual string getName() { return "blessing of kings on party";}
+	};
+
+	class CastBlessingOfSanctuaryAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfSanctuaryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of sanctuary") {}
+	};
+
+	class CastBlessingOfSanctuaryOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfSanctuaryOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of sanctuary") {}
+        virtual string getName() { return "blessing of sanctuary on party";}
+	};
+
+    class CastHolyLightAction : public CastHealingSpellAction
+    {
+    public:
+        CastHolyLightAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "holy light") {}
+    };
+
+    class CastHolyLightOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHolyLightOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "holy light") {}
+
+        virtual string getName() { return "holy light on party"; }
+    };
+
+    class CastFlashOfLightAction : public CastHealingSpellAction
+    {
+    public:
+        CastFlashOfLightAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "flash of light") {}
+    };
+
+    class CastFlashOfLightOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastFlashOfLightOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "flash of light") {}
+
+        virtual string getName() { return "flash of light on party"; }
+    };
+
+    class CastLayOnHandsAction : public CastHealingSpellAction
+    {
+    public:
+        CastLayOnHandsAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lay on hands") {}
+    };
+
+    class CastLayOnHandsOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLayOnHandsOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lay on hands") {}
+
+        virtual string getName() { return "lay on hands on party"; }
+    };
+
+	class CastDivineProtectionAction : public CastBuffSpellAction
+	{
+	public:
+		CastDivineProtectionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine protection") {}
+	};
+
+    class CastDivineProtectionOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastDivineProtectionOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "divine protection") {}
+
+        virtual string getName() { return "divine protection on party"; }
+    };
+
+	class CastDivineShieldAction: public CastBuffSpellAction
+	{
+	public:
+		CastDivineShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine shield") {}
+	};
+
+    class CastConsecrationAction : public CastMeleeSpellAction
+    {
+    public:
+	    CastConsecrationAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "consecration") {}
+    };
+
+    class CastHolyWrathAction : public CastMeleeSpellAction
+    {
+    public:
+        CastHolyWrathAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "holy wrath") {}
+    };
+
+    class CastHammerOfJusticeAction : public CastMeleeSpellAction
+    {
+    public:
+        CastHammerOfJusticeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of justice") {}
+    };
+
+	class CastHammerOfWrathAction : public CastMeleeSpellAction
+	{
+	public:
+		CastHammerOfWrathAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of wrath") {}
+	};
+
+	class CastHammerOfTheRighteousAction : public CastMeleeSpellAction
+	{
+	public:
+		CastHammerOfTheRighteousAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of the righteous") {}
+	};
+
+	class CastPurifyPoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastPurifyPoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "purify") {}
+	};
+
+	class CastPurifyDiseaseAction : public CastCureSpellAction
+	{
+	public:
+		CastPurifyDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "purify") {}
+	};
+
+    class CastPurifyPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastPurifyPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "purify", DISPEL_POISON) {}
+
+        virtual string getName() { return "purify poison on party"; }
+    };
+
+	class CastPurifyDiseaseOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastPurifyDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "purify", DISPEL_DISEASE) {}
+
+		virtual string getName() { return "purify disease on party"; }
+	};
+
+	class CastHandOfReckoningAction : public CastSpellAction
+	{
+	public:
+		CastHandOfReckoningAction(PlayerbotAI* ai) : CastSpellAction(ai, "hand of reckoning") {}
+	};
+
+	class CastCleansePoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastCleansePoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+	class CastCleanseDiseaseAction : public CastCureSpellAction
+	{
+	public:
+		CastCleanseDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+	class CastCleanseMagicAction : public CastCureSpellAction
+	{
+	public:
+		CastCleanseMagicAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+    class CastCleansePoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleansePoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_POISON) {}
+
+        virtual string getName() { return "cleanse poison on party"; }
+    };
+
+	class CastCleanseDiseaseOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastCleanseDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_DISEASE) {}
+
+		virtual string getName() { return "cleanse disease on party"; }
+	};
+
+	class CastCleanseMagicOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastCleanseMagicOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_MAGIC) {}
+
+		virtual string getName() { return "cleanse magic on party"; }
+	};
+
+    BEGIN_SPELL_ACTION(CastAvengersShieldAction, "avenger's shield")
+    END_SPELL_ACTION()
+
+	BEGIN_SPELL_ACTION(CastExorcismAction, "exorcism")
+	END_SPELL_ACTION()
+
+	class CastHolyShieldAction : public CastBuffSpellAction
+	{
+	public:
+		CastHolyShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "holy shield") {}
+	};
+
+	class CastRedemptionAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastRedemptionAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "redemption") {}
+	};
+
+    class CastHammerOfJusticeOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastHammerOfJusticeOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "hammer of justice") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
new file mode 100644
index 0000000..37c7468
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
@@ -0,0 +1,279 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinActions.h"
+#include "PaladinTriggers.h"
+#include "PaladinAiObjectContext.h"
+#include "GenericPaladinNonCombatStrategy.h"
+#include "TankPaladinStrategy.h"
+#include "DpsPaladinStrategy.h"
+#include "PaladinBuffStrategies.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &paladin::StrategyFactoryInternal::nc;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericPaladinNonCombatStrategy(ai); }
+        };
+
+        class ResistanceStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            ResistanceStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["rshadow"] = &paladin::ResistanceStrategyFactoryInternal::rshadow;
+                creators["rfrost"] = &paladin::ResistanceStrategyFactoryInternal::rfrost;
+                creators["rfire"] = &paladin::ResistanceStrategyFactoryInternal::rfire;
+            }
+
+        private:
+            static Strategy* rshadow(PlayerbotAI* ai) { return new PaladinShadowResistanceStrategy(ai); }
+            static Strategy* rfrost(PlayerbotAI* ai) { return new PaladinFrostResistanceStrategy(ai); }
+            static Strategy* rfire(PlayerbotAI* ai) { return new PaladinFireResistanceStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bhealth"] = &paladin::BuffStrategyFactoryInternal::bhealth;
+                creators["bmana"] = &paladin::BuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &paladin::BuffStrategyFactoryInternal::bdps;
+                creators["barmor"] = &paladin::BuffStrategyFactoryInternal::barmor;
+                creators["bspeed"] = &paladin::BuffStrategyFactoryInternal::bspeed;
+            }
+
+        private:
+            static Strategy* bhealth(PlayerbotAI* ai) { return new PaladinBuffHealthStrategy(ai); }
+            static Strategy* bmana(PlayerbotAI* ai) { return new PaladinBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new PaladinBuffDpsStrategy(ai); }
+            static Strategy* barmor(PlayerbotAI* ai) { return new PaladinBuffArmorStrategy(ai); }
+            static Strategy* bspeed(PlayerbotAI* ai) { return new PaladinBuffSpeedStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["tank"] = &paladin::CombatStrategyFactoryInternal::tank;
+                creators["dps"] = &paladin::CombatStrategyFactoryInternal::dps;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankPaladinStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsPaladinStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["judgement of wisdom"] = &TriggerFactoryInternal::judgement_of_wisdom;
+                creators["judgement of light"] = &TriggerFactoryInternal::judgement_of_light;
+                creators["blessing"] = &TriggerFactoryInternal::blessing;
+                creators["seal"] = &TriggerFactoryInternal::seal;
+                creators["art of war"] = &TriggerFactoryInternal::art_of_war;
+                creators["blessing of kings on party"] = &TriggerFactoryInternal::blessing_of_kings_on_party;
+                creators["crusader aura"] = &TriggerFactoryInternal::crusader_aura;
+                creators["retribution aura"] = &TriggerFactoryInternal::retribution_aura;
+                creators["devotion aura"] = &TriggerFactoryInternal::devotion_aura;
+                creators["shadow resistance aura"] = &TriggerFactoryInternal::shadow_resistance_aura;
+                creators["frost resistance aura"] = &TriggerFactoryInternal::frost_resistance_aura;
+                creators["fire resistance aura"] = &TriggerFactoryInternal::fire_resistance_aura;
+                creators["hammer of justice snare"] = &TriggerFactoryInternal::hammer_of_justice_snare;
+                creators["hammer of justice interrupt"] = &TriggerFactoryInternal::hammer_of_justice_interrupt;
+                creators["cleanse cure disease"] = &TriggerFactoryInternal::CleanseCureDisease;
+                creators["cleanse party member cure disease"] = &TriggerFactoryInternal::CleanseCurePartyMemberDisease;
+                creators["cleanse cure poison"] = &TriggerFactoryInternal::CleanseCurePoison;
+                creators["cleanse party member cure poison"] = &TriggerFactoryInternal::CleanseCurePartyMemberPoison;
+                creators["cleanse cure magic"] = &TriggerFactoryInternal::CleanseCureMagic;
+                creators["cleanse party member cure magic"] = &TriggerFactoryInternal::CleanseCurePartyMemberMagic;
+                creators["righteous fury"] = &TriggerFactoryInternal::righteous_fury;
+                creators["holy shield"] = &TriggerFactoryInternal::holy_shield;
+                creators["hammer of justice on enemy healer"] = &TriggerFactoryInternal::hammer_of_justice_on_enemy_target;
+            }
+
+        private:
+            static Trigger* holy_shield(PlayerbotAI* ai) { return new HolyShieldTrigger(ai); }
+            static Trigger* righteous_fury(PlayerbotAI* ai) { return new RighteousFuryTrigger(ai); }
+            static Trigger* judgement_of_wisdom(PlayerbotAI* ai) { return new JudgementOfWisdomTrigger(ai); }
+            static Trigger* judgement_of_light(PlayerbotAI* ai) { return new JudgementOfLightTrigger(ai); }
+            static Trigger* blessing(PlayerbotAI* ai) { return new BlessingTrigger(ai); }
+            static Trigger* seal(PlayerbotAI* ai) { return new SealTrigger(ai); }
+            static Trigger* art_of_war(PlayerbotAI* ai) { return new ArtOfWarTrigger(ai); }
+            static Trigger* blessing_of_kings_on_party(PlayerbotAI* ai) { return new BlessingOfKingsOnPartyTrigger(ai); }
+            static Trigger* crusader_aura(PlayerbotAI* ai) { return new CrusaderAuraTrigger(ai); }
+            static Trigger* retribution_aura(PlayerbotAI* ai) { return new RetributionAuraTrigger(ai); }
+            static Trigger* devotion_aura(PlayerbotAI* ai) { return new DevotionAuraTrigger(ai); }
+            static Trigger* shadow_resistance_aura(PlayerbotAI* ai) { return new ShadowResistanceAuraTrigger(ai); }
+            static Trigger* frost_resistance_aura(PlayerbotAI* ai) { return new FrostResistanceAuraTrigger(ai); }
+            static Trigger* fire_resistance_aura(PlayerbotAI* ai) { return new FireResistanceAuraTrigger(ai); }
+            static Trigger* hammer_of_justice_snare(PlayerbotAI* ai) { return new HammerOfJusticeSnareTrigger(ai); }
+            static Trigger* hammer_of_justice_interrupt(PlayerbotAI* ai) { return new HammerOfJusticeInterruptSpellTrigger(ai); }
+            static Trigger* CleanseCureDisease(PlayerbotAI* ai) { return new CleanseCureDiseaseTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberDisease(PlayerbotAI* ai) { return new CleanseCurePartyMemberDiseaseTrigger(ai); }
+            static Trigger* CleanseCurePoison(PlayerbotAI* ai) { return new CleanseCurePoisonTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberPoison(PlayerbotAI* ai) { return new CleanseCurePartyMemberPoisonTrigger(ai); }
+            static Trigger* CleanseCureMagic(PlayerbotAI* ai) { return new CleanseCureMagicTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberMagic(PlayerbotAI* ai) { return new CleanseCurePartyMemberMagicTrigger(ai); }
+            static Trigger* hammer_of_justice_on_enemy_target(PlayerbotAI* ai) { return new HammerOfJusticeEnemyHealerTrigger(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["seal of command"] = &AiObjectContextInternal::seal_of_command;
+                creators["seal of vengeance"] = &AiObjectContextInternal::seal_of_vengeance;
+                creators["blessing of might"] = &AiObjectContextInternal::blessing_of_might;
+                creators["divine storm"] = &AiObjectContextInternal::divine_storm;
+                creators["blessing of kings on party"] = &AiObjectContextInternal::blessing_of_kings_on_party;
+                creators["redemption"] = &AiObjectContextInternal::redemption;
+                creators["crusader strike"] = &AiObjectContextInternal::crusader_strike;
+                creators["crusader aura"] = &AiObjectContextInternal::crusader_aura;
+                creators["seal of light"] = &AiObjectContextInternal::seal_of_light;
+                creators["devotion aura"] = &AiObjectContextInternal::devotion_aura;
+                creators["holy wrath"] = &AiObjectContextInternal::holy_wrath;
+                creators["consecration"] = &AiObjectContextInternal::consecration;
+                creators["cleanse disease"] = &AiObjectContextInternal::cleanse_disease;
+                creators["cleanse poison"] = &AiObjectContextInternal::cleanse_poison;
+                creators["cleanse magic"] = &AiObjectContextInternal::cleanse_magic;
+                creators["purify disease"] = &AiObjectContextInternal::purify_disease;
+                creators["purify poison"] = &AiObjectContextInternal::purify_poison;
+                creators["cleanse poison on party"] = &AiObjectContextInternal::cleanse_poison_on_party;
+                creators["cleanse disease on party"] = &AiObjectContextInternal::cleanse_disease_on_party;
+                creators["cleanse magic on party"] = &AiObjectContextInternal::cleanse_magic_on_party;
+                creators["purify poison on party"] = &AiObjectContextInternal::purify_poison_on_party;
+                creators["purify disease on party"] = &AiObjectContextInternal::purify_disease_on_party;
+                creators["seal of wisdom"] = &AiObjectContextInternal::seal_of_wisdom;
+                creators["seal of justice"] = &AiObjectContextInternal::seal_of_justice;
+                creators["seal of righteousness"] = &AiObjectContextInternal::seal_of_righteousness;
+                creators["flash of light"] = &AiObjectContextInternal::flash_of_light;
+                creators["hand of reckoning"] = &AiObjectContextInternal::hand_of_reckoning;
+                creators["avenger's shield"] = &AiObjectContextInternal::avengers_shield;
+                creators["exorcism"] = &AiObjectContextInternal::exorcism;
+                creators["judgement of light"] = &AiObjectContextInternal::judgement_of_light;
+                creators["judgement of wisdom"] = &AiObjectContextInternal::judgement_of_wisdom;
+                creators["divine shield"] = &AiObjectContextInternal::divine_shield;
+                creators["divine protection"] = &AiObjectContextInternal::divine_protection;
+                creators["divine protection on party"] =&AiObjectContextInternal::divine_protection_on_party;
+                creators["hammer of justice"] = &AiObjectContextInternal::hammer_of_justice;
+                creators["flash of light on party"] = &AiObjectContextInternal::flash_of_light_on_party;
+                creators["holy light"] = &AiObjectContextInternal::holy_light;
+                creators["holy light on party"] = &AiObjectContextInternal::holy_light_on_party;
+                creators["lay on hands"] = &AiObjectContextInternal::lay_on_hands;
+                creators["lay on hands on party"] = &AiObjectContextInternal::lay_on_hands_on_party;
+                creators["judgement of justice"] = &AiObjectContextInternal::judgement_of_justice;
+                creators["hammer of wrath"] = &AiObjectContextInternal::hammer_of_wrath;
+                creators["holy shield"] = &AiObjectContextInternal::holy_shield;
+                creators["hammer of the righteous"] = &AiObjectContextInternal::hammer_of_the_righteous;
+                creators["blessing of kings"] = &AiObjectContextInternal::blessing_of_kings;
+                creators["retribution aura"] = &AiObjectContextInternal::retribution_aura;
+                creators["shadow resistance aura"] = &AiObjectContextInternal::shadow_resistance_aura;
+                creators["frost resistance aura"] = &AiObjectContextInternal::frost_resistance_aura;
+                creators["fire resistance aura"] = &AiObjectContextInternal::fire_resistance_aura;
+                creators["righteous fury"] = &AiObjectContextInternal::righteous_fury;
+                creators["blessing of sanctuary"] = &AiObjectContextInternal::blessing_of_sanctuary;
+                creators["hammer of justice on enemy healer"] = &AiObjectContextInternal::hammer_of_justice_on_enemy_healer;
+            }
+
+        private:
+            static Action* righteous_fury(PlayerbotAI* ai) { return new CastRighteousFuryAction(ai); }
+            static Action* blessing_of_sanctuary(PlayerbotAI* ai) { return new CastBlessingOfSanctuaryAction(ai); }
+            static Action* seal_of_command(PlayerbotAI* ai) { return new CastSealOfCommandAction(ai); }
+            static Action* seal_of_vengeance(PlayerbotAI* ai) { return new CastSealOfVengeanceAction(ai); }
+            static Action* blessing_of_might(PlayerbotAI* ai) { return new CastBlessingOfMightAction(ai); }
+            static Action* divine_storm(PlayerbotAI* ai) { return new CastDivineStormAction(ai); }
+            static Action* blessing_of_kings_on_party(PlayerbotAI* ai) { return new CastBlessingOfKingsOnPartyAction(ai); }
+            static Action* redemption(PlayerbotAI* ai) { return new CastRedemptionAction(ai); }
+            static Action* crusader_strike(PlayerbotAI* ai) { return new CastCrusaderStrikeAction(ai); }
+            static Action* crusader_aura(PlayerbotAI* ai) { return new CastCrusaderAuraAction(ai); }
+            static Action* seal_of_light(PlayerbotAI* ai) { return new CastSealOfLightAction(ai); }
+            static Action* devotion_aura(PlayerbotAI* ai) { return new CastDevotionAuraAction(ai); }
+            static Action* holy_wrath(PlayerbotAI* ai) { return new CastHolyWrathAction(ai); }
+            static Action* consecration(PlayerbotAI* ai) { return new CastConsecrationAction(ai); }
+            static Action* cleanse_poison(PlayerbotAI* ai) { return new CastCleansePoisonAction(ai); }
+            static Action* cleanse_disease(PlayerbotAI* ai) { return new CastCleanseDiseaseAction(ai); }
+            static Action* cleanse_magic(PlayerbotAI* ai) { return new CastCleanseMagicAction(ai); }
+            static Action* purify_poison(PlayerbotAI* ai) { return new CastPurifyPoisonAction(ai); }
+            static Action* purify_disease(PlayerbotAI* ai) { return new CastPurifyDiseaseAction(ai); }
+            static Action* cleanse_poison_on_party(PlayerbotAI* ai) { return new CastCleansePoisonOnPartyAction(ai); }
+            static Action* cleanse_disease_on_party(PlayerbotAI* ai) { return new CastCleanseDiseaseOnPartyAction(ai); }
+            static Action* cleanse_magic_on_party(PlayerbotAI* ai) { return new CastCleanseMagicOnPartyAction(ai); }
+            static Action* purify_poison_on_party(PlayerbotAI* ai) { return new CastPurifyPoisonOnPartyAction(ai); }
+            static Action* purify_disease_on_party(PlayerbotAI* ai) { return new CastPurifyDiseaseOnPartyAction(ai); }
+            static Action* seal_of_wisdom(PlayerbotAI* ai) { return new CastSealOfWisdomAction(ai); }
+            static Action* seal_of_justice(PlayerbotAI* ai) { return new CastSealOfJusticeAction(ai); }
+            static Action* seal_of_righteousness(PlayerbotAI* ai) { return new CastSealOfRighteousnessAction(ai); }
+            static Action* flash_of_light(PlayerbotAI* ai) { return new CastFlashOfLightAction(ai); }
+            static Action* hand_of_reckoning(PlayerbotAI* ai) { return new CastHandOfReckoningAction(ai); }
+            static Action* avengers_shield(PlayerbotAI* ai) { return new CastAvengersShieldAction(ai); }
+            static Action* exorcism(PlayerbotAI* ai) { return new CastExorcismAction(ai); }
+            static Action* judgement_of_light(PlayerbotAI* ai) { return new CastJudgementOfLightAction(ai); }
+            static Action* judgement_of_wisdom(PlayerbotAI* ai) { return new CastJudgementOfWisdomAction(ai); }
+            static Action* divine_shield(PlayerbotAI* ai) { return new CastDivineShieldAction(ai); }
+            static Action* divine_protection(PlayerbotAI* ai) { return new CastDivineProtectionAction(ai); }
+            static Action* divine_protection_on_party(PlayerbotAI* ai) { return new CastDivineProtectionOnPartyAction(ai); }
+            static Action* hammer_of_justice(PlayerbotAI* ai) { return new CastHammerOfJusticeAction(ai); }
+            static Action* flash_of_light_on_party(PlayerbotAI* ai) { return new CastFlashOfLightOnPartyAction(ai); }
+            static Action* holy_light(PlayerbotAI* ai) { return new CastHolyLightAction(ai); }
+            static Action* holy_light_on_party(PlayerbotAI* ai) { return new CastHolyLightOnPartyAction(ai); }
+            static Action* lay_on_hands(PlayerbotAI* ai) { return new CastLayOnHandsAction(ai); }
+            static Action* lay_on_hands_on_party(PlayerbotAI* ai) { return new CastLayOnHandsOnPartyAction(ai); }
+            static Action* judgement_of_justice(PlayerbotAI* ai) { return new CastJudgementOfJusticeAction(ai); }
+            static Action* hammer_of_wrath(PlayerbotAI* ai) { return new CastHammerOfWrathAction(ai); }
+            static Action* holy_shield(PlayerbotAI* ai) { return new CastHolyShieldAction(ai); }
+            static Action* hammer_of_the_righteous(PlayerbotAI* ai) { return new CastHammerOfTheRighteousAction(ai); }
+            static Action* blessing_of_kings(PlayerbotAI* ai) { return new CastBlessingOfKingsAction(ai); }
+            static Action* retribution_aura(PlayerbotAI* ai) { return new CastRetributionAuraAction(ai); }
+            static Action* shadow_resistance_aura(PlayerbotAI* ai) { return new CastShadowResistanceAuraAction(ai); }
+            static Action* frost_resistance_aura(PlayerbotAI* ai) { return new CastFrostResistanceAuraAction(ai); }
+            static Action* fire_resistance_aura(PlayerbotAI* ai) { return new CastFireResistanceAuraAction(ai); }
+            static Action* hammer_of_justice_on_enemy_healer(PlayerbotAI* ai) { return new CastHammerOfJusticeOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+PaladinAiObjectContext::PaladinAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::paladin::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::CombatStrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::BuffStrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::ResistanceStrategyFactoryInternal());
+    actionContexts.Add(new ai::paladin::AiObjectContextInternal());
+    triggerContexts.Add(new ai::paladin::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
new file mode 100644
index 0000000..1af3343
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class PaladinAiObjectContext : public AiObjectContext
+    {
+    public:
+        PaladinAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
new file mode 100644
index 0000000..5124024
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
@@ -0,0 +1,72 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "PaladinBuffStrategies.h"
+
+using namespace ai;
+
+void PaladinBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of wisdom", 90.0f), NULL)));
+}
+
+void PaladinBuffHealthStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of light", 90.0f), NULL)));
+}
+
+void PaladinBuffSpeedStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "crusader aura",
+        NextAction::array(0, new NextAction("crusader aura", 40.0f), NULL)));
+}
+
+void PaladinBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of vengeance", 89.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"retribution aura",
+		NextAction::array(0, new NextAction("retribution aura", 90.0f), NULL)));
+}
+
+void PaladinShadowResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"shadow resistance aura",
+		NextAction::array(0, new NextAction("shadow resistance aura", 90.0f), NULL)));
+}
+
+void PaladinFrostResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"frost resistance aura",
+		NextAction::array(0, new NextAction("frost resistance aura", 90.0f), NULL)));
+}
+
+void PaladinFireResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"fire resistance aura",
+		NextAction::array(0, new NextAction("fire resistance aura", 90.0f), NULL)));
+}
+
+
+void PaladinBuffArmorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of light", 89.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"devotion aura",
+		NextAction::array(0, new NextAction("devotion aura", 90.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
new file mode 100644
index 0000000..e5051a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
@@ -0,0 +1,86 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class PaladinBuffManaStrategy : public Strategy
+    {
+    public:
+        PaladinBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+    };
+
+    class PaladinBuffHealthStrategy : public Strategy
+    {
+    public:
+        PaladinBuffHealthStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bhealth"; }
+    };
+
+    class PaladinBuffDpsStrategy : public Strategy
+    {
+    public:
+        PaladinBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+    };
+
+	class PaladinBuffArmorStrategy : public Strategy
+	{
+	public:
+		PaladinBuffArmorStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "barmor"; }
+	};
+
+	class PaladinBuffSpeedStrategy : public Strategy
+	{
+	public:
+		PaladinBuffSpeedStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "bspeed"; }
+	};
+
+	class PaladinShadowResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinShadowResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rshadow"; }
+	};
+
+	class PaladinFrostResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinFrostResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rfrost"; }
+	};
+
+	class PaladinFireResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinFireResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rfire"; }
+	};
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
new file mode 100644
index 0000000..3082abb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "PaladinActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
new file mode 100644
index 0000000..1948441
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinTriggers.h"
+#include "PaladinActions.h"
+
+using namespace ai;
+
+bool SealTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return !ai->HasAura("seal of justice", target) &&
+        !ai->HasAura("seal of command", target) &&
+        !ai->HasAura("seal of vengeance", target) &&
+		!ai->HasAura("seal of righteousness", target) &&
+		!ai->HasAura("seal of light", target) &&
+		!ai->HasAura("seal of wisdom", target);
+}
+
+bool CrusaderAuraTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return AI_VALUE2(bool, "mounted", "self target") && !ai->HasAura("crusader aura", target);
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
new file mode 100644
index 0000000..3f53b4e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
@@ -0,0 +1,114 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+	BUFF_TRIGGER(HolyShieldTrigger, "holy shield", "holy shield")
+    BUFF_TRIGGER(RighteousFuryTrigger, "righteous fury", "righteous fury")
+
+    BUFF_TRIGGER(RetributionAuraTrigger, "retribution aura", "retribution aura")
+
+	class CrusaderAuraTrigger : public BuffTrigger
+	{
+	public:
+		CrusaderAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "crusader aura") {}
+		virtual bool IsActive();
+	};
+
+	class SealTrigger : public BuffTrigger
+	{
+	public:
+		SealTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "seal of justice") {}
+		virtual bool IsActive();
+	};
+
+    DEBUFF_TRIGGER(JudgementOfLightTrigger, "judgement of light", "judgement of light")
+    DEBUFF_TRIGGER(JudgementOfWisdomTrigger, "judgement of wisdom", "judgement of wisdom")
+
+    BUFF_ON_PARTY_TRIGGER(BlessingOfKingsOnPartyTrigger, "blessing of kings", "blessing of kings on party")
+    BUFF_TRIGGER(BlessingTrigger, "blessing of sanctuary", "blessing of sanctuary")
+
+    class HammerOfJusticeInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        HammerOfJusticeInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "hammer of justice") {}
+    };
+
+    class HammerOfJusticeSnareTrigger : public SnareTargetTrigger
+    {
+    public:
+        HammerOfJusticeSnareTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "hammer of justice") {}
+    };
+
+    class ArtOfWarTrigger : public HasAuraTrigger
+    {
+    public:
+        ArtOfWarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "the art of war") {}
+    };
+
+    class ShadowResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        ShadowResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "shadow resistance aura") {}
+    };
+
+    class FrostResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        FrostResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "frost resistance aura") {}
+    };
+
+    class FireResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        FireResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "fire resistance aura") {}
+    };
+
+    class DevotionAuraTrigger : public BuffTrigger
+    {
+    public:
+        DevotionAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "devotion aura") {}
+    };
+
+    class CleanseCureDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCureDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_DISEASE) {}
+    };
+
+    class CleanseCurePartyMemberDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_DISEASE) {}
+    };
+
+    class CleanseCurePoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCurePoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_POISON) {}
+    };
+
+    class CleanseCurePartyMemberPoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberPoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_POISON) {}
+    };
+
+    class CleanseCureMagicTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCureMagicTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_MAGIC) {}
+    };
+
+    class CleanseCurePartyMemberMagicTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberMagicTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_MAGIC) {}
+    };
+
+    class HammerOfJusticeEnemyHealerTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        HammerOfJusticeEnemyHealerTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "hammer of justice") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
new file mode 100644
index 0000000..6e6b51f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
@@ -0,0 +1,70 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "TankPaladinStrategy.h"
+
+using namespace ai;
+
+class TankPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    TankPaladinStrategyActionNodeFactory()
+    {
+        creators["blessing of sanctuary"] = &blessing_of_sanctuary;
+    }
+private:
+    static ActionNode* blessing_of_sanctuary(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blessing of sanctuary",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blessing of kings"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankPaladinStrategy::TankPaladinStrategy(PlayerbotAI* ai) : GenericPaladinStrategy(ai)
+{
+    actionNodeFactories.Add(new TankPaladinStrategyActionNodeFactory());
+}
+
+NextAction** TankPaladinStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("melee", ACTION_NORMAL), NULL);
+}
+
+void TankPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPaladinStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "judgement of light",
+        NextAction::array(0, new NextAction("judgement of light", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium mana",
+        NextAction::array(0, new NextAction("judgement of wisdom", ACTION_NORMAL + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "righteous fury",
+        NextAction::array(0, new NextAction("righteous fury", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("hammer of the righteous", ACTION_HIGH + 6), new NextAction("avenger's shield", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("consecration", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("hand of reckoning", ACTION_HIGH + 7), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"holy shield",
+		NextAction::array(0, new NextAction("holy shield", ACTION_HIGH + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "blessing",
+        NextAction::array(0, new NextAction("blessing of sanctuary", ACTION_HIGH + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
new file mode 100644
index 0000000..d5cf955
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class TankPaladinStrategy : public GenericPaladinStrategy
+    {
+    public:
+        TankPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "tank"; }
+        virtual NextAction** getDefaultActions();
+		virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
new file mode 100644
index 0000000..19103da
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
@@ -0,0 +1,67 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HealPriestStrategy.h"
+#include "GenericPriestStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+GenericPriestStrategy::GenericPriestStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPriestStrategyActionNodeFactory());
+}
+
+void GenericPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash heal", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash heal on party", 20.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("power word: shield", 70.0f), new NextAction("flash heal", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("power word: shield on party", 60.0f), new NextAction("flash heal on party", 60.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("power word: shield", 60.0f), new NextAction("greater heal", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("power word: shield on party", 50.0f), new NextAction("greater heal on party", 50.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic",
+        NextAction::array(0, new NextAction("dispel magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic on party",
+        NextAction::array(0, new NextAction("dispel magic on party", 40.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure disease",
+        NextAction::array(0, new NextAction("abolish disease", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure disease",
+        NextAction::array(0, new NextAction("abolish disease on party", 30.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("psychic scream", 50.0f), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
new file mode 100644
index 0000000..4633e8d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class GenericPriestStrategy : public CombatStrategy
+    {
+    public:
+        GenericPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
new file mode 100644
index 0000000..d3ef00b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
@@ -0,0 +1,173 @@
+#pragma once
+
+namespace ai
+{
+    class GenericPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        GenericPriestStrategyActionNodeFactory()
+        {
+            creators["inner fire"] = &inner_fire;
+            creators["holy nova"] = &holy_nova;
+            creators["power word: fortitude"] = &power_word_fortitude;
+            creators["power word: fortitude on party"] = &power_word_fortitude_on_party;
+            creators["divine spirit"] = &divine_spirit;
+            creators["divine spirit on party"] = &divine_spirit_on_party;
+            creators["power word: shield"] = &power_word_shield;
+            creators["power word: shield on party"] = &power_word_shield_on_party;
+            creators["renew"] = &renew;
+            creators["renew on party"] = &renew_on_party;
+            creators["greater heal"] = &greater_heal;
+            creators["greater heal on party"] = &greater_heal_on_party;
+            creators["heal"] = &heal;
+            creators["heal on party"] = &heal_on_party;
+            creators["lesser heal"] = &lesser_heal;
+            creators["lesser heal on party"] = &lesser_heal_on_party;
+            creators["flash heal"] = &flash_heal;
+            creators["flash heal on party"] = &flash_heal_on_party;
+            creators["psychic scream"] = &psychic_scream;
+            creators["fade"] = &fade;
+        }
+    private:
+        static ActionNode* inner_fire(PlayerbotAI* ai)
+        {
+            return new ActionNode ("inner fire",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* holy_nova(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy nova",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_fortitude(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: fortitude",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_fortitude_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: fortitude on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_spirit(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine spirit",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_spirit_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine spirit on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("renew", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("renew on party", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* renew(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* renew_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("greater heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("greater heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* psychic_scream(PlayerbotAI* ai)
+        {
+            return new ActionNode ("psychic scream",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("fade"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* fade(PlayerbotAI* ai)
+        {
+            return new ActionNode ("fade",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
new file mode 100644
index 0000000..68e6f37
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HealPriestStrategy.h"
+
+using namespace ai;
+
+NextAction** HealPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void HealPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe heal",
+		NextAction::array(0, new NextAction("circle of healing", 27.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("renew", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("renew on party", 10.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("fade", 50.0f), new NextAction("flee", 49.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
new file mode 100644
index 0000000..7f5603f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPriestStrategy.h"
+
+namespace ai
+{
+    class HealPriestStrategy : public GenericPriestStrategy
+    {
+    public:
+        HealPriestStrategy(PlayerbotAI* ai) : GenericPriestStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "heal"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
new file mode 100644
index 0000000..abeea31
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
@@ -0,0 +1,46 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HolyPriestStrategy.h"
+
+namespace ai
+{
+    class HolyPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        HolyPriestStrategyActionNodeFactory()
+        {
+            creators["smite"] = &smite;
+        }
+    private:
+        static ActionNode* smite(PlayerbotAI* ai)
+        {
+            return new ActionNode ("smite",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
+
+using namespace ai;
+
+HolyPriestStrategy::HolyPriestStrategy(PlayerbotAI* ai) : HealPriestStrategy(ai)
+{
+    actionNodeFactories.Add(new HolyPriestStrategyActionNodeFactory());
+}
+
+NextAction** HolyPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("holy fire", 10.0f), new NextAction("smite", 10.0f), NULL);
+}
+
+void HolyPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    HealPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
new file mode 100644
index 0000000..c21bcf1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "HealPriestStrategy.h"
+
+namespace ai
+{
+    class HolyPriestStrategy : public HealPriestStrategy
+    {
+    public:
+        HolyPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "holy"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS|STRATEGY_TYPE_RANGED; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestActions.cpp b/src/plugins/playerbot/strategy/priest/PriestActions.cpp
new file mode 100644
index 0000000..8760005
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestActions.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestActions.h"
+
+using namespace ai;
+
+
+NextAction** CastAbolishDiseaseAction::getAlternatives()
+{
+    return NextAction::merge(NextAction::array(0, new NextAction("cure disease"), NULL), CastSpellAction::getAlternatives());
+}
+
+NextAction** CastAbolishDiseaseOnPartyAction::getAlternatives()
+{
+    return NextAction::merge(NextAction::array(0, new NextAction("cure disease on party"), NULL), CastSpellAction::getAlternatives());
+}
+
diff --git a/src/plugins/playerbot/strategy/priest/PriestActions.h b/src/plugins/playerbot/strategy/priest/PriestActions.h
new file mode 100644
index 0000000..bf2ea2d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestActions.h
@@ -0,0 +1,246 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastGreaterHealAction : public CastHealingSpellAction {
+    public:
+        CastGreaterHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "greater heal") {}
+    };
+
+    class CastGreaterHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastGreaterHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "greater heal") {}
+
+        virtual string getName() { return "greater heal on party"; }
+    };
+
+    class CastLesserHealAction : public CastHealingSpellAction {
+    public:
+        CastLesserHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lesser heal") {}
+    };
+
+    class CastLesserHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLesserHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lesser heal") {}
+
+        virtual string getName() { return "lesser heal on party"; }
+    };
+
+    class CastFlashHealAction : public CastHealingSpellAction {
+    public:
+        CastFlashHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "flash heal") {}
+    };
+
+    class CastFlashHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastFlashHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "flash heal") {}
+
+        virtual string getName() { return "flash heal on party"; }
+    };
+
+    class CastHealAction : public CastHealingSpellAction {
+    public:
+        CastHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "heal") {}
+    };
+
+    class CastHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "heal") {}
+
+        virtual string getName() { return "heal on party"; }
+    };
+
+    class CastRenewAction : public CastHealingSpellAction {
+    public:
+        CastRenewAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "renew") {}
+    };
+
+    class CastRenewOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRenewOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "renew") {}
+
+        virtual string getName() { return "renew on party"; }
+    };
+
+    class CastFadeAction : public CastBuffSpellAction {
+    public:
+        CastFadeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fade") {}
+    };
+
+    class CastShadowformAction : public CastBuffSpellAction {
+    public:
+        CastShadowformAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shadowform") {}
+    };
+
+    class CastRemoveShadowformAction : public Action {
+    public:
+        CastRemoveShadowformAction(PlayerbotAI* ai) : Action(ai, "remove shadowform") {}
+        virtual bool isUseful() { return ai->HasAura("shadowform", AI_VALUE(Unit*, "self target")); }
+        virtual bool isPossible() { return true; }
+        virtual bool Execute(Event event) {
+            ai->RemoveAura("shadowform");
+            return true;
+        }
+    };
+
+	class CastVampiricEmbraceAction : public CastBuffSpellAction {
+	public:
+		CastVampiricEmbraceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "vampiric embrace") {}
+	};
+
+	class CastPowerWordShieldAction : public CastBuffSpellAction {
+	public:
+		CastPowerWordShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "power word: shield") {}
+	};
+
+    class CastPowerWordShieldOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastPowerWordShieldOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "power word: shield") {}
+
+        virtual string getName() { return "power word: shield on party"; }
+    };
+
+	class CastPowerWordFortitudeAction : public CastBuffSpellAction {
+	public:
+		CastPowerWordFortitudeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "power word: fortitude") {}
+	};
+
+	class CastDivineSpiritAction : public CastBuffSpellAction {
+	public:
+		CastDivineSpiritAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine spirit") {}
+	};
+
+	class CastInnerFireAction : public CastBuffSpellAction {
+	public:
+		CastInnerFireAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "inner fire") {}
+	};
+
+    BEGIN_SPELL_ACTION(CastHolyNovaAction, "holy nova")
+    virtual bool isUseful() {
+        return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+    }
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastHolyFireAction, "holy fire")
+        virtual bool isUseful() {
+            return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+        }
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastSmiteAction, "smite")
+        virtual bool isUseful() {
+			return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+        }
+    END_SPELL_ACTION()
+
+	class CastPowerWordFortitudeOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastPowerWordFortitudeOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "power word: fortitude") {}
+	};
+
+	class CastDivineSpiritOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastDivineSpiritOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "divine spirit") {}
+	};
+
+	class CastPowerWordPainAction : public CastDebuffSpellAction
+	{
+    public:
+	    CastPowerWordPainAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "shadow word: pain") {}
+	};
+
+	class CastPowerWordPainOnAttackerAction : public CastDebuffSpellOnAttackerAction
+	{
+    public:
+	    CastPowerWordPainOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "shadow word: pain") {}
+	};
+
+    BEGIN_DEBUFF_ACTION(CastDevouringPlagueAction, "devouring plague")
+    END_SPELL_ACTION()
+
+    BEGIN_DEBUFF_ACTION(CastVampiricTouchAction, "vampiric touch")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMindBlastAction, "mind blast")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMindFlayAction, "mind flay")
+    END_SPELL_ACTION()
+
+	class CastCureDiseaseAction : public CastCureSpellAction {
+	public:
+		CastCureDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cure disease") {}
+	};
+
+    class CastCureDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCureDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cure disease", DISPEL_DISEASE) {}
+        virtual string getName() { return "cure disease on party"; }
+    };
+
+	class CastAbolishDiseaseAction : public CastCureSpellAction {
+	public:
+		CastAbolishDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "abolish disease") {}
+		virtual NextAction** getAlternatives();
+	};
+
+    class CastAbolishDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastAbolishDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "abolish disease", DISPEL_DISEASE) {}
+        virtual string getName() { return "abolish disease on party"; }
+        virtual NextAction** getAlternatives();
+    };
+
+	class CastDispelMagicAction : public CastCureSpellAction {
+	public:
+		CastDispelMagicAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "dispel magic") {}
+	};
+
+    class CastDispelMagicOnTargetAction : public CastSpellAction {
+    public:
+        CastDispelMagicOnTargetAction(PlayerbotAI* ai) : CastSpellAction(ai, "dispel magic") {}
+    };
+
+    class CastDispelMagicOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastDispelMagicOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "dispel magic", DISPEL_MAGIC) {}
+        virtual string getName() { return "dispel magic on party"; }
+    };
+
+	class CastResurrectionAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastResurrectionAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "resurrection") {}
+	};
+
+	class CastCircleOfHealingAction : public CastAoeHealSpellAction
+	{
+	public:
+		CastCircleOfHealingAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "circle of healing") {}
+	};
+
+	class CastPsychicScreamAction : public CastSpellAction
+	{
+	public:
+	    CastPsychicScreamAction(PlayerbotAI* ai) : CastSpellAction(ai, "psychic scream") {}
+	};
+
+	class CastDispersionAction : public CastSpellAction
+	{
+	public:
+	    CastDispersionAction(PlayerbotAI* ai) : CastSpellAction(ai, "dispersion") {}
+	    virtual string GetTargetName() { return "self target"; }
+	};
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
new file mode 100644
index 0000000..8a40b2b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
@@ -0,0 +1,217 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestActions.h"
+#include "PriestAiObjectContext.h"
+#include "PriestNonCombatStrategy.h"
+#include "ShadowPriestStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "PriestTriggers.h"
+#include "../NamedObjectContext.h"
+#include "HolyPriestStrategy.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &priest::StrategyFactoryInternal::nc;
+                creators["pull"] = &priest::StrategyFactoryInternal::pull;
+                creators["aoe"] = &priest::StrategyFactoryInternal::shadow_aoe;
+                creators["shadow aoe"] = &priest::StrategyFactoryInternal::shadow_aoe;
+                creators["dps debuff"] = &priest::StrategyFactoryInternal::shadow_debuff;
+                creators["shadow debuff"] = &priest::StrategyFactoryInternal::shadow_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new PriestNonCombatStrategy(ai); }
+            static Strategy* shadow_aoe(PlayerbotAI* ai) { return new ShadowPriestAoeStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+            static Strategy* shadow_debuff(PlayerbotAI* ai) { return new ShadowPriestDebuffStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["heal"] = &priest::CombatStrategyFactoryInternal::heal;
+                creators["shadow"] = &priest::CombatStrategyFactoryInternal::dps;
+                creators["dps"] = &priest::CombatStrategyFactoryInternal::dps;
+                creators["holy"] = &priest::CombatStrategyFactoryInternal::holy;
+            }
+
+        private:
+            static Strategy* heal(PlayerbotAI* ai) { return new HealPriestStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new ShadowPriestStrategy(ai); }
+            static Strategy* holy(PlayerbotAI* ai) { return new HolyPriestStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["devouring plague"] = &TriggerFactoryInternal::devouring_plague;
+                creators["shadow word: pain"] = &TriggerFactoryInternal::shadow_word_pain;
+                creators["shadow word: pain on attacker"] = &TriggerFactoryInternal::shadow_word_pain_on_attacker;
+                creators["dispel magic"] = &TriggerFactoryInternal::dispel_magic;
+                creators["dispel magic on party"] = &TriggerFactoryInternal::dispel_magic_party_member;
+                creators["cure disease"] = &TriggerFactoryInternal::cure_disease;
+                creators["party member cure disease"] = &TriggerFactoryInternal::party_member_cure_disease;
+                creators["power word: fortitude"] = &TriggerFactoryInternal::power_word_fortitude;
+                creators["power word: fortitude on party"] = &TriggerFactoryInternal::power_word_fortitude_on_party;
+                creators["divine spirit"] = &TriggerFactoryInternal::divine_spirit;
+                creators["divine spirit on party"] = &TriggerFactoryInternal::divine_spirit_on_party;
+                creators["inner fire"] = &TriggerFactoryInternal::inner_fire;
+                creators["vampiric touch"] = &TriggerFactoryInternal::vampiric_touch;
+                creators["shadowform"] = &TriggerFactoryInternal::shadowform;
+                creators["vampiric embrace"] = &TriggerFactoryInternal::vampiric_embrace;
+
+            }
+
+        private:
+            static Trigger* vampiric_embrace(PlayerbotAI* ai) { return new VampiricEmbraceTrigger(ai); }
+            static Trigger* shadowform(PlayerbotAI* ai) { return new ShadowformTrigger(ai); }
+            static Trigger* vampiric_touch(PlayerbotAI* ai) { return new VampiricTouchTrigger(ai); }
+            static Trigger* devouring_plague(PlayerbotAI* ai) { return new DevouringPlagueTrigger(ai); }
+            static Trigger* shadow_word_pain(PlayerbotAI* ai) { return new PowerWordPainTrigger(ai); }
+            static Trigger* shadow_word_pain_on_attacker(PlayerbotAI* ai) { return new PowerWordPainOnAttackerTrigger(ai); }
+            static Trigger* dispel_magic(PlayerbotAI* ai) { return new DispelMagicTrigger(ai); }
+            static Trigger* dispel_magic_party_member(PlayerbotAI* ai) { return new DispelMagicPartyMemberTrigger(ai); }
+            static Trigger* cure_disease(PlayerbotAI* ai) { return new CureDiseaseTrigger(ai); }
+            static Trigger* party_member_cure_disease(PlayerbotAI* ai) { return new PartyMemberCureDiseaseTrigger(ai); }
+            static Trigger* power_word_fortitude(PlayerbotAI* ai) { return new PowerWordFortitudeTrigger(ai); }
+            static Trigger* power_word_fortitude_on_party(PlayerbotAI* ai) { return new PowerWordFortitudeOnPartyTrigger(ai); }
+            static Trigger* divine_spirit(PlayerbotAI* ai) { return new DivineSpiritTrigger(ai); }
+            static Trigger* divine_spirit_on_party(PlayerbotAI* ai) { return new DivineSpiritOnPartyTrigger(ai); }
+            static Trigger* inner_fire(PlayerbotAI* ai) { return new InnerFireTrigger(ai); }
+        };
+    };
+};
+
+
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["shadow word: pain"] = &AiObjectContextInternal::shadow_word_pain;
+                creators["shadow word: pain on attacker"] = &AiObjectContextInternal::shadow_word_pain_on_attacker;
+                creators["devouring plague"] = &AiObjectContextInternal::devouring_plague;
+                creators["mind flay"] = &AiObjectContextInternal::mind_flay;
+                creators["holy fire"] = &AiObjectContextInternal::holy_fire;
+                creators["smite"] = &AiObjectContextInternal::smite;
+                creators["mind blast"] = &AiObjectContextInternal::mind_blast;
+                creators["shadowform"] = &AiObjectContextInternal::shadowform;
+                creators["remove shadowform"] = &AiObjectContextInternal::remove_shadowform;
+                creators["holy nova"] = &AiObjectContextInternal::holy_nova;
+                creators["power word: fortitude"] = &AiObjectContextInternal::power_word_fortitude;
+                creators["power word: fortitude on party"] = &AiObjectContextInternal::power_word_fortitude_on_party;
+                creators["divine spirit"] = &AiObjectContextInternal::divine_spirit;
+                creators["divine spirit on party"] = &AiObjectContextInternal::divine_spirit_on_party;
+                creators["power word: shield"] = &AiObjectContextInternal::power_word_shield;
+                creators["power word: shield on party"] = &AiObjectContextInternal::power_word_shield_on_party;
+                creators["renew"] = &AiObjectContextInternal::renew;
+                creators["renew on party"] = &AiObjectContextInternal::renew_on_party;
+                creators["greater heal"] = &AiObjectContextInternal::greater_heal;
+                creators["greater heal on party"] = &AiObjectContextInternal::greater_heal_on_party;
+                creators["heal"] = &AiObjectContextInternal::heal;
+                creators["heal on party"] = &AiObjectContextInternal::heal_on_party;
+                creators["lesser heal"] = &AiObjectContextInternal::lesser_heal;
+                creators["lesser heal on party"] = &AiObjectContextInternal::lesser_heal_on_party;
+                creators["flash heal"] = &AiObjectContextInternal::flash_heal;
+                creators["flash heal on party"] = &AiObjectContextInternal::flash_heal_on_party;
+                creators["dispel magic"] = &AiObjectContextInternal::dispel_magic;
+                creators["dispel magic on party"] = &AiObjectContextInternal::dispel_magic_on_party;
+                creators["dispel magic on target"] = &AiObjectContextInternal::dispel_magic_on_target;
+                creators["cure disease"] = &AiObjectContextInternal::cure_disease;
+                creators["cure disease on party"] = &AiObjectContextInternal::cure_disease_on_party;
+                creators["abolish disease"] = &AiObjectContextInternal::abolish_disease;
+                creators["abolish disease on party"] = &AiObjectContextInternal::abolish_disease_on_party;
+                creators["fade"] = &AiObjectContextInternal::fade;
+                creators["inner fire"] = &AiObjectContextInternal::inner_fire;
+                creators["resurrection"] = &AiObjectContextInternal::resurrection;
+                creators["circle of healing"] = &AiObjectContextInternal::circle_of_healing;
+                creators["psychic scream"] = &AiObjectContextInternal::psychic_scream;
+                creators["vampiric touch"] = &AiObjectContextInternal::vampiric_touch;
+                creators["vampiric embrace"] = &AiObjectContextInternal::vampiric_embrace;
+                creators["dispersion"] = &AiObjectContextInternal::dispersion;
+            }
+
+        private:
+            static Action* dispersion(PlayerbotAI* ai) { return new CastDispersionAction(ai); }
+            static Action* vampiric_embrace(PlayerbotAI* ai) { return new CastVampiricEmbraceAction(ai); }
+            static Action* vampiric_touch(PlayerbotAI* ai) { return new CastVampiricTouchAction(ai); }
+            static Action* psychic_scream(PlayerbotAI* ai) { return new CastPsychicScreamAction(ai); }
+            static Action* circle_of_healing(PlayerbotAI* ai) { return new CastCircleOfHealingAction(ai); }
+            static Action* resurrection(PlayerbotAI* ai) { return new CastResurrectionAction(ai); }
+            static Action* shadow_word_pain(PlayerbotAI* ai) { return new CastPowerWordPainAction(ai); }
+            static Action* shadow_word_pain_on_attacker(PlayerbotAI* ai) { return new CastPowerWordPainOnAttackerAction(ai); }
+            static Action* devouring_plague(PlayerbotAI* ai) { return new CastDevouringPlagueAction(ai); }
+            static Action* mind_flay(PlayerbotAI* ai) { return new CastMindFlayAction(ai); }
+            static Action* holy_fire(PlayerbotAI* ai) { return new CastHolyFireAction(ai); }
+            static Action* smite(PlayerbotAI* ai) { return new CastSmiteAction(ai); }
+            static Action* mind_blast(PlayerbotAI* ai) { return new CastMindBlastAction(ai); }
+            static Action* shadowform(PlayerbotAI* ai) { return new CastShadowformAction(ai); }
+            static Action* remove_shadowform(PlayerbotAI* ai) { return new CastRemoveShadowformAction(ai); }
+            static Action* holy_nova(PlayerbotAI* ai) { return new CastHolyNovaAction(ai); }
+            static Action* power_word_fortitude(PlayerbotAI* ai) { return new CastPowerWordFortitudeAction(ai); }
+            static Action* power_word_fortitude_on_party(PlayerbotAI* ai) { return new CastPowerWordFortitudeOnPartyAction(ai); }
+            static Action* divine_spirit(PlayerbotAI* ai) { return new CastDivineSpiritAction(ai); }
+            static Action* divine_spirit_on_party(PlayerbotAI* ai) { return new CastDivineSpiritOnPartyAction(ai); }
+            static Action* power_word_shield(PlayerbotAI* ai) { return new CastPowerWordShieldAction(ai); }
+            static Action* power_word_shield_on_party(PlayerbotAI* ai) { return new CastPowerWordShieldOnPartyAction(ai); }
+            static Action* renew(PlayerbotAI* ai) { return new CastRenewAction(ai); }
+            static Action* renew_on_party(PlayerbotAI* ai) { return new CastRenewOnPartyAction(ai); }
+            static Action* greater_heal(PlayerbotAI* ai) { return new CastGreaterHealAction(ai); }
+            static Action* greater_heal_on_party(PlayerbotAI* ai) { return new CastGreaterHealOnPartyAction(ai); }
+            static Action* heal(PlayerbotAI* ai) { return new CastHealAction(ai); }
+            static Action* heal_on_party(PlayerbotAI* ai) { return new CastHealOnPartyAction(ai); }
+            static Action* lesser_heal(PlayerbotAI* ai) { return new CastLesserHealAction(ai); }
+            static Action* lesser_heal_on_party(PlayerbotAI* ai) { return new CastLesserHealOnPartyAction(ai); }
+            static Action* flash_heal(PlayerbotAI* ai) { return new CastFlashHealAction(ai); }
+            static Action* flash_heal_on_party(PlayerbotAI* ai) { return new CastFlashHealOnPartyAction(ai); }
+            static Action* dispel_magic(PlayerbotAI* ai) { return new CastDispelMagicAction(ai); }
+            static Action* dispel_magic_on_party(PlayerbotAI* ai) { return new CastDispelMagicOnPartyAction(ai); }
+            static Action* dispel_magic_on_target(PlayerbotAI* ai) { return new CastDispelMagicOnTargetAction(ai); }
+            static Action* cure_disease(PlayerbotAI* ai) { return new CastCureDiseaseAction(ai); }
+            static Action* cure_disease_on_party(PlayerbotAI* ai) { return new CastCureDiseaseOnPartyAction(ai); }
+            static Action* abolish_disease(PlayerbotAI* ai) { return new CastAbolishDiseaseAction(ai); }
+            static Action* abolish_disease_on_party(PlayerbotAI* ai) { return new CastAbolishDiseaseOnPartyAction(ai); }
+            static Action* fade(PlayerbotAI* ai) { return new CastFadeAction(ai); }
+            static Action* inner_fire(PlayerbotAI* ai) { return new CastInnerFireAction(ai); }
+        };
+    };
+};
+
+PriestAiObjectContext::PriestAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::priest::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::priest::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::priest::AiObjectContextInternal());
+    triggerContexts.Add(new ai::priest::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
new file mode 100644
index 0000000..315c335
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class PriestAiObjectContext : public AiObjectContext
+    {
+    public:
+        PriestAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp b/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
new file mode 100644
index 0000000..fced53e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "PriestActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestMultipliers.h b/src/plugins/playerbot/strategy/priest/PriestMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
new file mode 100644
index 0000000..a4d846b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
@@ -0,0 +1,82 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "PriestNonCombatStrategy.h"
+#include "PriestNonCombatStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+PriestNonCombatStrategy::PriestNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new PriestNonCombatStrategyActionNodeFactory());
+}
+
+void PriestNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "power word: fortitude",
+        NextAction::array(0, new NextAction("power word: fortitude", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "power word: fortitude on party",
+        NextAction::array(0, new NextAction("power word: fortitude on party", 11.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "divine spirit",
+        NextAction::array(0, new NextAction("divine spirit", 14.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "divine spirit on party",
+        NextAction::array(0, new NextAction("divine spirit on party", 13.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "inner fire",
+        NextAction::array(0, new NextAction("inner fire", 10.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("power word: shield", 70.0f), new NextAction("greater heal", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("power word: shield on party", 60.0f), new NextAction("greater heal on party", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("flash heal", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("flash heal on party", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("circle of healing", 27.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("resurrection", 30.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic",
+        NextAction::array(0, new NextAction("dispel magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic on party",
+        NextAction::array(0, new NextAction("dispel magic on party", 40.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure disease",
+        NextAction::array(0, new NextAction("abolish disease", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure disease",
+        NextAction::array(0, new NextAction("abolish disease on party", 30.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
new file mode 100644
index 0000000..da82e1a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class PriestNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        PriestNonCombatStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "nc"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
new file mode 100644
index 0000000..05edd68
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
@@ -0,0 +1,126 @@
+#pragma once
+
+namespace ai
+{
+    class PriestNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        PriestNonCombatStrategyActionNodeFactory()
+        {
+            creators["holy nova"] = &holy_nova;
+            creators["power word: shield"] = &power_word_shield;
+            creators["power word: shield on party"] = &power_word_shield_on_party;
+            creators["renew"] = &renew;
+            creators["renew on party"] = &renew_on_party;
+            creators["greater heal"] = &greater_heal;
+            creators["greater heal on party"] = &greater_heal_on_party;
+            creators["heal"] = &heal;
+            creators["heal on party"] = &heal_on_party;
+            creators["lesser heal"] = &lesser_heal;
+            creators["lesser heal on party"] = &lesser_heal_on_party;
+            creators["flash heal"] = &flash_heal;
+            creators["flash heal on party"] = &flash_heal_on_party;
+            creators["circle of healing"] = &circle_of_healing;
+        }
+    private:
+        static ActionNode* holy_nova(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy nova",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("renew", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("renew on party", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* renew(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* renew_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* circle_of_healing(PlayerbotAI* ai)
+        {
+            return new ActionNode ("circle of healing",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("flash heal on party"), NULL),
+                /*C*/ NULL);
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp b/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
new file mode 100644
index 0000000..941041c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestTriggers.h"
+#include "PriestActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/priest/PriestTriggers.h b/src/plugins/playerbot/strategy/priest/PriestTriggers.h
new file mode 100644
index 0000000..83b43c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestTriggers.h
@@ -0,0 +1,54 @@
+#pragma once
+
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_ON_PARTY_TRIGGER(PowerWordFortitudeOnPartyTrigger, "power word: fortitude", "power word: fortitude on party")
+    BUFF_TRIGGER(PowerWordFortitudeTrigger, "power word: fortitude", "power word: fortitude")
+
+    BUFF_ON_PARTY_TRIGGER(DivineSpiritOnPartyTrigger, "divine spirit", "divine spirit on party")
+    BUFF_TRIGGER(DivineSpiritTrigger, "divine spirit", "divine spirit")
+    BUFF_TRIGGER(InnerFireTrigger, "inner fire", "inner fire")
+    BUFF_TRIGGER(VampiricEmbraceTrigger, "vampiric embrace", "vampiric embrace")
+
+    class PowerWordPainOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        PowerWordPainOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "shadow word: pain") {}
+    };
+
+    DEBUFF_TRIGGER(PowerWordPainTrigger, "shadow word: pain", "shadow word: pain")
+    DEBUFF_TRIGGER(DevouringPlagueTrigger, "devouring plague", "devouring plague")
+    DEBUFF_TRIGGER(VampiricTouchTrigger, "vampiric touch", "vampiric touch")
+
+    class DispelMagicTrigger : public NeedCureTrigger
+    {
+    public:
+        DispelMagicTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "dispel magic", DISPEL_MAGIC) {}
+    };
+
+    class DispelMagicPartyMemberTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        DispelMagicPartyMemberTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "dispel magic", DISPEL_MAGIC) {}
+    };
+
+    class CureDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CureDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cure disease", DISPEL_DISEASE) {}
+    };
+
+    class PartyMemberCureDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCureDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cure disease", DISPEL_DISEASE) {}
+    };
+
+    class ShadowformTrigger : public BuffTrigger {
+    public:
+        ShadowformTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "shadowform") {}
+        virtual bool IsActive() { return !ai->HasAura("shadowform", bot); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
new file mode 100644
index 0000000..718794c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
@@ -0,0 +1,60 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "ShadowPriestStrategy.h"
+#include "ShadowPriestStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+ShadowPriestStrategy::ShadowPriestStrategy(PlayerbotAI* ai) : GenericPriestStrategy(ai)
+{
+    actionNodeFactories.Add(new ShadowPriestStrategyActionNodeFactory());
+}
+
+NextAction** ShadowPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("mind blast", 10.0f), NULL);
+}
+
+void ShadowPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shadowform",
+        NextAction::array(0, new NextAction("shadowform", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("dispersion", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "vampiric embrace",
+        NextAction::array(0, new NextAction("vampiric embrace", 16.0f), NULL)));
+}
+
+void ShadowPriestAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "shadow word: pain on attacker",
+        NextAction::array(0, new NextAction("shadow word: pain on attacker", 11.0f), NULL)));
+}
+
+void ShadowPriestDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "devouring plague",
+        NextAction::array(0, new NextAction("devouring plague", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "vampiric touch",
+        NextAction::array(0, new NextAction("vampiric touch", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shadow word: pain",
+        NextAction::array(0, new NextAction("shadow word: pain", 12.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
new file mode 100644
index 0000000..3097f4a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "HealPriestStrategy.h"
+
+namespace ai
+{
+    class ShadowPriestStrategy : public GenericPriestStrategy
+    {
+    public:
+        ShadowPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS|STRATEGY_TYPE_RANGED; }
+    };
+
+    class ShadowPriestAoeStrategy : public CombatStrategy
+    {
+    public:
+        ShadowPriestAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow aoe"; }
+    };
+
+    class ShadowPriestDebuffStrategy : public CombatStrategy
+    {
+    public:
+        ShadowPriestDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
new file mode 100644
index 0000000..1b9c533
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
@@ -0,0 +1,37 @@
+#pragma once
+
+namespace ai
+{
+    class ShadowPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        ShadowPriestStrategyActionNodeFactory()
+        {
+            creators["mind flay"] = &mind_flay;
+            creators["mind blast"] = &mind_blast;
+            creators["dispersion"] = &dispersion;
+        }
+    private:
+        static ActionNode* mind_flay(PlayerbotAI* ai)
+        {
+            return new ActionNode ("mind flay",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* mind_blast(PlayerbotAI* ai)
+        {
+            return new ActionNode ("mind blast",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("mind flay"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* dispersion(PlayerbotAI* ai)
+        {
+            return new ActionNode ("dispersion",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
new file mode 100644
index 0000000..650ac60
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
@@ -0,0 +1,110 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueMultipliers.h"
+#include "DpsRogueStrategy.h"
+
+using namespace ai;
+
+class DpsRogueStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsRogueStrategyActionNodeFactory()
+    {
+        creators["riposte"] = &riposte;
+        creators["mutilate"] = &mutilate;
+        creators["sinister strike"] = &sinister_strike;
+        creators["kick"] = &kick;
+        creators["kidney shot"] = &kidney_shot;
+        creators["rupture"] = &rupture;
+        creators["backstab"] = &backstab;
+    }
+private:
+    static ActionNode* riposte(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riposte",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mutilate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mutilate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mutilate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("sinister strike"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* sinister_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("sinister strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* kick(PlayerbotAI* ai)
+    {
+        return new ActionNode ("kick",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("kidney shot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* kidney_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("kidney shot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* rupture(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rupture",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("eviscerate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* backstab(PlayerbotAI* ai)
+    {
+        return new ActionNode ("backstab",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mutilate"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsRogueStrategy::DpsRogueStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsRogueStrategyActionNodeFactory());
+}
+
+NextAction** DpsRogueStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("riposte", ACTION_NORMAL), NULL);
+}
+
+void DpsRogueStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "combo points available",
+        NextAction::array(0, new NextAction("rupture", ACTION_HIGH + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium threat",
+		NextAction::array(0, new NextAction("vanish", ACTION_HIGH), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("evasion", ACTION_EMERGENCY), new NextAction("feint", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"kick",
+		NextAction::array(0, new NextAction("kick", ACTION_INTERRUPT + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"kick on enemy healer",
+		NextAction::array(0, new NextAction("kick on enemy healer", ACTION_INTERRUPT + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "behind target",
+        NextAction::array(0, new NextAction("backstab", ACTION_NORMAL), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
new file mode 100644
index 0000000..77e2249
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class DpsRogueStrategy : public MeleeCombatStrategy
+    {
+    public:
+        DpsRogueStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
new file mode 100644
index 0000000..0afb767
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
@@ -0,0 +1,14 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueTriggers.h"
+#include "RogueMultipliers.h"
+#include "GenericRogueNonCombatStrategy.h"
+#include "RogueActions.h"
+
+using namespace ai;
+
+void GenericRogueNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+        
+}
diff --git a/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
new file mode 100644
index 0000000..2d78612
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericRogueNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericRogueNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "nc"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueActions.cpp b/src/plugins/playerbot/strategy/rogue/RogueActions.cpp
new file mode 100644
index 0000000..aba6061
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/rogue/RogueActions.h b/src/plugins/playerbot/strategy/rogue/RogueActions.h
new file mode 100644
index 0000000..a7a78eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueActions.h
@@ -0,0 +1,82 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+#include "RogueComboActions.h"
+#include "RogueOpeningActions.h"
+#include "RogueFinishingActions.h"
+
+namespace ai
+{
+	class CastEvasionAction : public CastBuffSpellAction
+	{
+	public:
+		CastEvasionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "evasion") {}
+	};
+
+	class CastSprintAction : public CastBuffSpellAction
+	{
+	public:
+		CastSprintAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "sprint") {}
+	};
+
+	class CastKickAction : public CastSpellAction
+	{
+	public:
+		CastKickAction(PlayerbotAI* ai) : CastSpellAction(ai, "kick") {}
+	};
+
+	class CastFeintAction : public CastBuffSpellAction
+	{
+	public:
+		CastFeintAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "feint") {}
+	};
+
+	class CastDismantleAction : public CastSpellAction
+	{
+	public:
+		CastDismantleAction(PlayerbotAI* ai) : CastSpellAction(ai, "dismantle") {}
+	};
+
+	class CastDistractAction : public CastSpellAction
+	{
+	public:
+		CastDistractAction(PlayerbotAI* ai) : CastSpellAction(ai, "distract") {}
+	};
+
+	class CastVanishAction : public CastBuffSpellAction
+	{
+	public:
+		CastVanishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "vanish") {}
+	};
+
+	class CastBlindAction : public CastDebuffSpellAction
+	{
+	public:
+		CastBlindAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "blind") {}
+	};
+
+
+	class CastBladeFlurryAction : public CastBuffSpellAction
+	{
+	public:
+		CastBladeFlurryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blade flurry") {}
+	};
+
+	class CastAdrenalineRushAction : public CastBuffSpellAction
+	{
+	public:
+		CastAdrenalineRushAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "adrenaline rush") {}
+	};
+
+	class CastKillingSpreeAction : public CastBuffSpellAction
+	{
+	public:
+		CastKillingSpreeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "killing spree") {}
+	};
+
+    class CastKickOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastKickOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "kick") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
new file mode 100644
index 0000000..fdca0c0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
@@ -0,0 +1,119 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueActions.h"
+#include "RogueTriggers.h"
+#include "RogueAiObjectContext.h"
+#include "DpsRogueStrategy.h"
+#include "GenericRogueNonCombatStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["dps"] = &rogue::StrategyFactoryInternal::dps;
+                creators["nc"] = &rogue::StrategyFactoryInternal::nc;
+                creators["pull"] = &rogue::StrategyFactoryInternal::pull;
+            }
+
+        private:
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsRogueStrategy(ai); }
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericRogueNonCombatStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["kick"] = &TriggerFactoryInternal::kick;
+                creators["rupture"] = &TriggerFactoryInternal::rupture;
+                creators["slice and dice"] = &TriggerFactoryInternal::slice_and_dice;
+                creators["expose armor"] = &TriggerFactoryInternal::expose_armor;
+                creators["kick on enemy healer"] = &TriggerFactoryInternal::kick_on_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* kick(PlayerbotAI* ai) { return new KickInterruptSpellTrigger(ai); }
+            static Trigger* rupture(PlayerbotAI* ai) { return new RuptureTrigger(ai); }
+            static Trigger* slice_and_dice(PlayerbotAI* ai) { return new SliceAndDiceTrigger(ai); }
+            static Trigger* expose_armor(PlayerbotAI* ai) { return new ExposeArmorTrigger(ai); }
+            static Trigger* kick_on_enemy_healer(PlayerbotAI* ai) { return new KickInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["riposte"] = &AiObjectContextInternal::riposte;
+                creators["mutilate"] = &AiObjectContextInternal::mutilate;
+                creators["sinister strike"] = &AiObjectContextInternal::sinister_strike;
+                creators["kidney shot"] = &AiObjectContextInternal::kidney_shot;
+                creators["rupture"] = &AiObjectContextInternal::rupture;
+                creators["slice and dice"] = &AiObjectContextInternal::slice_and_dice;
+                creators["eviscerate"] = &AiObjectContextInternal::eviscerate;
+                creators["vanish"] = &AiObjectContextInternal::vanish;
+                creators["evasion"] = &AiObjectContextInternal::evasion;
+                creators["kick"] = &AiObjectContextInternal::kick;
+                creators["feint"] = &AiObjectContextInternal::feint;
+                creators["backstab"] = &AiObjectContextInternal::backstab;
+                creators["expose armor"] = &AiObjectContextInternal::expose_armor;
+                creators["kick on enemy healer"] = &AiObjectContextInternal::kick_on_enemy_healer;
+            }
+
+        private:
+            static Action* riposte(PlayerbotAI* ai) { return new CastRiposteAction(ai); }
+            static Action* mutilate(PlayerbotAI* ai) { return new CastMutilateAction(ai); }
+            static Action* sinister_strike(PlayerbotAI* ai) { return new CastSinisterStrikeAction(ai); }
+            static Action* kidney_shot(PlayerbotAI* ai) { return new CastKidneyShotAction(ai); }
+            static Action* rupture(PlayerbotAI* ai) { return new CastRuptureAction(ai); }
+            static Action* slice_and_dice(PlayerbotAI* ai) { return new CastSliceAndDiceAction(ai); }
+            static Action* eviscerate(PlayerbotAI* ai) { return new CastEviscerateAction(ai); }
+            static Action* vanish(PlayerbotAI* ai) { return new CastVanishAction(ai); }
+            static Action* evasion(PlayerbotAI* ai) { return new CastEvasionAction(ai); }
+            static Action* kick(PlayerbotAI* ai) { return new CastKickAction(ai); }
+            static Action* feint(PlayerbotAI* ai) { return new CastFeintAction(ai); }
+            static Action* backstab(PlayerbotAI* ai) { return new CastBackstabAction(ai); }
+            static Action* expose_armor(PlayerbotAI* ai) { return new CastExposeArmorAction(ai); }
+            static Action* kick_on_enemy_healer(PlayerbotAI* ai) { return new CastKickOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+RogueAiObjectContext::RogueAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::rogue::StrategyFactoryInternal());
+    actionContexts.Add(new ai::rogue::AiObjectContextInternal());
+    triggerContexts.Add(new ai::rogue::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
new file mode 100644
index 0000000..ba34626
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class RogueAiObjectContext : public AiObjectContext
+    {
+    public:
+        RogueAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueComboActions.h b/src/plugins/playerbot/strategy/rogue/RogueComboActions.h
new file mode 100644
index 0000000..186e2eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueComboActions.h
@@ -0,0 +1,45 @@
+#pragma once
+
+namespace ai
+{
+	class CastComboAction : public CastMeleeSpellAction
+	{
+	public:
+	    CastComboAction(PlayerbotAI* ai, string name) : CastMeleeSpellAction(ai, name) {}
+
+	    virtual bool isUseful()
+	    {
+	        return CastMeleeSpellAction::isUseful() && AI_VALUE2(uint8, "combo", "self target") < 5;
+	    }
+	};
+
+	class CastSinisterStrikeAction : public CastComboAction
+	{
+	public:
+		CastSinisterStrikeAction(PlayerbotAI* ai) : CastComboAction(ai, "sinister strike") {}
+	};
+
+    class CastMutilateAction : public CastComboAction
+    {
+    public:
+        CastMutilateAction(PlayerbotAI* ai) : CastComboAction(ai, "mutilate") {}
+    };
+
+    class CastRiposteAction : public CastComboAction
+    {
+    public:
+        CastRiposteAction(PlayerbotAI* ai) : CastComboAction(ai, "riposte") {}
+    };
+
+	class CastGougeAction : public CastComboAction
+	{
+	public:
+		CastGougeAction(PlayerbotAI* ai) : CastComboAction(ai, "gouge") {}
+	};
+
+    class CastBackstabAction : public CastComboAction
+    {
+    public:
+        CastBackstabAction(PlayerbotAI* ai) : CastComboAction(ai, "backstab") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h b/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
new file mode 100644
index 0000000..91a078b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
@@ -0,0 +1,35 @@
+#pragma once
+
+namespace ai
+{
+	class CastEviscerateAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastEviscerateAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "eviscerate") {} 
+	};
+
+	class CastSliceAndDiceAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastSliceAndDiceAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "slice and dice") {} 
+	};
+
+	class CastExposeArmorAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastExposeArmorAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "expose armor") {} 
+	};
+
+	class CastRuptureAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastRuptureAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "rupture") {} 
+	};
+	
+	class CastKidneyShotAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastKidneyShotAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "kidney shot") {} 
+	};
+	
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
new file mode 100644
index 0000000..136fd0d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueMultipliers.h"
+#include "RogueActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h b/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
new file mode 100644
index 0000000..35e0fc3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
@@ -0,0 +1,24 @@
+#pragma once
+
+namespace ai
+{
+	class CastSapAction : public CastMeleeSpellAction
+	{ 
+	public: 
+		CastSapAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "sap") {} 
+	};
+
+	class CastGarroteAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastGarroteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "garrote") {} 
+	};
+
+
+	class CastCheapShotAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastCheapShotAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "cheap shot") {} 
+	};
+	
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp b/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
new file mode 100644
index 0000000..8f57d24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueTriggers.h"
+#include "RogueActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/rogue/RogueTriggers.h b/src/plugins/playerbot/strategy/rogue/RogueTriggers.h
new file mode 100644
index 0000000..8d20e12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueTriggers.h
@@ -0,0 +1,36 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+
+    class KickInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        KickInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "kick") {}
+    };
+
+    class SliceAndDiceTrigger : public BuffTrigger
+    {
+    public:
+        SliceAndDiceTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "slice and dice") {}
+    };
+
+    class RuptureTrigger : public DebuffTrigger
+    {
+    public:
+        RuptureTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "rupture") {}
+    };
+
+    class ExposeArmorTrigger : public DebuffTrigger
+    {
+    public:
+        ExposeArmorTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "expose armor") {}
+    };
+
+    class KickInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        KickInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "kick") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
new file mode 100644
index 0000000..aa1b6a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "CasterShamanStrategy.h"
+
+using namespace ai;
+
+class CasterShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CasterShamanStrategyActionNodeFactory()
+    {
+        creators["magma totem"] = &magma_totem;
+    }
+private:
+    static ActionNode* magma_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("magma totem",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("fire nova"), NULL));
+    }
+};
+
+CasterShamanStrategy::CasterShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new CasterShamanStrategyActionNodeFactory());
+}
+
+NextAction** CasterShamanStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("lightning bolt", 10.0f), NULL);
+}
+
+void CasterShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("flametongue weapon", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "searing totem",
+        NextAction::array(0, new NextAction("searing totem", 19.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shock",
+        NextAction::array(0, new NextAction("earth shock", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "frost shock snare",
+        NextAction::array(0, new NextAction("frost shock", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("flametongue totem", ACTION_LIGHT_HEAL), NULL)));
+}
+
+void CasterAoeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeAoeShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("chain lightning", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("thunderstorm", 26.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
new file mode 100644
index 0000000..f9444c6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+#include "MeleeShamanStrategy.h"
+
+namespace ai
+{
+    class CasterShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        CasterShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "caster"; }
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_RANGED; }
+    };
+
+    class CasterAoeShamanStrategy : public MeleeAoeShamanStrategy
+    {
+    public:
+        CasterAoeShamanStrategy(PlayerbotAI* ai) : MeleeAoeShamanStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
new file mode 100644
index 0000000..18a9c3c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
@@ -0,0 +1,159 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "HealShamanStrategy.h"
+
+using namespace ai;
+
+class GenericShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericShamanStrategyActionNodeFactory()
+    {
+        creators["flametongue weapon"] = &flametongue_weapon;
+        creators["frostbrand weapon"] = &frostbrand_weapon;
+        creators["windfury weapon"] = &windfury_weapon;
+        creators["lesser healing wave"] = &lesser_healing_wave;
+        creators["lesser healing wave on party"] = &lesser_healing_wave_on_party;
+        creators["chain heal"] = &chain_heal;
+        creators["riptide"] = &riptide;
+        creators["chain heal on party"] = &chain_heal_on_party;
+        creators["riptide on party"] = &riptide_on_party;
+        creators["earth shock"] = &earth_shock;
+    }
+private:
+    static ActionNode* earth_shock(PlayerbotAI* ai)
+    {
+        return new ActionNode ("earth shock",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flame shock"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* flametongue_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("flametongue weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frostbrand weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* frostbrand_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frostbrand weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rockbiter weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* windfury_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("windfury weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rockbiter weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lesser_healing_wave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lesser healing wave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lesser_healing_wave_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lesser healing wave on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chain_heal(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chain heal",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lesser healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* riptide(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riptide",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chain_heal_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chain heal on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lesser healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* riptide_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riptide on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericShamanStrategy::GenericShamanStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericShamanStrategyActionNodeFactory());
+}
+
+void GenericShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "wind shear",
+        NextAction::array(0, new NextAction("wind shear", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "wind shear on enemy healer",
+        NextAction::array(0, new NextAction("wind shear on enemy healer", 23.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "purge",
+		NextAction::array(0, new NextAction("purge", 10.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "party member medium health",
+		NextAction::array(0, new NextAction("lesser healing wave on party", 25.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "party member low health",
+		NextAction::array(0, new NextAction("riptide on party", 25.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe heal",
+		NextAction::array(0, new NextAction("chain heal", 27.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium health",
+		NextAction::array(0, new NextAction("lesser healing wave", 26.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("riptide", 26.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"heroism",
+		NextAction::array(0, new NextAction("heroism", 31.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"bloodlust",
+		NextAction::array(0, new NextAction("bloodlust", 30.0f), NULL)));
+}
+
+void ShamanBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "lightning shield",
+        NextAction::array(0, new NextAction("lightning shield", 22.0f), NULL)));
+}
+
+void ShamanBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "water shield",
+        NextAction::array(0, new NextAction("water shield", 22.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
new file mode 100644
index 0000000..fdac460
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class GenericShamanStrategy : public CombatStrategy
+    {
+    public:
+        GenericShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+
+    class ShamanBuffDpsStrategy : public Strategy
+    {
+    public:
+        ShamanBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+
+    };
+
+    class ShamanBuffManaStrategy : public Strategy
+    {
+    public:
+        ShamanBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
new file mode 100644
index 0000000..0d05326
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
@@ -0,0 +1,82 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "HealShamanStrategy.h"
+
+using namespace ai;
+
+class HealShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    HealShamanStrategyActionNodeFactory()
+    {
+        creators["earthliving weapon"] = &earthliving_weapon;
+        creators["mana tide totem"] = &mana_tide_totem;
+    }
+private:
+    static ActionNode* earthliving_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("earthliving weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flametongue weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mana_tide_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mana tide totem",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+
+};
+
+HealShamanStrategy::HealShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new HealShamanStrategyActionNodeFactory());
+}
+
+void HealShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("earthliving weapon", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("mana tide totem", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit poison",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit curse",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit disease",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit poison",
+        NextAction::array(0, new NextAction("cleanse spirit poison on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit curse",
+        NextAction::array(0, new NextAction("cleanse spirit curse on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit disease",
+        NextAction::array(0, new NextAction("cleanse spirit disease on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("healing stream totem", ACTION_LIGHT_HEAL), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
new file mode 100644
index 0000000..e5d4ff1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class HealShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        HealShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "heal"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
new file mode 100644
index 0000000..d9563aa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
@@ -0,0 +1,93 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "MeleeShamanStrategy.h"
+
+using namespace ai;
+
+class MeleeShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    MeleeShamanStrategyActionNodeFactory()
+    {
+        creators["stormstrike"] = &stormstrike;
+        creators["lava lash"] = &lava_lash;
+        creators["magma totem"] = &magma_totem;
+    }
+private:
+    static ActionNode* stormstrike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("stormstrike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lava lash"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lava_lash(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lava lash",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* magma_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("magma totem",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("fire nova"), NULL));
+    }
+};
+
+MeleeShamanStrategy::MeleeShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new MeleeShamanStrategyActionNodeFactory());
+}
+
+NextAction** MeleeShamanStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("stormstrike", 10.0f), NULL);
+}
+
+void MeleeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("windfury weapon", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "searing totem",
+        NextAction::array(0, new NextAction("reach melee", 22.0f), new NextAction("searing totem", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shock",
+        NextAction::array(0, new NextAction("earth shock", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("strength of earth totem", ACTION_LIGHT_HEAL), NULL)));
+}
+
+void MeleeAoeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "magma totem",
+        NextAction::array(0, new NextAction("magma totem", 26.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("fire nova", 25.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
new file mode 100644
index 0000000..6c18fb6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class MeleeShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        MeleeShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "melee"; }
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+
+    class MeleeAoeShamanStrategy : public CombatStrategy
+    {
+    public:
+        MeleeAoeShamanStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "melee aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp b/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
new file mode 100644
index 0000000..ab8b070
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanActions.h b/src/plugins/playerbot/strategy/shaman/ShamanActions.h
new file mode 100644
index 0000000..478d08a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanActions.h
@@ -0,0 +1,304 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastLesserHealingWaveAction : public CastHealingSpellAction {
+    public:
+        CastLesserHealingWaveAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lesser healing wave") {}
+    };
+
+    class CastLesserHealingWaveOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLesserHealingWaveOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lesser healing wave") {}
+    };
+
+
+    class CastHealingWaveAction : public CastHealingSpellAction {
+    public:
+        CastHealingWaveAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "healing wave") {}
+    };
+
+    class CastHealingWaveOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealingWaveOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "healing wave") {}
+    };
+
+    class CastChainHealAction : public CastAoeHealSpellAction {
+    public:
+        CastChainHealAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "chain heal") {}
+    };
+
+    class CastRiptideAction : public CastHealingSpellAction {
+    public:
+        CastRiptideAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "riptide") {}
+    };
+
+    class CastRiptideOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRiptideOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "riptide") {}
+    };
+
+
+    class CastEarthShieldAction : public CastBuffSpellAction {
+    public:
+        CastEarthShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "earth shield") {}
+    };
+
+    class CastEarthShieldOnPartyAction : public BuffOnPartyAction
+    {
+    public:
+        CastEarthShieldOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "earth shield") {}
+    };
+
+    class CastWaterShieldAction : public CastBuffSpellAction {
+    public:
+        CastWaterShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water shield") {}
+    };
+
+	class CastLightningShieldAction : public CastBuffSpellAction {
+	public:
+		CastLightningShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "lightning shield") {}
+	};
+
+    class CastEarthlivingWeaponAction : public CastEnchantItemAction {
+    public:
+        CastEarthlivingWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "earthliving weapon") {}
+    };
+
+    class CastRockbiterWeaponAction : public CastEnchantItemAction {
+    public:
+        CastRockbiterWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "rockbiter weapon") {}
+    };
+
+    class CastFlametongueWeaponAction : public CastEnchantItemAction {
+    public:
+        CastFlametongueWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "flametongue weapon") {}
+    };
+
+    class CastFrostbrandWeaponAction : public CastEnchantItemAction {
+    public:
+        CastFrostbrandWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "frostbrand weapon") {}
+    };
+
+    class CastWindfuryWeaponAction : public CastEnchantItemAction {
+    public:
+        CastWindfuryWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "windfury weapon") {}
+    };
+
+    class CastTotemAction : public CastBuffSpellAction
+    {
+    public:
+        CastTotemAction(PlayerbotAI* ai, string spell) : CastBuffSpellAction(ai, spell) {}
+        virtual bool isUseful() { return CastBuffSpellAction::isUseful() && !AI_VALUE2(bool, "has totem", name); }
+    };
+
+    class CastStoneskinTotemAction : public CastTotemAction
+    {
+    public:
+        CastStoneskinTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "stoneskin totem") {}
+    };
+
+    class CastEarthbindTotemAction : public CastTotemAction
+    {
+    public:
+        CastEarthbindTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "earthbind totem") {}
+    };
+
+    class CastStrengthOfEarthTotemAction : public CastTotemAction
+    {
+    public:
+        CastStrengthOfEarthTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "strength of earth totem") {}
+    };
+
+    class CastManaSpringTotemAction : public CastTotemAction
+    {
+    public:
+        CastManaSpringTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "mana spring totem") {}
+    };
+
+	class CastManaTideTotemAction : public CastTotemAction
+	{
+	public:
+		CastManaTideTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "mana tide totem") {}
+		virtual string GetTargetName() { return "self target"; }
+	};
+
+	class CastHealingStreamTotemAction : public CastTotemAction
+	{
+	public:
+		CastHealingStreamTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "healing stream totem") {}
+	};
+
+    class CastCleansingTotemAction : public CastTotemAction
+    {
+    public:
+        CastCleansingTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "cleansing totem") {}
+    };
+
+    class CastFlametongueTotemAction : public CastTotemAction
+    {
+    public:
+        CastFlametongueTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "flametongue totem") {}
+    };
+
+    class CastWindfuryTotemAction : public CastTotemAction
+    {
+    public:
+        CastWindfuryTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "windfury totem") {}
+    };
+
+    class CastSearingTotemAction : public CastTotemAction
+    {
+    public:
+        CastSearingTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "searing totem") {}
+        virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CastMagmaTotemAction : public CastMeleeSpellAction
+    {
+    public:
+        CastMagmaTotemAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "magma totem") {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful() { return CastMeleeSpellAction::isUseful() && !AI_VALUE2(bool, "has totem", name); }
+    };
+
+    class CastFireNovaAction : public CastSpellAction {
+    public:
+        CastFireNovaAction(PlayerbotAI* ai) : CastSpellAction(ai, "fire nova") {}
+    };
+
+    class CastWindShearAction : public CastSpellAction {
+    public:
+        CastWindShearAction(PlayerbotAI* ai) : CastSpellAction(ai, "wind shear") {}
+    };
+
+	class CastAncestralSpiritAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastAncestralSpiritAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "ancestral spirit") {}
+	};
+
+
+	class CastPurgeAction : public CastSpellAction
+	{
+	public:
+		CastPurgeAction(PlayerbotAI* ai) : CastSpellAction(ai, "purge") {}
+	};
+
+	class CastStormstrikeAction : public CastMeleeSpellAction {
+	public:
+		CastStormstrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "stormstrike") {}
+	};
+
+	class CastLavaLashAction : public CastMeleeSpellAction {
+	public:
+		CastLavaLashAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "lava lash") {}
+	};
+
+    class CastWaterBreathingAction : public CastBuffSpellAction {
+    public:
+        CastWaterBreathingAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water breathing") {}
+    };
+
+    class CastWaterWalkingAction : public CastBuffSpellAction {
+    public:
+        CastWaterWalkingAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water walking") {}
+    };
+
+    class CastWaterBreathingOnPartyAction : public BuffOnPartyAction {
+    public:
+        CastWaterBreathingOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "water breathing") {}
+    };
+
+    class CastWaterWalkingOnPartyAction : public BuffOnPartyAction {
+    public:
+        CastWaterWalkingOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "water walking") {}
+    };
+
+
+    class CastCleanseSpiritAction : public CastCureSpellAction {
+    public:
+        CastCleanseSpiritAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse spirit") {}
+    };
+
+    class CastCleanseSpiritPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_POISON) {}
+
+        virtual string getName() { return "cleanse spirit poison on party"; }
+    };
+    class CastCleanseSpiritCurseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritCurseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_CURSE) {}
+
+        virtual string getName() { return "cleanse spirit curse on party"; }
+    };
+    class CastCleanseSpiritDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_DISEASE) {}
+
+        virtual string getName() { return "cleanse spirit disease on party"; }
+    };
+
+    class CastFlameShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFlameShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "flame shock") {}
+    };
+
+    class CastEarthShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastEarthShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "earth shock") {}
+    };
+
+    class CastFrostShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFrostShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "frost shock") {}
+    };
+
+    class CastChainLightningAction : public CastSpellAction
+    {
+    public:
+        CastChainLightningAction(PlayerbotAI* ai) : CastSpellAction(ai, "chain lightning") {}
+    };
+
+    class CastLightningBoltAction : public CastSpellAction
+    {
+    public:
+        CastLightningBoltAction(PlayerbotAI* ai) : CastSpellAction(ai, "lightning bolt") {}
+    };
+
+    class CastThunderstormAction : public CastMeleeSpellAction
+    {
+    public:
+        CastThunderstormAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "thunderstorm") {}
+    };
+
+    class CastHeroismAction : public CastBuffSpellAction
+    {
+    public:
+        CastHeroismAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "heroism") {}
+    };
+
+    class CastBloodlustAction : public CastBuffSpellAction
+    {
+    public:
+        CastBloodlustAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bloodlust") {}
+    };
+
+    class CastWindShearOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastWindShearOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "wind shear") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
new file mode 100644
index 0000000..cbd8ec3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
@@ -0,0 +1,268 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanActions.h"
+#include "ShamanAiObjectContext.h"
+#include "ShamanNonCombatStrategy.h"
+#include "HealShamanStrategy.h"
+#include "MeleeShamanStrategy.h"
+#include "ShamanTriggers.h"
+#include "../NamedObjectContext.h"
+#include "TotemsShamanStrategy.h"
+#include "CasterShamanStrategy.h"
+
+using namespace ai;
+
+
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &shaman::StrategyFactoryInternal::nc;
+                creators["totems"] = &shaman::StrategyFactoryInternal::totems;
+                creators["melee aoe"] = &shaman::StrategyFactoryInternal::melee_aoe;
+                creators["caster aoe"] = &shaman::StrategyFactoryInternal::caster_aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new ShamanNonCombatStrategy(ai); }
+            static Strategy* totems(PlayerbotAI* ai) { return new TotemsShamanStrategy(ai); }
+            static Strategy* melee_aoe(PlayerbotAI* ai) { return new MeleeAoeShamanStrategy(ai); }
+            static Strategy* caster_aoe(PlayerbotAI* ai) { return new CasterAoeShamanStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bmana"] = &shaman::BuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &shaman::BuffStrategyFactoryInternal::bdps;
+            }
+
+        private:
+            static Strategy* bmana(PlayerbotAI* ai) { return new ShamanBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new ShamanBuffDpsStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["heal"] = &shaman::CombatStrategyFactoryInternal::heal;
+                creators["melee"] = &shaman::CombatStrategyFactoryInternal::dps;
+                creators["dps"] = &shaman::CombatStrategyFactoryInternal::dps;
+                creators["caster"] = &shaman::CombatStrategyFactoryInternal::caster;
+            }
+
+        private:
+            static Strategy* heal(PlayerbotAI* ai) { return new HealShamanStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new MeleeShamanStrategy(ai); }
+            static Strategy* caster(PlayerbotAI* ai) { return new CasterShamanStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["windfury totem"] = &TriggerFactoryInternal::windfury_totem;
+                creators["mana spring totem"] = &TriggerFactoryInternal::mana_spring_totem;
+                creators["flametongue totem"] = &TriggerFactoryInternal::flametongue_totem;
+                creators["strength of earth totem"] = &TriggerFactoryInternal::strength_of_earth_totem;
+                creators["magma totem"] = &TriggerFactoryInternal::magma_totem;
+                creators["searing totem"] = &TriggerFactoryInternal::searing_totem;
+                creators["wind shear"] = &TriggerFactoryInternal::wind_shear;
+                creators["purge"] = &TriggerFactoryInternal::purge;
+                creators["shaman weapon"] = &TriggerFactoryInternal::shaman_weapon;
+                creators["water shield"] = &TriggerFactoryInternal::water_shield;
+                creators["lightning shield"] = &TriggerFactoryInternal::lightning_shield;
+                creators["water breathing"] = &TriggerFactoryInternal::water_breathing;
+                creators["water walking"] = &TriggerFactoryInternal::water_walking;
+                creators["water breathing on party"] = &TriggerFactoryInternal::water_breathing_on_party;
+                creators["water walking on party"] = &TriggerFactoryInternal::water_walking_on_party;
+                creators["cleanse spirit poison"] = &TriggerFactoryInternal::cleanse_poison;
+                creators["cleanse spirit curse"] = &TriggerFactoryInternal::cleanse_curse;
+                creators["cleanse spirit disease"] = &TriggerFactoryInternal::cleanse_disease;
+                creators["party member cleanse spirit poison"] = &TriggerFactoryInternal::party_member_cleanse_poison;
+                creators["party member cleanse spirit curse"] = &TriggerFactoryInternal::party_member_cleanse_curse;
+                creators["party member cleanse spirit disease"] = &TriggerFactoryInternal::party_member_cleanse_disease;
+                creators["shock"] = &TriggerFactoryInternal::shock;
+                creators["frost shock snare"] = &TriggerFactoryInternal::frost_shock_snare;
+                creators["heroism"] = &TriggerFactoryInternal::heroism;
+                creators["bloodlust"] = &TriggerFactoryInternal::bloodlust;
+                creators["maelstrom weapon"] = &TriggerFactoryInternal::maelstrom_weapon;
+                creators["wind shear on enemy healer"] = &TriggerFactoryInternal::wind_shear_on_enemy_healer;
+            }
+
+        private:
+            static Trigger* maelstrom_weapon(PlayerbotAI* ai) { return new MaelstromWeaponTrigger(ai); }
+            static Trigger* heroism(PlayerbotAI* ai) { return new HeroismTrigger(ai); }
+            static Trigger* bloodlust(PlayerbotAI* ai) { return new BloodlustTrigger(ai); }
+            static Trigger* party_member_cleanse_disease(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritDiseaseTrigger(ai); }
+            static Trigger* party_member_cleanse_curse(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritCurseTrigger(ai); }
+            static Trigger* party_member_cleanse_poison(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritPoisonTrigger(ai); }
+            static Trigger* cleanse_disease(PlayerbotAI* ai) { return new CleanseSpiritDiseaseTrigger(ai); }
+            static Trigger* cleanse_curse(PlayerbotAI* ai) { return new CleanseSpiritCurseTrigger(ai); }
+            static Trigger* cleanse_poison(PlayerbotAI* ai) { return new CleanseSpiritPoisonTrigger(ai); }
+            static Trigger* water_breathing(PlayerbotAI* ai) { return new WaterBreathingTrigger(ai); }
+            static Trigger* water_walking(PlayerbotAI* ai) { return new WaterWalkingTrigger(ai); }
+            static Trigger* water_breathing_on_party(PlayerbotAI* ai) { return new WaterBreathingOnPartyTrigger(ai); }
+            static Trigger* water_walking_on_party(PlayerbotAI* ai) { return new WaterWalkingOnPartyTrigger(ai); }
+            static Trigger* windfury_totem(PlayerbotAI* ai) { return new WindfuryTotemTrigger(ai); }
+            static Trigger* mana_spring_totem(PlayerbotAI* ai) { return new ManaSpringTotemTrigger(ai); }
+            static Trigger* flametongue_totem(PlayerbotAI* ai) { return new FlametongueTotemTrigger(ai); }
+            static Trigger* strength_of_earth_totem(PlayerbotAI* ai) { return new StrengthOfEarthTotemTrigger(ai); }
+            static Trigger* magma_totem(PlayerbotAI* ai) { return new MagmaTotemTrigger(ai); }
+            static Trigger* searing_totem(PlayerbotAI* ai) { return new SearingTotemTrigger(ai); }
+            static Trigger* wind_shear(PlayerbotAI* ai) { return new WindShearInterruptSpellTrigger(ai); }
+            static Trigger* purge(PlayerbotAI* ai) { return new PurgeTrigger(ai); }
+            static Trigger* shaman_weapon(PlayerbotAI* ai) { return new ShamanWeaponTrigger(ai); }
+            static Trigger* water_shield(PlayerbotAI* ai) { return new WaterShieldTrigger(ai); }
+            static Trigger* lightning_shield(PlayerbotAI* ai) { return new LightningShieldTrigger(ai); }
+            static Trigger* shock(PlayerbotAI* ai) { return new ShockTrigger(ai); }
+            static Trigger* frost_shock_snare(PlayerbotAI* ai) { return new FrostShockSnareTrigger(ai); }
+            static Trigger* wind_shear_on_enemy_healer(PlayerbotAI* ai) { return new WindShearInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["water shield"] = &AiObjectContextInternal::water_shield;
+                creators["lightning shield"] = &AiObjectContextInternal::lightning_shield;
+                creators["strength of earth totem"] = &AiObjectContextInternal::strength_of_earth_totem;
+                creators["flametongue totem"] = &AiObjectContextInternal::flametongue_totem;
+                creators["searing totem"] = &AiObjectContextInternal::searing_totem;
+                creators["magma totem"] = &AiObjectContextInternal::magma_totem;
+                creators["windfury totem"] = &AiObjectContextInternal::windfury_totem;
+                creators["mana spring totem"] = &AiObjectContextInternal::mana_spring_totem;
+                creators["mana tide totem"] = &AiObjectContextInternal::mana_tide_totem;
+                creators["healing stream totem"] = &AiObjectContextInternal::healing_stream_totem;
+                creators["wind shear"] = &AiObjectContextInternal::wind_shear;
+                creators["wind shear on enemy healer"] = &AiObjectContextInternal::wind_shear_on_enemy_healer;
+                creators["rockbiter weapon"] = &AiObjectContextInternal::rockbiter_weapon;
+                creators["flametongue weapon"] = &AiObjectContextInternal::flametongue_weapon;
+                creators["frostbrand weapon"] = &AiObjectContextInternal::frostbrand_weapon;
+                creators["windfury weapon"] = &AiObjectContextInternal::windfury_weapon;
+                creators["earthliving weapon"] = &AiObjectContextInternal::earthliving_weapon;
+                creators["purge"] = &AiObjectContextInternal::purge;
+                creators["healing wave"] = &AiObjectContextInternal::healing_wave;
+                creators["lesser healing wave"] = &AiObjectContextInternal::lesser_healing_wave;
+                creators["healing wave on party"] = &AiObjectContextInternal::healing_wave_on_party;
+                creators["lesser healing wave on party"] = &AiObjectContextInternal::lesser_healing_wave_on_party;
+                creators["earth shield"] = &AiObjectContextInternal::earth_shield;
+                creators["earth shield on party"] = &AiObjectContextInternal::earth_shield_on_party;
+                creators["chain heal"] = &AiObjectContextInternal::chain_heal;
+                creators["riptide"] = &AiObjectContextInternal::riptide;
+                creators["riptide on party"] = &AiObjectContextInternal::riptide_on_party;
+                creators["stormstrike"] = &AiObjectContextInternal::stormstrike;
+                creators["lava lash"] = &AiObjectContextInternal::lava_lash;
+                creators["fire nova"] = &AiObjectContextInternal::fire_nova;
+                creators["ancestral spirit"] = &AiObjectContextInternal::ancestral_spirit;
+                creators["water walking"] = &AiObjectContextInternal::water_walking;
+                creators["water breathing"] = &AiObjectContextInternal::water_breathing;
+                creators["water walking on party"] = &AiObjectContextInternal::water_walking_on_party;
+                creators["water breathing on party"] = &AiObjectContextInternal::water_breathing_on_party;
+                creators["cleanse spirit"] = &AiObjectContextInternal::cleanse_spirit;
+                creators["cleanse spirit poison on party"] = &AiObjectContextInternal::cleanse_spirit_poison_on_party;
+                creators["cleanse spirit disease on party"] = &AiObjectContextInternal::cleanse_spirit_disease_on_party;
+                creators["cleanse spirit curse on party"] = &AiObjectContextInternal::cleanse_spirit_curse_on_party;
+                creators["flame shock"] = &AiObjectContextInternal::flame_shock;
+                creators["earth shock"] = &AiObjectContextInternal::earth_shock;
+                creators["frost shock"] = &AiObjectContextInternal::frost_shock;
+                creators["chain lightning"] = &AiObjectContextInternal::chain_lightning;
+                creators["lightning bolt"] = &AiObjectContextInternal::lightning_bolt;
+                creators["thunderstorm"] = &AiObjectContextInternal::thunderstorm;
+                creators["heroism"] = &AiObjectContextInternal::heroism;
+                creators["bloodlust"] = &AiObjectContextInternal::bloodlust;
+            }
+
+        private:
+            static Action* heroism(PlayerbotAI* ai) { return new CastHeroismAction(ai); }
+            static Action* bloodlust(PlayerbotAI* ai) { return new CastBloodlustAction(ai); }
+            static Action* thunderstorm(PlayerbotAI* ai) { return new CastThunderstormAction(ai); }
+            static Action* lightning_bolt(PlayerbotAI* ai) { return new CastLightningBoltAction(ai); }
+            static Action* chain_lightning(PlayerbotAI* ai) { return new CastChainLightningAction(ai); }
+            static Action* frost_shock(PlayerbotAI* ai) { return new CastFrostShockAction(ai); }
+            static Action* earth_shock(PlayerbotAI* ai) { return new CastEarthShockAction(ai); }
+            static Action* flame_shock(PlayerbotAI* ai) { return new CastFlameShockAction(ai); }
+            static Action* cleanse_spirit_poison_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritPoisonOnPartyAction(ai); }
+            static Action* cleanse_spirit_disease_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritDiseaseOnPartyAction(ai); }
+            static Action* cleanse_spirit_curse_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritCurseOnPartyAction(ai); }
+            static Action* cleanse_spirit(PlayerbotAI* ai) { return new CastCleanseSpiritAction(ai); }
+            static Action* water_walking(PlayerbotAI* ai) { return new CastWaterWalkingAction(ai); }
+            static Action* water_breathing(PlayerbotAI* ai) { return new CastWaterBreathingAction(ai); }
+            static Action* water_walking_on_party(PlayerbotAI* ai) { return new CastWaterWalkingOnPartyAction(ai); }
+            static Action* water_breathing_on_party(PlayerbotAI* ai) { return new CastWaterBreathingOnPartyAction(ai); }
+            static Action* water_shield(PlayerbotAI* ai) { return new CastWaterShieldAction(ai); }
+            static Action* lightning_shield(PlayerbotAI* ai) { return new CastLightningShieldAction(ai); }
+            static Action* strength_of_earth_totem(PlayerbotAI* ai) { return new CastStrengthOfEarthTotemAction(ai); }
+            static Action* flametongue_totem(PlayerbotAI* ai) { return new CastFlametongueTotemAction(ai); }
+            static Action* magma_totem(PlayerbotAI* ai) { return new CastMagmaTotemAction(ai); }
+            static Action* searing_totem(PlayerbotAI* ai) { return new CastSearingTotemAction(ai); }
+            static Action* fire_nova(PlayerbotAI* ai) { return new CastFireNovaAction(ai); }
+            static Action* windfury_totem(PlayerbotAI* ai) { return new CastWindfuryTotemAction(ai); }
+            static Action* mana_spring_totem(PlayerbotAI* ai) { return new CastManaSpringTotemAction(ai); }
+            static Action* mana_tide_totem(PlayerbotAI* ai) { return new CastManaTideTotemAction(ai); }
+            static Action* healing_stream_totem(PlayerbotAI* ai) { return new CastHealingStreamTotemAction(ai); }
+            static Action* wind_shear(PlayerbotAI* ai) { return new CastWindShearAction(ai); }
+            static Action* rockbiter_weapon(PlayerbotAI* ai) { return new CastRockbiterWeaponAction(ai); }
+            static Action* flametongue_weapon(PlayerbotAI* ai) { return new CastFlametongueWeaponAction(ai); }
+            static Action* frostbrand_weapon(PlayerbotAI* ai) { return new CastFrostbrandWeaponAction(ai); }
+            static Action* windfury_weapon(PlayerbotAI* ai) { return new CastWindfuryWeaponAction(ai); }
+            static Action* earthliving_weapon(PlayerbotAI* ai) { return new CastEarthlivingWeaponAction(ai); }
+            static Action* purge(PlayerbotAI* ai) { return new CastPurgeAction(ai); }
+            static Action* healing_wave(PlayerbotAI* ai) { return new CastHealingWaveAction(ai); }
+            static Action* lesser_healing_wave(PlayerbotAI* ai) { return new CastLesserHealingWaveAction(ai); }
+            static Action* healing_wave_on_party(PlayerbotAI* ai) { return new CastHealingWaveOnPartyAction(ai); }
+            static Action* lesser_healing_wave_on_party(PlayerbotAI* ai) { return new CastLesserHealingWaveOnPartyAction(ai); }
+            static Action* earth_shield(PlayerbotAI* ai) { return new CastEarthShieldAction(ai); }
+            static Action* earth_shield_on_party(PlayerbotAI* ai) { return new CastEarthShieldOnPartyAction(ai); }
+            static Action* chain_heal(PlayerbotAI* ai) { return new CastChainHealAction(ai); }
+            static Action* riptide(PlayerbotAI* ai) { return new CastRiptideAction(ai); }
+            static Action* riptide_on_party(PlayerbotAI* ai) { return new CastRiptideOnPartyAction(ai); }
+            static Action* stormstrike(PlayerbotAI* ai) { return new CastStormstrikeAction(ai); }
+            static Action* lava_lash(PlayerbotAI* ai) { return new CastLavaLashAction(ai); }
+            static Action* ancestral_spirit(PlayerbotAI* ai) { return new CastAncestralSpiritAction(ai); }
+            static Action* wind_shear_on_enemy_healer(PlayerbotAI* ai) { return new CastWindShearOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+
+ShamanAiObjectContext::ShamanAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::shaman::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::shaman::CombatStrategyFactoryInternal());
+    strategyContexts.Add(new ai::shaman::BuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::shaman::AiObjectContextInternal());
+    triggerContexts.Add(new ai::shaman::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
new file mode 100644
index 0000000..718084a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class ShamanAiObjectContext : public AiObjectContext
+    {
+    public:
+        ShamanAiObjectContext(PlayerbotAI* ai);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
new file mode 100644
index 0000000..6c72f20
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "ShamanActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
new file mode 100644
index 0000000..044c6bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
@@ -0,0 +1,49 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "ShamanNonCombatStrategy.h"
+
+using namespace ai;
+
+void ShamanNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("ancestral spirit", 33.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"water breathing",
+		NextAction::array(0, new NextAction("water breathing", 12.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"water walking",
+		NextAction::array(0, new NextAction("water walking", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "water breathing on party",
+        NextAction::array(0, new NextAction("water breathing on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "water walking on party",
+        NextAction::array(0, new NextAction("water walking on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("healing wave", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("healing wave on party", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("chain heal", 27.0f), NULL)));
+}
+
+void ShamanNonCombatStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    NonCombatStrategy::InitMultipliers(multipliers);
+}
+
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
new file mode 100644
index 0000000..a6859ee
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class ShamanNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        ShamanNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "nc"; }
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
new file mode 100644
index 0000000..2a6c51e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanTriggers.h"
+#include "ShamanActions.h"
+
+using namespace ai;
+
+list<string> ShamanWeaponTrigger::spells;
+
+bool ShamanWeaponTrigger::IsActive()
+{
+    if (spells.empty())
+    {
+        spells.push_back("frostbrand weapon");
+        spells.push_back("rockbiter weapon");
+        spells.push_back("flametongue weapon");
+        spells.push_back("earthliving weapon");
+        spells.push_back("windfury weapon");
+    }
+
+    for (list<string>::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+        if (!spellId)
+            continue;
+
+        if (AI_VALUE2(Item*, "item for spell", spellId))
+            return true;
+    }
+
+    return false;
+}
+
+bool ShockTrigger::IsActive()
+{
+    return SpellTrigger::IsActive()
+            && !ai->HasAnyAuraOf(GetTarget(), "frost shock", "earth shock", "flame shock", NULL);
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
new file mode 100644
index 0000000..afa6d62
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
@@ -0,0 +1,197 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    class ShamanWeaponTrigger : public BuffTrigger {
+    public:
+        ShamanWeaponTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "rockbiter weapon") {}
+        virtual bool IsActive();
+    private:
+        static list<string> spells;
+    };
+
+    class TotemTrigger : public Trigger {
+    public:
+        TotemTrigger(PlayerbotAI* ai, string spell, int attackerCount = 0) : Trigger(ai, spell), attackerCount(attackerCount) {}
+
+        virtual bool IsActive()
+		{
+            return AI_VALUE(uint8, "attacker count") >= attackerCount && !AI_VALUE2(bool, "has totem", name);
+        }
+
+    protected:
+        int attackerCount;
+    };
+
+    class WindfuryTotemTrigger : public TotemTrigger {
+    public:
+        WindfuryTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "windfury totem") {}
+    };
+
+    class ManaSpringTotemTrigger : public TotemTrigger {
+    public:
+        ManaSpringTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "mana spring totem") {}
+        virtual bool IsActive()
+        {
+            return AI_VALUE(uint8, "attacker count") >= attackerCount &&
+                    !AI_VALUE2(bool, "has totem", "mana tide totem") &&
+                    !AI_VALUE2(bool, "has totem", name);
+        }
+    };
+
+    class FlametongueTotemTrigger : public TotemTrigger {
+    public:
+        FlametongueTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "flametongue totem") {}
+    };
+
+    class StrengthOfEarthTotemTrigger : public TotemTrigger {
+    public:
+        StrengthOfEarthTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "strength of earth totem") {}
+    };
+
+    class MagmaTotemTrigger : public TotemTrigger {
+    public:
+        MagmaTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "magma totem", 3) {}
+    };
+
+    class SearingTotemTrigger : public TotemTrigger {
+    public:
+        SearingTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "searing totem", 1) {}
+    };
+
+    class WindShearInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        WindShearInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "wind shear") {}
+    };
+
+    class WaterShieldTrigger : public BuffTrigger
+    {
+    public:
+        WaterShieldTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water shield") {}
+    };
+
+    class LightningShieldTrigger : public BuffTrigger
+    {
+    public:
+        LightningShieldTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "lightning shield") {}
+    };
+
+    class PurgeTrigger : public TargetAuraDispelTrigger
+    {
+    public:
+        PurgeTrigger(PlayerbotAI* ai) : TargetAuraDispelTrigger(ai, "purge", DISPEL_MAGIC) {}
+    };
+
+    class WaterWalkingTrigger : public BuffTrigger {
+    public:
+        WaterWalkingTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water walking") {}
+
+        virtual bool IsActive()
+        {
+            return BuffTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterBreathingTrigger : public BuffTrigger {
+    public:
+        WaterBreathingTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water breathing") {}
+
+        virtual bool IsActive()
+        {
+            return BuffTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterWalkingOnPartyTrigger : public BuffOnPartyTrigger {
+    public:
+        WaterWalkingOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "water walking on party") {}
+
+        virtual bool IsActive()
+        {
+            return BuffOnPartyTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterBreathingOnPartyTrigger : public BuffOnPartyTrigger {
+    public:
+        WaterBreathingOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "water breathing on party") {}
+
+        virtual bool IsActive()
+        {
+            return BuffOnPartyTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class CleanseSpiritPoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritPoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_POISON) {}
+    };
+
+    class PartyMemberCleanseSpiritPoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritPoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_POISON) {}
+    };
+
+    class CleanseSpiritCurseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritCurseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_CURSE) {}
+    };
+
+    class PartyMemberCleanseSpiritCurseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritCurseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_CURSE) {}
+    };
+
+    class CleanseSpiritDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_DISEASE) {}
+    };
+
+    class PartyMemberCleanseSpiritDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_DISEASE) {}
+    };
+
+    class ShockTrigger : public DebuffTrigger {
+    public:
+        ShockTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "earth shock") {}
+        virtual bool IsActive();
+    };
+
+    class FrostShockSnareTrigger : public SnareTargetTrigger {
+    public:
+        FrostShockSnareTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "frost shock") {}
+    };
+
+    class HeroismTrigger : public BoostTrigger
+    {
+    public:
+        HeroismTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "heroism") {}
+    };
+
+    class BloodlustTrigger : public BoostTrigger
+    {
+    public:
+        BloodlustTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "bloodlust") {}
+    };
+
+    class MaelstromWeaponTrigger : public HasAuraTrigger
+    {
+    public:
+        MaelstromWeaponTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "maelstrom weapon") {}
+    };
+
+    class WindShearInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        WindShearInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "wind shear") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
new file mode 100644
index 0000000..e23c97d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "TotemsShamanStrategy.h"
+
+using namespace ai;
+
+TotemsShamanStrategy::TotemsShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+}
+
+void TotemsShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "windfury totem",
+        NextAction::array(0, new NextAction("windfury totem", 16.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "mana spring totem",
+        NextAction::array(0, new NextAction("mana spring totem", 19.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "strength of earth totem",
+        NextAction::array(0, new NextAction("strength of earth totem", 18.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "flametongue totem",
+        NextAction::array(0, new NextAction("flametongue totem", 17.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
new file mode 100644
index 0000000..978fa26
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class TotemsShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        TotemsShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "totems"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h b/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
new file mode 100644
index 0000000..0e43d16
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+    class ChatCommandTrigger : public Trigger {
+    public:
+        ChatCommandTrigger(PlayerbotAI* ai, string command) : Trigger(ai, command), triggered(false) {}
+
+        virtual void ExternalEvent(string param, Player* owner = NULL)
+        {
+            this->param = param;
+            this->owner = owner;
+            triggered = true;
+        }
+
+        virtual Event Check()
+        {
+            if (!triggered)
+                return Event();
+
+            return Event(getName(), param, owner);
+        }
+
+        virtual void Reset()
+        {
+            triggered = false;
+        }
+
+   private:
+        string param;
+        bool triggered;
+        Player* owner;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h b/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
new file mode 100644
index 0000000..239e0ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
@@ -0,0 +1,140 @@
+#pragma once
+
+#include "ChatCommandTrigger.h"
+
+namespace ai
+{
+    class ChatTriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        ChatTriggerContext()
+        {
+            creators["quests"] = &ChatTriggerContext::quests;
+            creators["stats"] = &ChatTriggerContext::stats;
+            creators["leave"] = &ChatTriggerContext::leave;
+            creators["rep"] = &ChatTriggerContext::reputation;
+            creators["reputation"] = &ChatTriggerContext::reputation;
+            creators["log"] = &ChatTriggerContext::log;
+            creators["los"] = &ChatTriggerContext::los;
+            creators["drop"] = &ChatTriggerContext::drop;
+            creators["q"] = &ChatTriggerContext::q;
+            creators["ll"] = &ChatTriggerContext::ll;
+            creators["loot all"] = &ChatTriggerContext::loot_all;
+            creators["add all loot"] = &ChatTriggerContext::loot_all;
+            creators["release"] = &ChatTriggerContext::release;
+            creators["teleport"] = &ChatTriggerContext::teleport;
+            creators["taxi"] = &ChatTriggerContext::taxi;
+            creators["repair"] = &ChatTriggerContext::repair;
+            creators["u"] = &ChatTriggerContext::use;
+            creators["use"] = &ChatTriggerContext::use;
+            creators["c"] = &ChatTriggerContext::item_count;
+            creators["e"] = &ChatTriggerContext::equip;
+            creators["ue"] = &ChatTriggerContext::uneqip;
+            creators["s"] = &ChatTriggerContext::sell;
+            creators["b"] = &ChatTriggerContext::buy;
+            creators["r"] = &ChatTriggerContext::reward;
+            creators["t"] = &ChatTriggerContext::trade;
+            creators["nt"] = &ChatTriggerContext::nontrade;
+            creators["talents"] = &ChatTriggerContext::talents;
+            creators["spells"] = &ChatTriggerContext::spells;
+            creators["co"] = &ChatTriggerContext::co;
+            creators["nc"] = &ChatTriggerContext::nc;
+            creators["dead"] = &ChatTriggerContext::dead;
+            creators["trainer"] = &ChatTriggerContext::trainer;
+            creators["attack"] = &ChatTriggerContext::attack;
+            creators["chat"] = &ChatTriggerContext::chat;
+            creators["accept"] = &ChatTriggerContext::accept;
+            creators["home"] = &ChatTriggerContext::home;
+            creators["reset ai"] = &ChatTriggerContext::reset_ai;
+            creators["destroy"] = &ChatTriggerContext::destroy;
+            creators["emote"] = &ChatTriggerContext::emote;
+            creators["buff"] = &ChatTriggerContext::buff;
+            creators["help"] = &ChatTriggerContext::help;
+            creators["gb"] = &ChatTriggerContext::gb;
+            creators["bank"] = &ChatTriggerContext::bank;
+            creators["follow"] = &ChatTriggerContext::follow;
+            creators["stay"] = &ChatTriggerContext::stay;
+            creators["flee"] = &ChatTriggerContext::flee;
+            creators["grind"] = &ChatTriggerContext::grind;
+            creators["tank attack"] = &ChatTriggerContext::tank_attack;
+            creators["talk"] = &ChatTriggerContext::talk;
+            creators["cast"] = &ChatTriggerContext::talk;
+            creators["invite"] = &ChatTriggerContext::invite;
+            creators["spell"] = &ChatTriggerContext::spell;
+            creators["rti"] = &ChatTriggerContext::rti;
+            creators["revive"] = &ChatTriggerContext::revive;
+            creators["runaway"] = &ChatTriggerContext::runaway;
+            creators["warning"] = &ChatTriggerContext::warning;
+            creators["position"] = &ChatTriggerContext::position;
+            creators["summon"] = &ChatTriggerContext::summon;
+            creators["who"] = &ChatTriggerContext::who;
+            creators["save mana"] = &ChatTriggerContext::save_mana;
+            creators["max dps"] = &ChatTriggerContext::max_dps;
+            creators["attackers"] = &ChatTriggerContext::attackers;
+            creators["formation"] = &ChatTriggerContext::formation;
+        }
+
+    private:
+        static Trigger* formation(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "formation"); }
+        static Trigger* attackers(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "attackers"); }
+        static Trigger* max_dps(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "max dps"); }
+        static Trigger* save_mana(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "save mana"); }
+        static Trigger* who(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "who"); }
+        static Trigger* summon(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "summon"); }
+        static Trigger* position(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "position"); }
+        static Trigger* runaway(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "runaway"); }
+        static Trigger* warning(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "warning"); }
+        static Trigger* revive(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "revive"); }
+        static Trigger* rti(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "rti"); }
+        static Trigger* invite(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "invite"); }
+        static Trigger* cast(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "cast"); }
+        static Trigger* talk(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "talk"); }
+        static Trigger* flee(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "flee"); }
+        static Trigger* grind(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "grind"); }
+        static Trigger* tank_attack(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "tank attack"); }
+        static Trigger* stay(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "stay"); }
+        static Trigger* follow(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "follow"); }
+        static Trigger* gb(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "gb"); }
+        static Trigger* bank(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "bank"); }
+        static Trigger* help(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "help"); }
+        static Trigger* buff(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "buff"); }
+        static Trigger* emote(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "emote"); }
+        static Trigger* destroy(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "destroy"); }
+        static Trigger* home(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "home"); }
+        static Trigger* accept(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "accept"); }
+        static Trigger* chat(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "chat"); }
+        static Trigger* attack(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "attack"); }
+        static Trigger* trainer(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "trainer"); }
+        static Trigger* co(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "co"); }
+        static Trigger* nc(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "nc"); }
+        static Trigger* dead(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "dead"); }
+        static Trigger* spells(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "spells"); }
+        static Trigger* talents(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "talents"); }
+        static Trigger* equip(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "e"); }
+        static Trigger* uneqip(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "ue"); }
+        static Trigger* sell(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "s"); }
+        static Trigger* buy(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "b"); }
+        static Trigger* reward(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "r"); }
+        static Trigger* trade(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "t"); }
+        static Trigger* nontrade(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "nt"); }
+
+        static Trigger* item_count(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "c"); }
+        static Trigger* use(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "use"); }
+        static Trigger* repair(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "repair"); }
+        static Trigger* taxi(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "taxi"); }
+        static Trigger* teleport(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "teleport"); }
+        static Trigger* q(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "q"); }
+        static Trigger* ll(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "ll"); }
+        static Trigger* drop(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "drop"); }
+        static Trigger* quests(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "quests"); }
+        static Trigger* stats(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "stats"); }
+        static Trigger* leave(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "leave"); }
+        static Trigger* reputation(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "reputation"); }
+        static Trigger* log(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "log"); }
+        static Trigger* los(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "los"); }
+        static Trigger* loot_all(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "add all loot"); }
+        static Trigger* release(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "release"); }
+        static Trigger* reset_ai(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "reset ai"); }
+        static Trigger* spell(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "spell"); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp b/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
new file mode 100644
index 0000000..0be6ff6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericTriggers.h"
+#include "CureTriggers.h"
+
+using namespace ai;
+
+bool NeedCureTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return target && ai->HasAuraToDispel(target, dispelType);
+}
+
+Value<Unit*>* PartyMemberNeedCureTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("party member to dispel", dispelType);
+}
diff --git a/src/plugins/playerbot/strategy/triggers/CureTriggers.h b/src/plugins/playerbot/strategy/triggers/CureTriggers.h
new file mode 100644
index 0000000..2321953
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/CureTriggers.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Trigger.h"
+
+namespace ai
+{
+	class SpellTrigger;
+
+    class NeedCureTrigger : public SpellTrigger {
+    public:
+        NeedCureTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : SpellTrigger(ai, spell) 
+  	    {
+			this->dispelType = dispelType;
+        }
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+
+    protected:
+        uint32 dispelType;
+    };
+
+    class TargetAuraDispelTrigger : public NeedCureTrigger {
+    public:
+        TargetAuraDispelTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : 
+			NeedCureTrigger(ai, spell, dispelType) {}
+		virtual string GetTargetName() { return "current target"; }
+    };
+
+    class PartyMemberNeedCureTrigger : public NeedCureTrigger {
+    public:
+        PartyMemberNeedCureTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : 
+            NeedCureTrigger(ai, spell, dispelType) {}
+
+		virtual Value<Unit*>* GetTargetValue();
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp b/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
new file mode 100644
index 0000000..ebd6dbf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
@@ -0,0 +1,242 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericTriggers.h"
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool LowManaTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has mana", "self target") && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana;
+}
+
+bool MediumManaTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has mana", "self target") && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.mediumMana;
+}
+
+
+bool RageAvailable::IsActive()
+{
+    return AI_VALUE2(uint8, "rage", "self target") >= amount;
+}
+
+bool EnergyAvailable::IsActive()
+{
+	return AI_VALUE2(uint8, "energy", "self target") >= amount;
+}
+
+bool ComboPointsAvailableTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "combo", "current target") >= amount;
+}
+
+bool LoseAggroTrigger::IsActive()
+{
+    return !AI_VALUE2(bool, "has aggro", "current target");
+}
+
+bool HasAggroTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has aggro", "current target");
+}
+
+bool PanicTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "health", "self target") < sPlayerbotAIConfig.criticalHealth &&
+		(!AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana);
+}
+
+bool BuffTrigger::IsActive()
+{
+    Unit* target = GetTarget();
+	return SpellTrigger::IsActive() &&
+		!ai->HasAura(spell, target) &&
+		(!AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.lowMana);
+}
+
+Value<Unit*>* BuffOnPartyTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("party member without aura", spell);
+}
+
+Value<Unit*>* DebuffOnAttackerTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("attacker without aura", spell);
+}
+
+bool NoAttackersTrigger::IsActive()
+{
+    return !AI_VALUE(Unit*, "current target") && AI_VALUE(uint8, "attacker count") > 0;
+}
+
+bool InvalidTargetTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "invalid target", "current target");
+}
+
+bool NoTargetTrigger::IsActive()
+{
+	return !AI_VALUE(Unit*, "current target");
+}
+
+bool MyAttackerCountTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "my attacker count") >= amount;
+}
+
+bool AoeTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "attacker count") >= amount;
+}
+
+bool DebuffTrigger::IsActive()
+{
+	return BuffTrigger::IsActive() && AI_VALUE2(uint8, "health", "current target") > 25;
+}
+
+bool SpellTrigger::IsActive()
+{
+	return GetTarget();
+}
+
+bool SpellCanBeCastTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return target && ai->CanCastSpell(spell, target);
+}
+
+bool RandomTrigger::IsActive()
+{
+    int vl  = rand() % (int)(1 + probability * 10 / sPlayerbotAIConfig.randomChangeMultiplier);
+    return vl == 0;
+}
+
+bool AndTrigger::IsActive()
+{
+    return ls->IsActive() && rs->IsActive();
+}
+
+string AndTrigger::getName()
+{
+    std::string name(ls->getName());
+    name = name + " and ";
+    name = name + rs->getName();
+    return name;
+}
+
+bool BoostTrigger::IsActive()
+{
+	return BuffTrigger::IsActive() && AI_VALUE(uint8, "balance") <= balance;
+}
+
+bool SnareTargetTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return DebuffTrigger::IsActive() && AI_VALUE2(bool, "moving", "current target") && !ai->HasAura(spell, target);
+}
+
+bool ItemCountTrigger::IsActive()
+{
+	return AI_VALUE2(uint8, "item count", item) < count;
+}
+
+bool InterruptSpellTrigger::IsActive()
+{
+	return SpellTrigger::IsActive() && ai->IsInterruptableSpellCasting(GetTarget(), getName());
+}
+
+bool HasAuraTrigger::IsActive()
+{
+	return ai->HasAura(getName(), GetTarget());
+}
+
+bool TankAoeTrigger::IsActive()
+{
+    if (!AI_VALUE(uint8, "attacker count"))
+        return false;
+
+    Unit* currentTarget = AI_VALUE(Unit*, "current target");
+    if (!currentTarget)
+        return true;
+
+    Unit* tankTarget = AI_VALUE(Unit*, "tank target");
+    if (!tankTarget || currentTarget == tankTarget)
+        return false;
+
+    return currentTarget->GetVictim() == AI_VALUE(Unit*, "self target");
+}
+
+bool IsBehindTargetTrigger::IsActive()
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return target && AI_VALUE2(bool, "behind", "current target");
+}
+
+bool IsNotFacingTargetTrigger::IsActive()
+{
+    return !AI_VALUE2(bool, "facing", "current target");
+}
+
+bool HasCcTargetTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "attacker count") > 2 && AI_VALUE2(Unit*, "cc target", getName()) &&
+        !AI_VALUE2(Unit*, "current cc target", getName());
+}
+
+bool NoMovementTrigger::IsActive()
+{
+	return !AI_VALUE2(bool, "moving", "self target");
+}
+
+bool NoPossibleTargetsTrigger::IsActive()
+{
+    list<ObjectGuid> targets = AI_VALUE(list<ObjectGuid>, "possible targets");
+    return !targets.size();
+}
+
+bool NotLeastHpTargetActiveTrigger::IsActive()
+{
+    Unit* leastHp = AI_VALUE(Unit*, "least hp target");
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return leastHp && target != leastHp;
+}
+
+bool EnemyPlayerIsAttacking::IsActive()
+{
+    Unit* enemyPlayer = AI_VALUE(Unit*, "enemy player target");
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return enemyPlayer && target != enemyPlayer;
+}
+
+bool IsSwimmingTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "swimming", "self target");
+}
+
+bool HasNearestAddsTrigger::IsActive()
+{
+    list<ObjectGuid> targets = AI_VALUE(list<ObjectGuid>, "nearest adds");
+    return targets.size();
+}
+
+bool HasItemForSpellTrigger::IsActive()
+{
+	string spell = getName();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    return spellId && AI_VALUE2(Item*, "item for spell", spellId);
+}
+
+
+bool TargetChangedTrigger::IsActive()
+{
+    Unit* oldTarget = context->GetValue<Unit*>("old target")->Get();
+    Unit* target = context->GetValue<Unit*>("current target")->Get();
+    return target && oldTarget != target;
+}
+
+Value<Unit*>* InterruptEnemyHealerTrigger::GetTargetValue()
+{
+    return context->GetValue<Unit*>("enemy healer target", spell);
+}
diff --git a/src/plugins/playerbot/strategy/triggers/GenericTriggers.h b/src/plugins/playerbot/strategy/triggers/GenericTriggers.h
new file mode 100644
index 0000000..f176429
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/GenericTriggers.h
@@ -0,0 +1,540 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+#define BUFF_TRIGGER(clazz, spell, action) \
+    class clazz : public BuffTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : BuffTrigger(ai, spell) {} \
+    };
+
+#define BUFF_ON_PARTY_TRIGGER(clazz, spell, action) \
+    class clazz : public BuffOnPartyTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, spell) {}  \
+    };
+
+#define DEBUFF_TRIGGER(clazz, spell, action) \
+    class clazz : public DebuffTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : DebuffTrigger(ai, spell) {} \
+    };
+
+namespace ai
+{
+	class StatAvailable : public Trigger
+	{
+	public:
+		StatAvailable(PlayerbotAI* ai, int amount, string name = "stat available") : Trigger(ai, name)
+		{
+			this->amount = amount;
+		}
+
+	protected:
+		int amount;
+	};
+
+	class RageAvailable : public StatAvailable
+    {
+    public:
+        RageAvailable(PlayerbotAI* ai, int amount) : StatAvailable(ai, amount, "rage available") {}
+        virtual bool IsActive();
+    };
+
+    class LightRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        LightRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 20) {}
+    };
+
+    class MediumRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        MediumRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 40) {}
+    };
+
+    class HighRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        HighRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 60) {}
+    };
+
+	class EnergyAvailable : public StatAvailable
+	{
+	public:
+		EnergyAvailable(PlayerbotAI* ai, int amount) : StatAvailable(ai, amount, "energy available") {}
+		virtual bool IsActive();
+	};
+
+    class LightEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        LightEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 20) {}
+    };
+
+    class MediumEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        MediumEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 40) {}
+    };
+
+    class HighEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        HighEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 60) {}
+    };
+
+	class ComboPointsAvailableTrigger : public StatAvailable
+	{
+	public:
+	    ComboPointsAvailableTrigger(PlayerbotAI* ai, int amount = 5) : StatAvailable(ai, amount, "combo points available") {}
+		virtual bool IsActive();
+	};
+
+	class LoseAggroTrigger : public Trigger {
+	public:
+		LoseAggroTrigger(PlayerbotAI* ai) : Trigger(ai, "lose aggro") {}
+		virtual bool IsActive();
+	};
+
+	class HasAggroTrigger : public Trigger {
+	public:
+	    HasAggroTrigger(PlayerbotAI* ai) : Trigger(ai, "have aggro") {}
+		virtual bool IsActive();
+	};
+
+	class SpellTrigger : public Trigger
+	{
+	public:
+		SpellTrigger(PlayerbotAI* ai, string spell, int checkInterval = 1) : Trigger(ai, spell, checkInterval)
+		{
+			this->spell = spell;
+		}
+
+		virtual string GetTargetName() { return "current target"; }
+		virtual string getName() { return spell; }
+		virtual bool IsActive();
+
+	protected:
+		string spell;
+	};
+
+	class SpellCanBeCastTrigger : public SpellTrigger
+	{
+	public:
+		SpellCanBeCastTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+		virtual bool IsActive();
+	};
+
+	// TODO: check other targets
+    class InterruptSpellTrigger : public SpellTrigger
+	{
+    public:
+        InterruptSpellTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+        virtual bool IsActive();
+    };
+
+
+    class AttackerCountTrigger : public Trigger
+    {
+    public:
+        AttackerCountTrigger(PlayerbotAI* ai, int amount, float distance = sPlayerbotAIConfig.sightDistance) : Trigger(ai)
+        {
+            this->amount = amount;
+            this->distance = distance;
+        }
+    public:
+        virtual bool IsActive()
+		{
+            return AI_VALUE(uint8, "attacker count") >= amount;
+        }
+        virtual string getName() { return "attacker count"; }
+
+    protected:
+        int amount;
+        float distance;
+    };
+
+    class HasAttackersTrigger : public AttackerCountTrigger
+    {
+    public:
+        HasAttackersTrigger(PlayerbotAI* ai) : AttackerCountTrigger(ai, 1) {}
+    };
+
+    class MyAttackerCountTrigger : public AttackerCountTrigger
+    {
+    public:
+        MyAttackerCountTrigger(PlayerbotAI* ai, int amount) : AttackerCountTrigger(ai, amount) {}
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "my attacker count"; }
+    };
+
+    class MediumThreatTrigger : public MyAttackerCountTrigger
+    {
+    public:
+        MediumThreatTrigger(PlayerbotAI* ai) : MyAttackerCountTrigger(ai, 2) {}
+    };
+
+    class AoeTrigger : public AttackerCountTrigger
+    {
+    public:
+        AoeTrigger(PlayerbotAI* ai, int amount = 3, float range = 15.0f) : AttackerCountTrigger(ai, amount)
+        {
+            this->range = range;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "aoe"; }
+
+    private:
+        float range;
+    };
+
+    class NoFoodTrigger : public Trigger {
+    public:
+        NoFoodTrigger(PlayerbotAI* ai) : Trigger(ai, "no food trigger") {}
+        virtual bool IsActive() { return AI_VALUE2(list<Item*>, "inventory items", "food").empty(); }
+    };
+
+    class NoDrinkTrigger : public Trigger {
+    public:
+        NoDrinkTrigger(PlayerbotAI* ai) : Trigger(ai, "no drink trigger") {}
+        virtual bool IsActive() { return AI_VALUE2(list<Item*>, "inventory items", "drink").empty(); }
+    };
+
+    class LightAoeTrigger : public AoeTrigger
+    {
+    public:
+        LightAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 2, 15.0f) {}
+    };
+
+    class MediumAoeTrigger : public AoeTrigger
+    {
+    public:
+        MediumAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 3, 17.0f) {}
+    };
+
+    class HighAoeTrigger : public AoeTrigger
+    {
+    public:
+        HighAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 4, 20.0f) {}
+    };
+
+    class BuffTrigger : public SpellTrigger
+    {
+    public:
+        BuffTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell, 5) {}
+    public:
+		virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+    };
+
+    class BuffOnPartyTrigger : public BuffTrigger
+    {
+    public:
+        BuffOnPartyTrigger(PlayerbotAI* ai, string spell) : BuffTrigger(ai, spell) {}
+    public:
+		virtual Value<Unit*>* GetTargetValue();
+    };
+
+    BEGIN_TRIGGER(NoAttackersTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(NoTargetTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(InvalidTargetTrigger, Trigger)
+    END_TRIGGER()
+
+    class TargetInSightTrigger : public Trigger {
+    public:
+        TargetInSightTrigger(PlayerbotAI* ai) : Trigger(ai, "target in sight") {}
+        virtual bool IsActive() { return AI_VALUE(Unit*, "grind target"); }
+    };
+
+    class DebuffTrigger : public BuffTrigger
+    {
+    public:
+        DebuffTrigger(PlayerbotAI* ai, string spell) : BuffTrigger(ai, spell) {
+			checkInterval = 1;
+		}
+    public:
+		virtual string GetTargetName() { return "current target"; }
+        virtual bool IsActive();
+    };
+
+    class DebuffOnAttackerTrigger : public DebuffTrigger
+    {
+    public:
+        DebuffOnAttackerTrigger(PlayerbotAI* ai, string spell) : DebuffTrigger(ai, spell) {}
+    public:
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string getName() { return spell + " on attacker"; }
+    };
+
+	class BoostTrigger : public BuffTrigger
+	{
+	public:
+		BoostTrigger(PlayerbotAI* ai, string spell, float balance = 50) : BuffTrigger(ai, spell)
+		{
+			this->balance = balance;
+		}
+	public:
+		virtual bool IsActive();
+
+	protected:
+		float balance;
+	};
+
+    class RandomTrigger : public Trigger
+    {
+    public:
+        RandomTrigger(PlayerbotAI* ai, int probability = 200) : Trigger(ai)
+        {
+            this->probability = probability;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "random"; }
+
+    protected:
+        int probability;
+    };
+
+    class SeldomTrigger : public RandomTrigger
+    {
+    public:
+        SeldomTrigger(PlayerbotAI* ai) : RandomTrigger(ai, 9000) {}
+        virtual string getName() { return "seldom"; }
+    };
+
+    class OftenTrigger : public RandomTrigger
+    {
+    public:
+        OftenTrigger(PlayerbotAI* ai) : RandomTrigger(ai, 50) {}
+        virtual string getName() { return "often"; }
+    };
+
+    class AndTrigger : public Trigger
+    {
+    public:
+        AndTrigger(PlayerbotAI* ai, Trigger* ls, Trigger* rs) : Trigger(ai)
+        {
+            this->ls = ls;
+            this->rs = rs;
+        }
+        virtual ~AndTrigger()
+        {
+            delete ls;
+            delete rs;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName();
+
+    protected:
+        Trigger* ls;
+        Trigger* rs;
+    };
+
+    class SnareTargetTrigger : public DebuffTrigger
+    {
+    public:
+        SnareTargetTrigger(PlayerbotAI* ai, string aura) : DebuffTrigger(ai, aura) {}
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "target is moving"; }
+    };
+
+	class LowManaTrigger : public Trigger
+	{
+	public:
+		LowManaTrigger(PlayerbotAI* ai) : Trigger(ai, "low mana") {}
+
+		virtual bool IsActive();
+	};
+
+	class MediumManaTrigger : public Trigger
+	{
+	public:
+		MediumManaTrigger(PlayerbotAI* ai) : Trigger(ai, "medium mana") {}
+
+		virtual bool IsActive();
+	};
+
+    BEGIN_TRIGGER(PanicTrigger, Trigger)
+        virtual string getName() { return "panic"; }
+    END_TRIGGER()
+
+
+	class NoPetTrigger : public Trigger
+	{
+	public:
+		NoPetTrigger(PlayerbotAI* ai) : Trigger(ai, "no pet", 5) {}
+
+		virtual bool IsActive() {
+			return !AI_VALUE(Unit*, "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+		}
+	};
+
+	class ItemCountTrigger : public Trigger {
+	public:
+		ItemCountTrigger(PlayerbotAI* ai, string item, int count) : Trigger(ai, item, 5) {
+			this->item = item;
+			this->count = count;
+		}
+	public:
+		virtual bool IsActive();
+		virtual string getName() { return "item count"; }
+
+	protected:
+		string item;
+		int count;
+	};
+
+	class HasAuraTrigger : public Trigger {
+	public:
+		HasAuraTrigger(PlayerbotAI* ai, string spell) : Trigger(ai, spell, 5) {}
+
+		virtual string GetTargetName() { return "self target"; }
+		virtual bool IsActive();
+
+	};
+
+    class TimerTrigger : public Trigger
+    {
+    public:
+        TimerTrigger(PlayerbotAI* ai, int checkInterval = 5) : Trigger(ai, "timer", checkInterval) {}
+
+    public:
+        virtual bool IsActive() { return true; }
+    };
+
+	class TankAoeTrigger : public NoAttackersTrigger
+	{
+	public:
+		TankAoeTrigger(PlayerbotAI* ai) : NoAttackersTrigger(ai) {}
+
+	public:
+		virtual bool IsActive();
+
+	};
+
+    class IsBehindTargetTrigger : public Trigger
+    {
+    public:
+        IsBehindTargetTrigger(PlayerbotAI* ai) : Trigger(ai) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class IsNotFacingTargetTrigger : public Trigger
+    {
+    public:
+        IsNotFacingTargetTrigger(PlayerbotAI* ai) : Trigger(ai) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasCcTargetTrigger : public Trigger
+    {
+    public:
+        HasCcTargetTrigger(PlayerbotAI* ai, string name) : Trigger(ai, name) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+	class NoMovementTrigger : public Trigger
+	{
+	public:
+		NoMovementTrigger(PlayerbotAI* ai, string name) : Trigger(ai, name) {}
+
+	public:
+		virtual bool IsActive();
+	};
+
+
+    class NoPossibleTargetsTrigger : public Trigger
+    {
+    public:
+        NoPossibleTargetsTrigger(PlayerbotAI* ai) : Trigger(ai, "no possible targets") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class NotLeastHpTargetActiveTrigger : public Trigger
+    {
+    public:
+        NotLeastHpTargetActiveTrigger(PlayerbotAI* ai) : Trigger(ai, "not least hp target active") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class EnemyPlayerIsAttacking : public Trigger
+    {
+    public:
+        EnemyPlayerIsAttacking(PlayerbotAI* ai) : Trigger(ai, "enemy player is attacking") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class IsSwimmingTrigger : public Trigger
+    {
+    public:
+        IsSwimmingTrigger(PlayerbotAI* ai) : Trigger(ai, "swimming") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasNearestAddsTrigger : public Trigger
+    {
+    public:
+        HasNearestAddsTrigger(PlayerbotAI* ai) : Trigger(ai, "has nearest adds") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasItemForSpellTrigger : public Trigger
+    {
+    public:
+        HasItemForSpellTrigger(PlayerbotAI* ai, string spell) : Trigger(ai, spell) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class TargetChangedTrigger : public Trigger
+    {
+    public:
+        TargetChangedTrigger(PlayerbotAI* ai) : Trigger(ai, "target changed") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class InterruptEnemyHealerTrigger : public SpellTrigger
+    {
+    public:
+        InterruptEnemyHealerTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+    public:
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string getName() { return spell + " on enemy healer"; }
+    };
+
+}
+
+#include "RangeTriggers.h"
+#include "HealthTriggers.h"
+#include "CureTriggers.h"
diff --git a/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp b/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
new file mode 100644
index 0000000..703f00c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HealthTriggers.h"
+
+using namespace ai;
+
+float HealthInRangeTrigger::GetValue()
+{
+    return AI_VALUE2(uint8, "health", GetTargetName());
+}
+
+bool PartyMemberDeadTrigger::IsActive()
+{
+	return GetTarget();
+}
+
+bool DeadTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "dead", GetTargetName());
+}
+
+bool AoeHealTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "aoe heal", type) >= count;
+}
+
diff --git a/src/plugins/playerbot/strategy/triggers/HealthTriggers.h b/src/plugins/playerbot/strategy/triggers/HealthTriggers.h
new file mode 100644
index 0000000..49dc17b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/HealthTriggers.h
@@ -0,0 +1,139 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class ValueInRangeTrigger : public Trigger
+    {
+    public:
+        ValueInRangeTrigger(PlayerbotAI* ai, string name, float maxValue, float minValue) : Trigger(ai, name) {
+            this->maxValue = maxValue;
+            this->minValue = minValue;
+        }
+    public:
+        virtual float GetValue() = 0;
+        virtual bool IsActive() {
+            float value = GetValue();
+            return value < maxValue && value >= minValue;
+        }
+
+    protected:
+        float maxValue, minValue;
+    };
+
+	class HealthInRangeTrigger : public ValueInRangeTrigger
+	{
+	public:
+		HealthInRangeTrigger(PlayerbotAI* ai, string name, float maxValue, float minValue = 0) :
+		  ValueInRangeTrigger(ai, name, maxValue, minValue) {}
+
+		virtual bool IsActive()
+		{
+		    return ValueInRangeTrigger::IsActive() && !AI_VALUE2(bool, "dead", GetTargetName());
+		}
+
+		virtual float GetValue();
+	};
+
+    class LowHealthTrigger : public HealthInRangeTrigger
+    {
+    public:
+        LowHealthTrigger(PlayerbotAI* ai, string name = "low health",
+            float value = sPlayerbotAIConfig.lowHealth, float minValue = sPlayerbotAIConfig.criticalHealth) :
+            HealthInRangeTrigger(ai, name, value, minValue) {}
+
+		virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CriticalHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        CriticalHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "critical health", sPlayerbotAIConfig.criticalHealth, 0) {}
+    };
+
+    class MediumHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        MediumHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "medium health", sPlayerbotAIConfig.mediumHealth, sPlayerbotAIConfig.lowHealth) {}
+    };
+
+    class AlmostFullHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        AlmostFullHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "almost full health", sPlayerbotAIConfig.almostFullHealth, sPlayerbotAIConfig.mediumHealth) {}
+    };
+
+    class PartyMemberLowHealthTrigger : public HealthInRangeTrigger
+    {
+    public:
+        PartyMemberLowHealthTrigger(PlayerbotAI* ai, string name = "party member low health", float value = sPlayerbotAIConfig.lowHealth, float minValue = sPlayerbotAIConfig.criticalHealth) :
+            HealthInRangeTrigger(ai, name, value, minValue) {}
+
+        virtual string GetTargetName() { return "party member to heal"; }
+    };
+
+    class PartyMemberCriticalHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberCriticalHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member critical health", sPlayerbotAIConfig.criticalHealth, 0) {}
+    };
+
+    class PartyMemberMediumHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberMediumHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member medium health", sPlayerbotAIConfig.mediumHealth,sPlayerbotAIConfig.lowHealth) {}
+    };
+
+    class PartyMemberAlmostFullHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberAlmostFullHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member almost full health", sPlayerbotAIConfig.almostFullHealth,sPlayerbotAIConfig.mediumHealth) {}
+    };
+
+    class TargetLowHealthTrigger : public HealthInRangeTrigger {
+    public:
+        TargetLowHealthTrigger(PlayerbotAI* ai, float value, float minValue = 0) :
+            HealthInRangeTrigger(ai, "target low health", value, minValue) {}
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+    class TargetCriticalHealthTrigger : public TargetLowHealthTrigger
+    {
+    public:
+        TargetCriticalHealthTrigger(PlayerbotAI* ai) : TargetLowHealthTrigger(ai, 20) {}
+    };
+
+	class PartyMemberDeadTrigger : public Trigger {
+	public:
+		PartyMemberDeadTrigger(PlayerbotAI* ai) : Trigger(ai, "resurrect", 10) {}
+        virtual string GetTargetName() { return "party member to resurrect"; }
+		virtual bool IsActive();
+	};
+
+    class DeadTrigger : public Trigger {
+    public:
+        DeadTrigger(PlayerbotAI* ai) : Trigger(ai, "dead", 10) {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+    };
+
+    class AoeHealTrigger : public Trigger {
+    public:
+    	AoeHealTrigger(PlayerbotAI* ai, string name, string type, int count) :
+    		Trigger(ai, name), type(type), count(count) {}
+    public:
+        virtual bool IsActive();
+
+    protected:
+        int count;
+        string type;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LfgTriggers.h b/src/plugins/playerbot/strategy/triggers/LfgTriggers.h
new file mode 100644
index 0000000..ec8133e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LfgTriggers.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+class LfgProposalActiveTrigger : public Trigger
+{
+public:
+    LfgProposalActiveTrigger(PlayerbotAI* ai) : Trigger(ai, "lfg proposal active", 5) {}
+
+    virtual bool IsActive()
+    {
+        return AI_VALUE(uint32, "lfg proposal");
+    }
+};
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp b/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
new file mode 100644
index 0000000..cac9b60
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
@@ -0,0 +1,20 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootTriggers.h"
+
+using namespace ai;
+
+bool LootAvailableTrigger::IsActive()
+{
+    return AI_VALUE(bool, "has available loot") && AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool FarFromCurrentLootTrigger::IsActive()
+{
+    return AI_VALUE2(float, "distance", "loot target") > INTERACTION_DISTANCE;
+}
+
+bool CanLootTrigger::IsActive()
+{
+    return AI_VALUE(bool, "can loot");
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LootTriggers.h b/src/plugins/playerbot/strategy/triggers/LootTriggers.h
new file mode 100644
index 0000000..063456b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LootTriggers.h
@@ -0,0 +1,30 @@
+#pragma once
+#include "../Trigger.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class LootAvailableTrigger : public Trigger
+    {
+    public:
+        LootAvailableTrigger(PlayerbotAI* ai) : Trigger(ai, "loot available") {}
+
+        virtual bool IsActive();
+    };
+
+    class FarFromCurrentLootTrigger : public Trigger
+    {
+    public:
+        FarFromCurrentLootTrigger(PlayerbotAI* ai) : Trigger(ai, "far from current loot") {}
+
+        virtual bool IsActive();
+    };
+
+    class CanLootTrigger : public Trigger
+    {
+    public:
+        CanLootTrigger(PlayerbotAI* ai) : Trigger(ai, "can loot") {}
+
+        virtual bool IsActive();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/RangeTriggers.h b/src/plugins/playerbot/strategy/triggers/RangeTriggers.h
new file mode 100644
index 0000000..0a948f5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/RangeTriggers.h
@@ -0,0 +1,81 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class EnemyTooCloseForSpellTrigger : public Trigger {
+    public:
+        EnemyTooCloseForSpellTrigger(PlayerbotAI* ai) : Trigger(ai, "enemy too close for spell") {}
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, "current target");
+            return target && AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.spellDistance / 2;
+        }
+    };
+
+    class EnemyTooCloseForMeleeTrigger : public Trigger {
+    public:
+        EnemyTooCloseForMeleeTrigger(PlayerbotAI* ai) : Trigger(ai, "enemy too close for melee", 5) {}
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, "current target");
+            return target && AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.contactDistance / 2;
+        }
+    };
+
+    class OutOfRangeTrigger : public Trigger {
+    public:
+        OutOfRangeTrigger(PlayerbotAI* ai, string name, float distance) : Trigger(ai, name)
+		{
+            this->distance = distance;
+        }
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, GetTargetName());
+			return target && AI_VALUE2(float, "distance", GetTargetName()) > distance;
+        }
+        virtual string GetTargetName() { return "current target"; }
+
+    protected:
+        float distance;
+    };
+
+    class EnemyOutOfMeleeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        EnemyOutOfMeleeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "enemy out of melee range", sPlayerbotAIConfig.meleeDistance) {}
+    };
+
+    class EnemyOutOfSpellRangeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        EnemyOutOfSpellRangeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "enemy out of spell range", sPlayerbotAIConfig.spellDistance) {}
+    };
+
+    class PartyMemberToHealOutOfSpellRangeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        PartyMemberToHealOutOfSpellRangeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "party member to heal out of spell range", sPlayerbotAIConfig.spellDistance) {}
+        virtual string GetTargetName() { return "party member to heal"; }
+    };
+
+    class FarFromMasterTrigger : public Trigger {
+    public:
+        FarFromMasterTrigger(PlayerbotAI* ai, string name = "far from master", float distance = 12.0f, int checkInterval = 1) : Trigger(ai, name, checkInterval), distance(distance) {}
+
+        virtual bool IsActive()
+        {
+            return AI_VALUE2(float, "distance", "master target") > distance;
+        }
+
+    private:
+        float distance;
+    };
+
+    class OutOfReactRangeTrigger : public FarFromMasterTrigger
+    {
+    public:
+        OutOfReactRangeTrigger(PlayerbotAI* ai) : FarFromMasterTrigger(ai, "out of react range", sPlayerbotAIConfig.reactDistance / 2, 10) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/TriggerContext.h b/src/plugins/playerbot/strategy/triggers/TriggerContext.h
new file mode 100644
index 0000000..9906cae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/TriggerContext.h
@@ -0,0 +1,158 @@
+#pragma once
+
+#include "HealthTriggers.h"
+#include "GenericTriggers.h"
+#include "LootTriggers.h"
+#include "../triggers/GenericTriggers.h"
+#include "LfgTriggers.h"
+
+namespace ai
+{
+
+    class TriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        TriggerContext()
+        {
+            creators["timer"] = &TriggerContext::Timer;
+            creators["random"] = &TriggerContext::Random;
+            creators["seldom"] = &TriggerContext::seldom;
+            creators["often"] = &TriggerContext::often;
+
+            creators["target critical health"] = &TriggerContext::TargetCriticalHealth;
+
+            creators["critical health"] = &TriggerContext::CriticalHealth;
+            creators["low health"] = &TriggerContext::LowHealth;
+            creators["medium health"] = &TriggerContext::MediumHealth;
+            creators["almost full health"] = &TriggerContext::AlmostFullHealth;
+
+            creators["low mana"] = &TriggerContext::LowMana;
+            creators["medium mana"] = &TriggerContext::MediumMana;
+
+            creators["party member critical health"] = &TriggerContext::PartyMemberCriticalHealth;
+            creators["party member low health"] = &TriggerContext::PartyMemberLowHealth;
+            creators["party member medium health"] = &TriggerContext::PartyMemberMediumHealth;
+            creators["party member almost full health"] = &TriggerContext::PartyMemberAlmostFullHealth;
+
+            creators["light rage available"] = &TriggerContext::LightRageAvailable;
+            creators["medium rage available"] = &TriggerContext::MediumRageAvailable;
+            creators["high rage available"] = &TriggerContext::HighRageAvailable;
+
+            creators["light energy available"] = &TriggerContext::LightEnergyAvailable;
+            creators["medium energy available"] = &TriggerContext::MediumEnergyAvailable;
+            creators["high energy available"] = &TriggerContext::HighEnergyAvailable;
+
+            creators["loot available"] = &TriggerContext::LootAvailable;
+            creators["no attackers"] = &TriggerContext::NoAttackers;
+            creators["no target"] = &TriggerContext::NoTarget;
+            creators["target in sight"] = &TriggerContext::TargetInSight;
+            creators["not least hp target active"] = &TriggerContext::not_least_hp_target_active;
+            creators["has nearest adds"] = &TriggerContext::has_nearest_adds;
+            creators["enemy player is attacking"] = &TriggerContext::enemy_player_is_attacking;
+
+            creators["tank aoe"] = &TriggerContext::TankAoe;
+            creators["lose aggro"] = &TriggerContext::LoseAggro;
+            creators["has aggro"] = &TriggerContext::HasAggro;
+
+            creators["light aoe"] = &TriggerContext::LightAoe;
+            creators["medium aoe"] = &TriggerContext::MediumAoe;
+            creators["high aoe"] = &TriggerContext::HighAoe;
+
+            creators["enemy out of melee"] = &TriggerContext::EnemyOutOfMelee;
+            creators["enemy out of spell"] = &TriggerContext::EnemyOutOfSpell;
+            creators["enemy too close for spell"] = &TriggerContext::enemy_too_close_for_spell;
+            creators["enemy too close for melee"] = &TriggerContext::enemy_too_close_for_melee;
+
+            creators["combo points available"] = &TriggerContext::ComboPointsAvailable;
+
+            creators["medium threat"] = &TriggerContext::MediumThreat;
+
+            creators["dead"] = &TriggerContext::Dead;
+            creators["party member dead"] = &TriggerContext::PartyMemberDead;
+            creators["no pet"] = &TriggerContext::no_pet;
+            creators["has attackers"] = &TriggerContext::has_attackers;
+            creators["no possible targets"] = &TriggerContext::no_possible_targets;
+
+            creators["no drink"] = &TriggerContext::no_drink;
+            creators["no food"] = &TriggerContext::no_food;
+
+            creators["panic"] = &TriggerContext::panic;
+            creators["behind target"] = &TriggerContext::behind_target;
+            creators["not facing target"] = &TriggerContext::not_facing_target;
+            creators["far from master"] = &TriggerContext::far_from_master;
+            creators["far from loot target"] = &TriggerContext::far_from_loot_target;
+            creators["can loot"] = &TriggerContext::can_loot;
+            creators["swimming"] = &TriggerContext::swimming;
+            creators["target changed"] = &TriggerContext::target_changed;
+
+            creators["critical aoe heal"] = &TriggerContext::critical_aoe_heal;
+            creators["low aoe heal"] = &TriggerContext::low_aoe_heal;
+            creators["medium aoe heal"] = &TriggerContext::medium_aoe_heal;
+            creators["invalid target"] = &TriggerContext::invalid_target;
+            creators["lfg proposal active"] = &TriggerContext::lfg_proposal_active;
+        }
+
+    private:
+        static Trigger* lfg_proposal_active(PlayerbotAI* ai) { return new LfgProposalActiveTrigger(ai); }
+        static Trigger* invalid_target(PlayerbotAI* ai) { return new InvalidTargetTrigger(ai); }
+        static Trigger* critical_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "critical aoe heal", "critical", 2); }
+        static Trigger* low_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "low aoe heal", "low", 2); }
+        static Trigger* medium_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "medium aoe heal", "medium", 2); }
+        static Trigger* target_changed(PlayerbotAI* ai) { return new TargetChangedTrigger(ai); }
+        static Trigger* swimming(PlayerbotAI* ai) { return new IsSwimmingTrigger(ai); }
+        static Trigger* no_possible_targets(PlayerbotAI* ai) { return new NoPossibleTargetsTrigger(ai); }
+        static Trigger* can_loot(PlayerbotAI* ai) { return new CanLootTrigger(ai); }
+        static Trigger* far_from_loot_target(PlayerbotAI* ai) { return new FarFromCurrentLootTrigger(ai); }
+        static Trigger* far_from_master(PlayerbotAI* ai) { return new FarFromMasterTrigger(ai); }
+        static Trigger* behind_target(PlayerbotAI* ai) { return new IsBehindTargetTrigger(ai); }
+        static Trigger* not_facing_target(PlayerbotAI* ai) { return new IsNotFacingTargetTrigger(ai); }
+        static Trigger* panic(PlayerbotAI* ai) { return new PanicTrigger(ai); }
+        static Trigger* no_drink(PlayerbotAI* ai) { return new NoDrinkTrigger(ai); }
+        static Trigger* no_food(PlayerbotAI* ai) { return new NoFoodTrigger(ai); }
+        static Trigger* LightAoe(PlayerbotAI* ai) { return new LightAoeTrigger(ai); }
+        static Trigger* MediumAoe(PlayerbotAI* ai) { return new MediumAoeTrigger(ai); }
+        static Trigger* HighAoe(PlayerbotAI* ai) { return new HighAoeTrigger(ai); }
+        static Trigger* LoseAggro(PlayerbotAI* ai) { return new LoseAggroTrigger(ai); }
+        static Trigger* HasAggro(PlayerbotAI* ai) { return new HasAggroTrigger(ai); }
+        static Trigger* LowHealth(PlayerbotAI* ai) { return new LowHealthTrigger(ai); }
+        static Trigger* MediumHealth(PlayerbotAI* ai) { return new MediumHealthTrigger(ai); }
+        static Trigger* AlmostFullHealth(PlayerbotAI* ai) { return new AlmostFullHealthTrigger(ai); }
+        static Trigger* CriticalHealth(PlayerbotAI* ai) { return new CriticalHealthTrigger(ai); }
+        static Trigger* TargetCriticalHealth(PlayerbotAI* ai) { return new TargetCriticalHealthTrigger(ai); }
+        static Trigger* LowMana(PlayerbotAI* ai) { return new LowManaTrigger(ai); }
+        static Trigger* MediumMana(PlayerbotAI* ai) { return new MediumManaTrigger(ai); }
+        static Trigger* LightRageAvailable(PlayerbotAI* ai) { return new LightRageAvailableTrigger(ai); }
+        static Trigger* MediumRageAvailable(PlayerbotAI* ai) { return new MediumRageAvailableTrigger(ai); }
+        static Trigger* HighRageAvailable(PlayerbotAI* ai) { return new HighRageAvailableTrigger(ai); }
+        static Trigger* LightEnergyAvailable(PlayerbotAI* ai) { return new LightEnergyAvailableTrigger(ai); }
+        static Trigger* MediumEnergyAvailable(PlayerbotAI* ai) { return new MediumEnergyAvailableTrigger(ai); }
+        static Trigger* HighEnergyAvailable(PlayerbotAI* ai) { return new HighEnergyAvailableTrigger(ai); }
+        static Trigger* LootAvailable(PlayerbotAI* ai) { return new LootAvailableTrigger(ai); }
+        static Trigger* NoAttackers(PlayerbotAI* ai) { return new NoAttackersTrigger(ai); }
+        static Trigger* TankAoe(PlayerbotAI* ai) { return new TankAoeTrigger(ai); }
+        static Trigger* Timer(PlayerbotAI* ai) { return new TimerTrigger(ai); }
+        static Trigger* NoTarget(PlayerbotAI* ai) { return new NoTargetTrigger(ai); }
+        static Trigger* TargetInSight(PlayerbotAI* ai) { return new TargetInSightTrigger(ai); }
+        static Trigger* not_least_hp_target_active(PlayerbotAI* ai) { return new NotLeastHpTargetActiveTrigger(ai); }
+        static Trigger* has_nearest_adds(PlayerbotAI* ai) { return new HasNearestAddsTrigger(ai); }
+        static Trigger* enemy_player_is_attacking(PlayerbotAI* ai) { return new EnemyPlayerIsAttacking(ai); }
+        static Trigger* Random(PlayerbotAI* ai) { return new RandomTrigger(ai); }
+        static Trigger* seldom(PlayerbotAI* ai) { return new SeldomTrigger(ai); }
+        static Trigger* often(PlayerbotAI* ai) { return new OftenTrigger(ai); }
+        static Trigger* EnemyOutOfMelee(PlayerbotAI* ai) { return new EnemyOutOfMeleeTrigger(ai); }
+        static Trigger* EnemyOutOfSpell(PlayerbotAI* ai) { return new EnemyOutOfSpellRangeTrigger(ai); }
+        static Trigger* enemy_too_close_for_spell(PlayerbotAI* ai) { return new EnemyTooCloseForSpellTrigger(ai); }
+        static Trigger* enemy_too_close_for_melee(PlayerbotAI* ai) { return new EnemyTooCloseForMeleeTrigger(ai); }
+        static Trigger* ComboPointsAvailable(PlayerbotAI* ai) { return new ComboPointsAvailableTrigger(ai); }
+        static Trigger* MediumThreat(PlayerbotAI* ai) { return new MediumThreatTrigger(ai); }
+        static Trigger* Dead(PlayerbotAI* ai) { return new DeadTrigger(ai); }
+        static Trigger* PartyMemberDead(PlayerbotAI* ai) { return new PartyMemberDeadTrigger(ai); }
+        static Trigger* PartyMemberLowHealth(PlayerbotAI* ai) { return new PartyMemberLowHealthTrigger(ai); }
+        static Trigger* PartyMemberMediumHealth(PlayerbotAI* ai) { return new PartyMemberMediumHealthTrigger(ai); }
+        static Trigger* PartyMemberAlmostFullHealth(PlayerbotAI* ai) { return new PartyMemberAlmostFullHealthTrigger(ai); }
+        static Trigger* PartyMemberCriticalHealth(PlayerbotAI* ai) { return new PartyMemberCriticalHealthTrigger(ai); }
+        static Trigger* no_pet(PlayerbotAI* ai) { return new NoPetTrigger(ai); }
+        static Trigger* has_attackers(PlayerbotAI* ai) { return new HasAttackersTrigger(ai); }
+
+    };
+};
diff --git a/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h b/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
new file mode 100644
index 0000000..01c130a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
@@ -0,0 +1,76 @@
+#pragma once
+#include "../Trigger.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class WithinAreaTrigger : public Trigger {
+    public:
+        WithinAreaTrigger(PlayerbotAI* ai) : Trigger(ai, "within area trigger") {}
+
+        virtual bool IsActive()
+		{
+
+
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            if (!movement.lastAreaTrigger)
+                return false;
+
+            AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(movement.lastAreaTrigger);
+            if(!atEntry)
+                return false;
+
+            AreaTrigger const* at = sObjectMgr->GetAreaTrigger(movement.lastAreaTrigger);
+            if (!at)
+                return false;
+
+            return IsPointInAreaTriggerZone(atEntry, bot->GetMapId(), bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), 0.5f);
+        }
+
+    private:
+        bool IsPointInAreaTriggerZone(AreaTriggerEntry const* atEntry, uint32 mapid, float x, float y, float z, float delta)
+        {
+            if (mapid != atEntry->mapid)
+                return false;
+
+            if (atEntry->radius > 0)
+            {
+                // if we have radius check it
+                float dist2 = (x - atEntry->x) * (x - atEntry->x) + (y - atEntry->y) * (y - atEntry->y) + (z - atEntry->z) * (z - atEntry->z);
+                if (dist2 > (atEntry->radius + delta) * (atEntry->radius + delta))
+                    return false;
+            }
+            else
+            {
+                // we have only extent
+
+                // rotate the players position instead of rotating the whole cube, that way we can make a simplified
+                // is-in-cube check and we have to calculate only one point instead of 4
+
+                // 2PI = 360, keep in mind that ingame orientation is counter-clockwise
+                double rotation = 2 * M_PI - atEntry->box_orientation;
+                double sinVal = sin(rotation);
+                double cosVal = cos(rotation);
+
+                float playerBoxDistX = x - atEntry->x;
+                float playerBoxDistY = y - atEntry->y;
+
+                float rotPlayerX = float(atEntry->x + playerBoxDistX * cosVal - playerBoxDistY * sinVal);
+                float rotPlayerY = float(atEntry->y + playerBoxDistY * cosVal + playerBoxDistX * sinVal);
+
+                // box edges are parallel to coordiante axis, so we can treat every dimension independently :D
+                float dz = z - atEntry->z;
+                float dx = rotPlayerX - atEntry->x;
+                float dy = rotPlayerY - atEntry->y;
+                if ((fabs(dx) > atEntry->box_x / 2 + delta) ||
+                        (fabs(dy) > atEntry->box_y / 2 + delta) ||
+                        (fabs(dz) > atEntry->box_z / 2 + delta))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h b/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
new file mode 100644
index 0000000..b0f8b87
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+    class WorldPacketTrigger : public Trigger {
+    public:
+        WorldPacketTrigger(PlayerbotAI* ai, string command) : Trigger(ai, command), triggered(false) {}
+
+        virtual void ExternalEvent(WorldPacket &packet, Player* owner = NULL)
+        {
+            this->packet = packet;
+            this->owner = owner;
+            triggered = true;
+        }
+
+        virtual Event Check()
+        {
+            if (!triggered)
+                return Event();
+
+            return Event(getName(), packet, owner);
+        }
+
+        virtual void Reset()
+        {
+            triggered = false;
+        }
+
+    private:
+        WorldPacket packet;
+        bool triggered;
+        Player* owner;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h b/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
new file mode 100644
index 0000000..e1bda4f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
@@ -0,0 +1,85 @@
+#pragma once
+
+#include "WorldPacketTrigger.h"
+#include "WithinAreaTrigger.h"
+
+namespace ai
+{
+    class WorldPacketTriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        WorldPacketTriggerContext()
+        {
+            creators["gossip hello"] = &WorldPacketTriggerContext::gossip_hello;
+            creators["group invite"] = &WorldPacketTriggerContext::group_invite;
+            creators["group set leader"] = &WorldPacketTriggerContext::group_set_leader;
+            creators["not enough money"] = &WorldPacketTriggerContext::no_money;
+            creators["not enough reputation"] = &WorldPacketTriggerContext::no_reputation;
+            creators["cannot equip"] = &WorldPacketTriggerContext::cannot_equip;
+            creators["use game object"] = &WorldPacketTriggerContext::use_game_object;
+            creators["complete quest"] = &WorldPacketTriggerContext::complete_quest;
+            creators["accept quest"] = &WorldPacketTriggerContext::accept_quest;
+            creators["quest share"] = &WorldPacketTriggerContext::quest_share;
+            creators["loot roll"] = &WorldPacketTriggerContext::loot_roll;
+            creators["resurrect request"] = &WorldPacketTriggerContext::resurrect_request;
+            creators["area trigger"] = &WorldPacketTriggerContext::area_trigger;
+            creators["within area trigger"] = &WorldPacketTriggerContext::within_area_trigger;
+            creators["check mount state"] = &WorldPacketTriggerContext::check_mount_state;
+            creators["activate taxi"] = &WorldPacketTriggerContext::taxi;
+            creators["trade status"] = &WorldPacketTriggerContext::trade_status;
+            creators["loot response"] = &WorldPacketTriggerContext::loot_response;
+            creators["out of react range"] = &WorldPacketTriggerContext::out_of_react_range;
+            creators["quest objective completed"] = &WorldPacketTriggerContext::quest_objective_completed;
+            creators["item push result"] = &WorldPacketTriggerContext::item_push_result;
+            creators["party command"] = &WorldPacketTriggerContext::party_command;
+            creators["taxi done"] = &WorldPacketTriggerContext::taxi_done;
+            creators["cast failed"] = &WorldPacketTriggerContext::cast_failed;
+            creators["duel requested"] = &WorldPacketTriggerContext::duel_requested;
+            creators["ready check"] = &WorldPacketTriggerContext::ready_check;
+            creators["ready check finished"] = &WorldPacketTriggerContext::ready_check_finished;
+            creators["uninvite"] = &WorldPacketTriggerContext::uninvite;
+            creators["lfg join"] = &WorldPacketTriggerContext::lfg_update;
+            creators["lfg proposal"] = &WorldPacketTriggerContext::lfg_proposal;
+            creators["lfg role check"] = &WorldPacketTriggerContext::lfg_role_check;
+            creators["lfg leave"] = &WorldPacketTriggerContext::lfg_leave;
+            creators["guild invite"] = &WorldPacketTriggerContext::guild_invite;
+            creators["lfg teleport"] = &WorldPacketTriggerContext::lfg_teleport;
+        }
+
+    private:
+        static Trigger* guild_invite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "guild invite"); }
+        static Trigger* lfg_teleport(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg teleport"); }
+        static Trigger* lfg_leave(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg leave"); }
+        static Trigger* lfg_proposal(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg proposal"); }
+        static Trigger* lfg_role_check(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg role check"); }
+        static Trigger* lfg_update(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg join"); }
+        static Trigger* uninvite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "uninvite"); }
+        static Trigger* ready_check_finished(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "ready check finished"); }
+        static Trigger* ready_check(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "ready check"); }
+        static Trigger* duel_requested(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "duel requested"); }
+        static Trigger* cast_failed(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "cast failed"); }
+        static Trigger* taxi_done(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "taxi done"); }
+        static Trigger* party_command(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "party command"); }
+        static Trigger* item_push_result(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "item push result"); }
+        static Trigger* quest_objective_completed(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "quest objective completed"); }
+        static Trigger* out_of_react_range(PlayerbotAI* ai) { return new OutOfReactRangeTrigger(ai); }
+        static Trigger* loot_response(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "loot response"); }
+        static Trigger* trade_status(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "trade status"); }
+        static Trigger* cannot_equip(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "cannot equip"); }
+        static Trigger* check_mount_state(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "check mount state"); }
+        static Trigger* area_trigger(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "area trigger"); }
+        static Trigger* within_area_trigger(PlayerbotAI* ai) { return new WithinAreaTrigger(ai); }
+        static Trigger* resurrect_request(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "resurrect request"); }
+        static Trigger* gossip_hello(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "gossip hello"); }
+        static Trigger* group_invite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "group invite"); }
+        static Trigger* group_set_leader(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "group set leader"); }
+        static Trigger* no_money(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "not enough money"); }
+        static Trigger* no_reputation(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "not enough reputation"); }
+        static Trigger* use_game_object(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "use game object"); }
+        static Trigger* complete_quest(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "complete quest"); }
+        static Trigger* accept_quest(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "accept quest"); }
+        static Trigger* quest_share(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "quest share"); }
+        static Trigger* loot_roll(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "loot roll"); }
+        static Trigger* taxi(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "activate taxi"); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h b/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
new file mode 100644
index 0000000..22c2f3a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AlwaysLootListValue : public ManualSetValue<set<uint32>&>
+	{
+	public:
+        AlwaysLootListValue(PlayerbotAI* ai) : ManualSetValue<set<uint32>&>(ai, list) {}
+
+    private:
+        set<uint32> list;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AoeHealValues.cpp b/src/plugins/playerbot/strategy/values/AoeHealValues.cpp
new file mode 100644
index 0000000..14c50b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AoeHealValues.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AoeHealValues.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+uint8 AoeHealValue::Calculate()
+{
+    Group* group = bot->GetGroup();
+    if (!group)
+    	return 0;
+
+    float range = 0;
+    if (qualifier == "low")
+    	range = sPlayerbotAIConfig.lowHealth;
+    else if (qualifier == "medium")
+    	range = sPlayerbotAIConfig.mediumHealth;
+    else if (qualifier == "critical")
+    	range = sPlayerbotAIConfig.criticalHealth;
+
+    uint8 count = 0;
+	Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+	for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+	{
+		Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+		if( !player || !player->IsAlive())
+			continue;
+
+	    float percent = (static_cast<float> (player->GetHealth()) / player->GetMaxHealth()) * 100;
+	    if (percent <= range)
+	    	count++;
+	}
+
+	return count;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/AoeHealValues.h b/src/plugins/playerbot/strategy/values/AoeHealValues.h
new file mode 100644
index 0000000..d7d52c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AoeHealValues.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AoeHealValue : public Uint8CalculatedValue, public Qualified
+	{
+	public:
+    	AoeHealValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+    public:
+    	virtual uint8 Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp b/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
new file mode 100644
index 0000000..a406a90
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
@@ -0,0 +1,107 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackerCountValues.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+uint8 MyAttackerCountValue::Calculate()
+{
+    return bot->getAttackers().size();
+}
+
+bool HasAggroValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return true;
+
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    if (!ref)
+        return true; // simulate as target is not atacking anybody yet
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        if (victim == bot && target == attacker)
+            return true;
+        ref = ref->next();
+    }
+    return false;
+}
+
+uint8 AttackerCountValue::Calculate()
+{
+    int count = 0;
+    float range = sPlayerbotAIConfig.sightDistance;
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        float distance = bot->GetDistance(unit);
+        if (distance <= range)
+            count++;
+    }
+
+    return count;
+}
+
+uint8 BalancePercentValue::Calculate()
+{
+    float playerLevel = 0,
+        attackerLevel = 0;
+
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+            if( !player || !player->IsAlive())
+                continue;
+
+            playerLevel += player->getLevel();
+        }
+    }
+
+    list<ObjectGuid> v = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+
+    for (list<ObjectGuid>::iterator i = v.begin(); i!=v.end(); i++)
+    {
+        Creature* creature = ai->GetCreature((*i));
+        if (!creature || !creature->IsAlive())
+            continue;
+
+        uint32 level = creature->getLevel();
+
+        switch (creature->GetCreatureTemplate()->rank) {
+        case CREATURE_ELITE_RARE:
+            level *= 2;
+            break;
+        case CREATURE_ELITE_ELITE:
+            level *= 3;
+            break;
+        case CREATURE_ELITE_RAREELITE:
+            level *= 3;
+            break;
+        case CREATURE_ELITE_WORLDBOSS:
+            level *= 5;
+            break;
+        }
+        attackerLevel += level;
+    }
+
+    if (!attackerLevel)
+        return 100;
+
+    float percent = playerLevel * 100 / attackerLevel;
+    return percent <= 200 ? (uint8)percent : 200;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/AttackerCountValues.h b/src/plugins/playerbot/strategy/values/AttackerCountValues.h
new file mode 100644
index 0000000..9c77a3f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerCountValues.h
@@ -0,0 +1,59 @@
+#pragma once
+#include "StatsValues.h"
+
+namespace ai
+{
+
+    class AttackerCountValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        AttackerCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class MyAttackerCountValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        MyAttackerCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class HasAggroValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        HasAggroValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class BalancePercentValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        BalancePercentValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
new file mode 100644
index 0000000..10da8d2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackerWithoutAuraTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+Unit* AttackerWithoutAuraTargetValue::Calculate()
+{
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    Unit* target = ai->GetAiObjectContext()->GetValue<Unit*>("current target")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || unit == target)
+            continue;
+
+        if (bot->GetDistance(unit) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (!ai->HasAura(qualifier, unit))
+            return unit;
+    }
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
new file mode 100644
index 0000000..70a8983
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AttackerWithoutAuraTargetValue : public UnitCalculatedValue, public Qualified
+	{
+	public:
+        AttackerWithoutAuraTargetValue(PlayerbotAI* ai) :
+            UnitCalculatedValue(ai, "attacker without aura") {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackersValue.cpp b/src/plugins/playerbot/strategy/values/AttackersValue.cpp
new file mode 100644
index 0000000..e24f99d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackersValue.cpp
@@ -0,0 +1,94 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackersValue.h"
+
+#include "../../../../server/game/Entities/Pet/Pet.h"
+
+using namespace ai;
+
+list<ObjectGuid> AttackersValue::Calculate()
+{
+    set<Unit*> targets;
+
+    AddAttackersOf(bot, targets);
+
+    Group* group = bot->GetGroup();
+    if (group)
+        AddAttackersOf(group, targets);
+
+    RemoveNonThreating(targets);
+
+    list<ObjectGuid> result;
+	for (set<Unit*>::iterator i = targets.begin(); i != targets.end(); i++)
+		result.push_back((*i)->GetGUID());
+
+    if (bot->duel && bot->duel->opponent)
+        result.push_back(bot->duel->opponent->GetGUID());
+
+	return result;
+}
+
+void AttackersValue::AddAttackersOf(Group* group, set<Unit*>& targets)
+{
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if (!member || !member->IsAlive() || member == bot)
+            continue;
+
+        if (member->IsBeingTeleported())
+            return;
+
+        AddAttackersOf(member, targets);
+
+        Pet* pet = member->GetPet();
+        if (pet)
+            AddAttackersOf(pet, targets);
+    }
+}
+
+void AttackersValue::AddAttackersOf(Unit* unit, set<Unit*>& targets)
+{
+    HostileRefManager& refManager = unit->getHostileRefManager();
+    HostileReference *ref = refManager.getFirst();
+    if (!ref)
+        return;
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        if (victim == unit)
+            targets.insert(attacker);
+        ref = ref->next();
+    }
+}
+
+void AttackersValue::RemoveNonThreating(set<Unit*>& targets)
+{
+    for(set<Unit *>::iterator tIter = targets.begin(); tIter != targets.end();)
+    {
+        Unit* unit = *tIter;
+        if(!bot->IsWithinLOSInMap(unit) || bot->GetMapId() != unit->GetMapId() || !hasRealThreat(unit))
+        {
+            set<Unit *>::iterator tIter2 = tIter;
+            ++tIter;
+            targets.erase(tIter2);
+        }
+        else
+            ++tIter;
+    }
+}
+
+bool AttackersValue::hasRealThreat(Unit *attacker)
+{
+    return attacker &&
+        attacker->IsInWorld() &&
+        attacker->IsAlive() &&
+        !attacker->IsPolymorphed() &&
+        !attacker->isInRoots() &&
+        !attacker->IsFriendlyTo(bot) &&
+        (attacker->getThreatManager().getCurrentVictim() || dynamic_cast<Player*>(attacker));
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackersValue.h b/src/plugins/playerbot/strategy/values/AttackersValue.h
new file mode 100644
index 0000000..02f1b62
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackersValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "NearestUnitsValue.h"
+
+namespace ai
+{
+    class AttackersValue : public ObjectGuidListCalculatedValue
+	{
+	public:
+        AttackersValue(PlayerbotAI* ai) : ObjectGuidListCalculatedValue(ai, "attackers", 5) {}
+        list<ObjectGuid> Calculate();
+
+	private:
+        void AddAttackersOf(Group* group, set<Unit*>& targets);
+        void AddAttackersOf(Unit* unit, set<Unit*>& targets);
+		void RemoveNonThreating(set<Unit*>& targets);
+		bool hasRealThreat(Unit* attacker);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AvailableLootValue.h b/src/plugins/playerbot/strategy/values/AvailableLootValue.h
new file mode 100644
index 0000000..806f2ef
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AvailableLootValue.h
@@ -0,0 +1,40 @@
+#pragma once
+#include "../Value.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+   
+    class AvailableLootValue : public ManualSetValue<LootObjectStack*>
+	{
+	public:
+        AvailableLootValue(PlayerbotAI* ai) : ManualSetValue<LootObjectStack*>(ai, NULL) 
+        {
+            value = new LootObjectStack(ai->GetBot());
+        }
+
+        virtual ~AvailableLootValue()
+        {
+            if (value) 
+                delete value;
+        }
+    };
+
+    class LootTargetValue : public ManualSetValue<LootObject>
+    {
+    public:
+        LootTargetValue(PlayerbotAI* ai) : ManualSetValue<LootObject>(ai, LootObject()) {}
+    };
+
+    class CanLootValue : public BoolCalculatedValue
+    {
+    public:
+        CanLootValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            LootObject loot = AI_VALUE(LootObject, "loot target");
+            return !loot.IsEmpty() && loot.GetWorldObject(bot) && AI_VALUE2(float, "distance", "loot target") <= INTERACTION_DISTANCE;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CcTargetValue.cpp b/src/plugins/playerbot/strategy/values/CcTargetValue.cpp
new file mode 100644
index 0000000..2660a81
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CcTargetValue.cpp
@@ -0,0 +1,88 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CcTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../Action.h"
+
+using namespace ai;
+
+class FindTargetForCcStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForCcStrategy(PlayerbotAI* ai, string spell) : FindTargetStrategy(ai)
+    {
+        this->spell = spell;
+        maxDistance = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        Player* bot = ai->GetBot();
+        if (*ai->GetAiObjectContext()->GetValue<Unit*>("current target") == creature)
+            return;
+
+        uint8 health = creature->GetHealthPct();
+        if (health < sPlayerbotAIConfig.mediumHealth)
+            return;
+
+        if (!ai->CanCastSpell(spell, creature))
+            return;
+
+        if (*ai->GetAiObjectContext()->GetValue<Unit*>("rti target") == creature)
+        {
+            result = creature;
+            return;
+        }
+
+        float minDistance = sPlayerbotAIConfig.spellDistance;
+        Group* group = bot->GetGroup();
+        if (!group)
+            return;
+
+        if (group->GetTargetIcon(4) == creature->GetGUID())
+        {
+            result = creature;
+            return;
+        }
+
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+        if (!tankCount || !dpsCount)
+        {
+            result = creature;
+            return;
+        }
+
+        Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+            if( !member || !member->IsAlive() || member == bot)
+                continue;
+
+            if (!ai->IsTank(member))
+                continue;
+
+            float distance = member->GetDistance(creature);
+            if (distance < minDistance)
+                minDistance = distance;
+        }
+
+        if (!result || minDistance > maxDistance)
+        {
+            result = creature;
+            maxDistance = minDistance;
+        }
+    }
+
+private:
+    string spell;
+    float maxDistance;
+};
+
+Unit* CcTargetValue::Calculate()
+{
+    FindTargetForCcStrategy strategy(ai, qualifier);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/CcTargetValue.h b/src/plugins/playerbot/strategy/values/CcTargetValue.h
new file mode 100644
index 0000000..a27f8c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CcTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class CcTargetValue : public TargetValue, public Qualified
+	{
+	public:
+        CcTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ChatValue.h b/src/plugins/playerbot/strategy/values/ChatValue.h
new file mode 100644
index 0000000..b39a583
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ChatValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ChatValue : public ManualSetValue<ChatMsg>
+	{
+	public:
+        ChatValue(PlayerbotAI* ai) : ManualSetValue<ChatMsg>(ai, CHAT_MSG_WHISPER) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
new file mode 100644
index 0000000..932b0c0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CurrentCcTargetValue.h"
+
+using namespace ai;
+
+class FindCurrentCcTargetStrategy : public FindTargetStrategy
+{
+public:
+    FindCurrentCcTargetStrategy(PlayerbotAI* ai, string spell) : FindTargetStrategy(ai)
+    {
+        this->spell = spell;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (ai->HasAura(spell, attacker))
+            result = attacker;
+    }
+
+private:
+    string spell;
+};
+
+
+Unit* CurrentCcTargetValue::Calculate()
+{
+    FindCurrentCcTargetStrategy strategy(ai, qualifier);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
new file mode 100644
index 0000000..30646c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class CurrentCcTargetValue : public TargetValue, public Qualified
+	{
+	public:
+        CurrentCcTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp b/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
new file mode 100644
index 0000000..4e97d2c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
@@ -0,0 +1,22 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CurrentTargetValue.h"
+
+using namespace ai;
+
+Unit* CurrentTargetValue::Get()
+{
+    if (selection.IsEmpty())
+        return NULL;
+
+    Unit* unit = ObjectAccessor::GetUnit(*bot, selection);
+    if (unit && !bot->IsWithinLOSInMap(unit))
+        return NULL;
+
+    return unit;
+}
+
+void CurrentTargetValue::Set(Unit* target)
+{
+    selection = target ? target->GetGUID() : ObjectGuid::Empty;
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentTargetValue.h b/src/plugins/playerbot/strategy/values/CurrentTargetValue.h
new file mode 100644
index 0000000..6b9fb69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentTargetValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class CurrentTargetValue : public UnitManualSetValue
+	{
+	public:
+        CurrentTargetValue(PlayerbotAI* ai) : UnitManualSetValue(ai, NULL) {}
+
+        virtual Unit* Get();
+        virtual void Set(Unit* unit);
+
+    private:
+        ObjectGuid selection;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DistanceValue.h b/src/plugins/playerbot/strategy/values/DistanceValue.h
new file mode 100644
index 0000000..aee094f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DistanceValue.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class DistanceValue : public FloatCalculatedValue, public Qualified
+	{
+	public:
+        DistanceValue(PlayerbotAI* ai) : FloatCalculatedValue(ai) {}
+
+    public:
+        float Calculate()
+        {
+            if (qualifier == "loot target")
+            {
+                LootObject loot = AI_VALUE(LootObject, qualifier);
+                if (loot.IsEmpty())
+                    return 0.0f;
+
+                WorldObject* obj = loot.GetWorldObject(bot);
+                if (!obj)
+                    return 0.0f;
+
+                return ai->GetBot()->GetDistance2d(obj);
+            }
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target || !target->IsInWorld())
+                return 0.0f;
+
+            return ai->GetBot()->GetDistance2d(target);
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp b/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
new file mode 100644
index 0000000..afcdcbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
@@ -0,0 +1,45 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsTargetValue.h"
+
+using namespace ai;
+
+class FindTargetForDpsStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForDpsStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minThreat = 0;
+        maxTankCount = 0;
+        minDpsCount = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        float threat = threatManager->getThreat(ai->GetBot());
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+
+        if (!result ||
+            minThreat >= threat && (maxTankCount <= tankCount || minDpsCount >= dpsCount))
+        {
+            minThreat = threat;
+            maxTankCount = tankCount;
+            minDpsCount = dpsCount;
+            result = creature;
+        }
+    }
+
+protected:
+    float minThreat;
+    int maxTankCount;
+    int minDpsCount;
+};
+
+
+Unit* DpsTargetValue::Calculate()
+{
+    FindTargetForDpsStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/DpsTargetValue.h b/src/plugins/playerbot/strategy/values/DpsTargetValue.h
new file mode 100644
index 0000000..dcfcc8b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DpsTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class DpsTargetValue : public TargetValue
+	{
+	public:
+        DpsTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp b/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
new file mode 100644
index 0000000..06c9bf3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DuelTargetValue.h"
+
+using namespace ai;
+
+Unit* DuelTargetValue::Calculate()
+{
+    return bot->duel ? bot->duel->opponent : NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/DuelTargetValue.h b/src/plugins/playerbot/strategy/values/DuelTargetValue.h
new file mode 100644
index 0000000..9e7d2d6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DuelTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class DuelTargetValue : public TargetValue
+	{
+	public:
+        DuelTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
new file mode 100644
index 0000000..d4df967
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EnemyHealerTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+Unit* EnemyHealerTargetValue::Calculate()
+{
+    string spell = qualifier;
+
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    Unit* target = ai->GetAiObjectContext()->GetValue<Unit*>("current target")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || unit == target)
+            continue;
+
+        if (bot->GetDistance(unit) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (!ai->IsInterruptableSpellCasting(unit, spell))
+            continue;
+
+        Spell* spell = unit->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+        if (spell && spell->m_spellInfo->IsPositive())
+            return unit;
+
+        spell = unit->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+        if (spell && spell->m_spellInfo->IsPositive())
+            return unit;
+    }
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
new file mode 100644
index 0000000..bea36c4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class EnemyHealerTargetValue : public UnitCalculatedValue, public Qualified
+	{
+	public:
+        EnemyHealerTargetValue(PlayerbotAI* ai) :
+            UnitCalculatedValue(ai, "enemy healer target") {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
new file mode 100644
index 0000000..5576e75
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EnemyPlayerValue.h"
+#include "TargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+class FindEnemyPlayerStrategy : public FindTargetStrategy
+{
+public:
+    FindEnemyPlayerStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (!result)
+        {
+            Player* enemy = dynamic_cast<Player*>(attacker);
+            if (enemy && ai->IsOpposing(enemy) && enemy->IsOutdoorPvPActive())
+                result = attacker;
+        }
+    }
+
+};
+
+
+Unit* EnemyPlayerValue::Calculate()
+{
+    FindEnemyPlayerStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
new file mode 100644
index 0000000..ea50739
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class EnemyPlayerValue : public TargetValue
+	{
+	public:
+        EnemyPlayerValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/Formations.cpp b/src/plugins/playerbot/strategy/values/Formations.cpp
new file mode 100644
index 0000000..808cffe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/Formations.cpp
@@ -0,0 +1,377 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "Formations.h"
+#include "formations/Arrow.h"
+
+using namespace ai;
+
+WorldLocation Formation::NullLocation = WorldLocation();
+
+namespace ai
+{
+    class MeleeFormation : public FollowFormation
+    {
+    public:
+        MeleeFormation(PlayerbotAI* ai) : FollowFormation(ai, "melee") {}
+        virtual string GetTargetName() { return "master target"; }
+    };
+
+    class QueueFormation : public FollowFormation
+    {
+    public:
+        QueueFormation(PlayerbotAI* ai) : FollowFormation(ai, "queue") {}
+        virtual string GetTargetName() { return "line target"; }
+    };
+
+    class NearFormation : public MoveFormation
+    {
+    public:
+        NearFormation(PlayerbotAI* ai) : MoveFormation(ai, "near") {}
+        virtual WorldLocation GetLocation()
+        {
+            Player* master = GetMaster();
+            if (!master)
+                return WorldLocation();
+
+            float range = sPlayerbotAIConfig.followDistance;
+            float angle = GetFollowAngle();
+            float x = master->GetPositionX() + cos(angle) * range;
+            float y = master->GetPositionY() + sin(angle) * range;
+            float z = master->GetPositionZ();
+            float ground = master->GetMap()->GetHeight(x, y, z + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            return WorldLocation(master->GetMapId(), x, y, ground + 0.5f);
+        }
+
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.followDistance; }
+    };
+
+
+    class ChaosFormation : public MoveFormation
+    {
+    public:
+        ChaosFormation(PlayerbotAI* ai) : MoveFormation(ai, "chaos") {}
+        virtual WorldLocation GetLocation()
+        {
+            Player* master = GetMaster();
+            if (!master)
+                return WorldLocation();
+
+            float range = sPlayerbotAIConfig.lootDistance * (float)(rand() % 10) / 10;
+			float angle = GetFollowAngle();
+            float x = master->GetPositionX() + cos(angle) * range;
+            float y = master->GetPositionY() + sin(angle) * range;
+            float z = master->GetPositionZ();
+            float ground = master->GetMap()->GetHeight(x, y, z + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            return WorldLocation(master->GetMapId(), x, y, ground + 0.5f);
+        }
+
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.lootDistance; }
+    };
+
+    class CircleFormation : public MoveFormation
+    {
+    public:
+        CircleFormation(PlayerbotAI* ai) : MoveFormation(ai, "circle") {}
+        virtual WorldLocation GetLocation()
+        {
+            float range = 2.0f;
+
+            Unit* target = AI_VALUE(Unit*, "current target");
+            Player* master = GetMaster();
+            if (!target)
+                target = master;
+
+            if (!target)
+				return Formation::NullLocation;
+
+            switch (bot->getClass())
+            {
+            case CLASS_HUNTER:
+            case CLASS_MAGE:
+            case CLASS_PRIEST:
+            case CLASS_WARLOCK:
+                range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            case CLASS_DRUID:
+                if (!ai->IsTank(bot))
+                    range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            case CLASS_SHAMAN:
+                if (ai->IsHeal(bot))
+                    range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            }
+
+            float x = target->GetPositionX();
+            float y = target->GetPositionY();
+            float z = target->GetPositionZ();
+            float ground = target->GetMap()->GetHeight(x, y, z + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            float angle = GetFollowAngle();
+            return WorldLocation(bot->GetMapId(), x + cos(angle) * range, y + sin(angle) * range, ground + 0.5f);
+        }
+    };
+
+    class LineFormation : public MoveFormation
+    {
+    public:
+        LineFormation(PlayerbotAI* ai) : MoveFormation(ai, "line") {}
+        virtual WorldLocation GetLocation()
+        {
+            Group* group = bot->GetGroup();
+            if (!group)
+                return Formation::NullLocation;
+
+            float range = 2.0f;
+
+            Player* master = GetMaster();
+            if (!master)
+                return Formation::NullLocation;
+
+            float x = master->GetPositionX();
+            float y = master->GetPositionY();
+            float z = master->GetPositionZ();
+            float orientation = master->GetOrientation();
+
+            vector<Player*> players;
+            GroupReference *gref = group->GetFirstMember();
+            while( gref )
+            {
+                Player* member = gref->GetSource();
+                if (member != master)
+                    players.push_back(member);
+
+                gref = gref->next();
+            }
+
+            players.insert(players.begin() + group->GetMembersCount() / 2, master);
+
+            return MoveLine(players, 0.0f, x, y, z, orientation, range);
+        }
+    };
+
+    class ShieldFormation : public MoveFormation
+    {
+    public:
+        ShieldFormation(PlayerbotAI* ai) : MoveFormation(ai, "shield") {}
+        virtual WorldLocation GetLocation()
+        {
+            Group* group = bot->GetGroup();
+            if (!group)
+                return Formation::NullLocation;
+
+            float range = sPlayerbotAIConfig.followDistance;
+
+            Player* master = GetMaster();
+            if (!master)
+                return Formation::NullLocation;
+
+            float x = master->GetPositionX();
+            float y = master->GetPositionY();
+            float z = master->GetPositionZ();
+            float orientation = master->GetOrientation();
+
+            vector<Player*> tanks;
+            vector<Player*> dps;
+            GroupReference *gref = group->GetFirstMember();
+            while( gref )
+            {
+                Player* member = gref->GetSource();
+                if (member != master)
+                {
+                    if (ai->IsTank(member))
+                        tanks.push_back(member);
+                    else
+                        dps.push_back(member);
+                }
+
+                gref = gref->next();
+            }
+
+            if (ai->IsTank(master))
+                tanks.insert(tanks.begin() + (tanks.size() + 1) / 2, master);
+            else
+                dps.insert(dps.begin() + (dps.size() + 1) / 2, master);
+
+            if (ai->IsTank(bot) && ai->IsTank(master))
+            {
+                return MoveLine(tanks, 0.0f, x, y, z, orientation, range);
+            }
+            if (!ai->IsTank(bot) && !ai->IsTank(master))
+            {
+                return MoveLine(dps, 0.0f, x, y, z, orientation, range);
+            }
+            if (ai->IsTank(bot) && !ai->IsTank(master))
+            {
+                float diff = tanks.size() % 2 == 0 ? -sPlayerbotAIConfig.tooCloseDistance / 2.0f : 0.0f;
+                return MoveLine(tanks, diff, x + cos(orientation) * range, y + sin(orientation) * range, z, orientation, range);
+            }
+            if (!ai->IsTank(bot) && ai->IsTank(master))
+            {
+                float diff = dps.size() % 2 == 0 ? -sPlayerbotAIConfig.tooCloseDistance / 2.0f : 0.0f;
+                return MoveLine(dps, diff, x - cos(orientation) * range, y - sin(orientation) * range, z, orientation, range);
+            }
+            return Formation::NullLocation;
+        }
+    };
+};
+
+float Formation::GetFollowAngle()
+{
+    Player* master = GetMaster();
+    Group* group = master ? master->GetGroup() : bot->GetGroup();
+    if (!group)
+        return 0.0f;
+
+    int index = 1;
+    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+    {
+        if( ref->GetSource() == master)
+            continue;
+
+        if( ref->GetSource() == bot)
+            return 2 * M_PI / (group->GetMembersCount() -1) * index;
+
+        index++;
+    }
+    return 0;
+}
+
+FormationValue::FormationValue(PlayerbotAI* ai) : ManualSetValue<Formation*>(ai, new NearFormation(ai), "formation")
+{
+}
+
+bool SetFormationAction::Execute(Event event)
+{
+    string formation = event.getParam();
+
+	Value<Formation*>* value = context->GetValue<Formation*>("formation");
+    if (formation == "?" || formation.empty())
+    {
+        ostringstream str; str << "Formation: |cff00ff00" << value->Get()->getName();
+        ai->TellMaster(str);
+        return true;
+    }
+
+    if (formation == "melee")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new MeleeFormation(ai));
+    }
+    else if (formation == "queue")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new QueueFormation(ai));
+    }
+    else if (formation == "chaos")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ChaosFormation(ai));
+    }
+    else if (formation == "circle")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new CircleFormation(ai));
+    }
+    else if (formation == "line")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new LineFormation(ai));
+    }
+    else if (formation == "shield")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ShieldFormation(ai));
+    }
+    else if (formation == "arrow")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ArrowFormation(ai));
+    }
+    else if (formation == "near" || formation == "default")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new NearFormation(ai));
+    }
+    else
+    {
+        ostringstream str; str << "Invalid formation: |cffff0000" << formation;
+        ai->TellMaster(str);
+        ai->TellMaster("Please set to any of:|cffffffff melee (default), queue, chaos, circle, line, shield, arrow, near");
+        return false;
+    }
+
+    ostringstream str; str << "Formation set to: " << formation;
+    ai->TellMaster(str);
+    return true;
+}
+
+
+WorldLocation MoveFormation::MoveLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range)
+{
+    if (line.size() < 5)
+    {
+        return MoveSingleLine(line, diff, cx, cy, cz, orientation, range);
+    }
+
+    int lines = ceil((double)line.size() / 5.0);
+    for (int i = 0; i < lines; i++)
+    {
+        float radius = range * i;
+        float x = cx + cos(orientation) * radius;
+        float y = cy + sin(orientation) * radius;
+        vector<Player*> singleLine;
+        for (int j = 0; j < 5 && !line.empty(); j++)
+        {
+            singleLine.push_back(line[line.size() - 1]);
+            line.pop_back();
+        }
+
+        WorldLocation loc = MoveSingleLine(singleLine, diff, x, y,cz, orientation, range);
+        if (loc != Formation::NullLocation)
+            return loc;
+    }
+
+    return Formation::NullLocation;
+}
+
+WorldLocation MoveFormation::MoveSingleLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range)
+{
+    float count = line.size();
+    float angle = orientation - M_PI / 2.0f;
+    float x = cx + cos(angle) * (range * floor(count / 2.0f) + diff);
+    float y = cy + sin(angle) * (range * floor(count / 2.0f) + diff);
+
+    int index = 0;
+    for (vector<Player*>::iterator i = line.begin(); i != line.end(); i++)
+    {
+        Player* member = *i;
+
+        if (member == bot)
+        {
+            float angle = orientation + M_PI / 2.0f;
+            float radius = range * index;
+
+            float lx = x + cos(angle) * radius;
+            float ly = y + sin(angle) * radius;
+            float lz = cz;
+            float ground = bot->GetMap()->GetHeight(lx, ly, lz + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            return WorldLocation(bot->GetMapId(), lx, ly, ground + 0.5f);
+        }
+
+        index++;
+    }
+
+    return Formation::NullLocation;
+}
diff --git a/src/plugins/playerbot/strategy/values/Formations.h b/src/plugins/playerbot/strategy/values/Formations.h
new file mode 100644
index 0000000..2589cd7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/Formations.h
@@ -0,0 +1,52 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class Formation : public AiNamedObject
+    {
+    public:
+        Formation(PlayerbotAI* ai, string name) : AiNamedObject (ai, name) {}
+
+    public:
+        virtual string GetTargetName() { return ""; }
+        virtual WorldLocation GetLocation() { return NullLocation; }
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.followDistance; }
+        static WorldLocation NullLocation;
+
+    protected:
+        float GetFollowAngle();
+    };
+
+    class FollowFormation : public Formation
+    {
+    public:
+        FollowFormation(PlayerbotAI* ai, string name) : Formation(ai, name) {}
+    };
+
+    class MoveFormation : public Formation
+    {
+    public:
+        MoveFormation(PlayerbotAI* ai, string name) : Formation(ai, name) {}
+
+    protected:
+        WorldLocation MoveLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range);
+        WorldLocation MoveSingleLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range);
+    };
+
+    class FormationValue : public ManualSetValue<Formation*>
+	{
+	public:
+        FormationValue(PlayerbotAI* ai);
+        ~FormationValue() { if (value) { delete value; value = NULL; } }
+    };
+
+    class SetFormationAction : public Action
+    {
+    public:
+        SetFormationAction(PlayerbotAI* ai) : Action(ai, "set formation") {}
+        virtual bool Execute(Event event);
+    };
+};
+
diff --git a/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp b/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
new file mode 100644
index 0000000..451dbf7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
@@ -0,0 +1,126 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GrindTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+Unit* GrindTargetValue::Calculate()
+{
+    uint32 memberCount = 1;
+    Group* group = bot->GetGroup();
+    if (group)
+        memberCount = group->GetMembersCount();
+
+    Unit* target = NULL;
+    uint32 assistCount = 0;
+    while (!target && assistCount < memberCount)
+    {
+        target = FindTargetForGrinding(assistCount++);
+    }
+
+    return target;
+}
+
+
+Unit* GrindTargetValue::FindTargetForGrinding(int assistCount)
+{
+    uint32 memberCount = 1;
+    Group* group = bot->GetGroup();
+    Player* master = GetMaster();
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        return unit;
+    }
+
+    list<ObjectGuid> targets = *context->GetValue<list<ObjectGuid> >("possible targets");
+
+    if(targets.empty())
+        return NULL;
+
+    float distance = 0;
+    Unit* result = NULL;
+    for(list<ObjectGuid>::iterator tIter = targets.begin(); tIter != targets.end(); tIter++)
+    {
+        Unit* unit = ai->GetUnit(*tIter);
+        if (!unit)
+            continue;
+
+        if (abs(bot->GetPositionZ() - unit->GetPositionZ()) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (GetTargetingPlayerCount(unit) > assistCount)
+            continue;
+
+		if (master && master->GetDistance(unit) >= sPlayerbotAIConfig.grindDistance && !sRandomPlayerbotMgr.IsRandomBot(bot))
+            continue;
+
+		if ((int)unit->getLevel() - (int)bot->getLevel() > 4 && !unit->GetGUID().IsPlayer())
+		    continue;
+
+		Creature* creature = dynamic_cast<Creature*>(unit);
+		if (creature && creature->GetCreatureTemplate() && creature->GetCreatureTemplate()->rank > CREATURE_ELITE_NORMAL)
+		    continue;
+
+        if (group)
+        {
+            Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+            for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+                if( !member || !member->IsAlive())
+                    continue;
+
+                float d = member->GetDistance(unit);
+                if (!result || d < distance)
+                {
+                    distance = d;
+                    result = unit;
+                }
+            }
+        }
+        else
+        {
+            float d = bot->GetDistance(unit);
+            if (!result || d < distance)
+            {
+                distance = d;
+                result = unit;
+            }
+        }
+    }
+
+    return result;
+}
+
+
+int GrindTargetValue::GetTargetingPlayerCount( Unit* unit )
+{
+    Group* group = bot->GetGroup();
+    if (!group)
+        return 0;
+
+    int count = 0;
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !member || !member->IsAlive() || member == bot)
+            continue;
+
+        PlayerbotAI* ai = member->GetPlayerbotAI();
+        if ((ai && *ai->GetAiObjectContext()->GetValue<Unit*>("current target") == unit) ||
+            (!ai && member->GetSelectedUnit() == unit))
+            count++;
+    }
+
+    return count;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/GrindTargetValue.h b/src/plugins/playerbot/strategy/values/GrindTargetValue.h
new file mode 100644
index 0000000..f333297
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/GrindTargetValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class GrindTargetValue : public TargetValue
+	{
+	public:
+        GrindTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+
+    private:
+        int GetTargetingPlayerCount(Unit* unit);
+        Unit* FindTargetForGrinding(int assistCount);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h b/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
new file mode 100644
index 0000000..3dac17f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class HasAvailableLootValue : public BoolCalculatedValue
+	{
+	public:
+        HasAvailableLootValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        virtual bool Calculate()
+        {
+            return !AI_VALUE(bool, "can loot") &&
+                    AI_VALUE(LootObjectStack*, "available loot")->CanLoot(sPlayerbotAIConfig.lootDistance) &&
+                    !bot->IsMounted();
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/HasTotemValue.h b/src/plugins/playerbot/strategy/values/HasTotemValue.h
new file mode 100644
index 0000000..a65b3a2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/HasTotemValue.h
@@ -0,0 +1,34 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class HasTotemValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        HasTotemValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        bool Calculate()
+        {
+            list<ObjectGuid> units = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+            for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+            {
+                Unit* unit = ai->GetUnit(*i);
+                if (!unit)
+                    continue;
+
+                Creature* creature = dynamic_cast<Creature*>(unit);
+                if (!creature || !creature->IsTotem())
+                    continue;
+
+                if (strstri(creature->GetName().c_str(), qualifier.c_str()) && bot->GetDistance(creature) <= sPlayerbotAIConfig.spellDistance)
+                    return true;
+            }
+
+            return false;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp b/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
new file mode 100644
index 0000000..41440c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InvalidTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool InvalidTargetValue::Calculate()
+{
+    Unit* target = AI_VALUE(Unit*, qualifier);
+    if (qualifier == "current target")
+    {
+        return !target ||
+                target->GetMapId() != bot->GetMapId() ||
+                target->isDead() ||
+                target->IsPolymorphed() ||
+                target->IsCharmed() ||
+                target->isFeared() ||
+                target->HasUnitState(UNIT_STATE_ISOLATED) ||
+                target->IsFriendlyTo(bot) ||
+                !bot->IsWithinDistInMap(target, sPlayerbotAIConfig.sightDistance) ||
+                !bot->IsWithinLOSInMap(target);
+    }
+
+    return !target;
+}
diff --git a/src/plugins/playerbot/strategy/values/InvalidTargetValue.h b/src/plugins/playerbot/strategy/values/InvalidTargetValue.h
new file mode 100644
index 0000000..5d277fd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/InvalidTargetValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class InvalidTargetValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        InvalidTargetValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+	public:
+        virtual bool Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsBehindValue.h b/src/plugins/playerbot/strategy/values/IsBehindValue.h
new file mode 100644
index 0000000..da61670
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsBehindValue.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsBehindValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsBehindValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate() 
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target)
+                return false;
+
+            
+            float targetOrientation = target->GetOrientation();
+            float orientation = bot->GetOrientation();
+            float distance = bot->GetDistance(target);
+
+            return distance <= ATTACK_DISTANCE && abs(targetOrientation - orientation) < M_PI / 2;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsFacingValue.h b/src/plugins/playerbot/strategy/values/IsFacingValue.h
new file mode 100644
index 0000000..814014f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsFacingValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsFacingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsFacingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target)
+                return false;
+
+            return bot->isInFront(target, M_PI / 3.0f);
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsMovingValue.h b/src/plugins/playerbot/strategy/values/IsMovingValue.h
new file mode 100644
index 0000000..bbee8bd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsMovingValue.h
@@ -0,0 +1,42 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsMovingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsMovingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+
+            if (!target)
+                return false;
+
+            switch (target->GetMotionMaster()->GetCurrentMovementGeneratorType())
+            {
+            case IDLE_MOTION_TYPE:
+                return false;
+            }
+            return true;
+        }
+    };
+
+    class IsSwimmingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsSwimmingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+
+            if (!target)
+                return false;
+
+            return target->IsUnderWater() || target->IsInWater();
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemCountValue.cpp b/src/plugins/playerbot/strategy/values/ItemCountValue.cpp
new file mode 100644
index 0000000..2b6c0a2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemCountValue.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemCountValue.h"
+
+using namespace ai;
+
+list<Item*> InventoryItemValueBase::Find(string qualifier)
+{
+    list<Item*> result;
+
+    Player* bot = InventoryAction::ai->GetBot();
+
+    list<Item*> items = InventoryAction::parseItems(qualifier);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); i++)
+        result.push_back(*i);
+
+    return result;
+}
+
+
+uint8 ItemCountValue::Calculate()
+{
+    uint8 count = 0;
+    list<Item*> items = Find(qualifier);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        Item* item = *i;
+        count += item->GetCount();
+    }
+
+    return count;
+}
+
+list<Item*> InventoryItemValue::Calculate()
+{
+    return Find(qualifier);
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemCountValue.h b/src/plugins/playerbot/strategy/values/ItemCountValue.h
new file mode 100644
index 0000000..f81d9b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemCountValue.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Value.h"
+#include "../ItemVisitors.h"
+#include "../actions/InventoryAction.h"
+
+namespace ai
+{
+    class InventoryItemValueBase : public InventoryAction
+    {
+    public:
+        InventoryItemValueBase(PlayerbotAI* ai) : InventoryAction(ai, "empty") {}
+        virtual bool Execute(Event event) { return false; }
+
+    protected:
+        list<Item*> Find(string qualifier);
+    };
+
+    class ItemCountValue : public Uint8CalculatedValue, public Qualified, InventoryItemValueBase
+	{
+	public:
+        ItemCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai), InventoryItemValueBase(ai) {}
+
+    public:
+        virtual uint8 Calculate();
+	};
+
+    class InventoryItemValue : public CalculatedValue<list<Item*> >, public Qualified, InventoryItemValueBase
+    {
+    public:
+        InventoryItemValue(PlayerbotAI* ai) : CalculatedValue<list<Item*> >(ai), InventoryItemValueBase(ai) {}
+
+    public:
+        virtual list<Item*> Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp b/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
new file mode 100644
index 0000000..671cd97
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
@@ -0,0 +1,70 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemForSpellValue.h"
+
+using namespace ai;
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+Item* ItemForSpellValue::Calculate()
+{
+    uint32 spellid = atoi(qualifier.c_str());
+    if (!spellid)
+        return NULL;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+    if (!spellInfo)
+        return NULL;
+
+    Item* itemForSpell = NULL;
+    Player* trader = bot->GetTrader();
+    if (trader)
+    {
+        itemForSpell = trader->GetTradeData()->GetItem(TRADE_SLOT_NONTRADED);
+        if (itemForSpell && itemForSpell->IsFitToSpellRequirements(spellInfo))
+            return itemForSpell;
+    }
+
+    // Workaround as some spells have no item mask (e.g. shaman weapon enhancements)
+    if (!strcmpi(spellInfo->SpellName[0], "rockbiter weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "flametongue weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "earthliving weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "frostbrand weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "windfury weapon"))
+    {
+        itemForSpell = GetItemFitsToSpellRequirements(EQUIPMENT_SLOT_MAINHAND, spellInfo);
+        if (itemForSpell && itemForSpell->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+            return itemForSpell;
+
+        itemForSpell = GetItemFitsToSpellRequirements(EQUIPMENT_SLOT_OFFHAND, spellInfo);
+        if (itemForSpell && itemForSpell->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+            return itemForSpell;
+
+        return NULL;
+    }
+
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++ ) {
+        itemForSpell = GetItemFitsToSpellRequirements(slot, spellInfo);
+        if (itemForSpell)
+            return itemForSpell;
+    }
+    return NULL;
+}
+
+Item* ItemForSpellValue::GetItemFitsToSpellRequirements(uint8 slot, SpellInfo const *spellInfo)
+{
+    Item* const itemForSpell = bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+    if (!itemForSpell || itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+        return NULL;
+
+    if (itemForSpell->IsFitToSpellRequirements(spellInfo))
+        return itemForSpell;
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemForSpellValue.h b/src/plugins/playerbot/strategy/values/ItemForSpellValue.h
new file mode 100644
index 0000000..39ce6af
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemForSpellValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class ItemForSpellValue : public CalculatedValue<Item*>, public Qualified
+	{
+	public:
+        ItemForSpellValue(PlayerbotAI* ai) : CalculatedValue<Item*>(ai) {}
+
+    public:
+        virtual Item* Calculate();
+
+    private:
+        Item* GetItemFitsToSpellRequirements(uint8 slot, SpellInfo const *spellInfo);
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp b/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
new file mode 100644
index 0000000..b7fbcfc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
@@ -0,0 +1,146 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemUsageValue.h"
+
+#include "../../GuildTaskMgr.h"
+using namespace ai;
+
+ItemUsage ItemUsageValue::Calculate()
+{
+    uint32 itemId = atoi(qualifier.c_str());
+    if (!itemId)
+        return ITEM_USAGE_NONE;
+
+    const ItemTemplate* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return ITEM_USAGE_NONE;
+
+    if (IsItemUsefulForSkill(proto))
+        return ITEM_USAGE_SKILL;
+
+    switch (proto->Class)
+    {
+    case ITEM_CLASS_KEY:
+    case ITEM_CLASS_CONSUMABLE:
+        return ITEM_USAGE_USE;
+    }
+
+    if (bot->GetGuildId() && sGuildTaskMgr.IsGuildTaskItem(itemId, bot->GetGuildId()))
+        return ITEM_USAGE_GUILD_TASK;
+
+    return QueryItemUsageForEquip(proto);
+}
+
+ItemUsage ItemUsageValue::QueryItemUsageForEquip(ItemTemplate const * item)
+{
+    if (bot->CanUseItem(item) != EQUIP_ERR_OK)
+        return ITEM_USAGE_NONE;
+
+    if (item->InventoryType == INVTYPE_NON_EQUIP)
+        return ITEM_USAGE_NONE;
+
+    Item *pItem = Item::CreateItem(item->ItemId, 1, bot);
+    if (!pItem)
+        return ITEM_USAGE_NONE;
+
+    uint16 dest;
+    InventoryResult result = bot->CanEquipItem(NULL_SLOT, dest, pItem, true, false);
+    pItem->RemoveFromUpdateQueueOf(bot);
+    delete pItem;
+
+    if( result != EQUIP_ERR_OK )
+        return ITEM_USAGE_NONE;
+
+    Item* existingItem = bot->GetItemByPos(dest);
+    if (!existingItem)
+        return ITEM_USAGE_EQUIP;
+
+    const ItemTemplate* oldItem = existingItem->GetTemplate();
+    if (oldItem->ItemLevel < item->ItemLevel && oldItem->ItemId != item->ItemId)
+    {
+        switch (item->Class)
+        {
+        case ITEM_CLASS_ARMOR:
+            if (oldItem->SubClass <= item->SubClass) {
+                return ITEM_USAGE_REPLACE;
+            }
+            break;
+        default:
+            return ITEM_USAGE_EQUIP;
+        }
+    }
+
+    return ITEM_USAGE_NONE;
+}
+
+bool ItemUsageValue::IsItemUsefulForSkill(ItemTemplate const * proto)
+{
+    switch (proto->Class)
+    {
+    case ITEM_CLASS_GEM:
+        if (proto->SubClass == ITEM_SUBCLASS_GEM_SIMPLE && bot->HasSkill(SKILL_JEWELCRAFTING))
+            return true;
+        if (proto->SubClass != ITEM_SUBCLASS_GEM_SIMPLE)
+            return true;
+        break;
+    case ITEM_CLASS_TRADE_GOODS:
+        switch (proto->SubClass)
+        {
+        case ITEM_SUBCLASS_PARTS:
+        case ITEM_SUBCLASS_EXPLOSIVES:
+        case ITEM_SUBCLASS_DEVICES:
+            return bot->HasSkill(SKILL_ENGINEERING);
+        case ITEM_SUBCLASS_JEWELCRAFTING:
+            return bot->HasSkill(SKILL_JEWELCRAFTING);
+        case ITEM_SUBCLASS_CLOTH:
+            return bot->HasSkill(SKILL_TAILORING);
+        case ITEM_SUBCLASS_LEATHER:
+            return bot->HasSkill(SKILL_LEATHERWORKING) || bot->HasSkill(SKILL_SKINNING);
+        case ITEM_SUBCLASS_METAL_STONE:
+            return (bot->HasSkill(SKILL_BLACKSMITHING) ||
+                bot->HasSkill(SKILL_ENGINEERING) ||
+                bot->HasSkill(SKILL_MINING));
+        case ITEM_SUBCLASS_MEAT:
+            return bot->HasSkill(SKILL_COOKING);
+        case ITEM_SUBCLASS_HERB:
+            return (bot->HasSkill(SKILL_HERBALISM) ||
+                bot->HasSkill(SKILL_ALCHEMY) ||
+                bot->HasSkill(SKILL_INSCRIPTION));
+        case ITEM_SUBCLASS_ELEMENTAL:
+            return true;
+        case ITEM_SUBCLASS_ENCHANTING:
+            return bot->HasSkill(SKILL_ENCHANTING);
+        }
+        break;
+    case ITEM_CLASS_RECIPE:
+        {
+            if (bot->HasSpell(proto->Spells[2].SpellId))
+                break;
+
+            switch (proto->SubClass)
+            {
+            case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
+                return bot->HasSkill(SKILL_LEATHERWORKING);
+            case ITEM_SUBCLASS_TAILORING_PATTERN:
+                return bot->HasSkill(SKILL_TAILORING);
+            case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
+                return bot->HasSkill(SKILL_ENGINEERING);
+            case ITEM_SUBCLASS_BLACKSMITHING:
+                return bot->HasSkill(SKILL_BLACKSMITHING);
+            case ITEM_SUBCLASS_COOKING_RECIPE:
+                return bot->HasSkill(SKILL_COOKING);
+            case ITEM_SUBCLASS_ALCHEMY_RECIPE:
+                return bot->HasSkill(SKILL_ALCHEMY);
+            case ITEM_SUBCLASS_FIRST_AID_MANUAL:
+                return bot->HasSkill(SKILL_FIRST_AID);
+            case ITEM_SUBCLASS_ENCHANTING_FORMULA:
+                return bot->HasSkill(SKILL_ENCHANTING);
+            case ITEM_SUBCLASS_FISHING_MANUAL:
+                return bot->HasSkill(SKILL_FISHING);
+            case ITEM_SUBCLASS_JEWELCRAFTING_RECIPE:
+                return bot->HasSkill(SKILL_JEWELCRAFTING);
+            }
+        }
+    }
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemUsageValue.h b/src/plugins/playerbot/strategy/values/ItemUsageValue.h
new file mode 100644
index 0000000..95e0a52
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemUsageValue.h
@@ -0,0 +1,28 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    enum ItemUsage
+    {
+        ITEM_USAGE_NONE = 0,
+        ITEM_USAGE_EQUIP = 1,
+        ITEM_USAGE_REPLACE = 2,
+        ITEM_USAGE_SKILL = 3,
+        ITEM_USAGE_USE = 4,
+        ITEM_USAGE_GUILD_TASK = 5
+    };
+
+    class ItemUsageValue : public CalculatedValue<ItemUsage>, public Qualified
+	{
+	public:
+        ItemUsageValue(PlayerbotAI* ai) : CalculatedValue<ItemUsage>(ai) {}
+
+    public:
+        virtual ItemUsage Calculate();
+
+    private:
+        ItemUsage QueryItemUsageForEquip(ItemTemplate const * proto);
+        bool IsItemUsefulForSkill(ItemTemplate const * proto);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LastMovementValue.h b/src/plugins/playerbot/strategy/values/LastMovementValue.h
new file mode 100644
index 0000000..0467833
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastMovementValue.h
@@ -0,0 +1,61 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastMovement
+    {
+    public:
+        LastMovement() 
+        {
+            lastMoveToX = 0;
+            lastMoveToY = 0;
+            lastMoveToZ = 0;
+            lastMoveToOri = 0;
+            lastFollow = NULL;
+        }
+
+        LastMovement(LastMovement& other)
+        {
+            taxiNodes = other.taxiNodes;
+            taxiMaster = other.taxiMaster;
+            lastFollow = other.lastFollow;
+            lastAreaTrigger = other.lastAreaTrigger;
+            lastMoveToX = other.lastMoveToX;
+            lastMoveToY = other.lastMoveToY;
+            lastMoveToZ = other.lastMoveToZ;
+            lastMoveToOri = other.lastMoveToOri;
+        }
+        
+        void Set(Unit* lastFollow)
+        {
+            Set(0.0f, 0.0f, 0.0f, 0.0f);
+            this->lastFollow = lastFollow;
+        }
+
+        void Set(float x, float y, float z, float ori)
+        {
+            lastMoveToX = x;
+            lastMoveToY = y;
+            lastMoveToZ = z;
+            lastMoveToOri = ori;
+            lastFollow = NULL;
+        }
+
+    public:
+        vector<uint32> taxiNodes;
+        ObjectGuid taxiMaster;
+        Unit* lastFollow;
+        uint32 lastAreaTrigger;
+        float lastMoveToX, lastMoveToY, lastMoveToZ, lastMoveToOri;
+    };
+
+    class LastMovementValue : public ManualSetValue<LastMovement&>
+	{
+	public:
+        LastMovementValue(PlayerbotAI* ai) : ManualSetValue<LastMovement&>(ai, data) {}
+
+    private:
+        LastMovement data;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSaidValue.h b/src/plugins/playerbot/strategy/values/LastSaidValue.h
new file mode 100644
index 0000000..1690bf9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSaidValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSaidValue : public ManualSetValue<time_t>, public Qualified
+	{
+	public:
+        LastSaidValue(PlayerbotAI* ai) : ManualSetValue<time_t>(ai, time(0) - 120, "last said") {}
+    };
+
+    class LastEmoteValue : public ManualSetValue<time_t>, public Qualified
+	{
+	public:
+        LastEmoteValue(PlayerbotAI* ai) : ManualSetValue<time_t>(ai, time(0) - 120, "last emote") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h b/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
new file mode 100644
index 0000000..bf0a17e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSpellCastTimeValue : public ManualSetValue<time_t>, public Qualified
+	{
+	public:
+        LastSpellCastTimeValue(PlayerbotAI* ai) : ManualSetValue<time_t>(ai, 0), Qualified() {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSpellCastValue.h b/src/plugins/playerbot/strategy/values/LastSpellCastValue.h
new file mode 100644
index 0000000..5d05541
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSpellCastValue.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSpellCast 
+    {
+    public:
+        LastSpellCast() : id(0),time(0) {}
+
+    public:
+        void Set(uint32 id, ObjectGuid target, time_t time)
+        {
+            this->id = id;
+            this->target = target;
+            this->time = time;
+        }
+        
+        void Reset()
+        {
+            id = 0;
+            target.Set(0);
+            time = 0;
+        }
+    public:
+        uint32 id;
+        ObjectGuid target;
+        time_t time;
+    };
+   
+    class LastSpellCastValue : public ManualSetValue<LastSpellCast&>
+	{
+	public:
+        LastSpellCastValue(PlayerbotAI* ai) : ManualSetValue<LastSpellCast&>(ai, data) {}
+
+    private:
+        LastSpellCast data;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
new file mode 100644
index 0000000..39021c5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
@@ -0,0 +1,33 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LeastHpTargetValue.h"
+#include "TargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+class FindLeastHpTargetStrategy : public FindTargetStrategy
+{
+public:
+    FindLeastHpTargetStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minHealth = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (!result || result->GetHealth() > attacker->GetHealth())
+            result = attacker;
+    }
+
+protected:
+    float minHealth;
+};
+
+
+Unit* LeastHpTargetValue::Calculate()
+{
+    FindLeastHpTargetStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
new file mode 100644
index 0000000..e748e7f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class LeastHpTargetValue : public TargetValue
+	{
+	public:
+        LeastHpTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LfgValues.h b/src/plugins/playerbot/strategy/values/LfgValues.h
new file mode 100644
index 0000000..290a4c4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LfgValues.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../Value.h"
+
+namespace ai
+{
+class LfgProposalValue : public ManualSetValue<uint32>
+{
+public:
+    LfgProposalValue(PlayerbotAI* ai) : ManualSetValue<uint32>(ai, 0, "lfg proposal") {}
+};
+}
diff --git a/src/plugins/playerbot/strategy/values/LineTargetValue.cpp b/src/plugins/playerbot/strategy/values/LineTargetValue.cpp
new file mode 100644
index 0000000..3546e12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LineTargetValue.cpp
@@ -0,0 +1,33 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LineTargetValue.h"
+
+using namespace ai;
+
+Unit* LineTargetValue::Calculate()
+{
+    Player* master = GetMaster();
+    if (!master)
+        return NULL;
+
+    Group* group = master->GetGroup();
+    if (!group)
+        return NULL;
+
+    Player *prev = master;
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !player || !player->IsAlive() || player == master)
+            continue;
+
+        if (player == bot)
+            return prev;
+
+        prev = player;
+    }
+
+    return master;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/LineTargetValue.h b/src/plugins/playerbot/strategy/values/LineTargetValue.h
new file mode 100644
index 0000000..57998fa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LineTargetValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LineTargetValue : public UnitCalculatedValue
+	{
+	public:
+        LineTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    public:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LogLevelValue.h b/src/plugins/playerbot/strategy/values/LogLevelValue.h
new file mode 100644
index 0000000..c5f9da9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LogLevelValue.h
@@ -0,0 +1,12 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LogLevelValue : public ManualSetValue<LogLevel>
+	{
+	public:
+        LogLevelValue(PlayerbotAI* ai) :
+            ManualSetValue<LogLevel>(ai, LOG_LEVEL_DEBUG) {}
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LootStrategyValue.h b/src/plugins/playerbot/strategy/values/LootStrategyValue.h
new file mode 100644
index 0000000..210e518
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LootStrategyValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LootStrategyValue : public ManualSetValue<LootStrategy>
+	{
+	public:
+        LootStrategyValue(PlayerbotAI* ai) : ManualSetValue<LootStrategy>(ai, LOOTSTRATEGY_SKILL) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h b/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
new file mode 100644
index 0000000..6c29f1f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ManaSaveLevelValue : public ManualSetValue<double>
+	{
+	public:
+        ManaSaveLevelValue(PlayerbotAI* ai) : ManualSetValue<double>(ai, 1.0, "mana save level") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/MasterTargetValue.h b/src/plugins/playerbot/strategy/values/MasterTargetValue.h
new file mode 100644
index 0000000..a137694
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/MasterTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class MasterTargetValue : public UnitCalculatedValue
+	{
+	public:
+        MasterTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return ai->GetMaster(); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp b/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
new file mode 100644
index 0000000..3370836
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
@@ -0,0 +1,11 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestAdsValue.h"
+
+using namespace ai;
+
+bool NearestAdsValue::AcceptUnit(Unit* unit)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return unit != target;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestAdsValue.h b/src/plugins/playerbot/strategy/values/NearestAdsValue.h
new file mode 100644
index 0000000..16e4a84
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestAdsValue.h
@@ -0,0 +1,18 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "PossibleTargetsValue.h"
+
+namespace ai
+{
+    class NearestAdsValue : public PossibleTargetsValue
+	{
+	public:
+        NearestAdsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.tooCloseDistance) :
+            PossibleTargetsValue(ai, range) {}
+
+    protected:
+        bool AcceptUnit(Unit* unit);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
new file mode 100644
index 0000000..ad6e30a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestCorpsesValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+class AnyDeadUnitInObjectRangeCheck
+{
+public:
+    AnyDeadUnitInObjectRangeCheck(WorldObject const* obj, float range) : i_obj(obj), i_range(range) {}
+    WorldObject const& GetFocusObject() const { return *i_obj; }
+    bool operator()(Unit* u)
+    {
+        return !u->IsAlive() && i_obj->IsWithinDistInMap(u, i_range);
+    }
+private:
+    WorldObject const* i_obj;
+    float i_range;
+};
+
+void NearestCorpsesValue::FindUnits(list<Unit*> &targets)
+{
+    AnyDeadUnitInObjectRangeCheck u_check(bot, range);
+    UnitListSearcher<AnyDeadUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool NearestCorpsesValue::AcceptUnit(Unit* unit)
+{
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
new file mode 100644
index 0000000..c23a5b8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestCorpsesValue : public NearestUnitsValue
+	{
+	public:
+        NearestCorpsesValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        void FindUnits(list<Unit*> &targets);
+        bool AcceptUnit(Unit* unit);
+
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp b/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
new file mode 100644
index 0000000..405b1c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestGameObjects.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+class AnyGameObjectInObjectRangeCheck
+{
+public:
+    AnyGameObjectInObjectRangeCheck(WorldObject const* obj, float range) : i_obj(obj), i_range(range) {}
+    WorldObject const& GetFocusObject() const { return *i_obj; }
+    bool operator()(GameObject* u)
+    {
+        if (u && i_obj->IsWithinDistInMap(u, i_range) && u->isSpawned() && u->GetGOInfo())
+            return true;
+
+        return false;
+    }
+
+private:
+    WorldObject const* i_obj;
+    float i_range;
+};
+
+list<ObjectGuid> NearestGameObjects::Calculate()
+{
+    list<GameObject*> targets;
+
+    AnyGameObjectInObjectRangeCheck u_check(bot, range);
+    GameObjectListSearcher<AnyGameObjectInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+
+    list<ObjectGuid> result;
+    for(list<GameObject*>::iterator tIter = targets.begin(); tIter != targets.end(); ++tIter)
+    {
+		GameObject* go = *tIter;
+        if(bot->IsWithinLOSInMap(go))
+			result.push_back(go->GetGUID());
+    }
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestGameObjects.h b/src/plugins/playerbot/strategy/values/NearestGameObjects.h
new file mode 100644
index 0000000..78dcf57
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestGameObjects.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestGameObjects : public ObjectGuidListCalculatedValue
+	{
+	public:
+        NearestGameObjects(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+            ObjectGuidListCalculatedValue(ai), range(range) {}
+
+    protected:
+        virtual list<ObjectGuid> Calculate();
+
+    private:
+        float range;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp b/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
new file mode 100644
index 0000000..9f82f10
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestNpcsValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+
+using namespace ai;
+using namespace Trinity;
+
+void NearestNpcsValue::FindUnits(list<Unit*> &targets)
+{
+    AnyFriendlyUnitInObjectRangeCheck u_check(bot, bot, range);
+    UnitListSearcher<AnyFriendlyUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool NearestNpcsValue::AcceptUnit(Unit* unit)
+{
+    return !dynamic_cast<Player*>(unit);
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestNpcsValue.h b/src/plugins/playerbot/strategy/values/NearestNpcsValue.h
new file mode 100644
index 0000000..ebbbd75
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestNpcsValue.h
@@ -0,0 +1,18 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestNpcsValue : public NearestUnitsValue
+	{
+	public:
+        NearestNpcsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        void FindUnits(list<Unit*> &targets);
+        bool AcceptUnit(Unit* unit);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestUnitsValue.h b/src/plugins/playerbot/strategy/values/NearestUnitsValue.h
new file mode 100644
index 0000000..c6d1ed5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestUnitsValue.h
@@ -0,0 +1,36 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestUnitsValue : public ObjectGuidListCalculatedValue
+	{
+	public:
+        NearestUnitsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+            ObjectGuidListCalculatedValue(ai, "nearest units", 5), range(range) {}
+
+	public:
+        list<ObjectGuid> Calculate()
+        {
+            list<Unit*> targets;
+            FindUnits(targets);
+
+            list<ObjectGuid> results;
+            for(list<Unit *>::iterator i = targets.begin(); i!= targets.end(); ++i)
+            {
+                Unit* unit = *i;
+                if(bot->IsWithinLOSInMap(unit) && AcceptUnit(unit))
+                    results.push_back(unit->GetGUID());
+            }
+            return results;
+        }
+
+    protected:
+        virtual void FindUnits(list<Unit*> &targets) = 0;
+        virtual bool AcceptUnit(Unit* unit) = 0;
+
+    protected:
+        float range;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
new file mode 100644
index 0000000..1f50b6b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToDispel.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class PartyMemberToDispelPredicate : public FindPlayerPredicate, public PlayerbotAIAware
+{
+public:
+    PartyMemberToDispelPredicate(PlayerbotAI* ai, uint32 dispelType) :
+        PlayerbotAIAware(ai), FindPlayerPredicate(), dispelType(dispelType) {}
+
+public:
+    virtual bool Check(Unit* unit)
+    {
+        if (unit->IsPet())
+        {
+            Pet* pet = unit->ToPet();
+            if (pet && pet->getPetType() == SUMMON_PET)
+                return false;
+        }
+
+        return unit->IsAlive() && ai->HasAuraToDispel(unit, dispelType);
+    }
+
+private:
+    uint32 dispelType;
+};
+
+Unit* PartyMemberToDispel::Calculate()
+{
+    uint32 dispelType = atoi(qualifier.c_str());
+
+    PartyMemberToDispelPredicate predicate(ai, dispelType);
+    return FindPartyMember(predicate);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
new file mode 100644
index 0000000..dfbc809
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToDispel : public PartyMemberValue, Qualified
+	{
+	public:
+        PartyMemberToDispel(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
new file mode 100644
index 0000000..2ef8e3c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
@@ -0,0 +1,60 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToHeal.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class IsTargetOfHealingSpell : public SpellEntryPredicate
+{
+public:
+    virtual bool Check(SpellInfo const* spell) {
+        for (int i=0; i<3; i++) {
+            if (spell->Effects[i].Effect == SPELL_EFFECT_HEAL ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_MAX_HEALTH ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_MECHANICAL ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_PCT)
+                return true;
+        }
+        return false;
+    }
+
+};
+
+Unit* PartyMemberToHeal::Calculate()
+{
+
+    IsTargetOfHealingSpell predicate;
+
+    Group* group = bot->GetGroup();
+    if (!group)
+        return NULL;
+
+    bool isRaid = bot->GetGroup()->isRaidGroup();
+    MinValueCalculator calc(100);
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+        if (!Check(player) || !player->IsAlive())
+            continue;
+
+        uint8 health = player->GetHealthPct();
+        if (isRaid || health < sPlayerbotAIConfig.mediumHealth || !IsTargetOfSpellCast(player, predicate))
+            calc.probe(health, player);
+
+        Pet* pet = player->GetPet();
+        if (pet && CanHealPet(pet))
+        {
+            health = ((Unit*)pet)->GetHealthPct();
+            if (isRaid || health < sPlayerbotAIConfig.mediumHealth || !IsTargetOfSpellCast(player, predicate))
+                calc.probe(health, player);
+        }
+    }
+    return (Unit*)calc.param;
+}
+
+bool PartyMemberToHeal::CanHealPet(Pet* pet)
+{
+    return HUNTER_PET == pet->getPetType();
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
new file mode 100644
index 0000000..bbbc2f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToHeal : public PartyMemberValue
+	{
+	public:
+        PartyMemberToHeal(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+        bool CanHealPet(Pet* pet);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
new file mode 100644
index 0000000..58dd203
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToResurrect.h"
+
+using namespace ai;
+
+class IsTargetOfResurrectSpell : public SpellEntryPredicate
+{
+public:
+    virtual bool Check(SpellInfo const* spell)
+    {
+        for (int i=0; i<3; i++)
+        {
+            if (spell->Effects[i].Effect == SPELL_EFFECT_RESURRECT ||
+                spell->Effects[i].Effect == SPELL_EFFECT_RESURRECT_NEW ||
+                spell->Effects[i].Effect == SPELL_EFFECT_SELF_RESURRECT)
+                return true;
+        }
+        return false;
+    }
+
+};
+
+class FindDeadPlayer : public FindPlayerPredicate
+{
+public:
+    FindDeadPlayer(PartyMemberValue* value) : value(value) {}
+
+    virtual bool Check(Unit* unit)
+    {
+        Player* player = dynamic_cast<Player*>(unit);
+        return player && player->getDeathState() == CORPSE && !value->IsTargetOfSpellCast(player, predicate);
+    }
+
+private:
+    PartyMemberValue* value;
+    IsTargetOfResurrectSpell predicate;
+};
+
+Unit* PartyMemberToResurrect::Calculate()
+{
+	FindDeadPlayer finder(this);
+    return FindPartyMember(finder);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
new file mode 100644
index 0000000..36815f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToResurrect : public PartyMemberValue
+	{
+	public:
+        PartyMemberToResurrect(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp b/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
new file mode 100644
index 0000000..2f5bcc4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
@@ -0,0 +1,111 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+Unit* PartyMemberValue::FindPartyMember(list<Player*>* party, FindPlayerPredicate &predicate)
+{
+    for (list<Player*>::iterator i = party->begin(); i != party->end(); ++i)
+    {
+        Player* player = *i;
+
+        if (!player)
+            continue;
+
+        if (Check(player) && predicate.Check(player))
+            return player;
+
+        Pet* pet = player->GetPet();
+        if (!pet)
+            continue;
+
+        Unit* unit = (Unit*)pet;
+        if (unit && Check(unit) && predicate.Check(unit))
+            return unit;
+    }
+
+    return NULL;
+}
+
+Unit* PartyMemberValue::FindPartyMember(FindPlayerPredicate &predicate)
+{
+    Player* master = GetMaster();
+    Group* group = bot->GetGroup();
+    if (!group)
+        return NULL;
+
+    list<Player*> healers, tanks, others, masters;
+    masters.push_back(master);
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+
+        if (ai->IsHeal(player))
+            healers.push_back(player);
+        else if (ai->IsTank(player))
+            tanks.push_back(player);
+        else if (player != master)
+            others.push_back(player);
+    }
+
+    list<list<Player*>* > lists;
+    lists.push_back(&healers);
+    lists.push_back(&tanks);
+    lists.push_back(&masters);
+    lists.push_back(&others);
+
+    for (list<list<Player*>* >::iterator i = lists.begin(); i != lists.end(); ++i)
+    {
+        list<Player*>* party = *i;
+        Unit* target = FindPartyMember(party, predicate);
+        if (target)
+            return target;
+    }
+
+    return NULL;
+}
+
+bool PartyMemberValue::Check(Unit* player)
+{
+
+
+    return player && player != bot && player->GetMapId() == bot->GetMapId() &&
+        bot->GetDistance(player) < sPlayerbotAIConfig.spellDistance &&
+        bot->IsWithinLOS(player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+}
+
+bool PartyMemberValue::IsTargetOfSpellCast(Player* target, SpellEntryPredicate &predicate)
+{
+
+    Group* group = bot->GetGroup();
+    ObjectGuid targetGuid = target ? target->GetGUID() : bot->GetGUID();
+    ObjectGuid corpseGuid = target && target->GetCorpse() ? target->GetCorpse()->GetGUID() : ObjectGuid();
+
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+        if (player == bot)
+            continue;
+
+        if (player->IsNonMeleeSpellCast(true))
+        {
+            for (int type = CURRENT_GENERIC_SPELL; type < CURRENT_MAX_SPELL; type++) {
+                Spell* spell = player->GetCurrentSpell((CurrentSpellTypes)type);
+                if (spell && predicate.Check(spell->m_spellInfo)) {
+                    ObjectGuid unitTarget = spell->m_targets.GetUnitTargetGUID();
+                    if (unitTarget == targetGuid)
+                        return true;
+
+                    ObjectGuid corpseTarget = spell->m_targets.GetCorpseTargetGUID();
+                    if (corpseTarget == corpseGuid)
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberValue.h b/src/plugins/playerbot/strategy/values/PartyMemberValue.h
new file mode 100644
index 0000000..5229b46
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberValue.h
@@ -0,0 +1,31 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class FindPlayerPredicate
+    {
+    public:
+        virtual bool Check(Unit*) = 0;
+    };
+
+    class SpellEntryPredicate
+    {
+    public:
+        virtual bool Check(SpellInfo const*) = 0;
+    };
+
+    class PartyMemberValue : public UnitCalculatedValue
+	{
+	public:
+        PartyMemberValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    public:
+        bool IsTargetOfSpellCast(Player* target, SpellEntryPredicate &predicate);
+
+    protected:
+        Unit* FindPartyMember(FindPlayerPredicate &predicate);
+        Unit* FindPartyMember(list<Player*>* party, FindPlayerPredicate &predicate);
+        bool Check(Unit* player);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
new file mode 100644
index 0000000..63f7008
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
@@ -0,0 +1,35 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberWithoutAuraValue.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class PlayerWithoutAuraPredicate : public FindPlayerPredicate, public PlayerbotAIAware
+{
+public:
+    PlayerWithoutAuraPredicate(PlayerbotAI* ai, string aura) :
+        PlayerbotAIAware(ai), FindPlayerPredicate(), aura(aura) {}
+
+public:
+    virtual bool Check(Unit* unit)
+    {
+        if (unit->IsPet())
+        {
+            Pet* pet = unit->ToPet();
+            if (pet && pet->getPetType() == SUMMON_PET)
+                return false;
+        }
+
+        return unit->IsAlive() && !ai->HasAura(aura, unit);
+    }
+
+private:
+    string aura;
+};
+
+Unit* PartyMemberWithoutAuraValue::Calculate()
+{
+	PlayerWithoutAuraPredicate predicate(ai, qualifier);
+    return FindPartyMember(predicate);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
new file mode 100644
index 0000000..63961de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class PartyMemberWithoutAuraValue : public PartyMemberValue, public Qualified
+	{
+	public:
+        PartyMemberWithoutAuraValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          PartyMemberValue(ai) {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PetTargetValue.h b/src/plugins/playerbot/strategy/values/PetTargetValue.h
new file mode 100644
index 0000000..35705c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PetTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class PetTargetValue : public UnitCalculatedValue
+	{
+	public:
+        PetTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return (Unit*)(ai->GetBot()->GetPet()); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/PositionValue.cpp b/src/plugins/playerbot/strategy/values/PositionValue.cpp
new file mode 100644
index 0000000..70424b0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PositionValue.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PositionValue.h"
+
+using namespace ai;
+
+PositionValue::PositionValue(PlayerbotAI* ai)
+    : ManualSetValue<ai::Position&>(ai, position), Qualified()
+{
+}
diff --git a/src/plugins/playerbot/strategy/values/PositionValue.h b/src/plugins/playerbot/strategy/values/PositionValue.h
new file mode 100644
index 0000000..4d453e1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PositionValue.h
@@ -0,0 +1,26 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class Position
+    {
+    public:
+        Position() : valueSet(false) {}
+        void Set(double x, double y, double z) { this->x = x; this->y = y; this->z = z; this->valueSet = true; }
+        void Reset() { valueSet = false; }
+        bool isSet() { return valueSet; }
+
+        double x, y, z;
+        bool valueSet;
+    };
+
+    class PositionValue : public ManualSetValue<Position&>, public Qualified
+	{
+	public:
+        PositionValue(PlayerbotAI* ai);
+
+	private:
+        Position position;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
new file mode 100644
index 0000000..17e1c27
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PossibleTargetsValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+void PossibleTargetsValue::FindUnits(list<Unit*> &targets)
+{
+    AnyUnfriendlyUnitInObjectRangeCheck u_check(bot, bot, range);
+    UnitListSearcher<AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool PossibleTargetsValue::AcceptUnit(Unit* unit)
+{
+    return !unit->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) &&
+            (unit->IsHostileTo(bot) || (unit->getLevel() > 1 && !unit->IsFriendlyTo(bot)));
+}
diff --git a/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
new file mode 100644
index 0000000..5a97a71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class PossibleTargetsValue : public NearestUnitsValue
+	{
+	public:
+        PossibleTargetsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        virtual void FindUnits(list<Unit*> &targets);
+        virtual bool AcceptUnit(Unit* unit);
+
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiTargetValue.h b/src/plugins/playerbot/strategy/values/RtiTargetValue.h
new file mode 100644
index 0000000..01aac86
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiTargetValue.h
@@ -0,0 +1,51 @@
+#pragma once
+#include "../Value.h"
+#include "../../../Groups/Group.h"
+
+namespace ai
+{
+    class RtiTargetValue : public UnitCalculatedValue
+    {
+    public:
+        RtiTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai)
+        {}
+
+    public:
+        static int GetRtiIndex(string rti)
+        {
+            int index = -1;
+            if(rti == "star") index = 0;
+            else if(rti == "circle") index = 1;
+            else if(rti == "diamond") index = 2;
+            else if(rti == "triangle") index = 3;
+            else if(rti == "moon") index = 4;
+            else if(rti == "square") index = 5;
+            else if(rti == "cross") index = 6;
+            else if(rti == "skull") index = 7;
+            return index;
+        }
+
+        Unit *Calculate()
+        {
+            Group *group = bot->GetGroup();
+            if(!group)
+                return NULL;
+
+            string rti = AI_VALUE(string, "rti");
+            int index = GetRtiIndex(rti);
+
+            if (index == -1)
+                return NULL;
+
+            uint64 guid = group->GetTargetIcon(index);
+            if (!guid)
+                return NULL;
+
+            Unit* unit = ai->GetUnit(ObjectGuid(guid));
+            if (!unit || unit->isDead())
+                return NULL;
+
+            return unit;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiValue.cpp b/src/plugins/playerbot/strategy/values/RtiValue.cpp
new file mode 100644
index 0000000..3698212
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RtiValue.h"
+
+using namespace ai;
+
+RtiValue::RtiValue(PlayerbotAI* ai)
+    : ManualSetValue<string>(ai, "none")
+{
+    switch (ai->GetBot()->getClass())
+    {
+    case CLASS_DRUID:
+        value = "circle";
+        break;
+    case CLASS_ROGUE:
+        value = "star";
+        break;
+    case CLASS_SHAMAN:
+        value = "square";
+        break;
+    case CLASS_HUNTER:
+        value = "triangle";
+        break;
+    case CLASS_WARLOCK:
+    case CLASS_PALADIN:
+        value = "diamond";
+        break;
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+        value = "moon";
+        break;
+    default:
+        value = "skull";
+        break;
+    }
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiValue.h b/src/plugins/playerbot/strategy/values/RtiValue.h
new file mode 100644
index 0000000..760485e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class RtiValue : public ManualSetValue<string>
+	{
+	public:
+        RtiValue(PlayerbotAI* ai);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SelfTargetValue.h b/src/plugins/playerbot/strategy/values/SelfTargetValue.h
new file mode 100644
index 0000000..f64a0fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SelfTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class SelfTargetValue : public UnitCalculatedValue
+	{
+	public:
+        SelfTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return ai->GetBot(); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
new file mode 100644
index 0000000..c9d6c5c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
@@ -0,0 +1,52 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SpellCastUsefulValue.h"
+#include "LastSpellCastValue.h"
+
+using namespace ai;
+
+bool SpellCastUsefulValue::Calculate()
+{
+    uint32 spellid = AI_VALUE2(uint32, "spell id", qualifier);
+	if (!spellid)
+		return true; // there can be known alternatives
+
+	SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+	if (!spellInfo)
+		return true; // there can be known alternatives
+
+	if (spellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING ||
+		spellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING_2)
+	{
+		Spell* spell = bot->GetCurrentSpell(CURRENT_MELEE_SPELL);
+		if (spell && spell->m_spellInfo->Id == spellid && spell->IsNextMeleeSwingSpell() && bot->HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+			return false;
+	}
+	else
+	{
+        uint32 lastSpellId = AI_VALUE(LastSpellCast&, "last spell cast").id;
+        if (spellid == lastSpellId)
+        {
+            Spell* const pSpell = bot->FindCurrentSpellBySpellId(lastSpellId);
+            if (pSpell)
+                return false;
+        }
+	}
+
+    if (spellInfo->IsAutoRepeatRangedSpell() && bot->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL) &&
+            bot->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL)->m_spellInfo->Id == spellid)
+    {
+        return false;
+    }
+
+    // TODO: workaround
+    if (qualifier == "windfury weapon" || qualifier == "flametongue weapon" || qualifier == "frostbrand weapon" ||
+            qualifier == "rockbiter weapon" || qualifier == "earthliving weapon" || qualifier == "spellstone")
+    {
+        Item *item = AI_VALUE2(Item*, "item for spell", spellid);
+        if (item && item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+            return false;
+    }
+
+	return true;
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
new file mode 100644
index 0000000..8fa9386
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class SpellCastUsefulValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        SpellCastUsefulValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+      
+    public:
+        virtual bool Calculate();
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellIdValue.cpp b/src/plugins/playerbot/strategy/values/SpellIdValue.cpp
new file mode 100644
index 0000000..61755b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellIdValue.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SpellIdValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+SpellIdValue::SpellIdValue(PlayerbotAI* ai) :
+        CalculatedValue<uint32>(ai, "spell id", 5)
+{
+}
+
+uint32 SpellIdValue::Calculate()
+{
+    string namepart = qualifier;
+    wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    wstrToLower(wnamepart);
+    char firstSymbol = tolower(qualifier[0]);
+    int spellLength = wnamepart.length();
+
+    int loc = bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL)
+            continue;
+
+        char* spellName = pSpellInfo->SpellName[loc];
+        if (tolower(spellName[0]) != firstSymbol || strlen(spellName) != spellLength || !Utf8FitTo(spellName, wnamepart))
+            continue;
+
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0);
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0) {
+            if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell) {
+            foundSpellId = spellId;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    Pet* pet = bot->GetPet();
+    if (!foundSpellId && pet)
+    {
+        for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+        {
+            if(itr->second.state == PETSPELL_REMOVED)
+                continue;
+
+            uint32 spellId = itr->first;
+            const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL)
+                continue;
+
+            char* spellName = pSpellInfo->SpellName[loc];
+            if (tolower(spellName[0]) != firstSymbol || strlen(spellName) != spellLength || !Utf8FitTo(spellName, wnamepart))
+                continue;
+
+            foundSpellId = spellId;
+        }
+    }
+
+    return foundSpellId;
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellIdValue.h b/src/plugins/playerbot/strategy/values/SpellIdValue.h
new file mode 100644
index 0000000..1281b38
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellIdValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class SpellIdValue : public CalculatedValue<uint32>, public Qualified
+	{
+	public:
+        SpellIdValue(PlayerbotAI* ai);
+
+    public:
+        virtual uint32 Calculate();
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/StatsValues.cpp b/src/plugins/playerbot/strategy/values/StatsValues.cpp
new file mode 100644
index 0000000..258a71b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/StatsValues.cpp
@@ -0,0 +1,120 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StatsValues.h"
+
+using namespace ai;
+
+uint8 HealthValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+    return (static_cast<float> (target->GetHealth()) / target->GetMaxHealth()) * 100;
+}
+
+bool IsDeadValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+    return target->getDeathState() != ALIVE;
+}
+
+
+uint8 RageValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 0;
+    return (static_cast<float> (target->GetPower(POWER_RAGE)));
+}
+
+uint8 EnergyValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 0;
+    return (static_cast<float> (target->GetPower(POWER_ENERGY)));
+}
+
+uint8 ManaValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+    return (static_cast<float> (target->GetPower(POWER_MANA)) / target->GetMaxPower(POWER_MANA)) * 100;
+}
+
+bool HasManaValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+    return target->GetPower(POWER_MANA);
+}
+
+
+uint8 ComboPointsValue::Calculate()
+{
+    Unit *target = GetTarget();
+    if (!target || target->GetGUID() != bot->GetComboTarget())
+        return 0;
+
+    return bot->GetComboPoints();
+}
+
+bool IsMountedValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+
+    return target->IsMounted();
+}
+
+
+bool IsInCombatValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+
+    return target->IsInCombat();
+}
+
+uint8 BagSpaceValue::Calculate()
+{
+    uint32 totalused = 0, total = 16;
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        if (bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+            totalused++;
+    }
+
+    uint32 totalfree = 16 - totalused;
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+            {
+                total += pBag->GetBagSize();
+                totalfree += pBag->GetFreeSlots();
+            }
+        }
+
+    }
+
+    return (static_cast<float> (totalused) / total) * 100;
+}
+
+uint8 SpeedValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+
+    return (uint8) (100.0f * target->GetSpeedRate(MOVE_RUN));
+}
diff --git a/src/plugins/playerbot/strategy/values/StatsValues.h b/src/plugins/playerbot/strategy/values/StatsValues.h
new file mode 100644
index 0000000..cc7b460
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/StatsValues.h
@@ -0,0 +1,146 @@
+#pragma once
+#include "../Value.h"
+
+class Unit;
+
+namespace ai
+{
+    class HealthValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        HealthValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class IsDeadValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsDeadValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class RageValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        RageValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class EnergyValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        EnergyValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class ManaValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        ManaValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class HasManaValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        HasManaValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class ComboPointsValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        ComboPointsValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class IsMountedValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsMountedValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class IsInCombatValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsInCombatValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate() ;
+    };
+
+    class BagSpaceValue : public Uint8CalculatedValue
+    {
+    public:
+        BagSpaceValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        virtual uint8 Calculate();
+    };
+
+    class SpeedValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        SpeedValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/values/TankTargetValue.cpp b/src/plugins/playerbot/strategy/values/TankTargetValue.cpp
new file mode 100644
index 0000000..01967f8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TankTargetValue.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankTargetValue.h"
+
+using namespace ai;
+
+class FindTargetForTankStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForTankStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minThreat = 0;
+        minTankCount = 0;
+        maxDpsCount = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        Player* bot = ai->GetBot();
+        float threat = threatManager->getThreat(bot);
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+
+        if (!result ||
+            (minThreat >= threat &&
+            (minTankCount >= tankCount || maxDpsCount <= dpsCount)))
+        {
+            minThreat = threat;
+            minTankCount = tankCount;
+            maxDpsCount = dpsCount;
+            result = creature;
+        }
+    }
+
+protected:
+    float minThreat;
+    int minTankCount;
+    int maxDpsCount;
+};
+
+
+Unit* TankTargetValue::Calculate()
+{
+    FindTargetForTankStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/TankTargetValue.h b/src/plugins/playerbot/strategy/values/TankTargetValue.h
new file mode 100644
index 0000000..f297eb0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TankTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class TankTargetValue : public TargetValue
+	{
+	public:
+        TankTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/TargetValue.cpp b/src/plugins/playerbot/strategy/values/TargetValue.cpp
new file mode 100644
index 0000000..2586bad
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TargetValue.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TargetValue.h"
+
+using namespace ai;
+
+Unit* TargetValue::FindTarget(FindTargetStrategy* strategy)
+{
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit)
+            continue;
+
+        ThreatManager &threatManager = unit->getThreatManager();
+        strategy->CheckAttacker(unit, &threatManager);
+    }
+
+    return strategy->GetResult();
+}
+
+void FindTargetStrategy::GetPlayerCount(Unit* creature, int* tankCount, int* dpsCount)
+{
+    Player* bot = ai->GetBot();
+    if (tankCountCache.find(creature) != tankCountCache.end())
+    {
+        *tankCount = tankCountCache[creature];
+        *dpsCount = dpsCountCache[creature];
+        return;
+    }
+
+    *tankCount = 0;
+    *dpsCount = 0;
+
+    for (HostileReference *ref = creature->getHostileRefManager().getFirst(); ref; ref = ref->next())
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        Player *player = dynamic_cast<Player*>(victim);
+
+        if (!player)
+            continue;
+
+        if (ai->IsTank(player))
+            (*tankCount)++;
+        else
+            (*dpsCount)++;
+    }
+
+    tankCountCache[creature] = *tankCount;
+    dpsCountCache[creature] = *dpsCount;
+}
diff --git a/src/plugins/playerbot/strategy/values/TargetValue.h b/src/plugins/playerbot/strategy/values/TargetValue.h
new file mode 100644
index 0000000..700d51d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TargetValue.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class FindTargetStrategy
+    {
+    public:
+        FindTargetStrategy(PlayerbotAI* ai)
+        {
+            result = NULL;
+            this->ai = ai;
+        }
+
+    public:
+        Unit* GetResult() { return result; }
+
+    public:
+        virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager) = 0;
+        void GetPlayerCount(Unit* creature, int* tankCount, int* dpsCount);
+
+    protected:
+        Unit* result;
+        PlayerbotAI* ai;
+
+    protected:
+        map<Unit*, int> tankCountCache;
+        map<Unit*, int> dpsCountCache;
+    };
+
+    class TargetValue : public UnitCalculatedValue
+	{
+	public:
+        TargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    protected:
+        Unit* FindTarget(FindTargetStrategy* strategy);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ThreatValues.cpp b/src/plugins/playerbot/strategy/values/ThreatValues.cpp
new file mode 100644
index 0000000..b0e0a00
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ThreatValues.cpp
@@ -0,0 +1,62 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ThreatValues.h"
+
+using namespace ai;
+
+uint8 ThreatValue::Calculate()
+{
+    if (qualifier == "aoe")
+    {
+        uint8 maxThreat = 0;
+        list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+        for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+        {
+            Unit* unit = ai->GetUnit(*i);
+            if (!unit || !unit->IsAlive())
+                continue;
+
+            uint8 threat = Calculate(unit);
+            if (!maxThreat || threat > maxThreat)
+                maxThreat = threat;
+        }
+
+        return maxThreat;
+    }
+
+    Unit* target = AI_VALUE(Unit*, qualifier);
+    return Calculate(target);
+}
+
+uint8 ThreatValue::Calculate(Unit* target)
+{
+    if (!target)
+        return 0;
+
+    if (dynamic_cast<Player*>(target))
+        return 0;
+
+    Group* group = bot->GetGroup();
+    if (!group)
+        return 0;
+
+    float botThreat = target->getThreatManager().getThreat(bot);
+    float maxThreat = 0;
+
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !player || !player->IsAlive() || player == bot)
+            continue;
+
+        float threat = target->getThreatManager().getThreat(player);
+        if (maxThreat < threat)
+            maxThreat = threat;
+    }
+
+    if (maxThreat <= 0)
+        return 0;
+
+    return botThreat * 100 / maxThreat;
+}
diff --git a/src/plugins/playerbot/strategy/values/ThreatValues.h b/src/plugins/playerbot/strategy/values/ThreatValues.h
new file mode 100644
index 0000000..7301f79
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ThreatValues.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ThreatValue : public Uint8CalculatedValue, public Qualified
+	{
+	public:
+        ThreatValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+    public:
+    	virtual uint8 Calculate();
+
+    protected:
+    	uint8 Calculate(Unit* target);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ValueContext.h b/src/plugins/playerbot/strategy/values/ValueContext.h
new file mode 100644
index 0000000..a10d432
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ValueContext.h
@@ -0,0 +1,232 @@
+#pragma once
+
+#include "NearestGameObjects.h"
+#include "LogLevelValue.h"
+#include "NearestNpcsValue.h"
+#include "PossibleTargetsValue.h"
+#include "NearestAdsValue.h"
+#include "NearestCorpsesValue.h"
+#include "PartyMemberWithoutAuraValue.h"
+#include "PartyMemberToHeal.h"
+#include "PartyMemberToResurrect.h"
+#include "CurrentTargetValue.h"
+#include "SelfTargetValue.h"
+#include "MasterTargetValue.h"
+#include "LineTargetValue.h"
+#include "TankTargetValue.h"
+#include "DpsTargetValue.h"
+#include "CcTargetValue.h"
+#include "CurrentCcTargetValue.h"
+#include "PetTargetValue.h"
+#include "GrindTargetValue.h"
+#include "RtiTargetValue.h"
+#include "PartyMemberToDispel.h"
+#include "StatsValues.h"
+#include "AttackerCountValues.h"
+#include "AttackersValue.h"
+#include "AvailableLootValue.h"
+#include "AlwaysLootListValue.h"
+#include "LootStrategyValue.h"
+#include "HasAvailableLootValue.h"
+#include "LastMovementValue.h"
+#include "DistanceValue.h"
+#include "IsMovingValue.h"
+#include "IsBehindValue.h"
+#include "IsFacingValue.h"
+#include "ItemCountValue.h"
+#include "SpellIdValue.h"
+#include "ItemForSpellValue.h"
+#include "SpellCastUsefulValue.h"
+#include "LastSpellCastValue.h"
+#include "ChatValue.h"
+#include "HasTotemValue.h"
+#include "LeastHpTargetValue.h"
+#include "AoeHealValues.h"
+#include "RtiValue.h"
+#include "PositionValue.h"
+#include "ThreatValues.h"
+#include "DuelTargetValue.h"
+#include "InvalidTargetValue.h"
+#include "EnemyPlayerValue.h"
+#include "AttackerWithoutAuraTargetValue.h"
+#include "LastSpellCastTimeValue.h"
+#include "ManaSaveLevelValue.h"
+#include "LfgValues.h"
+#include "EnemyHealerTargetValue.h"
+#include "Formations.h"
+#include "ItemUsageValue.h"
+#include "LastSaidValue.h"
+
+namespace ai
+{
+    class ValueContext : public NamedObjectContext<UntypedValue>
+    {
+    public:
+        ValueContext()
+        {
+            creators["nearest game objects"] = &ValueContext::nearest_game_objects;
+            creators["nearest npcs"] = &ValueContext::nearest_npcs;
+            creators["possible targets"] = &ValueContext::possible_targets;
+            creators["nearest adds"] = &ValueContext::nearest_adds;
+            creators["nearest corpses"] = &ValueContext::nearest_corpses;
+            creators["log level"] = &ValueContext::log_level;
+            creators["party member without aura"] = &ValueContext::party_member_without_aura;
+            creators["attacker without aura"] = &ValueContext::attacker_without_aura;
+            creators["party member to heal"] = &ValueContext::party_member_to_heal;
+            creators["party member to resurrect"] = &ValueContext::party_member_to_resurrect;
+            creators["current target"] = &ValueContext::current_target;
+            creators["self target"] = &ValueContext::self_target;
+            creators["master target"] = &ValueContext::master;
+            creators["line target"] = &ValueContext::line_target;
+            creators["tank target"] = &ValueContext::tank_target;
+            creators["dps target"] = &ValueContext::dps_target;
+            creators["least hp target"] = &ValueContext::least_hp_target;
+            creators["enemy player target"] = &ValueContext::enemy_player_target;
+            creators["cc target"] = &ValueContext::cc_target;
+            creators["current cc target"] = &ValueContext::current_cc_target;
+            creators["pet target"] = &ValueContext::pet_target;
+            creators["old target"] = &ValueContext::old_target;
+            creators["grind target"] = &ValueContext::grind_target;
+            creators["rti target"] = &ValueContext::rti_target;
+            creators["duel target"] = &ValueContext::duel_target;
+            creators["party member to dispel"] = &ValueContext::party_member_to_dispel;
+            creators["health"] = &ValueContext::health;
+            creators["rage"] = &ValueContext::rage;
+            creators["energy"] = &ValueContext::energy;
+            creators["mana"] = &ValueContext::mana;
+            creators["combo"] = &ValueContext::combo;
+            creators["dead"] = &ValueContext::dead;
+            creators["has mana"] = &ValueContext::has_mana;
+            creators["attacker count"] = &ValueContext::attacker_count;
+            creators["my attacker count"] = &ValueContext::my_attacker_count;
+            creators["has aggro"] = &ValueContext::has_aggro;
+            creators["mounted"] = &ValueContext::mounted;
+
+            creators["can loot"] = &ValueContext::can_loot;
+            creators["loot target"] = &ValueContext::loot_target;
+            creators["available loot"] = &ValueContext::available_loot;
+            creators["has available loot"] = &ValueContext::has_available_loot;
+            creators["always loot list"] = &ValueContext::always_loot_list;
+            creators["loot strategy"] = &ValueContext::loot_strategy;
+            creators["last movement"] = &ValueContext::last_movement;
+            creators["distance"] = &ValueContext::distance;
+            creators["moving"] = &ValueContext::moving;
+            creators["swimming"] = &ValueContext::swimming;
+            creators["behind"] = &ValueContext::behind;
+            creators["facing"] = &ValueContext::facing;
+
+            creators["item count"] = &ValueContext::item_count;
+            creators["inventory items"] = &ValueContext::inventory_item;
+
+            creators["spell id"] = &ValueContext::spell_id;
+            creators["item for spell"] = &ValueContext::item_for_spell;
+            creators["spell cast useful"] = &ValueContext::spell_cast_useful;
+            creators["last spell cast"] = &ValueContext::last_spell_cast;
+            creators["last spell cast time"] = &ValueContext::last_spell_cast_time;
+            creators["chat"] = &ValueContext::chat;
+            creators["has totem"] = &ValueContext::has_totem;
+
+            creators["aoe heal"] = &ValueContext::aoe_heal;
+
+            creators["rti"] = &ValueContext::rti;
+            creators["position"] = &ValueContext::position;
+            creators["threat"] = &ValueContext::threat;
+
+            creators["balance"] = &ValueContext::balance;
+            creators["attackers"] = &ValueContext::attackers;
+            creators["invalid target"] = &ValueContext::invalid_target;
+            creators["mana save level"] = &ValueContext::mana_save_level;
+            creators["combat"] = &ValueContext::combat;
+            creators["lfg proposal"] = &ValueContext::lfg_proposal;
+            creators["bag space"] = &ValueContext::bag_space;
+            creators["enemy healer target"] = &ValueContext::enemy_healer_target;
+            creators["formation"] = &ValueContext::formation;
+            creators["item usage"] = &ValueContext::item_usage;
+            creators["speed"] = &ValueContext::speed;
+            creators["last said"] = &ValueContext::last_said;
+            creators["last emote"] = &ValueContext::last_emote;
+        }
+
+    private:
+        static UntypedValue* item_usage(PlayerbotAI* ai) { return new ItemUsageValue(ai); }
+        static UntypedValue* formation(PlayerbotAI* ai) { return new FormationValue(ai); }
+        static UntypedValue* mana_save_level(PlayerbotAI* ai) { return new ManaSaveLevelValue(ai); }
+        static UntypedValue* invalid_target(PlayerbotAI* ai) { return new InvalidTargetValue(ai); }
+        static UntypedValue* balance(PlayerbotAI* ai) { return new BalancePercentValue(ai); }
+        static UntypedValue* attackers(PlayerbotAI* ai) { return new AttackersValue(ai); }
+
+        static UntypedValue* position(PlayerbotAI* ai) { return new PositionValue(ai); }
+        static UntypedValue* rti(PlayerbotAI* ai) { return new RtiValue(ai); }
+
+        static UntypedValue* aoe_heal(PlayerbotAI* ai) { return new AoeHealValue(ai); }
+
+        static UntypedValue* chat(PlayerbotAI* ai) { return new ChatValue(ai); }
+        static UntypedValue* last_spell_cast(PlayerbotAI* ai) { return new LastSpellCastValue(ai); }
+        static UntypedValue* last_spell_cast_time(PlayerbotAI* ai) { return new LastSpellCastTimeValue(ai); }
+        static UntypedValue* spell_cast_useful(PlayerbotAI* ai) { return new SpellCastUsefulValue(ai); }
+        static UntypedValue* item_for_spell(PlayerbotAI* ai) { return new ItemForSpellValue(ai); }
+        static UntypedValue* spell_id(PlayerbotAI* ai) { return new SpellIdValue(ai); }
+        static UntypedValue* inventory_item(PlayerbotAI* ai) { return new InventoryItemValue(ai); }
+        static UntypedValue* item_count(PlayerbotAI* ai) { return new ItemCountValue(ai); }
+        static UntypedValue* behind(PlayerbotAI* ai) { return new IsBehindValue(ai); }
+        static UntypedValue* facing(PlayerbotAI* ai) { return new IsFacingValue(ai); }
+        static UntypedValue* moving(PlayerbotAI* ai) { return new IsMovingValue(ai); }
+        static UntypedValue* swimming(PlayerbotAI* ai) { return new IsSwimmingValue(ai); }
+        static UntypedValue* distance(PlayerbotAI* ai) { return new DistanceValue(ai); }
+        static UntypedValue* last_movement(PlayerbotAI* ai) { return new LastMovementValue(ai); }
+
+        static UntypedValue* can_loot(PlayerbotAI* ai) { return new CanLootValue(ai); }
+        static UntypedValue* available_loot(PlayerbotAI* ai) { return new AvailableLootValue(ai); }
+        static UntypedValue* loot_target(PlayerbotAI* ai) { return new LootTargetValue(ai); }
+        static UntypedValue* has_available_loot(PlayerbotAI* ai) { return new HasAvailableLootValue(ai); }
+        static UntypedValue* always_loot_list(PlayerbotAI* ai) { return new AlwaysLootListValue(ai); }
+        static UntypedValue* loot_strategy(PlayerbotAI* ai) { return new LootStrategyValue(ai); }
+
+        static UntypedValue* attacker_count(PlayerbotAI* ai) { return new AttackerCountValue(ai); }
+        static UntypedValue* my_attacker_count(PlayerbotAI* ai) { return new MyAttackerCountValue(ai); }
+        static UntypedValue* has_aggro(PlayerbotAI* ai) { return new HasAggroValue(ai); }
+        static UntypedValue* mounted(PlayerbotAI* ai) { return new IsMountedValue(ai); }
+        static UntypedValue* health(PlayerbotAI* ai) { return new HealthValue(ai); }
+        static UntypedValue* rage(PlayerbotAI* ai) { return new RageValue(ai); }
+        static UntypedValue* energy(PlayerbotAI* ai) { return new EnergyValue(ai); }
+        static UntypedValue* mana(PlayerbotAI* ai) { return new ManaValue(ai); }
+        static UntypedValue* combo(PlayerbotAI* ai) { return new ComboPointsValue(ai); }
+        static UntypedValue* dead(PlayerbotAI* ai) { return new IsDeadValue(ai); }
+        static UntypedValue* has_mana(PlayerbotAI* ai) { return new HasManaValue(ai); }
+        static UntypedValue* nearest_game_objects(PlayerbotAI* ai) { return new NearestGameObjects(ai); }
+        static UntypedValue* log_level(PlayerbotAI* ai) { return new LogLevelValue(ai); }
+        static UntypedValue* nearest_npcs(PlayerbotAI* ai) { return new NearestNpcsValue(ai); }
+        static UntypedValue* nearest_corpses(PlayerbotAI* ai) { return new NearestCorpsesValue(ai); }
+        static UntypedValue* possible_targets(PlayerbotAI* ai) { return new PossibleTargetsValue(ai); }
+        static UntypedValue* nearest_adds(PlayerbotAI* ai) { return new NearestAdsValue(ai); }
+        static UntypedValue* party_member_without_aura(PlayerbotAI* ai) { return new PartyMemberWithoutAuraValue(ai); }
+        static UntypedValue* attacker_without_aura(PlayerbotAI* ai) { return new AttackerWithoutAuraTargetValue(ai); }
+        static UntypedValue* party_member_to_heal(PlayerbotAI* ai) { return new PartyMemberToHeal(ai); }
+        static UntypedValue* party_member_to_resurrect(PlayerbotAI* ai) { return new PartyMemberToResurrect(ai); }
+        static UntypedValue* party_member_to_dispel(PlayerbotAI* ai) { return new PartyMemberToDispel(ai); }
+        static UntypedValue* current_target(PlayerbotAI* ai) { return new CurrentTargetValue(ai); }
+        static UntypedValue* old_target(PlayerbotAI* ai) { return new CurrentTargetValue(ai); }
+        static UntypedValue* self_target(PlayerbotAI* ai) { return new SelfTargetValue(ai); }
+        static UntypedValue* master(PlayerbotAI* ai) { return new MasterTargetValue(ai); }
+        static UntypedValue* line_target(PlayerbotAI* ai) { return new LineTargetValue(ai); }
+        static UntypedValue* tank_target(PlayerbotAI* ai) { return new TankTargetValue(ai); }
+        static UntypedValue* dps_target(PlayerbotAI* ai) { return new DpsTargetValue(ai); }
+        static UntypedValue* least_hp_target(PlayerbotAI* ai) { return new LeastHpTargetValue(ai); }
+        static UntypedValue* enemy_player_target(PlayerbotAI* ai) { return new EnemyPlayerValue(ai); }
+        static UntypedValue* cc_target(PlayerbotAI* ai) { return new CcTargetValue(ai); }
+        static UntypedValue* current_cc_target(PlayerbotAI* ai) { return new CurrentCcTargetValue(ai); }
+        static UntypedValue* pet_target(PlayerbotAI* ai) { return new PetTargetValue(ai); }
+        static UntypedValue* grind_target(PlayerbotAI* ai) { return new GrindTargetValue(ai); }
+        static UntypedValue* rti_target(PlayerbotAI* ai) { return new RtiTargetValue(ai); }
+        static UntypedValue* duel_target(PlayerbotAI* ai) { return new DuelTargetValue(ai); }
+        static UntypedValue* has_totem(PlayerbotAI* ai) { return new HasTotemValue(ai); }
+        static UntypedValue* threat(PlayerbotAI* ai) { return new ThreatValue(ai); }
+        static UntypedValue* combat(PlayerbotAI* ai) { return new IsInCombatValue(ai); }
+        static UntypedValue* lfg_proposal(PlayerbotAI* ai) { return new LfgProposalValue(ai); }
+        static UntypedValue* bag_space(PlayerbotAI* ai) { return new BagSpaceValue(ai); }
+        static UntypedValue* enemy_healer_target(PlayerbotAI* ai) { return new EnemyHealerTargetValue(ai); }
+        static UntypedValue* speed(PlayerbotAI* ai) { return new SpeedValue(ai); }
+        static UntypedValue* last_said(PlayerbotAI* ai) { return new LastSaidValue(ai); }
+        static UntypedValue* last_emote(PlayerbotAI* ai) { return new LastEmoteValue(ai); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/values/formations/Arrow.cpp b/src/plugins/playerbot/strategy/values/formations/Arrow.cpp
new file mode 100644
index 0000000..7b3a07f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/formations/Arrow.cpp
@@ -0,0 +1,162 @@
+#include "../../../../pchdef.h"
+#include "../../../playerbot.h"
+#include "../Formations.h"
+#include "Arrow.h"
+
+using namespace ai;
+
+WorldLocation ArrowFormation::GetLocation()
+{
+    Build();
+
+    int tankLines = 1 + tanks.Size() / 6;
+    int meleeLines = 1 + melee.Size() / 6;
+    int rangedLines = 1 + ranged.Size() / 6;
+    int healerLines = 1 + healers.Size() / 6;
+    float offset = 0;
+
+    Player* master = ai->GetMaster();
+    float orientation = master->GetOrientation();
+    MultiLineUnitPlacer placer(orientation);
+
+    tanks.PlaceUnits(&placer);
+
+    offset = tankLines * sPlayerbotAIConfig.followDistance;
+    melee.PlaceUnits(&placer);
+    melee.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    offset += meleeLines * sPlayerbotAIConfig.followDistance + sPlayerbotAIConfig.tooCloseDistance;
+    ranged.PlaceUnits(&placer);
+    ranged.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    offset += rangedLines * sPlayerbotAIConfig.followDistance;
+    healers.PlaceUnits(&placer);
+    healers.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    float x = master->GetPositionX() - masterUnit->GetX() + botUnit->GetX();
+    float y = master->GetPositionY() - masterUnit->GetY() + botUnit->GetY();
+    float z = master->GetPositionZ();
+
+    float ground = master->GetMap()->GetHeight(x, y, z + 0.5f);
+    if (ground <= INVALID_HEIGHT)
+        return Formation::NullLocation;
+
+    return WorldLocation(master->GetMapId(), x, y, 0.05f + ground);
+
+
+}
+
+void ArrowFormation::Build()
+{
+    if (built)
+        return;
+
+    FillSlotsExceptMaster();
+    AddMasterToSlot();
+
+    built = true;
+}
+
+FormationSlot* ArrowFormation::FindSlot(Player* member)
+{
+    if (ai->IsTank(member))
+        return &tanks;
+    else if (ai->IsHeal(member))
+        return &healers;
+    else if (ai->IsRanged(member))
+        return &ranged;
+    else
+        return &melee;
+}
+
+void ArrowFormation::FillSlotsExceptMaster()
+{
+    Group* group = bot->GetGroup();
+    GroupReference *gref = group->GetFirstMember();
+    uint32 index = 0;
+    while (gref)
+    {
+        Player* member = gref->GetSource();
+
+        if (member == bot)
+            FindSlot(member)->AddLast(botUnit = new FormationUnit(index, false));
+        else if (member != ai->GetMaster())
+            FindSlot(member)->AddLast(new FormationUnit(index, false));
+
+        gref = gref->next();
+        index++;
+    }
+}
+
+void ArrowFormation::AddMasterToSlot()
+{
+    Group* group = bot->GetGroup();
+    GroupReference *gref = group->GetFirstMember();
+    uint32 index = 0;
+    while (gref)
+    {
+        Player* member = gref->GetSource();
+
+        if (member == ai->GetMaster())
+        {
+            FindSlot(member)->InsertAtCenter(masterUnit = new FormationUnit(index, true));
+            break;
+        }
+
+        gref = gref->next();
+        index++;
+    }
+}
+
+void FormationSlot::PlaceUnits(UnitPlacer* placer)
+{
+    uint32 index = 0;
+    uint32 count = units.size();
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        unit->SetLocation(placer->Place(unit, index, count));
+        index++;
+    }
+}
+
+UnitPosition MultiLineUnitPlacer::Place(FormationUnit *unit, uint32 index, uint32 count)
+{
+    SingleLineUnitPlacer placer(orientation);
+    if (count <= 6)
+        return placer.Place(unit, index, count);
+
+    int lineNo = index / 6;
+    int indexInLine = index % 6;
+    int lineSize = max(count - lineNo * 6, uint32(6));
+    float x = cos(orientation) * sPlayerbotAIConfig.followDistance * lineNo;
+    float y = sin(orientation) * sPlayerbotAIConfig.followDistance * lineNo;
+    return placer.Place(unit, indexInLine, lineSize);
+}
+
+UnitPosition SingleLineUnitPlacer::Place(FormationUnit *unit, uint32 index, uint32 count)
+{
+    float angle = orientation - M_PI / 2.0f;
+    float x = cos(angle) * sPlayerbotAIConfig.followDistance * ((float)index - (float)count / 2);
+    float y = sin(angle) * sPlayerbotAIConfig.followDistance * ((float)index - (float)count / 2);
+    return UnitPosition(x, y);
+}
+
+void FormationSlot::Move(float dx, float dy)
+{
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        unit->SetLocation(unit->GetX() + dx, unit->GetY() + dy);
+    }
+}
+
+FormationSlot::~FormationSlot()
+{
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        delete unit;
+    }
+    units.clear();
+}
diff --git a/src/plugins/playerbot/strategy/values/formations/Arrow.h b/src/plugins/playerbot/strategy/values/formations/Arrow.h
new file mode 100644
index 0000000..e302c87
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/formations/Arrow.h
@@ -0,0 +1,109 @@
+#pragma once
+
+namespace ai
+{
+    class UnitPosition
+    {
+    public:
+        UnitPosition(float x, float y) : x(x), y(y) {}
+        UnitPosition(const UnitPosition& other) { x = other.x; y = other.y; }
+        float x, y;
+    };
+
+    class FormationUnit
+    {
+    public:
+        FormationUnit(uint32 groupIndex, bool master) : groupIndex(groupIndex), master(master), position(0, 0) {}
+        FormationUnit(const FormationUnit& other) : position(other.position.x, other.position.y)
+        {
+            groupIndex = other.groupIndex;
+            master = other.master;
+        }
+
+    public:
+        uint32 GetGroupIdex() { return groupIndex; }
+        void SetLocation(UnitPosition pos) { position = pos; }
+        void SetLocation(float x, float y) { position.x = x; position.y = y; }
+        float GetX() { return position.x; }
+        float GetY() { return position.y; }
+
+    private:
+        uint32 groupIndex;
+        bool master;
+        UnitPosition position;
+    };
+
+    class UnitPlacer
+    {
+    public:
+        UnitPlacer() {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count) = 0;
+    };
+
+    class FormationSlot
+    {
+    public:
+        FormationSlot() {}
+        virtual ~FormationSlot();
+
+    public:
+        void AddLast(FormationUnit* unit) { units.push_back(unit); }
+        void InsertAtCenter(FormationUnit* unit) { units.insert(units.begin() + (units.size() + 1) / 2, unit); }
+        void PlaceUnits(UnitPlacer* placer);
+        void Move(float dx, float dy);
+        int Size() { return units.size(); }
+
+    private:
+        WorldLocation center;
+        vector<FormationUnit*> units;
+    };
+
+
+    class MultiLineUnitPlacer : public UnitPlacer
+    {
+    public:
+        MultiLineUnitPlacer(float orientation) : UnitPlacer(), orientation(orientation) {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count);
+
+    private:
+        float orientation;
+    };
+
+    class SingleLineUnitPlacer
+    {
+    public:
+        SingleLineUnitPlacer(float orientation) : orientation(orientation) {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count);
+
+    private:
+        float orientation;
+    };
+
+    class ArrowFormation : public MoveFormation
+    {
+    public:
+        ArrowFormation(PlayerbotAI* ai) : MoveFormation(ai, "arrow"), built(false), masterUnit(NULL), botUnit(NULL) {}
+
+    public:
+        virtual WorldLocation GetLocation();
+
+    private:
+        void Build();
+        void FillSlotsExceptMaster();
+        void AddMasterToSlot();
+        FormationSlot* FindSlot(Player* member);
+
+    private:
+        FormationSlot tanks, melee, ranged, healers;
+        FormationUnit *masterUnit, *botUnit;
+        bool built;
+    };
+
+}
+
diff --git a/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
new file mode 100644
index 0000000..039fd53
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
@@ -0,0 +1,76 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockTriggers.h"
+#include "WarlockMultipliers.h"
+#include "DpsWarlockStrategy.h"
+#include "WarlockActions.h"
+
+using namespace ai;
+
+class DpsWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsWarlockStrategyActionNodeFactory()
+    {
+        creators["shadow bolt"] = &shadow_bolt;
+    }
+private:
+    static ActionNode* shadow_bolt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shadow bolt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsWarlockStrategy::DpsWarlockStrategy(PlayerbotAI* ai) : GenericWarlockStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsWarlockStrategyActionNodeFactory());
+}
+
+
+NextAction** DpsWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("incinirate", 10.0f), new NextAction("shadow bolt", 10.0f), NULL);
+}
+
+void DpsWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarlockStrategy::InitTriggers(triggers);
+
+	triggers.push_back(new TriggerNode(
+		"shadow trance",
+		NextAction::array(0, new NextAction("shadow bolt", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"backlash",
+		NextAction::array(0, new NextAction("shadow bolt", 20.0f), NULL)));
+}
+
+void DpsAoeWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "high aoe",
+        NextAction::array(0, new NextAction("rain of fire", 30.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("seed of corruption", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("shadowfury", 29.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "corruption on attacker",
+        NextAction::array(0, new NextAction("corruption on attacker", 28.0f), NULL)));
+
+}
+
+void DpsWarlockDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "corruption",
+        NextAction::array(0, new NextAction("corruption", 12.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
new file mode 100644
index 0000000..846f9df
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericWarlockStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class DpsWarlockStrategy : public GenericWarlockStrategy
+    {
+    public:
+        DpsWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "dps"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+
+    class DpsAoeWarlockStrategy : public CombatStrategy
+    {
+    public:
+        DpsAoeWarlockStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+
+    class DpsWarlockDebuffStrategy : public CombatStrategy
+    {
+    public:
+        DpsWarlockDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps debuff"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
new file mode 100644
index 0000000..3dc73c6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "GenericWarlockNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockNonCombatStrategyActionNodeFactory()
+    {
+        creators["fel armor"] = &fel_armor;
+        creators["demon armor"] = &demon_armor;
+    }
+private:
+    static ActionNode* fel_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("fel armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("demon armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* demon_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("demon armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("demon skin"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarlockNonCombatStrategy::GenericWarlockNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockNonCombatStrategyActionNodeFactory());
+}
+
+void GenericWarlockNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "demon armor",
+        NextAction::array(0, new NextAction("fel armor", 21.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no healthstone",
+		NextAction::array(0, new NextAction("create healthstone", 15.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no firestone",
+		NextAction::array(0, new NextAction("create firestone", 14.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no spellstone",
+		NextAction::array(0, new NextAction("create spellstone", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "spellstone",
+        NextAction::array(0, new NextAction("spellstone", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("summon imp", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
new file mode 100644
index 0000000..c5e483f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarlockNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericWarlockNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
new file mode 100644
index 0000000..e880061
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
@@ -0,0 +1,74 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "GenericWarlockStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockStrategyActionNodeFactory()
+    {
+        creators["summon voidwalker"] = &summon_voidwalker;
+        creators["banish"] = &banish;
+    }
+private:
+    static ActionNode* summon_voidwalker(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon voidwalker",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drain soul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* banish(PlayerbotAI* ai)
+    {
+        return new ActionNode ("banish",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("fear"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarlockStrategy::GenericWarlockStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockStrategyActionNodeFactory());
+}
+
+NextAction** GenericWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void GenericWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "curse of agony",
+        NextAction::array(0, new NextAction("curse of agony", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("drain life", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("life tap", ACTION_EMERGENCY + 5), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"target critical health",
+		NextAction::array(0, new NextAction("drain soul", 30.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "banish",
+        NextAction::array(0, new NextAction("banish", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "fear",
+        NextAction::array(0, new NextAction("fear on cc", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "immolate",
+        NextAction::array(0, new NextAction("immolate", 19.0f), new NextAction("conflagrate", 19.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
new file mode 100644
index 0000000..473da59
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarlockStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "warlock"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
new file mode 100644
index 0000000..cb4f5a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "TankWarlockStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockStrategyActionNodeFactory()
+    {
+        creators["summon voidwalker"] = &summon_voidwalker;
+        creators["summon felguard"] = &summon_felguard;
+    }
+private:
+    static ActionNode* summon_voidwalker(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon voidwalker",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drain soul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* summon_felguard(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon felguard",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("summon voidwalker"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankWarlockStrategy::TankWarlockStrategy(PlayerbotAI* ai) : GenericWarlockStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockStrategyActionNodeFactory());
+}
+
+NextAction** TankWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void TankWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarlockStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("summon felguard", 50.0f), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
new file mode 100644
index 0000000..9cdd6e6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericWarlockStrategy.h"
+
+namespace ai
+{
+    class TankWarlockStrategy : public GenericWarlockStrategy
+    {
+    public:
+        TankWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "tank"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp b/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
new file mode 100644
index 0000000..0a01ebb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockActions.h b/src/plugins/playerbot/strategy/warlock/WarlockActions.h
new file mode 100644
index 0000000..fb1689a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockActions.h
@@ -0,0 +1,176 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+	class CastDemonSkinAction : public CastBuffSpellAction {
+	public:
+		CastDemonSkinAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "demon skin") {}
+	};
+
+	class CastDemonArmorAction : public CastBuffSpellAction
+	{
+	public:
+		CastDemonArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "demon armor") {}
+	};
+
+	class CastFelArmorAction : public CastBuffSpellAction
+	{
+	public:
+		CastFelArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fel armor") {}
+	};
+
+    BEGIN_RANGED_SPELL_ACTION(CastShadowBoltAction, "shadow bolt")
+    END_SPELL_ACTION()
+
+	class CastDrainSoulAction : public CastSpellAction
+	{
+	public:
+		CastDrainSoulAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain soul") {}
+		virtual bool isUseful()
+		{
+			return AI_VALUE2(uint8, "item count", "soul shard") < 2;
+		}
+	};
+
+	class CastDrainManaAction : public CastSpellAction
+	{
+	public:
+		CastDrainManaAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain mana") {}
+	};
+
+	class CastDrainLifeAction : public CastSpellAction
+	{
+	public:
+		CastDrainLifeAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain life") {}
+	};
+
+	class CastCurseOfAgonyAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCurseOfAgonyAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "curse of agony") {}
+	};
+
+	class CastCurseOfWeaknessAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCurseOfWeaknessAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "curse of weakness") {}
+	};
+
+	class CastCorruptionAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCorruptionAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "corruption") {}
+	};
+
+	class CastCorruptionOnAttackerAction : public CastDebuffSpellOnAttackerAction
+	{
+	public:
+	    CastCorruptionOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "corruption") {}
+	};
+
+
+	class CastSummonVoidwalkerAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonVoidwalkerAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon voidwalker") {}
+	};
+
+	class CastSummonFelguardAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonFelguardAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon felguard") {}
+	};
+
+	class CastSummonImpAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonImpAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon imp") {}
+	};
+
+	class CastCreateHealthstoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateHealthstoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create healthstone") {}
+	};
+
+	class CastCreateFirestoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateFirestoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create firestone") {}
+	};
+
+	class CastCreateSpellstoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateSpellstoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create spellstone") {}
+	};
+
+    class CastBanishAction : public CastBuffSpellAction
+    {
+    public:
+        CastBanishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "banish on cc") {}
+        virtual Value<Unit*>* GetTargetValue() { return context->GetValue<Unit*>("cc target", "banish"); }
+        virtual bool Execute(Event event) { return ai->CastSpell("banish", GetTarget()); }
+    };
+
+    class CastSeedOfCorruptionAction : public CastDebuffSpellAction
+    {
+    public:
+        CastSeedOfCorruptionAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "seed of corruption") {}
+    };
+
+    class CastRainOfFireAction : public CastSpellAction
+    {
+    public:
+        CastRainOfFireAction(PlayerbotAI* ai) : CastSpellAction(ai, "rain of fire") {}
+    };
+
+    class CastShadowfuryAction : public CastSpellAction
+    {
+    public:
+        CastShadowfuryAction(PlayerbotAI* ai) : CastSpellAction(ai, "shadowfury") {}
+    };
+
+    class CastImmolateAction : public CastDebuffSpellAction
+    {
+    public:
+        CastImmolateAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "immolate") {}
+    };
+
+    class CastConflagrateAction : public CastSpellAction
+    {
+    public:
+        CastConflagrateAction(PlayerbotAI* ai) : CastSpellAction(ai, "conflagrate") {}
+    };
+
+    class CastIncinirateAction : public CastSpellAction
+    {
+    public:
+        CastIncinirateAction(PlayerbotAI* ai) : CastSpellAction(ai, "incinirate") {}
+    };
+
+    class CastFearAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFearAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "fear") {}
+    };
+
+    class CastFearOnCcAction : public CastBuffSpellAction
+    {
+    public:
+        CastFearOnCcAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fear on cc") {}
+        virtual Value<Unit*>* GetTargetValue() { return context->GetValue<Unit*>("cc target", "fear"); }
+        virtual bool Execute(Event event) { return ai->CastSpell("fear", GetTarget()); }
+    };
+
+    class CastLifeTapAction: public CastSpellAction
+    {
+    public:
+        CastLifeTapAction(PlayerbotAI* ai) : CastSpellAction(ai, "life tap") {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful() { return AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.lowHealth; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
new file mode 100644
index 0000000..8c25fd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
@@ -0,0 +1,183 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockActions.h"
+#include "WarlockAiObjectContext.h"
+#include "DpsWarlockStrategy.h"
+#include "GenericWarlockNonCombatStrategy.h"
+#include "TankWarlockStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "WarlockTriggers.h"
+#include "../NamedObjectContext.h"
+#include "../actions/UseItemAction.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &warlock::StrategyFactoryInternal::nc;
+                creators["pull"] = &warlock::StrategyFactoryInternal::pull;
+                creators["aoe"] = &warlock::StrategyFactoryInternal::aoe;
+                creators["dps debuff"] = &warlock::StrategyFactoryInternal::dps_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericWarlockNonCombatStrategy(ai); }
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsAoeWarlockStrategy(ai); }
+            static Strategy* dps_debuff(PlayerbotAI* ai) { return new DpsWarlockDebuffStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["dps"] = &warlock::CombatStrategyFactoryInternal::dps;
+                creators["tank"] = &warlock::CombatStrategyFactoryInternal::tank;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankWarlockStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsWarlockStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["shadow trance"] = &TriggerFactoryInternal::shadow_trance;
+                creators["demon armor"] = &TriggerFactoryInternal::demon_armor;
+                creators["no healthstone"] = &TriggerFactoryInternal::HasHealthstone;
+                creators["no firestone"] = &TriggerFactoryInternal::HasFirestone;
+                creators["no spellstone"] = &TriggerFactoryInternal::HasSpellstone;
+                creators["corruption"] = &TriggerFactoryInternal::corruption;
+                creators["corruption on attacker"] = &TriggerFactoryInternal::corruption_on_attacker;
+                creators["curse of agony"] = &TriggerFactoryInternal::curse_of_agony;
+                creators["banish"] = &TriggerFactoryInternal::banish;
+                creators["spellstone"] = &TriggerFactoryInternal::spellstone;
+                creators["backlash"] = &TriggerFactoryInternal::backlash;
+                creators["fear"] = &TriggerFactoryInternal::fear;
+                creators["immolate"] = &TriggerFactoryInternal::immolate;
+
+
+            }
+
+        private:
+            static Trigger* shadow_trance(PlayerbotAI* ai) { return new ShadowTranceTrigger(ai); }
+            static Trigger* demon_armor(PlayerbotAI* ai) { return new DemonArmorTrigger(ai); }
+            static Trigger* HasHealthstone(PlayerbotAI* ai) { return new HasHealthstoneTrigger(ai); }
+            static Trigger* HasFirestone(PlayerbotAI* ai) { return new HasFirestoneTrigger(ai); }
+            static Trigger* HasSpellstone(PlayerbotAI* ai) { return new HasSpellstoneTrigger(ai); }
+            static Trigger* corruption(PlayerbotAI* ai) { return new CorruptionTrigger(ai); }
+            static Trigger* corruption_on_attacker(PlayerbotAI* ai) { return new CorruptionOnAttackerTrigger(ai); }
+            static Trigger* curse_of_agony(PlayerbotAI* ai) { return new CurseOfAgonyTrigger(ai); }
+            static Trigger* banish(PlayerbotAI* ai) { return new BanishTrigger(ai); }
+            static Trigger* spellstone(PlayerbotAI* ai) { return new SpellstoneTrigger(ai); }
+            static Trigger* backlash(PlayerbotAI* ai) { return new BacklashTrigger(ai); }
+            static Trigger* fear(PlayerbotAI* ai) { return new FearTrigger(ai); }
+            static Trigger* immolate(PlayerbotAI* ai) { return new ImmolateTrigger(ai); }
+
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["summon imp"] = &AiObjectContextInternal::summon_imp;
+                creators["fel armor"] = &AiObjectContextInternal::fel_armor;
+                creators["demon armor"] = &AiObjectContextInternal::demon_armor;
+                creators["demon skin"] = &AiObjectContextInternal::demon_skin;
+                creators["create healthstone"] = &AiObjectContextInternal::create_healthstone;
+                creators["create firestone"] = &AiObjectContextInternal::create_firestone;
+                creators["create spellstone"] = &AiObjectContextInternal::create_spellstone;
+                creators["spellstone"] = &AiObjectContextInternal::spellstone;
+                creators["summon voidwalker"] = &AiObjectContextInternal::summon_voidwalker;
+                creators["summon felguard"] = &AiObjectContextInternal::summon_felguard;
+                creators["immolate"] = &AiObjectContextInternal::immolate;
+                creators["corruption"] = &AiObjectContextInternal::corruption;
+                creators["corruption on attacker"] = &AiObjectContextInternal::corruption_on_attacker;
+                creators["curse of agony"] = &AiObjectContextInternal::curse_of_agony;
+                creators["shadow bolt"] = &AiObjectContextInternal::shadow_bolt;
+                creators["drain soul"] = &AiObjectContextInternal::drain_soul;
+                creators["drain mana"] = &AiObjectContextInternal::drain_mana;
+                creators["drain life"] = &AiObjectContextInternal::drain_life;
+                creators["banish"] = &AiObjectContextInternal::banish;
+                creators["seed of corruption"] = &AiObjectContextInternal::seed_of_corruption;
+                creators["rain of fire"] = &AiObjectContextInternal::rain_of_fire;
+                creators["shadowfury"] = &AiObjectContextInternal::shadowfury;
+                creators["life tap"] = &AiObjectContextInternal::life_tap;
+                creators["fear"] = &AiObjectContextInternal::fear;
+                creators["fear on cc"] = &AiObjectContextInternal::fear_on_cc;
+                creators["incinirate"] = &AiObjectContextInternal::incinirate;
+                creators["conflagrate"] = &AiObjectContextInternal::conflagrate;
+            }
+
+        private:
+            static Action* conflagrate(PlayerbotAI* ai) { return new CastConflagrateAction(ai); }
+            static Action* incinirate(PlayerbotAI* ai) { return new CastIncinirateAction(ai); }
+            static Action* fear_on_cc(PlayerbotAI* ai) { return new CastFearOnCcAction(ai); }
+            static Action* fear(PlayerbotAI* ai) { return new CastFearAction(ai); }
+            static Action* immolate(PlayerbotAI* ai) { return new CastImmolateAction(ai); }
+            static Action* summon_imp(PlayerbotAI* ai) { return new CastSummonImpAction(ai); }
+            static Action* fel_armor(PlayerbotAI* ai) { return new CastFelArmorAction(ai); }
+            static Action* demon_armor(PlayerbotAI* ai) { return new CastDemonArmorAction(ai); }
+            static Action* demon_skin(PlayerbotAI* ai) { return new CastDemonSkinAction(ai); }
+            static Action* create_healthstone(PlayerbotAI* ai) { return new CastCreateHealthstoneAction(ai); }
+            static Action* create_firestone(PlayerbotAI* ai) { return new CastCreateFirestoneAction(ai); }
+            static Action* create_spellstone(PlayerbotAI* ai) { return new CastCreateSpellstoneAction(ai); }
+            static Action* spellstone(PlayerbotAI* ai) { return new UseSpellItemAction(ai, "spellstone", true); }
+            static Action* summon_voidwalker(PlayerbotAI* ai) { return new CastSummonVoidwalkerAction(ai); }
+            static Action* summon_felguard(PlayerbotAI* ai) { return new CastSummonFelguardAction(ai); }
+            static Action* corruption(PlayerbotAI* ai) { return new CastCorruptionAction(ai); }
+            static Action* corruption_on_attacker(PlayerbotAI* ai) { return new CastCorruptionOnAttackerAction(ai); }
+            static Action* curse_of_agony(PlayerbotAI* ai) { return new CastCurseOfAgonyAction(ai); }
+            static Action* shadow_bolt(PlayerbotAI* ai) { return new CastShadowBoltAction(ai); }
+            static Action* drain_soul(PlayerbotAI* ai) { return new CastDrainSoulAction(ai); }
+            static Action* drain_mana(PlayerbotAI* ai) { return new CastDrainManaAction(ai); }
+            static Action* drain_life(PlayerbotAI* ai) { return new CastDrainLifeAction(ai); }
+            static Action* banish(PlayerbotAI* ai) { return new CastBanishAction(ai); }
+            static Action* seed_of_corruption(PlayerbotAI* ai) { return new CastSeedOfCorruptionAction(ai); }
+            static Action* rain_of_fire(PlayerbotAI* ai) { return new CastRainOfFireAction(ai); }
+            static Action* shadowfury(PlayerbotAI* ai) { return new CastShadowfuryAction(ai); }
+            static Action* life_tap(PlayerbotAI* ai) { return new CastLifeTapAction(ai); }
+
+        };
+    };
+};
+
+
+
+WarlockAiObjectContext::WarlockAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::warlock::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::warlock::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::warlock::AiObjectContextInternal());
+    triggerContexts.Add(new ai::warlock::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
new file mode 100644
index 0000000..0d3fa27
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class WarlockAiObjectContext : public AiObjectContext
+    {
+    public:
+        WarlockAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
new file mode 100644
index 0000000..a75926a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "WarlockActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
new file mode 100644
index 0000000..660e584
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
@@ -0,0 +1,19 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockTriggers.h"
+#include "WarlockActions.h"
+
+using namespace ai;
+
+bool DemonArmorTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return !ai->HasAura("demon skin", target) &&
+		!ai->HasAura("demon armor", target) &&
+		!ai->HasAura("fel armor", target);
+}
+
+bool SpellstoneTrigger::IsActive() 
+{
+    return BuffTrigger::IsActive() && AI_VALUE2(uint8, "item count", getName()) > 0;
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
new file mode 100644
index 0000000..796f884
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
@@ -0,0 +1,81 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+	class DemonArmorTrigger : public BuffTrigger
+	{
+	public:
+		DemonArmorTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "demon armor") {}
+		virtual bool IsActive();
+	};
+
+    class SpellstoneTrigger : public BuffTrigger
+    {
+    public:
+        SpellstoneTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "spellstone") {}
+        virtual bool IsActive();
+    };
+
+    DEBUFF_TRIGGER(CurseOfAgonyTrigger, "curse of agony", "curse of agony");
+    DEBUFF_TRIGGER(CorruptionTrigger, "corruption", "corruption");
+
+    class CorruptionOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        CorruptionOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "corruption") {}
+    };
+
+    DEBUFF_TRIGGER(ImmolateTrigger, "immolate", "immolate");
+
+    class ShadowTranceTrigger : public HasAuraTrigger
+    {
+    public:
+        ShadowTranceTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "shadow trance") {}
+    };
+
+    class BacklashTrigger : public HasAuraTrigger
+    {
+    public:
+        BacklashTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "backlash") {}
+    };
+
+    class BanishTrigger : public HasCcTargetTrigger
+    {
+    public:
+        BanishTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "banish") {}
+    };
+
+    class WarlockConjuredItemTrigger : public ItemCountTrigger
+    {
+    public:
+        WarlockConjuredItemTrigger(PlayerbotAI* ai, string item) : ItemCountTrigger(ai, item, 1) {}
+
+        virtual bool IsActive() { return ItemCountTrigger::IsActive() && AI_VALUE2(uint8, "item count", "soul shard") > 0; }
+    };
+
+    class HasSpellstoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasSpellstoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "spellstone") {}
+    };
+
+    class HasFirestoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasFirestoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "firestone") {}
+    };
+
+    class HasHealthstoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasHealthstoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "healthstone") {}
+    };
+
+    class FearTrigger : public HasCcTargetTrigger
+    {
+    public:
+        FearTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "fear") {}
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
new file mode 100644
index 0000000..7b13bec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
@@ -0,0 +1,130 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "DpsWarriorStrategy.h"
+
+using namespace ai;
+
+class DpsWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsWarriorStrategyActionNodeFactory()
+    {
+        creators["overpower"] = &overpower;
+        creators["melee"] = &melee;
+        creators["charge"] = &charge;
+        creators["bloodthirst"] = &bloodthirst;
+        creators["rend"] = &rend;
+        creators["mocking blow"] = &mocking_blow;
+        creators["death wish"] = &death_wish;
+        creators["execute"] = &execute;
+    }
+private:
+    static ActionNode* overpower(PlayerbotAI* ai)
+    {
+        return new ActionNode ("overpower",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("charge"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* charge(PlayerbotAI* ai)
+    {
+        return new ActionNode ("charge",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* bloodthirst(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bloodthirst",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("heroic strike"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rend(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rend",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mocking_blow(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mocking blow",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* death_wish(PlayerbotAI* ai)
+    {
+        return new ActionNode ("death wish",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("berserker rage"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* execute(PlayerbotAI* ai)
+    {
+        return new ActionNode ("execute",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("heroic strike"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsWarriorStrategy::DpsWarriorStrategy(PlayerbotAI* ai) : GenericWarriorStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsWarriorStrategyActionNodeFactory());
+}
+
+NextAction** DpsWarriorStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("bloodthirst", ACTION_NORMAL + 1), NULL);
+}
+
+void DpsWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarriorStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("charge", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "target critical health",
+        NextAction::array(0, new NextAction("execute", ACTION_HIGH + 4), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hamstring",
+		NextAction::array(0, new NextAction("hamstring", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"victory rush",
+		NextAction::array(0, new NextAction("victory rush", ACTION_HIGH + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "death wish",
+        NextAction::array(0, new NextAction("death wish", ACTION_HIGH + 2), NULL)));
+}
+
+
+void DpsWarrirorAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "rend on attacker",
+        NextAction::array(0, new NextAction("rend on attacker", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("thunder clap", ACTION_HIGH + 2), new NextAction("demoralizing shout", ACTION_HIGH + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("cleave", ACTION_HIGH + 3), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
new file mode 100644
index 0000000..3ef29c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericWarriorStrategy.h"
+
+namespace ai
+{
+    class DpsWarriorStrategy : public GenericWarriorStrategy
+    {
+    public:
+        DpsWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+
+    class DpsWarrirorAoeStrategy : public CombatStrategy
+    {
+    public:
+        DpsWarrirorAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
new file mode 100644
index 0000000..6bd7d08
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "GenericWarriorNonCombatStrategy.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
new file mode 100644
index 0000000..1041a2e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarriorNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericWarriorNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "nc"; }
+   };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
new file mode 100644
index 0000000..4d7b851
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericWarriorStrategy.h"
+#include "WarriorAiObjectContext.h"
+
+using namespace ai;
+
+class GenericWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarriorStrategyActionNodeFactory()
+    {
+        creators["hamstring"] = &hamstring;
+        creators["heroic strike"] = &heroic_strike;
+        creators["battle shout"] = &battle_shout;
+    }
+private:
+    static ActionNode* hamstring(PlayerbotAI* ai)
+    {
+        return new ActionNode ("hamstring",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* heroic_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("heroic strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* battle_shout(PlayerbotAI* ai)
+    {
+        return new ActionNode ("battle shout",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarriorStrategy::GenericWarriorStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarriorStrategyActionNodeFactory());
+}
+
+void GenericWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "battle shout",
+        NextAction::array(0, new NextAction("battle shout", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rend",
+        NextAction::array(0, new NextAction("rend", ACTION_NORMAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bloodrage",
+        NextAction::array(0, new NextAction("bloodrage", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shield bash",
+        NextAction::array(0, new NextAction("shield bash", ACTION_INTERRUPT + 4), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shield bash on enemy healer",
+        NextAction::array(0, new NextAction("shield bash on enemy healer", ACTION_INTERRUPT + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("intimidating shout", ACTION_EMERGENCY), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
new file mode 100644
index 0000000..0ef2dcf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericWarriorStrategy : public MeleeCombatStrategy
+    {
+    public:
+        GenericWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "warrior"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
new file mode 100644
index 0000000..d37c08d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
@@ -0,0 +1,126 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "TankWarriorStrategy.h"
+
+using namespace ai;
+
+class TankWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    TankWarriorStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["shield wall"] = &shield_wall;
+        creators["rend"] = &rend;
+        creators["revenge"] = &revenge;
+        creators["devastate"] = &devastate;
+        creators["shockwave"] = &shockwave;
+        creators["taunt"] = &taunt;
+    }
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("defensive stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* shield_wall(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shield wall",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shield block"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rend(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rend",
+            /*P*/ NextAction::array(0, new NextAction("defensive stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* revenge(PlayerbotAI* ai)
+    {
+        return new ActionNode ("revenge",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* devastate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("devastate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("sunder armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* shockwave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shockwave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("cleave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* taunt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("taunt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mocking blow"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankWarriorStrategy::TankWarriorStrategy(PlayerbotAI* ai) : GenericWarriorStrategy(ai)
+{
+    actionNodeFactories.Add(new TankWarriorStrategyActionNodeFactory());
+}
+
+NextAction** TankWarriorStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("devastate", ACTION_NORMAL + 1), new NextAction("revenge", ACTION_NORMAL + 1), NULL);
+}
+
+void TankWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarriorStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium rage available",
+        NextAction::array(0, new NextAction("shield slam", ACTION_NORMAL + 2), new NextAction("heroic strike", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "disarm",
+        NextAction::array(0, new NextAction("disarm", ACTION_NORMAL), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("taunt", ACTION_HIGH + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("shield wall", ACTION_MEDIUM_HEAL), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("last stand", ACTION_EMERGENCY + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe",
+		NextAction::array(0, new NextAction("shockwave", ACTION_HIGH + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("thunder clap", ACTION_HIGH + 2), new NextAction("demoralizing shout", ACTION_HIGH + 2),  new NextAction("cleave", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "high aoe",
+        NextAction::array(0, new NextAction("challenging shout", ACTION_HIGH + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"concussion blow",
+		NextAction::array(0, new NextAction("concussion blow", ACTION_INTERRUPT), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "sword and board",
+        NextAction::array(0, new NextAction("shield slam", ACTION_HIGH + 3), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
new file mode 100644
index 0000000..0f98946
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericWarriorStrategy.h"
+
+namespace ai
+{
+    class TankWarriorStrategy : public GenericWarriorStrategy
+    {
+    public:
+        TankWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "tank"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp b/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
new file mode 100644
index 0000000..12ab057
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorActions.h"
+
+using namespace ai;
+
+NextAction** CastDisarmAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastRevengeAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorActions.h b/src/plugins/playerbot/strategy/warrior/WarriorActions.h
new file mode 100644
index 0000000..d51ddb4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorActions.h
@@ -0,0 +1,207 @@
+#pragma once
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    // battle
+    class CastBattleMeleeSpellAction : public CastMeleeSpellAction {
+    public:
+        CastBattleMeleeSpellAction(PlayerbotAI* ai, string spell) : CastMeleeSpellAction(ai, spell) {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("battle stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+        }
+    };
+
+    // defensive
+    class CastDefensiveMeleeSpellAction : public CastMeleeSpellAction {
+    public:
+        CastDefensiveMeleeSpellAction(PlayerbotAI* ai, string spell) : CastMeleeSpellAction(ai, spell) {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+        }
+    };
+
+    // all
+    class CastHeroicStrikeAction : public CastMeleeSpellAction {
+    public:
+        CastHeroicStrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "heroic strike") {}
+    };
+
+    // all
+    class CastCleaveAction : public CastMeleeSpellAction {
+    public:
+        CastCleaveAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "cleave") {}
+    };
+
+    // battle, berserker
+    class CastMockingBlowAction : public CastMeleeSpellAction {
+    public:
+        CastMockingBlowAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mocking blow") {}
+    };
+
+    class CastBloodthirstAction : public CastMeleeSpellAction {
+    public:
+        CastBloodthirstAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "bloodthirst") {}
+    };
+
+    // battle, berserker
+    class CastExecuteAction : public CastMeleeSpellAction {
+    public:
+        CastExecuteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "execute") {}
+    };
+
+    // battle
+    class CastOverpowerAction : public CastBattleMeleeSpellAction {
+    public:
+        CastOverpowerAction(PlayerbotAI* ai) : CastBattleMeleeSpellAction(ai, "overpower") {}
+    };
+
+    // battle, berserker
+    class CastHamstringAction : public CastMeleeSpellAction {
+    public:
+        CastHamstringAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hamstring") {}
+    };
+
+    // defensive
+    class CastTauntAction : public CastSpellAction {
+    public:
+        CastTauntAction(PlayerbotAI* ai) : CastSpellAction(ai, "taunt") {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastSpellAction::getPrerequisites());
+        }
+    };
+
+    // defensive
+    class CastShieldBlockAction : public CastBuffSpellAction {
+    public:
+        CastShieldBlockAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shield block") {}
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastSpellAction::getPrerequisites());
+		}
+    };
+
+    // defensive
+    class CastShieldWallAction : public CastDefensiveMeleeSpellAction {
+    public:
+        CastShieldWallAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "shield wall") {}
+    };
+
+    class CastBloodrageAction : public CastBuffSpellAction {
+    public:
+        CastBloodrageAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bloodrage") {}
+    };
+
+    // defensive
+    class CastDevastateAction : public CastDefensiveMeleeSpellAction {
+    public:
+        CastDevastateAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "devastate") {}
+    };
+
+    // all
+    class CastSlamAction : public CastMeleeSpellAction {
+    public:
+        CastSlamAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "slam") {}
+    };
+
+	// all
+	class CastShieldSlamAction : public CastMeleeSpellAction {
+	public:
+		CastShieldSlamAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "shield slam") {}
+	};
+
+    // after dodge
+    BEGIN_MELEE_SPELL_ACTION(CastRevengeAction, "revenge")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+
+    //debuffs
+    BEGIN_DEBUFF_ACTION(CastRendAction, "rend")
+    END_SPELL_ACTION()
+
+    class CastRendOnAttackerAction : public CastDebuffSpellOnAttackerAction
+    {
+    public:
+        CastRendOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "rend") {}
+    };
+
+    BEGIN_DEBUFF_ACTION(CastDisarmAction, "disarm")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    BEGIN_DEBUFF_ACTION(CastSunderArmorAction, "sunder armor") // 5 times
+    END_SPELL_ACTION()
+
+    class CastDemoralizingShoutAction : public CastDebuffSpellAction {
+    public:
+        CastDemoralizingShoutAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "demoralizing shout") {}
+    };
+
+    BEGIN_MELEE_SPELL_ACTION(CastChallengingShoutAction, "challenging shout")
+    END_SPELL_ACTION()
+
+    // stuns
+    BEGIN_MELEE_SPELL_ACTION(CastShieldBashAction, "shield bash")
+    END_SPELL_ACTION()
+
+    BEGIN_MELEE_SPELL_ACTION(CastIntimidatingShoutAction, "intimidating shout")
+    END_SPELL_ACTION()
+
+    BEGIN_MELEE_SPELL_ACTION(CastThunderClapAction, "thunder clap")
+    END_SPELL_ACTION()
+
+    // buffs
+	class CastBattleShoutAction : public CastBuffSpellAction {
+	public:
+		CastBattleShoutAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "battle shout") {}
+	};
+
+	class CastDefensiveStanceAction : public CastBuffSpellAction {
+	public:
+		CastDefensiveStanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "defensive stance") {}
+	};
+
+	class CastBattleStanceAction : public CastBuffSpellAction {
+	public:
+		CastBattleStanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "battle stance") {}
+	};
+
+    BEGIN_RANGED_SPELL_ACTION(CastChargeAction, "charge")
+    END_SPELL_ACTION()
+
+	class CastDeathWishAction : public CastBuffSpellAction {
+	public:
+		CastDeathWishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "death wish") {}
+	};
+
+	class CastBerserkerRageAction : public CastBuffSpellAction {
+	public:
+		CastBerserkerRageAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "berserker rage") {}
+	};
+
+	class CastLastStandAction : public CastBuffSpellAction {
+	public:
+		CastLastStandAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "last stand") {}
+	};
+
+	// defensive
+	class CastShockwaveAction : public CastDefensiveMeleeSpellAction {
+	public:
+		CastShockwaveAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "shockwave") {}
+	};
+
+	// defensive
+	class CastConcussionBlowAction : public CastDefensiveMeleeSpellAction {
+	public:
+		CastConcussionBlowAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "concussion blow") {}
+	};
+
+	BEGIN_MELEE_SPELL_ACTION(CastVictoryRushAction, "victory rush")
+	END_SPELL_ACTION()
+
+    class CastShieldBashOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastShieldBashOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "shield bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
new file mode 100644
index 0000000..bc74075
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
@@ -0,0 +1,192 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorActions.h"
+#include "WarriorAiObjectContext.h"
+#include "GenericWarriorNonCombatStrategy.h"
+#include "TankWarriorStrategy.h"
+#include "DpsWarriorStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "WarriorTriggers.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &warrior::StrategyFactoryInternal::nc;
+                creators["pull"] = &warrior::StrategyFactoryInternal::pull;
+                creators["aoe"] = &warrior::StrategyFactoryInternal::aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericWarriorNonCombatStrategy(ai); }
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsWarrirorAoeStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["tank"] = &warrior::CombatStrategyFactoryInternal::tank;
+                creators["dps"] = &warrior::CombatStrategyFactoryInternal::dps;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankWarriorStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsWarriorStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["hamstring"] = &TriggerFactoryInternal::hamstring;
+                creators["victory rush"] = &TriggerFactoryInternal::victory_rush;
+                creators["death wish"] = &TriggerFactoryInternal::death_wish;
+                creators["battle shout"] = &TriggerFactoryInternal::battle_shout;
+                creators["rend"] = &TriggerFactoryInternal::rend;
+                creators["rend on attacker"] = &TriggerFactoryInternal::rend_on_attacker;
+                creators["bloodrage"] = &TriggerFactoryInternal::bloodrage;
+                creators["shield bash"] = &TriggerFactoryInternal::shield_bash;
+                creators["disarm"] = &TriggerFactoryInternal::disarm;
+                creators["concussion blow"] = &TriggerFactoryInternal::concussion_blow;
+                creators["sword and board"] = &TriggerFactoryInternal::SwordAndBoard;
+                creators["shield bash on enemy healer"] = &TriggerFactoryInternal::shield_bash_on_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* hamstring(PlayerbotAI* ai) { return new HamstringTrigger(ai); }
+            static Trigger* victory_rush(PlayerbotAI* ai) { return new VictoryRushTrigger(ai); }
+            static Trigger* death_wish(PlayerbotAI* ai) { return new DeathWishTrigger(ai); }
+            static Trigger* battle_shout(PlayerbotAI* ai) { return new BattleShoutTrigger(ai); }
+            static Trigger* rend(PlayerbotAI* ai) { return new RendDebuffTrigger(ai); }
+            static Trigger* rend_on_attacker(PlayerbotAI* ai) { return new RendDebuffOnAttackerTrigger(ai); }
+            static Trigger* bloodrage(PlayerbotAI* ai) { return new BloodrageDebuffTrigger(ai); }
+            static Trigger* shield_bash(PlayerbotAI* ai) { return new ShieldBashInterruptSpellTrigger(ai); }
+            static Trigger* disarm(PlayerbotAI* ai) { return new DisarmDebuffTrigger(ai); }
+            static Trigger* concussion_blow(PlayerbotAI* ai) { return new ConcussionBlowTrigger(ai); }
+            static Trigger* SwordAndBoard(PlayerbotAI* ai) { return new SwordAndBoardTrigger(ai); }
+            static Trigger* shield_bash_on_enemy_healer(PlayerbotAI* ai) { return new ShieldBashInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["devastate"] = &AiObjectContextInternal::devastate;
+                creators["overpower"] = &AiObjectContextInternal::overpower;
+                creators["charge"] = &AiObjectContextInternal::charge;
+                creators["bloodthirst"] = &AiObjectContextInternal::bloodthirst;
+                creators["rend"] = &AiObjectContextInternal::rend;
+                creators["rend on attacker"] = &AiObjectContextInternal::rend_on_attacker;
+                creators["mocking blow"] = &AiObjectContextInternal::mocking_blow;
+                creators["death wish"] = &AiObjectContextInternal::death_wish;
+                creators["berserker rage"] = &AiObjectContextInternal::berserker_rage;
+                creators["victory rush"] = &AiObjectContextInternal::victory_rush;
+                creators["execute"] = &AiObjectContextInternal::execute;
+                creators["defensive stance"] = &AiObjectContextInternal::defensive_stance;
+                creators["hamstring"] = &AiObjectContextInternal::hamstring;
+                creators["shield bash"] = &AiObjectContextInternal::shield_bash;
+                creators["shield block"] = &AiObjectContextInternal::shield_block;
+                creators["bloodrage"] = &AiObjectContextInternal::bloodrage;
+                creators["battle stance"] = &AiObjectContextInternal::battle_stance;
+                creators["heroic strike"] = &AiObjectContextInternal::heroic_strike;
+                creators["intimidating shout"] = &AiObjectContextInternal::intimidating_shout;
+                creators["demoralizing shout"] = &AiObjectContextInternal::demoralizing_shout;
+                creators["challenging shout"] = &AiObjectContextInternal::challenging_shout;
+                creators["shield wall"] = &AiObjectContextInternal::shield_wall;
+                creators["battle shout"] = &AiObjectContextInternal::battle_shout;
+                creators["thunder clap"] = &AiObjectContextInternal::thunder_clap;
+                creators["taunt"] = &AiObjectContextInternal::taunt;
+                creators["revenge"] = &AiObjectContextInternal::revenge;
+                creators["slam"] = &AiObjectContextInternal::slam;
+                creators["shield slam"] = &AiObjectContextInternal::shield_slam;
+                creators["disarm"] = &AiObjectContextInternal::disarm;
+                creators["sunder armor"] = &AiObjectContextInternal::sunder_armor;
+                creators["last stand"] = &AiObjectContextInternal::last_stand;
+                creators["shockwave"] = &AiObjectContextInternal::shockwave;
+                creators["cleave"] = &AiObjectContextInternal::cleave;
+                creators["concussion blow"] = &AiObjectContextInternal::concussion_blow;
+                creators["shield bash on enemy healer"] = &AiObjectContextInternal::shield_bash_on_enemy_healer;
+            }
+
+        private:
+            static Action* devastate(PlayerbotAI* ai) { return new CastDevastateAction(ai); }
+            static Action* last_stand(PlayerbotAI* ai) { return new CastLastStandAction(ai); }
+            static Action* shockwave(PlayerbotAI* ai) { return new CastShockwaveAction(ai); }
+            static Action* cleave(PlayerbotAI* ai) { return new CastCleaveAction(ai); }
+            static Action* concussion_blow(PlayerbotAI* ai) { return new CastConcussionBlowAction(ai); }
+            static Action* taunt(PlayerbotAI* ai) { return new CastTauntAction(ai); }
+            static Action* revenge(PlayerbotAI* ai) { return new CastRevengeAction(ai); }
+            static Action* slam(PlayerbotAI* ai) { return new CastSlamAction(ai); }
+            static Action* shield_slam(PlayerbotAI* ai) { return new CastShieldSlamAction(ai); }
+            static Action* disarm(PlayerbotAI* ai) { return new CastDisarmAction(ai); }
+            static Action* sunder_armor(PlayerbotAI* ai) { return new CastSunderArmorAction(ai); }
+            static Action* overpower(PlayerbotAI* ai) { return new CastOverpowerAction(ai); }
+            static Action* charge(PlayerbotAI* ai) { return new CastChargeAction(ai); }
+            static Action* bloodthirst(PlayerbotAI* ai) { return new CastBloodthirstAction(ai); }
+            static Action* rend(PlayerbotAI* ai) { return new CastRendAction(ai); }
+            static Action* rend_on_attacker(PlayerbotAI* ai) { return new CastRendOnAttackerAction(ai); }
+            static Action* mocking_blow(PlayerbotAI* ai) { return new CastMockingBlowAction(ai); }
+            static Action* death_wish(PlayerbotAI* ai) { return new CastDeathWishAction(ai); }
+            static Action* berserker_rage(PlayerbotAI* ai) { return new CastBerserkerRageAction(ai); }
+            static Action* victory_rush(PlayerbotAI* ai) { return new CastVictoryRushAction(ai); }
+            static Action* execute(PlayerbotAI* ai) { return new CastExecuteAction(ai); }
+            static Action* defensive_stance(PlayerbotAI* ai) { return new CastDefensiveStanceAction(ai); }
+            static Action* hamstring(PlayerbotAI* ai) { return new CastHamstringAction(ai); }
+            static Action* shield_bash(PlayerbotAI* ai) { return new CastShieldBashAction(ai); }
+            static Action* shield_block(PlayerbotAI* ai) { return new CastShieldBlockAction(ai); }
+            static Action* bloodrage(PlayerbotAI* ai) { return new CastBloodrageAction(ai); }
+            static Action* battle_stance(PlayerbotAI* ai) { return new CastBattleStanceAction(ai); }
+            static Action* heroic_strike(PlayerbotAI* ai) { return new CastHeroicStrikeAction(ai); }
+            static Action* intimidating_shout(PlayerbotAI* ai) { return new CastIntimidatingShoutAction(ai); }
+            static Action* demoralizing_shout(PlayerbotAI* ai) { return new CastDemoralizingShoutAction(ai); }
+            static Action* challenging_shout(PlayerbotAI* ai) { return new CastChallengingShoutAction(ai); }
+            static Action* shield_wall(PlayerbotAI* ai) { return new CastShieldWallAction(ai); }
+            static Action* battle_shout(PlayerbotAI* ai) { return new CastBattleShoutAction(ai); }
+            static Action* thunder_clap(PlayerbotAI* ai) { return new CastThunderClapAction(ai); }
+            static Action* shield_bash_on_enemy_healer(PlayerbotAI* ai) { return new CastShieldBashOnEnemyHealerAction(ai); }
+
+        };
+    };
+};
+
+WarriorAiObjectContext::WarriorAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::warrior::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::warrior::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::warrior::AiObjectContextInternal());
+    triggerContexts.Add(new ai::warrior::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
new file mode 100644
index 0000000..bc1b5d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class WarriorAiObjectContext : public AiObjectContext
+    {
+    public:
+        WarriorAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
new file mode 100644
index 0000000..0698aa1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "WarriorActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
new file mode 100644
index 0000000..0b8d183
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorTriggers.h"
+#include "WarriorActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
new file mode 100644
index 0000000..72a1285
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
@@ -0,0 +1,78 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_TRIGGER(BattleShoutTrigger, "battle shout", "battle shout")
+
+    DEBUFF_TRIGGER(RendDebuffTrigger, "rend", "rend")
+    DEBUFF_TRIGGER(DisarmDebuffTrigger, "disarm", "disarm")
+    DEBUFF_TRIGGER(SunderArmorDebuffTrigger, "sunder armor", "sunder armor")
+
+    class RendDebuffOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        RendDebuffOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "rend") {}
+    };
+
+	class RevengeAvailableTrigger : public SpellCanBeCastTrigger
+	{
+	public:
+		RevengeAvailableTrigger(PlayerbotAI* ai) : SpellCanBeCastTrigger(ai, "revenge") {}
+	};
+
+    class BloodrageDebuffTrigger : public DebuffTrigger
+    {
+    public:
+        BloodrageDebuffTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "bloodrage") {}
+        virtual bool IsActive()
+        {
+            return DebuffTrigger::IsActive() &&
+                AI_VALUE2(uint8, "health", "self target") >= 75 &&
+                AI_VALUE2(uint8, "rage", "self target") < 20;
+        }
+    };
+
+    class ShieldBashInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        ShieldBashInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "shield bash") {}
+    };
+
+    class VictoryRushTrigger : public HasAuraTrigger
+    {
+    public:
+        VictoryRushTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "victory rush") {}
+    };
+
+    class SwordAndBoardTrigger : public HasAuraTrigger
+    {
+    public:
+        SwordAndBoardTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "sword and board") {}
+    };
+
+    class ConcussionBlowTrigger : public SnareTargetTrigger
+    {
+    public:
+        ConcussionBlowTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "concussion blow") {}
+    };
+
+    class HamstringTrigger : public SnareTargetTrigger
+    {
+    public:
+        HamstringTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "hamstring") {}
+    };
+
+    class DeathWishTrigger : public BoostTrigger
+    {
+    public:
+        DeathWishTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "death wish") {}
+    };
+
+    class ShieldBashInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        ShieldBashInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "shield bash") {}
+    };
+
+}
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index d9f5388..2f4dda5 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -31,6 +31,8 @@
 #include "Language.h"
 #include "Log.h"
 
+#include "../../plugins/ahbot/AhBot.h"
+
 enum eAuctionHouse
 {
     AH_MINIMUM_DEPOSIT = 100
@@ -217,6 +219,9 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry* auction, SQLTransa
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_SUCCESSFUL), AuctionEntry::BuildAuctionMailBody(auction->bidder, auction->bid, auction->buyout, auction->deposit, auction->GetAuctionCut()))
             .AddMoney(profit)
             .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, sWorld->getIntConfig(CONFIG_MAIL_DELIVERY_DELAY));
+
+        // ahbot mod
+        auctionbot.Won(auction);
     }
 }
 
@@ -240,6 +245,9 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry* auction, SQLTransacti
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_EXPIRED), AuctionEntry::BuildAuctionMailBody(0, 0, auction->buyout, auction->deposit, 0))
             .AddItem(pItem)
             .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, 0);
+
+        // ahbot mod
+        auctionbot.Expired(auction);
     }
     else
     {
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 239e59d..c11f4d9 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -73,6 +73,7 @@ if( BUILD_SHARED_LIBS )
   endif()
 endif()
 
+add_dependencies(game plugins)
 # Generate precompiled header
 if (USE_COREPCH)
   add_cxx_pch(game ${PRIVATE_PCH_HEADER} ${PRIVATE_PCH_SOURCE})
diff --git a/src/server/game/DungeonFinding/LFGQueue.cpp b/src/server/game/DungeonFinding/LFGQueue.cpp
index d156158..206109c 100644
--- a/src/server/game/DungeonFinding/LFGQueue.cpp
+++ b/src/server/game/DungeonFinding/LFGQueue.cpp
@@ -24,6 +24,8 @@
 #include "LFGMgr.h"
 #include "Log.h"
 
+#include "../Entities/Player/Player.h"
+
 namespace lfg
 {
 
@@ -528,6 +530,22 @@ LfgCompatibility LFGQueue::CheckCompatibility(GuidList check)
         return LFG_COMPATIBLES_WITH_LESS_PLAYERS;
     }
 
+    // playerbot mod
+    bool nonBotFound = false;
+    for (GuidList::const_iterator it = check.begin(); it != check.end(); ++it)
+    {
+        ObjectGuid guid = *it;
+        Player *player = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (guid.IsGroup() || (player && !player->GetPlayerbotAI()))
+        {
+            nonBotFound = true;
+            break;
+        }
+    }
+    if (!nonBotFound)
+        return LFG_INCOMPATIBLES_HAS_IGNORES;
+    // end of playerbot mod
+
     ObjectGuid gguid = *check.begin();
     proposal.queues = check;
     proposal.isNew = numLfgGroups != 1 || sLFGMgr->GetOldState(gguid) != LFG_STATE_DUNGEON;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 1c42d14..819a91e 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -102,7 +102,9 @@
 // 77
 // 78
 // 79
-// 80
+// Playerbot mod:
+#include "../../../../plugins/playerbot/playerbot.h"
+#include "../../../../plugins/playerbot/GuildTaskMgr.h"
 // Visit http://www.realmsofwarcraft.com/bb for forums and information
 //
 // End of prepatch
@@ -554,6 +556,10 @@ Player::Player(WorldSession* session): Unit(true)
 
     m_achievementMgr = new AchievementMgr(this);
     m_reputationMgr = new ReputationMgr(this);
+
+    // playerbot mod
+    m_playerbotAI = NULL;
+    m_playerbotMgr = NULL;
 }
 
 Player::~Player()
@@ -1589,7 +1595,11 @@ void Player::Update(uint32 p_time)
     // 97
     // 98
     // 99
-    // 100
+    // Playerbot mod
+    if (m_playerbotAI)
+       m_playerbotAI->UpdateAI(p_time);
+    if (m_playerbotMgr)
+       m_playerbotMgr->UpdateAI(p_time);
     // Visit http://www.realmsofwarcraft.com/bb for forums and information
     //
     // End of prepatch
@@ -15160,7 +15170,7 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     if (quest->GetRewSpellCast() > 0)
     {
         SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->GetRewSpellCast());
-        if (questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
+        if (spellInfo && questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
         {
             if (Creature* creature = GetMap()->GetCreature(questGiver->GetGUID()))
                 creature->CastSpell(this, quest->GetRewSpellCast(), true);
@@ -15171,7 +15181,7 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     else if (quest->GetRewSpell() > 0)
     {
         SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->GetRewSpell());
-        if (questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
+        if (spellInfo && questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
         {
             if (Creature* creature = GetMap()->GetCreature(questGiver->GetGUID()))
                 creature->CastSpell(this, quest->GetRewSpell(), true);
@@ -23737,6 +23747,9 @@ bool Player::GetsRecruitAFriendBonus(bool forXP)
 void Player::RewardPlayerAndGroupAtKill(Unit* victim, bool isBattleGround)
 {
     KillRewarder(this, victim, isBattleGround).Reward();
+    // playerbot mod
+    sGuildTaskMgr.CheckKillTask(this, victim);
+    // end of playerbot mod
 }
 
 void Player::RewardPlayerAndGroupAtEvent(uint32 creature_id, WorldObject* pRewardSource)
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 3757b2a..a46d788 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -59,6 +59,10 @@ class PlayerAI;
 
 struct CharacterCustomizeInfo;
 
+// Playerbot mod
+class PlayerbotAI;
+class PlayerbotMgr;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2269,6 +2273,18 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
 
         bool CanFly() const override { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_CAN_FLY); }
 
+        // Playerbot mod:
+        // A Player can either have a playerbotMgr (to manage its bots), or have playerbotAI (if it is a bot), or
+        // neither. Code that enables bots must create the playerbotMgr and set it using SetPlayerbotMgr.
+        EquipmentSets& GetEquipmentSets() { return m_EquipmentSets; }
+        void SetPlayerbotAI(PlayerbotAI* ai) { m_playerbotAI=ai; }
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        void SetPlayerbotMgr(PlayerbotMgr* mgr) { m_playerbotMgr=mgr; }
+        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        PlayerTalentMap& GetTalentMap(uint8 spec) { return *m_talents[spec]; }
+        bool MinimalLoadFromDB( QueryResult result, uint32 guid );
+
         //! Return collision height sent to client
         float GetCollisionHeight(bool mounted) const;
 
@@ -2647,7 +2663,8 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
         // 37
         // 38
         // 39
-        // 40
+        PlayerbotAI* m_playerbotAI;
+        PlayerbotMgr* m_playerbotMgr;
         // Visit http://www.realmsofwarcraft.com/bb for forums and information
         //
         // End of prepatch
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index 18b8119..0848f2f 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -324,6 +324,11 @@ class TC_GAME_API Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        // ai playerbot mod
+        ObjectGuid GetTargetIcon(int index) { return m_targetIcons[index]; }
+        Rolls* GetRolls() { return &RollId; }
+        // end
+
     protected:
         bool _setMembersGroup(ObjectGuid guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 9800d0b..1176ba8 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -47,6 +47,9 @@
 #include "WorldSession.h"
 #include "Metric.h"
 
+// Playerbot mod:
+#include "../../plugins/playerbot/playerbot.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
 
 class LoginQueryHolder : public SQLQueryHolder
 {
@@ -61,6 +64,76 @@ class LoginQueryHolder : public SQLQueryHolder
         bool Initialize();
 };
 
+class PlayerbotLoginQueryHolder : public LoginQueryHolder
+{
+private:
+    uint32 masterAccountId;
+    PlayerbotHolder* playerbotHolder;
+
+public:
+    PlayerbotLoginQueryHolder(PlayerbotHolder* playerbotHolder, uint32 masterAccount, uint32 accountId, uint64 guid)
+        : LoginQueryHolder(accountId, ObjectGuid(guid)), masterAccountId(masterAccount), playerbotHolder(playerbotHolder) { }
+
+public:
+    uint32 GetMasterAccountId() const { return masterAccountId; }
+    PlayerbotHolder* GetPlayerbotHolder() { return playerbotHolder; }
+};
+
+void PlayerbotHolder::AddPlayerBot(uint64 playerGuid, uint32 masterAccount)
+{
+    // has bot already been added?
+	Player* bot = sObjectMgr->GetPlayerByLowGUID(playerGuid);
+
+	if (bot && bot->IsInWorld())
+        return;
+
+    uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(ObjectGuid(playerGuid));
+    if (accountId == 0)
+        return;
+
+    PlayerbotLoginQueryHolder *holder = new PlayerbotLoginQueryHolder(this, masterAccount, accountId, playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+
+    QueryResultHolderFuture future = CharacterDatabase.DelayQueryHolder(holder);
+    future.get();
+
+    WorldSession* masterSession = masterAccount ? sWorld->FindSession(masterAccount) : NULL;
+    uint32 botAccountId = holder->GetAccountId();
+    WorldSession *botSession = new WorldSession(botAccountId, "bot", NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0, false);
+
+    botSession->HandlePlayerLogin(holder); // will delete lqh
+
+	bot = botSession->GetPlayer();
+	if (!bot)
+		return;
+
+	PlayerbotMgr *mgr = bot->GetPlayerbotMgr();
+	bot->SetPlayerbotMgr(NULL);
+	delete mgr;
+	sRandomPlayerbotMgr.OnPlayerLogout(bot);
+
+    bool allowed = false;
+    if (botAccountId == masterAccount)
+        allowed = true;
+    else if (masterSession && sPlayerbotAIConfig.allowGuildBots && bot->GetGuildId() == masterSession->GetPlayer()->GetGuildId())
+        allowed = true;
+    else if (sPlayerbotAIConfig.IsInRandomAccountList(botAccountId))
+        allowed = true;
+
+    if (allowed)
+        OnBotLogin(bot);
+    else if (masterSession)
+    {
+        ChatHandler ch(masterSession);
+        ch.PSendSysMessage("You are not allowed to control bot %s...", bot->GetName().c_str());
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
 bool LoginQueryHolder::Initialize()
 {
     SetSize(MAX_PLAYER_LOGIN_QUERY);
@@ -995,6 +1068,14 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     // Handle Login-Achievements (should be handled after loading)
     _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ON_LOGIN, 1);
 
+    // playerbot mod
+    if (!_player->GetPlayerbotAI())
+    {
+        _player->SetPlayerbotMgr(new PlayerbotMgr(_player));
+        sRandomPlayerbotMgr.OnPlayerLogin(_player);
+    }
+    // end of playerbot mod
+
     sScriptMgr->OnPlayerLogin(pCurrChar, firstLogin);
 
     TC_METRIC_EVENT("player_events", "Login", pCurrChar->GetName());
diff --git a/src/server/game/Handlers/CharacterHandler.cpp.orig b/src/server/game/Handlers/CharacterHandler.cpp.orig
new file mode 100644
index 0000000..53c6285
--- /dev/null
+++ b/src/server/game/Handlers/CharacterHandler.cpp.orig
@@ -0,0 +1,2188 @@
+/*
+ * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "AccountMgr.h"
+#include "ArenaTeam.h"
+#include "ArenaTeamMgr.h"
+#include "Battleground.h"
+#include "CalendarMgr.h"
+#include "Chat.h"
+#include "Common.h"
+#include "DatabaseEnv.h"
+#include "Group.h"
+#include "Guild.h"
+#include "GuildMgr.h"
+#include "Language.h"
+#include "Log.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Opcodes.h"
+#include "Pet.h"
+#include "PlayerDump.h"
+#include "Player.h"
+#include "ReputationMgr.h"
+#include "GitRevision.h"
+#include "ScriptMgr.h"
+#include "SharedDefines.h"
+#include "SocialMgr.h"
+#include "UpdateMask.h"
+#include "Util.h"
+#include "World.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "Metric.h"
+
+
+class LoginQueryHolder : public SQLQueryHolder
+{
+    private:
+        uint32 m_accountId;
+        ObjectGuid m_guid;
+    public:
+        LoginQueryHolder(uint32 accountId, ObjectGuid guid)
+            : m_accountId(accountId), m_guid(guid) { }
+        ObjectGuid GetGuid() const { return m_guid; }
+        uint32 GetAccountId() const { return m_accountId; }
+        bool Initialize();
+};
+
+bool LoginQueryHolder::Initialize()
+{
+    SetSize(MAX_PLAYER_LOGIN_QUERY);
+
+    bool res = true;
+    ObjectGuid::LowType lowGuid = m_guid.GetCounter();
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_FROM, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GROUP_MEMBER);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_GROUP, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_INSTANCE);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_BOUND_INSTANCES, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_AURAS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_AURAS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_SPELL);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_SPELLS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_QUESTSTATUS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_QUEST_STATUS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_QUESTSTATUS_DAILY);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_DAILY_QUEST_STATUS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_QUESTSTATUS_WEEKLY);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_WEEKLY_QUEST_STATUS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_QUESTSTATUS_MONTHLY);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_MONTHLY_QUEST_STATUS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_QUESTSTATUS_SEASONAL);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_SEASONAL_QUEST_STATUS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_REPUTATION);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_REPUTATION, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_INVENTORY);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_INVENTORY, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ACTIONS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_ACTIONS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_MAILCOUNT);
+    stmt->setUInt32(0, lowGuid);
+    stmt->setUInt64(1, uint64(time(NULL)));
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_MAIL_COUNT, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_MAILDATE);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_MAIL_DATE, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_SOCIALLIST);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_SOCIAL_LIST, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_HOMEBIND);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_HOME_BIND, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_SPELLCOOLDOWNS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_SPELL_COOLDOWNS, stmt);
+
+    if (sWorld->getBoolConfig(CONFIG_DECLINED_NAMES_USED))
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_DECLINEDNAMES);
+        stmt->setUInt32(0, lowGuid);
+        res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_DECLINED_NAMES, stmt);
+    }
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_GUILD, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ARENAINFO);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_ARENA_INFO, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ACHIEVEMENTS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_ACHIEVEMENTS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_CRITERIAPROGRESS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_CRITERIA_PROGRESS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_EQUIPMENTSETS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_EQUIPMENT_SETS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_BGDATA);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_BG_DATA, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_GLYPHS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_GLYPHS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_TALENTS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_TALENTS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PLAYER_ACCOUNT_DATA);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_ACCOUNT_DATA, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_SKILLS);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_SKILLS, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_RANDOMBG);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_RANDOM_BG, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_BANNED);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_BANNED, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_QUESTSTATUSREW);
+    stmt->setUInt32(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_QUEST_STATUS_REW, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ACCOUNT_INSTANCELOCKTIMES);
+    stmt->setUInt32(0, m_accountId);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_INSTANCE_LOCK_TIMES, stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CORPSE_LOCATION);
+    stmt->setUInt64(0, lowGuid);
+    res &= SetPreparedQuery(PLAYER_LOGIN_QUERY_LOAD_CORPSE_LOCATION, stmt);
+
+    return res;
+}
+
+void WorldSession::HandleCharEnum(PreparedQueryResult result)
+{
+    WorldPacket data(SMSG_CHAR_ENUM, 100);                  // we guess size
+
+    uint8 num = 0;
+
+    data << num;
+
+    _legitCharacters.clear();
+    if (result)
+    {
+        do
+        {
+            ObjectGuid guid(HighGuid::Player, (*result)[0].GetUInt32());
+            TC_LOG_INFO("network", "Loading %s from account %u.", guid.ToString().c_str(), GetAccountId());
+            if (Player::BuildEnumData(result, &data))
+            {
+                // Do not allow banned characters to log in
+                if (!(*result)[23].GetUInt32())
+                    _legitCharacters.insert(guid);
+
+                if (!sWorld->HasCharacterInfo(guid)) // This can happen if characters are inserted into the database manually. Core hasn't loaded name data yet.
+                    sWorld->AddCharacterInfo(guid, GetAccountId(), (*result)[1].GetString(), (*result)[4].GetUInt8(), (*result)[2].GetUInt8(), (*result)[3].GetUInt8(), (*result)[10].GetUInt8());
+                ++num;
+            }
+        }
+        while (result->NextRow());
+    }
+
+    data.put<uint8>(0, num);
+
+    SendPacket(&data);
+}
+
+void WorldSession::HandleCharEnumOpcode(WorldPacket& /*recvData*/)
+{
+    // remove expired bans
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_EXPIRED_BANS);
+    CharacterDatabase.Execute(stmt);
+
+    /// get all the data necessary for loading all characters (along with their pets) on the account
+
+    if (sWorld->getBoolConfig(CONFIG_DECLINED_NAMES_USED))
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ENUM_DECLINED_NAME);
+    else
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ENUM);
+
+    stmt->setUInt8(0, PET_SAVE_AS_CURRENT);
+    stmt->setUInt32(1, GetAccountId());
+
+    _charEnumCallback = CharacterDatabase.AsyncQuery(stmt);
+}
+
+void WorldSession::HandleCharCreateOpcode(WorldPacket& recvData)
+{
+    CharacterCreateInfo createInfo;
+
+    recvData >> createInfo.Name
+             >> createInfo.Race
+             >> createInfo.Class
+             >> createInfo.Gender
+             >> createInfo.Skin
+             >> createInfo.Face
+             >> createInfo.HairStyle
+             >> createInfo.HairColor
+             >> createInfo.FacialHair
+             >> createInfo.OutfitId;
+
+    if (!HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_TEAMMASK))
+    {
+        if (uint32 mask = sWorld->getIntConfig(CONFIG_CHARACTER_CREATING_DISABLED))
+        {
+            bool disabled = false;
+
+            switch (Player::TeamForRace(createInfo.Race))
+            {
+                case ALLIANCE:
+                    disabled = (mask & (1 << 0)) != 0;
+                    break;
+                case HORDE:
+                    disabled = (mask & (1 << 1)) != 0;
+                    break;
+            }
+
+            if (disabled)
+            {
+                SendCharCreate(CHAR_CREATE_DISABLED);
+                return;
+            }
+        }
+    }
+
+    ChrClassesEntry const* classEntry = sChrClassesStore.LookupEntry(createInfo.Class);
+    if (!classEntry)
+    {
+        TC_LOG_ERROR("network", "Class (%u) not found in DBC while creating new char for account (ID: %u): wrong DBC files or cheater?", createInfo.Class, GetAccountId());
+        SendCharCreate(CHAR_CREATE_FAILED);
+        return;
+    }
+
+    ChrRacesEntry const* raceEntry = sChrRacesStore.LookupEntry(createInfo.Race);
+    if (!raceEntry)
+    {
+        TC_LOG_ERROR("network", "Race (%u) not found in DBC while creating new char for account (ID: %u): wrong DBC files or cheater?", createInfo.Race, GetAccountId());
+        SendCharCreate(CHAR_CREATE_FAILED);
+        return;
+    }
+
+    // prevent character creating Expansion race without Expansion account
+    if (raceEntry->expansion > Expansion())
+    {
+        TC_LOG_ERROR("entities.player.cheat", "Expansion %u account:[%d] tried to Create character with expansion %u race (%u)", Expansion(), GetAccountId(), raceEntry->expansion, createInfo.Race);
+        SendCharCreate(CHAR_CREATE_EXPANSION);
+        return;
+    }
+
+    // prevent character creating Expansion class without Expansion account
+    if (classEntry->expansion > Expansion())
+    {
+        TC_LOG_ERROR("entities.player.cheat", "Expansion %u account:[%d] tried to Create character with expansion %u class (%u)", Expansion(), GetAccountId(), classEntry->expansion, createInfo.Class);
+        SendCharCreate(CHAR_CREATE_EXPANSION_CLASS);
+        return;
+    }
+
+    if (!HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_RACEMASK))
+    {
+        uint32 raceMaskDisabled = sWorld->getIntConfig(CONFIG_CHARACTER_CREATING_DISABLED_RACEMASK);
+        if ((1 << (createInfo.Race - 1)) & raceMaskDisabled)
+        {
+            SendCharCreate(CHAR_CREATE_DISABLED);
+            return;
+        }
+    }
+
+    if (!HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_CLASSMASK))
+    {
+        uint32 classMaskDisabled = sWorld->getIntConfig(CONFIG_CHARACTER_CREATING_DISABLED_CLASSMASK);
+        if ((1 << (createInfo.Class - 1)) & classMaskDisabled)
+        {
+            SendCharCreate(CHAR_CREATE_DISABLED);
+            return;
+        }
+    }
+
+    // prevent character creating with invalid name
+    if (!normalizePlayerName(createInfo.Name))
+    {
+        TC_LOG_ERROR("entities.player.cheat", "Account:[%d] but tried to Create character with empty [name] ", GetAccountId());
+        SendCharCreate(CHAR_NAME_NO_NAME);
+        return;
+    }
+
+    // check name limitations
+    ResponseCodes res = ObjectMgr::CheckPlayerName(createInfo.Name, GetSessionDbcLocale(), true);
+    if (res != CHAR_NAME_SUCCESS)
+    {
+        SendCharCreate(res);
+        return;
+    }
+
+    if (!HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_RESERVEDNAME) && sObjectMgr->IsReservedName(createInfo.Name))
+    {
+        SendCharCreate(CHAR_NAME_RESERVED);
+        return;
+    }
+
+    if (createInfo.Class == CLASS_DEATH_KNIGHT && !HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_HEROIC_CHARACTER))
+    {
+        // speedup check for heroic class disabled case
+        uint32 heroic_free_slots = sWorld->getIntConfig(CONFIG_HEROIC_CHARACTERS_PER_REALM);
+        if (heroic_free_slots == 0)
+        {
+            SendCharCreate(CHAR_CREATE_UNIQUE_CLASS_LIMIT);
+            return;
+        }
+
+        // speedup check for heroic class disabled case
+        uint32 req_level_for_heroic = sWorld->getIntConfig(CONFIG_CHARACTER_CREATING_MIN_LEVEL_FOR_HEROIC_CHARACTER);
+        if (req_level_for_heroic > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        {
+            SendCharCreate(CHAR_CREATE_LEVEL_REQUIREMENT);
+            return;
+        }
+    }
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHECK_NAME);
+    stmt->setString(0, createInfo.Name);
+
+    delete _charCreateCallback.GetParam(); // Delete existing if any, to make the callback chain reset to stage 0
+    _charCreateCallback.SetParam(new CharacterCreateInfo(std::move(createInfo)));
+    _charCreateCallback.SetFutureResult(CharacterDatabase.AsyncQuery(stmt));
+}
+
+void WorldSession::HandleCharCreateCallback(PreparedQueryResult result, CharacterCreateInfo* createInfo)
+{
+    /** This is a series of callbacks executed consecutively as a result from the database becomes available.
+        This is much more efficient than synchronous requests on packet handler, and much less DoS prone.
+        It also prevents data syncrhonisation errors.
+    */
+    switch (_charCreateCallback.GetStage())
+    {
+        case 0:
+        {
+            if (result)
+            {
+                SendCharCreate(CHAR_CREATE_NAME_IN_USE);
+                delete createInfo;
+                _charCreateCallback.Reset();
+                return;
+            }
+
+            ASSERT(_charCreateCallback.GetParam() == createInfo);
+
+            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_SUM_REALM_CHARACTERS);
+            stmt->setUInt32(0, GetAccountId());
+
+            _charCreateCallback.FreeResult();
+            _charCreateCallback.SetFutureResult(LoginDatabase.AsyncQuery(stmt));
+            _charCreateCallback.NextStage();
+            break;
+        }
+        case 1:
+        {
+            uint64 acctCharCount = 0;
+            if (result)
+            {
+                Field* fields = result->Fetch();
+                acctCharCount = uint64(fields[0].GetDouble());
+            }
+
+            if (acctCharCount >= sWorld->getIntConfig(CONFIG_CHARACTERS_PER_ACCOUNT))
+            {
+                SendCharCreate(CHAR_CREATE_ACCOUNT_LIMIT);
+                delete createInfo;
+                _charCreateCallback.Reset();
+                return;
+            }
+
+            ASSERT(_charCreateCallback.GetParam() == createInfo);
+
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_SUM_CHARS);
+            stmt->setUInt32(0, GetAccountId());
+
+            _charCreateCallback.FreeResult();
+            _charCreateCallback.SetFutureResult(CharacterDatabase.AsyncQuery(stmt));
+            _charCreateCallback.NextStage();
+            break;
+        }
+        case 2:
+        {
+            if (result)
+            {
+                Field* fields = result->Fetch();
+                createInfo->CharCount = uint8(fields[0].GetUInt64()); // SQL's COUNT() returns uint64 but it will always be less than uint8.Max
+
+                if (createInfo->CharCount >= sWorld->getIntConfig(CONFIG_CHARACTERS_PER_REALM))
+                {
+                    SendCharCreate(CHAR_CREATE_SERVER_LIMIT);
+                    delete createInfo;
+                    _charCreateCallback.Reset();
+                    return;
+                }
+            }
+
+            bool allowTwoSideAccounts = !sWorld->IsPvPRealm() || HasPermission(rbac::RBAC_PERM_TWO_SIDE_CHARACTER_CREATION);
+            uint32 skipCinematics = sWorld->getIntConfig(CONFIG_SKIP_CINEMATICS);
+
+            _charCreateCallback.FreeResult();
+
+            if (!allowTwoSideAccounts || skipCinematics == 1 || createInfo->Class == CLASS_DEATH_KNIGHT)
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_CREATE_INFO);
+                stmt->setUInt32(0, GetAccountId());
+                stmt->setUInt32(1, (skipCinematics == 1 || createInfo->Class == CLASS_DEATH_KNIGHT) ? 10 : 1);
+                _charCreateCallback.SetFutureResult(CharacterDatabase.AsyncQuery(stmt));
+                _charCreateCallback.NextStage();
+                return;
+            }
+
+            _charCreateCallback.NextStage();
+            HandleCharCreateCallback(PreparedQueryResult(NULL), createInfo);   // Will jump to case 3
+            break;
+        }
+        case 3:
+        {
+            bool haveSameRace = false;
+            uint32 heroicReqLevel = sWorld->getIntConfig(CONFIG_CHARACTER_CREATING_MIN_LEVEL_FOR_HEROIC_CHARACTER);
+            bool hasHeroicReqLevel = (heroicReqLevel == 0);
+            bool allowTwoSideAccounts = !sWorld->IsPvPRealm() || HasPermission(rbac::RBAC_PERM_TWO_SIDE_CHARACTER_CREATION);
+            uint32 skipCinematics = sWorld->getIntConfig(CONFIG_SKIP_CINEMATICS);
+            bool checkHeroicReqs = createInfo->Class == CLASS_DEATH_KNIGHT && !HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_HEROIC_CHARACTER);
+
+            if (result)
+            {
+                uint32 team = Player::TeamForRace(createInfo->Race);
+                uint32 freeHeroicSlots = sWorld->getIntConfig(CONFIG_HEROIC_CHARACTERS_PER_REALM);
+
+                Field* field = result->Fetch();
+                uint8 accRace  = field[1].GetUInt8();
+
+                if (checkHeroicReqs)
+                {
+                    uint8 accClass = field[2].GetUInt8();
+                    if (accClass == CLASS_DEATH_KNIGHT)
+                    {
+                        if (freeHeroicSlots > 0)
+                            --freeHeroicSlots;
+
+                        if (freeHeroicSlots == 0)
+                        {
+                            SendCharCreate(CHAR_CREATE_UNIQUE_CLASS_LIMIT);
+                            delete createInfo;
+                            _charCreateCallback.Reset();
+                            return;
+                        }
+                    }
+
+                    if (!hasHeroicReqLevel)
+                    {
+                        uint8 accLevel = field[0].GetUInt8();
+                        if (accLevel >= heroicReqLevel)
+                            hasHeroicReqLevel = true;
+                    }
+                }
+
+                // need to check team only for first character
+                /// @todo what to if account already has characters of both races?
+                if (!allowTwoSideAccounts)
+                {
+                    uint32 accTeam = 0;
+                    if (accRace > 0)
+                        accTeam = Player::TeamForRace(accRace);
+
+                    if (accTeam != team)
+                    {
+                        SendCharCreate(CHAR_CREATE_PVP_TEAMS_VIOLATION);
+                        delete createInfo;
+                        _charCreateCallback.Reset();
+                        return;
+                    }
+                }
+
+                // search same race for cinematic or same class if need
+                /// @todo check if cinematic already shown? (already logged in?; cinematic field)
+                while ((skipCinematics == 1 && !haveSameRace) || createInfo->Class == CLASS_DEATH_KNIGHT)
+                {
+                    if (!result->NextRow())
+                        break;
+
+                    field = result->Fetch();
+                    accRace = field[1].GetUInt8();
+
+                    if (!haveSameRace)
+                        haveSameRace = createInfo->Race == accRace;
+
+                    if (checkHeroicReqs)
+                    {
+                        uint8 acc_class = field[2].GetUInt8();
+                        if (acc_class == CLASS_DEATH_KNIGHT)
+                        {
+                            if (freeHeroicSlots > 0)
+                                --freeHeroicSlots;
+
+                            if (freeHeroicSlots == 0)
+                            {
+                                SendCharCreate(CHAR_CREATE_UNIQUE_CLASS_LIMIT);
+                                delete createInfo;
+                                _charCreateCallback.Reset();
+                                return;
+                            }
+                        }
+
+                        if (!hasHeroicReqLevel)
+                        {
+                            uint8 acc_level = field[0].GetUInt8();
+                            if (acc_level >= heroicReqLevel)
+                                hasHeroicReqLevel = true;
+                        }
+                    }
+                }
+            }
+
+            if (checkHeroicReqs && !hasHeroicReqLevel)
+            {
+                SendCharCreate(CHAR_CREATE_LEVEL_REQUIREMENT);
+                delete createInfo;
+                _charCreateCallback.Reset();
+                return;
+            }
+
+            Player newChar(this);
+            newChar.GetMotionMaster()->Initialize();
+            if (!newChar.Create(sObjectMgr->GetGenerator<HighGuid::Player>().Generate(), createInfo))
+
+            {
+                // Player not create (race/class/etc problem?)
+                newChar.CleanupsBeforeDelete();
+
+                SendCharCreate(CHAR_CREATE_ERROR);
+                delete createInfo;
+                _charCreateCallback.Reset();
+                return;
+            }
+
+            if ((haveSameRace && skipCinematics == 1) || skipCinematics == 2)
+                newChar.setCinematic(1);                          // not show intro
+
+            newChar.SetAtLoginFlag(AT_LOGIN_FIRST);               // First login
+
+            // Player created, save it now
+            newChar.SaveToDB(true);
+            createInfo->CharCount += 1;
+
+            SQLTransaction trans = LoginDatabase.BeginTransaction();
+
+            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_REALM_CHARACTERS_BY_REALM);
+            stmt->setUInt32(0, GetAccountId());
+            stmt->setUInt32(1, realm.Id.Realm);
+            trans->Append(stmt);
+
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_REALM_CHARACTERS);
+            stmt->setUInt32(0, createInfo->CharCount);
+            stmt->setUInt32(1, GetAccountId());
+            stmt->setUInt32(2, realm.Id.Realm);
+            trans->Append(stmt);
+
+            LoginDatabase.CommitTransaction(trans);
+
+            SendCharCreate(CHAR_CREATE_SUCCESS);
+
+            TC_LOG_INFO("entities.player.character", "Account: %d (IP: %s) Create Character:[%s] (GUID: %u)", GetAccountId(), GetRemoteAddress().c_str(), createInfo->Name.c_str(), newChar.GetGUID().GetCounter());
+            sScriptMgr->OnPlayerCreate(&newChar);
+            sWorld->AddCharacterInfo(newChar.GetGUID(), GetAccountId(), newChar.GetName(), newChar.GetByteValue(PLAYER_BYTES_3, PLAYER_BYTES_3_OFFSET_GENDER), newChar.getRace(), newChar.getClass(), newChar.getLevel());
+
+            newChar.CleanupsBeforeDelete();
+            delete createInfo;
+            _charCreateCallback.Reset();
+            break;
+        }
+    }
+}
+
+void WorldSession::HandleCharDeleteOpcode(WorldPacket& recvData)
+{
+    ObjectGuid guid;
+    recvData >> guid;
+    // Initiating
+    uint32 initAccountId = GetAccountId();
+
+    // can't delete loaded character
+    if (ObjectAccessor::FindPlayer(guid))
+    {
+        sScriptMgr->OnPlayerFailedDelete(guid, initAccountId);
+        return;
+    }
+
+    uint32 accountId = 0;
+    uint8 level = 0;
+    std::string name;
+
+    // is guild leader
+    if (sGuildMgr->GetGuildByLeader(guid))
+    {
+        sScriptMgr->OnPlayerFailedDelete(guid, initAccountId);
+        SendCharDelete(CHAR_DELETE_FAILED_GUILD_LEADER);
+        return;
+    }
+
+    // is arena team captain
+    if (sArenaTeamMgr->GetArenaTeamByCaptain(guid))
+    {
+        sScriptMgr->OnPlayerFailedDelete(guid, initAccountId);
+        SendCharDelete(CHAR_DELETE_FAILED_ARENA_CAPTAIN);
+        return;
+    }
+
+    CharacterInfo const* characterInfo = sWorld->GetCharacterInfo(guid);
+    if (!characterInfo)
+    {
+        sScriptMgr->OnPlayerFailedDelete(guid, initAccountId);
+        return;
+    }
+
+    accountId = characterInfo->AccountId;
+    name = characterInfo->Name;
+    level = characterInfo->Level;
+
+    // prevent deleting other players' characters using cheating tools
+    if (accountId != initAccountId)
+    {
+        sScriptMgr->OnPlayerFailedDelete(guid, initAccountId);
+        return;
+    }
+
+    TC_LOG_INFO("entities.player.character", "Account: %d, IP: %s deleted character: %s, %s, Level: %u", accountId, GetRemoteAddress().c_str(), name.c_str(), guid.ToString().c_str(), level);
+
+    // To prevent hook failure, place hook before removing reference from DB
+    sScriptMgr->OnPlayerDelete(guid, initAccountId); // To prevent race conditioning, but as it also makes sense, we hand the accountId over for successful delete.
+    // Shouldn't interfere with character deletion though
+
+    if (sLog->ShouldLog("entities.player.dump", LOG_LEVEL_INFO)) // optimize GetPlayerDump call
+    {
+        std::string dump;
+        if (PlayerDumpWriter().GetDump(guid.GetCounter(), dump))
+            sLog->outCharDump(dump.c_str(), accountId, guid.GetRawValue(), name.c_str());
+    }
+
+    sCalendarMgr->RemoveAllPlayerEventsAndInvites(guid);
+    Player::DeleteFromDB(guid, accountId);
+
+    SendCharDelete(CHAR_DELETE_SUCCESS);
+}
+
+void WorldSession::HandlePlayerLoginOpcode(WorldPacket& recvData)
+{
+    if (PlayerLoading() || GetPlayer() != NULL)
+    {
+        TC_LOG_ERROR("network", "Player tries to login again, AccountId = %d", GetAccountId());
+        KickPlayer();
+        return;
+    }
+
+    m_playerLoading = true;
+    ObjectGuid playerGuid;
+
+    recvData >> playerGuid;
+
+    if (!IsLegitCharacterForAccount(playerGuid))
+    {
+        TC_LOG_ERROR("network", "Account (%u) can't login with that character (%s).", GetAccountId(), playerGuid.ToString().c_str());
+        KickPlayer();
+        return;
+    }
+
+    LoginQueryHolder *holder = new LoginQueryHolder(GetAccountId(), playerGuid);
+    if (!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        m_playerLoading = false;
+        return;
+    }
+
+    _charLoginCallback = CharacterDatabase.DelayQueryHolder(holder);
+}
+
+void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
+{
+    ObjectGuid playerGuid = holder->GetGuid();
+
+    Player* pCurrChar = new Player(this);
+     // for send server info and strings (config)
+    ChatHandler chH = ChatHandler(pCurrChar->GetSession());
+
+    // "GetAccountId() == db stored account id" checked in LoadFromDB (prevent login not own character using cheating tools)
+    if (!pCurrChar->LoadFromDB(playerGuid, holder))
+    {
+        SetPlayer(NULL);
+        KickPlayer();                                       // disconnect client, player no set to session and it will not deleted or saved at kick
+        delete pCurrChar;                                   // delete it manually
+        delete holder;                                      // delete all unprocessed queries
+        m_playerLoading = false;
+        return;
+    }
+
+    pCurrChar->GetMotionMaster()->Initialize();
+    pCurrChar->SendDungeonDifficulty(false);
+
+    WorldPacket data(SMSG_LOGIN_VERIFY_WORLD, 20);
+    data << pCurrChar->GetMapId();
+    data << pCurrChar->GetPositionX();
+    data << pCurrChar->GetPositionY();
+    data << pCurrChar->GetPositionZ();
+    data << pCurrChar->GetOrientation();
+    SendPacket(&data);
+
+    // load player specific part before send times
+    LoadAccountData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ACCOUNT_DATA), PER_CHARACTER_CACHE_MASK);
+    SendAccountDataTimes(PER_CHARACTER_CACHE_MASK);
+
+    data.Initialize(SMSG_FEATURE_SYSTEM_STATUS, 2);         // added in 2.2.0
+    data << uint8(2);                                       // unknown value
+    data << uint8(0);                                       // enable(1)/disable(0) voice chat interface in client
+    SendPacket(&data);
+
+    // Send MOTD
+    {
+        data.Initialize(SMSG_MOTD, 50);                     // new in 2.0.1
+        data << (uint32)0;
+
+        uint32 linecount=0;
+        std::string str_motd = sWorld->GetMotd();
+        std::string::size_type pos, nextpos;
+
+        pos = 0;
+        while ((nextpos= str_motd.find('@', pos)) != std::string::npos)
+        {
+            if (nextpos != pos)
+            {
+                data << str_motd.substr(pos, nextpos-pos);
+                ++linecount;
+            }
+            pos = nextpos+1;
+        }
+
+        if (pos<str_motd.length())
+        {
+            data << str_motd.substr(pos);
+            ++linecount;
+        }
+
+        data.put(0, linecount);
+
+        SendPacket(&data);
+
+        // send server info
+        if (sWorld->getIntConfig(CONFIG_ENABLE_SINFO_LOGIN) == 1)
+            chH.PSendSysMessage(GitRevision::GetFullVersion());
+    }
+
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT guildid, rank FROM guild_member WHERE guid = '%u'", pCurrChar->GetGUID().GetCounter());
+    if (PreparedQueryResult resultGuild = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GUILD))
+    {
+        Field* fields = resultGuild->Fetch();
+        pCurrChar->SetInGuild(fields[0].GetUInt32());
+        pCurrChar->SetRank(fields[1].GetUInt8());
+    }
+    else if (pCurrChar->GetGuildId())                        // clear guild related fields in case wrong data about non existed membership
+    {
+        pCurrChar->SetInGuild(0);
+        pCurrChar->SetRank(0);
+    }
+
+    if (pCurrChar->GetGuildId() != 0)
+    {
+        if (Guild* guild = sGuildMgr->GetGuildById(pCurrChar->GetGuildId()))
+            guild->SendLoginInfo(this);
+        else
+        {
+            // remove wrong guild data
+            TC_LOG_ERROR("network", "Player %s (GUID: %u) marked as member of not existing guild (id: %u), removing guild membership for player.", pCurrChar->GetName().c_str(), pCurrChar->GetGUID().GetCounter(), pCurrChar->GetGuildId());
+            pCurrChar->SetInGuild(0);
+        }
+    }
+
+    data.Initialize(SMSG_LEARNED_DANCE_MOVES, 4+4);
+    data << uint32(0);
+    data << uint32(0);
+    SendPacket(&data);
+
+    pCurrChar->SendInitialPacketsBeforeAddToMap();
+
+    //Show cinematic at the first time that player login
+    if (!pCurrChar->getCinematic())
+    {
+        pCurrChar->setCinematic(1);
+
+        if (ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(pCurrChar->getClass()))
+        {
+            if (cEntry->CinematicSequence)
+                pCurrChar->SendCinematicStart(cEntry->CinematicSequence);
+            else if (ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(pCurrChar->getRace()))
+                pCurrChar->SendCinematicStart(rEntry->CinematicSequence);
+
+            // send new char string if not empty
+            if (!sWorld->GetNewCharString().empty())
+                chH.PSendSysMessage("%s", sWorld->GetNewCharString().c_str());
+        }
+    }
+
+    if (!pCurrChar->GetMap()->AddPlayerToMap(pCurrChar))
+    {
+        AreaTrigger const* at = sObjectMgr->GetGoBackTrigger(pCurrChar->GetMapId());
+        if (at)
+            pCurrChar->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, pCurrChar->GetOrientation());
+        else
+            pCurrChar->TeleportTo(pCurrChar->m_homebindMapId, pCurrChar->m_homebindX, pCurrChar->m_homebindY, pCurrChar->m_homebindZ, pCurrChar->GetOrientation());
+    }
+
+    ObjectAccessor::AddObject(pCurrChar);
+    //TC_LOG_DEBUG("Player %s added to Map.", pCurrChar->GetName().c_str());
+
+    pCurrChar->SendInitialPacketsAfterAddToMap();
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ONLINE);
+
+    stmt->setUInt32(0, pCurrChar->GetGUID().GetCounter());
+
+    CharacterDatabase.Execute(stmt);
+
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_ACCOUNT_ONLINE);
+
+    stmt->setUInt32(0, GetAccountId());
+
+    LoginDatabase.Execute(stmt);
+
+    pCurrChar->SetInGameTime(getMSTime());
+
+    // announce group about member online (must be after add to player list to receive announce to self)
+    if (Group* group = pCurrChar->GetGroup())
+    {
+        //pCurrChar->groupInfo.group->SendInit(this); // useless
+        group->SendUpdate();
+        group->ResetMaxEnchantingLevel();
+    }
+
+    // friend status
+    sSocialMgr->SendFriendStatus(pCurrChar, FRIEND_ONLINE, pCurrChar->GetGUID().GetCounter(), true);
+
+    // Place character in world (and load zone) before some object loading
+    pCurrChar->LoadCorpse(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CORPSE_LOCATION));
+
+    // setting Ghost+speed if dead
+    if (pCurrChar->m_deathState != ALIVE)
+    {
+        // not blizz like, we must correctly save and load player instead...
+        if (pCurrChar->getRace() == RACE_NIGHTELF)
+            pCurrChar->CastSpell(pCurrChar, 20584, true, nullptr);// auras SPELL_AURA_INCREASE_SPEED(+speed in wisp form), SPELL_AURA_INCREASE_SWIM_SPEED(+swim speed in wisp form), SPELL_AURA_TRANSFORM (to wisp form)
+        pCurrChar->CastSpell(pCurrChar, 8326, true, nullptr);     // auras SPELL_AURA_GHOST, SPELL_AURA_INCREASE_SPEED(why?), SPELL_AURA_INCREASE_SWIM_SPEED(why?)
+
+        pCurrChar->SetMovement(MOVE_WATER_WALK);
+    }
+
+    pCurrChar->ContinueTaxiFlight();
+
+    // reset for all pets before pet loading
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_RESET_PET_TALENTS))
+        Pet::resetTalentsForAllPetsOf(pCurrChar);
+
+    // Load pet if any (if player not alive and in taxi flight or another then pet will remember as temporary unsummoned)
+    pCurrChar->LoadPet();
+
+    // Set FFA PvP for non GM in non-rest mode
+    if (sWorld->IsFFAPvPRealm() && !pCurrChar->IsGameMaster() && !pCurrChar->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
+        pCurrChar->SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+
+    if (pCurrChar->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP))
+        pCurrChar->SetContestedPvP();
+
+    // Apply at_login requests
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_RESET_SPELLS))
+    {
+        pCurrChar->ResetSpells();
+        SendNotification(LANG_RESET_SPELLS);
+    }
+
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_RESET_TALENTS))
+    {
+        pCurrChar->ResetTalents(true);
+        pCurrChar->SendTalentsInfoData(false);              // original talents send already in to SendInitialPacketsBeforeAddToMap, resend reset state
+        SendNotification(LANG_RESET_TALENTS);
+    }
+
+    bool firstLogin = pCurrChar->HasAtLoginFlag(AT_LOGIN_FIRST);
+    if (firstLogin)
+    {
+        pCurrChar->RemoveAtLoginFlag(AT_LOGIN_FIRST);
+
+        PlayerInfo const* info = sObjectMgr->GetPlayerInfo(pCurrChar->getRace(), pCurrChar->getClass());
+        for (uint32 spellId : info->castSpells)
+            pCurrChar->CastSpell(pCurrChar, spellId, true);
+    }
+
+    // show time before shutdown if shutdown planned.
+    if (sWorld->IsShuttingDown())
+        sWorld->ShutdownMsg(true, pCurrChar);
+
+    if (sWorld->getBoolConfig(CONFIG_ALL_TAXI_PATHS))
+        pCurrChar->SetTaxiCheater(true);
+
+    if (pCurrChar->IsGameMaster())
+        SendNotification(LANG_GM_ON);
+
+    std::string IP_str = GetRemoteAddress();
+    TC_LOG_INFO("entities.player.character", "Account: %d (IP: %s) Login Character:[%s] (GUID: %u) Level: %d",
+        GetAccountId(), IP_str.c_str(), pCurrChar->GetName().c_str(), pCurrChar->GetGUID().GetCounter(), pCurrChar->getLevel());
+
+    if (!pCurrChar->IsStandState() && !pCurrChar->HasUnitState(UNIT_STATE_STUNNED))
+        pCurrChar->SetStandState(UNIT_STAND_STATE_STAND);
+
+    m_playerLoading = false;
+
+    // Handle Login-Achievements (should be handled after loading)
+    _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ON_LOGIN, 1);
+
+    sScriptMgr->OnPlayerLogin(pCurrChar, firstLogin);
+
+    TC_METRIC_EVENT("player_events", "Login", pCurrChar->GetName());
+
+    delete holder;
+}
+
+void WorldSession::HandleSetFactionAtWar(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "WORLD: Received CMSG_SET_FACTION_ATWAR");
+
+    uint32 repListID;
+    uint8  flag;
+
+    recvData >> repListID;
+    recvData >> flag;
+
+    GetPlayer()->GetReputationMgr().SetAtWar(repListID, flag != 0);
+}
+
+//I think this function is never used :/ I dunno, but i guess this opcode not exists
+void WorldSession::HandleSetFactionCheat(WorldPacket& /*recvData*/)
+{
+    TC_LOG_ERROR("network", "WORLD SESSION: HandleSetFactionCheat, not expected call, please report.");
+    GetPlayer()->GetReputationMgr().SendStates();
+}
+
+void WorldSession::HandleTutorialFlag(WorldPacket& recvData)
+{
+    uint32 data;
+    recvData >> data;
+
+    uint8 index = uint8(data / 32);
+    if (index >= MAX_ACCOUNT_TUTORIAL_VALUES)
+        return;
+
+    uint32 value = (data % 32);
+
+    uint32 flag = GetTutorialInt(index);
+    flag |= (1 << value);
+    SetTutorialInt(index, flag);
+}
+
+void WorldSession::HandleTutorialClear(WorldPacket& /*recvData*/)
+{
+    for (uint8 i = 0; i < MAX_ACCOUNT_TUTORIAL_VALUES; ++i)
+        SetTutorialInt(i, 0xFFFFFFFF);
+}
+
+void WorldSession::HandleTutorialReset(WorldPacket& /*recvData*/)
+{
+    for (uint8 i = 0; i < MAX_ACCOUNT_TUTORIAL_VALUES; ++i)
+        SetTutorialInt(i, 0x00000000);
+}
+
+void WorldSession::HandleSetWatchedFactionOpcode(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "WORLD: Received CMSG_SET_WATCHED_FACTION");
+    uint32 fact;
+    recvData >> fact;
+    GetPlayer()->SetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, fact);
+}
+
+void WorldSession::HandleSetFactionInactiveOpcode(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "WORLD: Received CMSG_SET_FACTION_INACTIVE");
+    uint32 replistid;
+    uint8 inactive;
+    recvData >> replistid >> inactive;
+
+    _player->GetReputationMgr().SetInactive(replistid, inactive != 0);
+}
+
+void WorldSession::HandleShowingHelmOpcode(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "CMSG_SHOWING_HELM for %s", _player->GetName().c_str());
+    recvData.read_skip<uint8>(); // unknown, bool?
+    _player->ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM);
+}
+
+void WorldSession::HandleShowingCloakOpcode(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "CMSG_SHOWING_CLOAK for %s", _player->GetName().c_str());
+    recvData.read_skip<uint8>(); // unknown, bool?
+    _player->ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK);
+}
+
+void WorldSession::HandleCharRenameOpcode(WorldPacket& recvData)
+{
+    CharacterRenameInfo renameInfo;
+
+    recvData >> renameInfo.Guid
+             >> renameInfo.Name;
+
+    // prevent character rename to invalid name
+    if (!normalizePlayerName(renameInfo.Name))
+    {
+        SendCharRename(CHAR_NAME_NO_NAME, renameInfo);
+        return;
+    }
+
+    ResponseCodes res = ObjectMgr::CheckPlayerName(renameInfo.Name, GetSessionDbcLocale(), true);
+    if (res != CHAR_NAME_SUCCESS)
+    {
+        SendCharRename(res, renameInfo);
+        return;
+    }
+
+    // check name limitations
+    if (!HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_RESERVEDNAME) && sObjectMgr->IsReservedName(renameInfo.Name))
+    {
+        SendCharRename(CHAR_NAME_RESERVED, renameInfo);
+        return;
+    }
+
+    // Ensure that the character belongs to the current account, that rename at login is enabled
+    // and that there is no character with the desired new name
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_FREE_NAME);
+
+    stmt->setUInt32(0, renameInfo.Guid.GetCounter());
+    stmt->setUInt32(1, GetAccountId());
+    stmt->setUInt16(2, AT_LOGIN_RENAME);
+    stmt->setUInt16(3, AT_LOGIN_RENAME);
+    stmt->setString(4, renameInfo.Name);
+
+    delete _charRenameCallback.GetParam();
+    _charRenameCallback.SetParam(new CharacterRenameInfo(std::move(renameInfo)));
+    _charRenameCallback.SetFutureResult(CharacterDatabase.AsyncQuery(stmt));
+}
+
+void WorldSession::HandleChangePlayerNameOpcodeCallBack(PreparedQueryResult result, CharacterRenameInfo const* renameInfo)
+{
+    if (!result)
+    {
+        SendCharRename(CHAR_CREATE_ERROR, *renameInfo);
+        return;
+    }
+
+    Field* fields = result->Fetch();
+
+    ObjectGuid::LowType guidLow      = fields[0].GetUInt32();
+    std::string oldName = fields[1].GetString();
+
+    // Update name and at_login flag in the db
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NAME);
+
+    stmt->setString(0, renameInfo->Name);
+    stmt->setUInt16(1, AT_LOGIN_RENAME);
+    stmt->setUInt32(2, guidLow);
+
+    CharacterDatabase.Execute(stmt);
+
+    // Removed declined name from db
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_DECLINED_NAME);
+
+    stmt->setUInt32(0, guidLow);
+
+    CharacterDatabase.Execute(stmt);
+
+    TC_LOG_INFO("entities.player.character", "Account: %d (IP: %s) Character:[%s] (%s) Changed name to: %s", GetAccountId(), GetRemoteAddress().c_str(), oldName.c_str(), renameInfo->Guid.ToString().c_str(), renameInfo->Name.c_str());
+
+    SendCharRename(RESPONSE_SUCCESS, *renameInfo);
+
+    sWorld->UpdateCharacterInfo(renameInfo->Guid, renameInfo->Name);
+}
+
+void WorldSession::HandleSetPlayerDeclinedNames(WorldPacket& recvData)
+{
+    ObjectGuid guid;
+
+    recvData >> guid;
+
+    // not accept declined names for unsupported languages
+    std::string name;
+    if (!sObjectMgr->GetPlayerNameByGUID(guid, name))
+    {
+        SendSetPlayerDeclinedNamesResult(DECLINED_NAMES_RESULT_ERROR, guid);
+        return;
+    }
+
+    std::wstring wname;
+    if (!Utf8toWStr(name, wname))
+    {
+        SendSetPlayerDeclinedNamesResult(DECLINED_NAMES_RESULT_ERROR, guid);
+        return;
+    }
+
+    if (!isCyrillicCharacter(wname[0]))                      // name already stored as only single alphabet using
+    {
+        SendSetPlayerDeclinedNamesResult(DECLINED_NAMES_RESULT_ERROR, guid);
+        return;
+    }
+
+    std::string name2;
+    DeclinedName declinedname;
+
+    recvData >> name2;
+
+    if (name2 != name)                                       // character have different name
+    {
+        SendSetPlayerDeclinedNamesResult(DECLINED_NAMES_RESULT_ERROR, guid);
+        return;
+    }
+
+    for (int i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
+    {
+        recvData >> declinedname.name[i];
+        if (!normalizePlayerName(declinedname.name[i]))
+        {
+            SendSetPlayerDeclinedNamesResult(DECLINED_NAMES_RESULT_ERROR, guid);
+            return;
+        }
+    }
+
+    if (!ObjectMgr::CheckDeclinedNames(wname, declinedname))
+    {
+        SendSetPlayerDeclinedNamesResult(DECLINED_NAMES_RESULT_ERROR, guid);
+        return;
+    }
+
+    for (int i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
+        CharacterDatabase.EscapeString(declinedname.name[i]);
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
+    stmt->setUInt32(0, guid.GetCounter());
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_DECLINED_NAME);
+    stmt->setUInt32(0, guid.GetCounter());
+
+    for (uint8 i = 0; i < 5; i++)
+        stmt->setString(i+1, declinedname.name[i]);
+
+    trans->Append(stmt);
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    SendSetPlayerDeclinedNamesResult(DECLINED_NAMES_RESULT_SUCCESS, guid);
+}
+
+void WorldSession::HandleAlterAppearance(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "CMSG_ALTER_APPEARANCE");
+
+    uint32 Hair, Color, FacialHair, SkinColor;
+    recvData >> Hair >> Color >> FacialHair >> SkinColor;
+
+    BarberShopStyleEntry const* bs_hair = sBarberShopStyleStore.LookupEntry(Hair);
+
+    if (!bs_hair || bs_hair->type != 0 || bs_hair->race != _player->getRace() || bs_hair->gender != _player->GetByteValue(PLAYER_BYTES_3, PLAYER_BYTES_3_OFFSET_GENDER))
+        return;
+
+    BarberShopStyleEntry const* bs_facialHair = sBarberShopStyleStore.LookupEntry(FacialHair);
+
+    if (!bs_facialHair || bs_facialHair->type != 2 || bs_facialHair->race != _player->getRace() || bs_facialHair->gender != _player->GetByteValue(PLAYER_BYTES_3, PLAYER_BYTES_3_OFFSET_GENDER))
+        return;
+
+    BarberShopStyleEntry const* bs_skinColor = sBarberShopStyleStore.LookupEntry(SkinColor);
+
+    if (bs_skinColor && (bs_skinColor->type != 3 || bs_skinColor->race != _player->getRace() || bs_skinColor->gender != _player->GetByteValue(PLAYER_BYTES_3, PLAYER_BYTES_3_OFFSET_GENDER)))
+        return;
+
+    if (!Player::ValidateAppearance(_player->getRace(), _player->getClass(), _player->GetByteValue(PLAYER_BYTES_3, PLAYER_BYTES_3_OFFSET_GENDER),
+        bs_hair->hair_id,
+        Color,
+        _player->GetByteValue(PLAYER_BYTES, PLAYER_BYTES_OFFSET_FACE_ID),
+        bs_facialHair->hair_id,
+        bs_skinColor ? bs_skinColor->hair_id : _player->GetByteValue(PLAYER_BYTES, PLAYER_BYTES_OFFSET_SKIN_ID)))
+        return;
+
+    GameObject* go = _player->FindNearestGameObjectOfType(GAMEOBJECT_TYPE_BARBER_CHAIR, 5.0f);
+    if (!go)
+    {
+        SendBarberShopResult(BARBER_SHOP_RESULT_NOT_ON_CHAIR);
+        return;
+    }
+
+    if (_player->GetStandState() != UNIT_STAND_STATE_SIT_LOW_CHAIR + go->GetGOInfo()->barberChair.chairheight)
+    {
+        SendBarberShopResult(BARBER_SHOP_RESULT_NOT_ON_CHAIR);
+        return;
+    }
+
+    uint32 cost = _player->GetBarberShopCost(bs_hair->hair_id, Color, bs_facialHair->hair_id, bs_skinColor);
+
+    // 0 - ok
+    // 1, 3 - not enough money
+    // 2 - you have to seat on barber chair
+    if (!_player->HasEnoughMoney(cost))
+    {
+        SendBarberShopResult(BARBER_SHOP_RESULT_NO_MONEY);
+        return;
+    }
+
+    SendBarberShopResult(BARBER_SHOP_RESULT_SUCCESS);
+
+    _player->ModifyMoney(-int32(cost));                     // it isn't free
+    _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_AT_BARBER, cost);
+
+    _player->SetByteValue(PLAYER_BYTES, PLAYER_BYTES_OFFSET_HAIR_STYLE_ID, uint8(bs_hair->hair_id));
+    _player->SetByteValue(PLAYER_BYTES, PLAYER_BYTES_OFFSET_HAIR_COLOR_ID, uint8(Color));
+    _player->SetByteValue(PLAYER_BYTES_2, PLAYER_BYTES_2_OFFSET_FACIAL_STYLE, uint8(bs_facialHair->hair_id));
+    if (bs_skinColor)
+        _player->SetByteValue(PLAYER_BYTES, PLAYER_BYTES_OFFSET_SKIN_ID, uint8(bs_skinColor->hair_id));
+
+    _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_VISIT_BARBER_SHOP, 1);
+
+    _player->SetStandState(0);                              // stand up
+}
+
+void WorldSession::HandleRemoveGlyph(WorldPacket& recvData)
+{
+    uint32 slot;
+    recvData >> slot;
+
+    if (slot >= MAX_GLYPH_SLOT_INDEX)
+    {
+        TC_LOG_DEBUG("network", "Client sent wrong glyph slot number in opcode CMSG_REMOVE_GLYPH %u", slot);
+        return;
+    }
+
+    if (uint32 glyph = _player->GetGlyph(slot))
+    {
+        if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyph))
+        {
+            _player->RemoveAurasDueToSpell(gp->SpellId);
+            _player->SetGlyph(slot, 0);
+            _player->SendTalentsInfoData(false);
+        }
+    }
+}
+
+void WorldSession::HandleCharCustomize(WorldPacket& recvData)
+{
+    CharacterCustomizeInfo customizeInfo;
+
+    recvData >> customizeInfo.Guid;
+    if (!IsLegitCharacterForAccount(customizeInfo.Guid))
+    {
+        TC_LOG_ERROR("entities.player.cheat", "Account %u, IP: %s tried to customise %s, but it does not belong to their account!",
+            GetAccountId(), GetRemoteAddress().c_str(), customizeInfo.Guid.ToString().c_str());
+        recvData.rfinish();
+        KickPlayer();
+        return;
+    }
+
+    recvData >> customizeInfo.Name
+             >> customizeInfo.Gender
+             >> customizeInfo.Skin
+             >> customizeInfo.HairColor
+             >> customizeInfo.HairStyle
+             >> customizeInfo.FacialHair
+             >> customizeInfo.Face;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_NAME_DATA);
+    stmt->setUInt32(0, customizeInfo.Guid.GetCounter());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+    {
+        SendCharCustomize(CHAR_CREATE_ERROR, customizeInfo);
+        return;
+    }
+
+    Field* fields = result->Fetch();
+    uint8 plrRace = fields[0].GetUInt8();
+    uint8 plrClass = fields[1].GetUInt8();
+    uint8 plrGender = fields[2].GetUInt8();
+    std::string oldName = fields[4].GetString();
+
+    if (!Player::ValidateAppearance(plrRace, plrClass, plrGender, customizeInfo.HairStyle, customizeInfo.HairColor, customizeInfo.Face, customizeInfo.FacialHair, customizeInfo.Skin, true))
+    {
+        SendCharCustomize(CHAR_CREATE_ERROR, customizeInfo);
+        return;
+    }
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_AT_LOGIN);
+
+    stmt->setUInt32(0, customizeInfo.Guid.GetCounter());
+    // TODO: Make async with callback
+    result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+    {
+        SendCharCustomize(CHAR_CREATE_ERROR, customizeInfo);
+        return;
+    }
+
+    fields = result->Fetch();
+    uint32 at_loginFlags = fields[0].GetUInt16();
+
+    if (!(at_loginFlags & AT_LOGIN_CUSTOMIZE))
+    {
+        SendCharCustomize(CHAR_CREATE_ERROR, customizeInfo);
+        return;
+    }
+
+    // prevent character rename
+    if (sWorld->getBoolConfig(CONFIG_PREVENT_RENAME_CUSTOMIZATION) && (customizeInfo.Name != oldName))
+    {
+        SendCharCustomize(CHAR_NAME_FAILURE, customizeInfo);
+        return;
+    }
+
+    // prevent character rename to invalid name
+    if (!normalizePlayerName(customizeInfo.Name))
+    {
+        SendCharCustomize(CHAR_NAME_NO_NAME, customizeInfo);
+        return;
+    }
+
+    ResponseCodes res = ObjectMgr::CheckPlayerName(customizeInfo.Name, GetSessionDbcLocale(), true);
+    if (res != CHAR_NAME_SUCCESS)
+    {
+        SendCharCustomize(res, customizeInfo);
+        return;
+    }
+
+    // check name limitations
+    if (!HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_RESERVEDNAME) && sObjectMgr->IsReservedName(customizeInfo.Name))
+    {
+        SendCharCustomize(CHAR_NAME_RESERVED, customizeInfo);
+        return;
+    }
+
+    // character with this name already exist
+    if (ObjectGuid newGuid = sObjectMgr->GetPlayerGUIDByName(customizeInfo.Name))
+    {
+        if (newGuid != customizeInfo.Guid)
+        {
+            SendCharCustomize(CHAR_CREATE_NAME_IN_USE, customizeInfo);
+            return;
+        }
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    Player::Customize(&customizeInfo, trans);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_NAME_AT_LOGIN);
+    stmt->setString(0, customizeInfo.Name);
+    stmt->setUInt16(1, uint16(AT_LOGIN_CUSTOMIZE));
+    stmt->setUInt32(2, customizeInfo.Guid.GetCounter());
+
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_DECLINED_NAME);
+    stmt->setUInt32(0, customizeInfo.Guid.GetCounter());
+
+    trans->Append(stmt);
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    sWorld->UpdateCharacterInfo(customizeInfo.Guid, customizeInfo.Name, customizeInfo.Gender);
+
+    SendCharCustomize(RESPONSE_SUCCESS, customizeInfo);
+
+    TC_LOG_INFO("entities.player.character", "Account: %d (IP: %s), Character[%s] (%s) Customized to: %s",
+        GetAccountId(), GetRemoteAddress().c_str(), oldName.c_str(), customizeInfo.Guid.ToString().c_str(), customizeInfo.Name.c_str());
+}
+
+void WorldSession::HandleEquipmentSetSave(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "CMSG_EQUIPMENT_SET_SAVE");
+
+    uint64 setGuid;
+    recvData.readPackGUID(setGuid);
+
+    uint32 index;
+    recvData >> index;
+    if (index >= MAX_EQUIPMENT_SET_INDEX)                    // client set slots amount
+        return;
+
+    std::string name;
+    recvData >> name;
+
+    std::string iconName;
+    recvData >> iconName;
+
+    EquipmentSet eqSet;
+
+    eqSet.Guid      = setGuid;
+    eqSet.Name      = name;
+    eqSet.IconName  = iconName;
+    eqSet.state     = EQUIPMENT_SET_NEW;
+
+    for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        ObjectGuid itemGuid;
+        recvData >> itemGuid.ReadAsPacked();
+
+        // equipment manager sends "1" (as raw GUID) for slots set to "ignore" (don't touch slot at equip set)
+        if (itemGuid.GetRawValue() == 1)
+        {
+            // ignored slots saved as bit mask because we have no free special values for Items[i]
+            eqSet.IgnoreMask |= 1 << i;
+            continue;
+        }
+
+        Item* item = _player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+
+        if (!item && itemGuid)                               // cheating check 1
+            return;
+
+        if (item && item->GetGUID() != itemGuid)             // cheating check 2
+            return;
+
+        eqSet.Items[i] = itemGuid.GetCounter();
+    }
+
+    _player->SetEquipmentSet(index, eqSet);
+}
+
+void WorldSession::HandleEquipmentSetDelete(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "CMSG_EQUIPMENT_SET_DELETE");
+
+    uint64 setGuid;
+    recvData.readPackGUID(setGuid);
+
+    _player->DeleteEquipmentSet(setGuid);
+}
+
+void WorldSession::HandleEquipmentSetUse(WorldPacket& recvData)
+{
+    TC_LOG_DEBUG("network", "CMSG_EQUIPMENT_SET_USE");
+
+    for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        ObjectGuid itemGuid;
+        recvData >> itemGuid.ReadAsPacked();
+
+        uint8 srcbag, srcslot;
+        recvData >> srcbag >> srcslot;
+
+        TC_LOG_DEBUG("entities.player.items", "%s: srcbag %u, srcslot %u", itemGuid.ToString().c_str(), srcbag, srcslot);
+
+        // check if item slot is set to "ignored" (raw value == 1), must not be unequipped then
+        if (itemGuid.GetRawValue() == 1)
+            continue;
+
+        // Only equip weapons in combat
+        if (_player->IsInCombat() && i != EQUIPMENT_SLOT_MAINHAND && i != EQUIPMENT_SLOT_OFFHAND && i != EQUIPMENT_SLOT_RANGED)
+            continue;
+
+        Item* item = _player->GetItemByGuid(itemGuid);
+
+        uint16 dstpos = i | (INVENTORY_SLOT_BAG_0 << 8);
+
+        if (!item)
+        {
+            Item* uItem = _player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+            if (!uItem)
+                continue;
+
+            ItemPosCountVec sDest;
+            InventoryResult msg = _player->CanStoreItem(NULL_BAG, NULL_SLOT, sDest, uItem, false);
+            if (msg == EQUIP_ERR_OK)
+            {
+                _player->RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
+                _player->StoreItem(sDest, uItem, true);
+            }
+            else
+                _player->SendEquipError(msg, uItem, NULL);
+
+            continue;
+        }
+
+        if (item->GetPos() == dstpos)
+            continue;
+
+        _player->SwapItem(item->GetPos(), dstpos);
+    }
+
+    WorldPacket data(SMSG_EQUIPMENT_SET_USE_RESULT, 1);
+    data << uint8(0);                                       // 4 - equipment swap failed - inventory is full
+    SendPacket(&data);
+}
+
+void WorldSession::HandleCharFactionOrRaceChange(WorldPacket& recvData)
+{
+    CharacterFactionChangeInfo factionChangeInfo;
+    recvData >> factionChangeInfo.Guid;
+
+    if (!IsLegitCharacterForAccount(factionChangeInfo.Guid))
+    {
+        TC_LOG_ERROR("entities.player.cheat", "Account %u, IP: %s tried to factionchange character %s, but it does not belong to their account!",
+            GetAccountId(), GetRemoteAddress().c_str(), factionChangeInfo.Guid.ToString().c_str());
+        recvData.rfinish();
+        KickPlayer();
+        return;
+    }
+
+    recvData >> factionChangeInfo.Name
+             >> factionChangeInfo.Gender
+             >> factionChangeInfo.Skin
+             >> factionChangeInfo.HairColor
+             >> factionChangeInfo.HairStyle
+             >> factionChangeInfo.FacialHair
+             >> factionChangeInfo.Face
+             >> factionChangeInfo.Race;
+
+    ObjectGuid::LowType lowGuid = factionChangeInfo.Guid.GetCounter();
+
+    // get the players old (at this moment current) race
+    CharacterInfo const* nameData = sWorld->GetCharacterInfo(factionChangeInfo.Guid);
+    if (!nameData)
+    {
+        SendCharFactionChange(CHAR_CREATE_ERROR, factionChangeInfo);
+        return;
+    }
+
+    std::string oldName = nameData->Name;
+    uint8 oldRace = nameData->Race;
+    uint8 playerClass = nameData->Class;
+    uint8 level = nameData->Level;
+
+    // TO Do: Make async
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_AT_LOGIN_TITLES);
+    stmt->setUInt32(0, lowGuid);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+    {
+        SendCharFactionChange(CHAR_CREATE_ERROR, factionChangeInfo);
+        return;
+    }
+
+    Field* fields = result->Fetch();
+    uint32 at_loginFlags = fields[0].GetUInt16();
+    std::string knownTitlesStr = fields[1].GetString();
+    uint32 used_loginFlag = ((recvData.GetOpcode() == CMSG_CHAR_RACE_CHANGE) ? AT_LOGIN_CHANGE_RACE : AT_LOGIN_CHANGE_FACTION);
+
+    if (!sObjectMgr->GetPlayerInfo(factionChangeInfo.Race, playerClass))
+    {
+        SendCharFactionChange(CHAR_CREATE_ERROR, factionChangeInfo);
+        return;
+    }
+
+    if (!(at_loginFlags & used_loginFlag))
+    {
+        SendCharFactionChange(CHAR_CREATE_ERROR, factionChangeInfo);
+        return;
+    }
+
+    if (!HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_RACEMASK))
+    {
+        uint32 raceMaskDisabled = sWorld->getIntConfig(CONFIG_CHARACTER_CREATING_DISABLED_RACEMASK);
+        if ((1 << (factionChangeInfo.Race - 1)) & raceMaskDisabled)
+        {
+            SendCharFactionChange(CHAR_CREATE_ERROR, factionChangeInfo);
+            return;
+        }
+    }
+
+    // prevent character rename
+    if (sWorld->getBoolConfig(CONFIG_PREVENT_RENAME_CUSTOMIZATION) && (factionChangeInfo.Name != oldName))
+    {
+        SendCharFactionChange(CHAR_NAME_FAILURE, factionChangeInfo);
+        return;
+    }
+
+    // prevent character rename to invalid name
+    if (!normalizePlayerName(factionChangeInfo.Name))
+    {
+        SendCharFactionChange(CHAR_NAME_NO_NAME, factionChangeInfo);
+        return;
+    }
+
+    ResponseCodes res = ObjectMgr::CheckPlayerName(factionChangeInfo.Name, GetSessionDbcLocale(), true);
+    if (res != CHAR_NAME_SUCCESS)
+    {
+        SendCharFactionChange(res, factionChangeInfo);
+        return;
+    }
+
+    // check name limitations
+    if (!HasPermission(rbac::RBAC_PERM_SKIP_CHECK_CHARACTER_CREATION_RESERVEDNAME) && sObjectMgr->IsReservedName(factionChangeInfo.Name))
+    {
+        SendCharFactionChange(CHAR_NAME_RESERVED, factionChangeInfo);
+        return;
+    }
+
+    // character with this name already exist
+    if (ObjectGuid newGuid = sObjectMgr->GetPlayerGUIDByName(factionChangeInfo.Name))
+    {
+        if (newGuid != factionChangeInfo.Guid)
+        {
+            SendCharFactionChange(CHAR_CREATE_NAME_IN_USE, factionChangeInfo);
+            return;
+        }
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    // resurrect the character in case he's dead
+    Player::OfflineResurrect(factionChangeInfo.Guid, trans);
+
+    CharacterDatabase.EscapeString(factionChangeInfo.Name);
+    Player::Customize(&factionChangeInfo, trans);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_FACTION_OR_RACE);
+    stmt->setString(0, factionChangeInfo.Name);
+    stmt->setUInt8(1, factionChangeInfo.Race);
+    stmt->setUInt16(2, used_loginFlag);
+    stmt->setUInt32(3, lowGuid);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
+    stmt->setUInt32(0, lowGuid);
+    trans->Append(stmt);
+
+    sWorld->UpdateCharacterInfo(factionChangeInfo.Guid, factionChangeInfo.Name, factionChangeInfo.Gender, factionChangeInfo.Race);
+
+    if (oldRace != factionChangeInfo.Race)
+    {
+        TeamId team = TEAM_ALLIANCE;
+
+        // Search each faction is targeted
+        switch (factionChangeInfo.Race)
+        {
+            case RACE_ORC:
+            case RACE_TAUREN:
+            case RACE_UNDEAD_PLAYER:
+            case RACE_TROLL:
+            case RACE_BLOODELF:
+                team = TEAM_HORDE;
+                break;
+            default:
+                break;
+        }
+
+        // Switch Languages
+        // delete all languages first
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILL_LANGUAGES);
+        stmt->setUInt32(0, lowGuid);
+        trans->Append(stmt);
+
+        // Now add them back
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILL_LANGUAGE);
+        stmt->setUInt32(0, lowGuid);
+
+        // Faction specific languages
+        if (team == TEAM_HORDE)
+            stmt->setUInt16(1, 109);
+        else
+            stmt->setUInt16(1, 98);
+
+        trans->Append(stmt);
+
+        // Race specific languages
+        if (factionChangeInfo.Race != RACE_ORC && factionChangeInfo.Race != RACE_HUMAN)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILL_LANGUAGE);
+            stmt->setUInt32(0, lowGuid);
+
+            switch (factionChangeInfo.Race)
+            {
+                case RACE_DWARF:
+                    stmt->setUInt16(1, 111);
+                    break;
+                case RACE_DRAENEI:
+                    stmt->setUInt16(1, 759);
+                    break;
+                case RACE_GNOME:
+                    stmt->setUInt16(1, 313);
+                    break;
+                case RACE_NIGHTELF:
+                    stmt->setUInt16(1, 113);
+                    break;
+                case RACE_UNDEAD_PLAYER:
+                    stmt->setUInt16(1, 673);
+                    break;
+                case RACE_TAUREN:
+                    stmt->setUInt16(1, 115);
+                    break;
+                case RACE_TROLL:
+                    stmt->setUInt16(1, 315);
+                    break;
+                case RACE_BLOODELF:
+                    stmt->setUInt16(1, 137);
+                    break;
+            }
+
+            trans->Append(stmt);
+        }
+
+        if (recvData.GetOpcode() == CMSG_CHAR_FACTION_CHANGE)
+        {
+            // Delete all Flypaths
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_TAXI_PATH);
+            stmt->setUInt32(0, lowGuid);
+            trans->Append(stmt);
+
+            if (level > 7)
+            {
+                // Update Taxi path
+                // this doesn't seem to be 100% blizzlike... but it can't really be helped.
+                std::ostringstream taximaskstream;
+                uint32 numFullTaximasks = level / 7;
+                if (numFullTaximasks > 11)
+                    numFullTaximasks = 11;
+                if (team == TEAM_ALLIANCE)
+                {
+                    if (playerClass != CLASS_DEATH_KNIGHT)
+                    {
+                        for (uint8 i = 0; i < numFullTaximasks; ++i)
+                            taximaskstream << uint32(sAllianceTaxiNodesMask[i]) << ' ';
+                    }
+                    else
+                    {
+                        for (uint8 i = 0; i < numFullTaximasks; ++i)
+                            taximaskstream << uint32(sAllianceTaxiNodesMask[i] | sDeathKnightTaxiNodesMask[i]) << ' ';
+                    }
+                }
+                else
+                {
+                    if (playerClass != CLASS_DEATH_KNIGHT)
+                    {
+                        for (uint8 i = 0; i < numFullTaximasks; ++i)
+                            taximaskstream << uint32(sHordeTaxiNodesMask[i]) << ' ';
+                    }
+                    else
+                    {
+                        for (uint8 i = 0; i < numFullTaximasks; ++i)
+                            taximaskstream << uint32(sHordeTaxiNodesMask[i] | sDeathKnightTaxiNodesMask[i]) << ' ';
+                    }
+                }
+
+                uint32 numEmptyTaximasks = 11 - numFullTaximasks;
+                for (uint8 i = 0; i < numEmptyTaximasks; ++i)
+                    taximaskstream << "0 ";
+                taximaskstream << '0';
+                std::string taximask = taximaskstream.str();
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_TAXIMASK);
+                stmt->setString(0, taximask);
+                stmt->setUInt32(1, lowGuid);
+                trans->Append(stmt);
+            }
+
+            /// @todo: make this part async
+            if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD))
+            {
+                // Reset guild
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
+
+                stmt->setUInt32(0, lowGuid);
+
+                PreparedQueryResult result = CharacterDatabase.Query(stmt);
+                if (result)
+                    if (Guild* guild = sGuildMgr->GetGuildById((result->Fetch()[0]).GetUInt32()))
+                        guild->DeleteMember(factionChangeInfo.Guid, false, false, true);
+
+                Player::LeaveAllArenaTeams(factionChangeInfo.Guid);
+            }
+
+            if (!HasPermission(rbac::RBAC_PERM_TWO_SIDE_ADD_FRIEND))
+            {
+                // Delete Friend List
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_GUID);
+                stmt->setUInt32(0, lowGuid);
+                trans->Append(stmt);
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND);
+                stmt->setUInt32(0, lowGuid);
+                trans->Append(stmt);
+            }
+
+            // Reset homebind and position
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
+            stmt->setUInt32(0, lowGuid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_HOMEBIND);
+            stmt->setUInt32(0, lowGuid);
+
+            WorldLocation loc;
+            uint16 zoneId = 0;
+            if (team == TEAM_ALLIANCE)
+            {
+                loc.WorldRelocate(0, -8867.68f, 673.373f, 97.9034f, 0.0f);
+                zoneId = 1519;
+            }
+            else
+            {
+                loc.WorldRelocate(1, 1633.33f, -4439.11f, 15.7588f, 0.0f);
+                zoneId = 1637;
+            }
+
+            stmt->setUInt16(1, loc.GetMapId());
+            stmt->setUInt16(2, zoneId);
+            stmt->setFloat(3, loc.GetPositionX());
+            stmt->setFloat(4, loc.GetPositionY());
+            stmt->setFloat(5, loc.GetPositionZ());
+            trans->Append(stmt);
+
+            Player::SavePositionInDB(loc, zoneId, factionChangeInfo.Guid, trans);
+
+            // Achievement conversion
+            for (std::map<uint32, uint32>::const_iterator it = sObjectMgr->FactionChangeAchievements.begin(); it != sObjectMgr->FactionChangeAchievements.end(); ++it)
+            {
+                uint32 achiev_alliance = it->first;
+                uint32 achiev_horde = it->second;
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT_BY_ACHIEVEMENT);
+                stmt->setUInt16(0, uint16(team == TEAM_ALLIANCE ? achiev_alliance : achiev_horde));
+                stmt->setUInt32(1, lowGuid);
+                trans->Append(stmt);
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACHIEVEMENT);
+                stmt->setUInt16(0, uint16(team == TEAM_ALLIANCE ? achiev_alliance : achiev_horde));
+                stmt->setUInt16(1, uint16(team == TEAM_ALLIANCE ? achiev_horde : achiev_alliance));
+                stmt->setUInt32(2, lowGuid);
+                trans->Append(stmt);
+            }
+
+            // Item conversion
+            for (std::map<uint32, uint32>::const_iterator it = sObjectMgr->FactionChangeItems.begin(); it != sObjectMgr->FactionChangeItems.end(); ++it)
+            {
+                uint32 item_alliance = it->first;
+                uint32 item_horde = it->second;
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_INVENTORY_FACTION_CHANGE);
+                stmt->setUInt32(0, (team == TEAM_ALLIANCE ? item_alliance : item_horde));
+                stmt->setUInt32(1, (team == TEAM_ALLIANCE ? item_horde : item_alliance));
+                stmt->setUInt32(2, lowGuid);
+                trans->Append(stmt);
+            }
+
+            // Delete all current quests
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS);
+            stmt->setUInt32(0, lowGuid);
+            trans->Append(stmt);
+
+            // Quest conversion
+            for (std::map<uint32, uint32>::const_iterator it = sObjectMgr->FactionChangeQuests.begin(); it != sObjectMgr->FactionChangeQuests.end(); ++it)
+            {
+                uint32 quest_alliance = it->first;
+                uint32 quest_horde = it->second;
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
+                stmt->setUInt32(0, lowGuid);
+                stmt->setUInt32(1, (team == TEAM_ALLIANCE ? quest_alliance : quest_horde));
+                trans->Append(stmt);
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_QUESTSTATUS_REWARDED_FACTION_CHANGE);
+                stmt->setUInt32(0, (team == TEAM_ALLIANCE ? quest_alliance : quest_horde));
+                stmt->setUInt32(1, (team == TEAM_ALLIANCE ? quest_horde : quest_alliance));
+                stmt->setUInt32(2, lowGuid);
+                trans->Append(stmt);
+            }
+
+            // Mark all rewarded quests as "active" (will count for completed quests achievements)
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_QUESTSTATUS_REWARDED_ACTIVE);
+            stmt->setUInt32(0, lowGuid);
+            trans->Append(stmt);
+
+            // Disable all old-faction specific quests
+            {
+                ObjectMgr::QuestMap const& questTemplates = sObjectMgr->GetQuestTemplates();
+                for (ObjectMgr::QuestMap::const_iterator iter = questTemplates.begin(); iter != questTemplates.end(); ++iter)
+                {
+                    Quest const* quest = iter->second;
+                    uint32 newRaceMask = (team == TEAM_ALLIANCE) ? RACEMASK_ALLIANCE : RACEMASK_HORDE;
+                    if (!(quest->GetAllowableRaces() & newRaceMask))
+                    {
+                        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_QUESTSTATUS_REWARDED_ACTIVE_BY_QUEST);
+                        stmt->setUInt32(0, lowGuid);
+                        stmt->setUInt32(1, quest->GetQuestId());
+                        trans->Append(stmt);
+                    }
+                }
+            }
+
+            // Spell conversion
+            for (std::map<uint32, uint32>::const_iterator it = sObjectMgr->FactionChangeSpells.begin(); it != sObjectMgr->FactionChangeSpells.end(); ++it)
+            {
+                uint32 spell_alliance = it->first;
+                uint32 spell_horde = it->second;
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
+                stmt->setUInt32(0, (team == TEAM_ALLIANCE ? spell_alliance : spell_horde));
+                stmt->setUInt32(1, lowGuid);
+                trans->Append(stmt);
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_SPELL_FACTION_CHANGE);
+                stmt->setUInt32(0, (team == TEAM_ALLIANCE ? spell_alliance : spell_horde));
+                stmt->setUInt32(1, (team == TEAM_ALLIANCE ? spell_horde : spell_alliance));
+                stmt->setUInt32(2, lowGuid);
+                trans->Append(stmt);
+            }
+
+            // Reputation conversion
+            for (std::map<uint32, uint32>::const_iterator it = sObjectMgr->FactionChangeReputation.begin(); it != sObjectMgr->FactionChangeReputation.end(); ++it)
+            {
+                uint32 reputation_alliance = it->first;
+                uint32 reputation_horde = it->second;
+                uint32 newReputation = (team == TEAM_ALLIANCE) ? reputation_alliance : reputation_horde;
+                uint32 oldReputation = (team == TEAM_ALLIANCE) ? reputation_horde : reputation_alliance;
+
+                // select old standing set in db
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_REP_BY_FACTION);
+                stmt->setUInt32(0, oldReputation);
+                stmt->setUInt32(1, lowGuid);
+
+                if (PreparedQueryResult reputationResult = CharacterDatabase.Query(stmt))
+                {
+                    fields = reputationResult->Fetch();
+                    int32 oldDBRep = fields[0].GetInt32();
+                    FactionEntry const* factionEntry = sFactionStore.LookupEntry(oldReputation);
+
+                    // old base reputation
+                    int32 oldBaseRep = sObjectMgr->GetBaseReputationOf(factionEntry, oldRace, playerClass);
+
+                    // new base reputation
+                    int32 newBaseRep = sObjectMgr->GetBaseReputationOf(sFactionStore.LookupEntry(newReputation), factionChangeInfo.Race, playerClass);
+
+                    // final reputation shouldnt change
+                    int32 FinalRep = oldDBRep + oldBaseRep;
+                    int32 newDBRep = FinalRep - newBaseRep;
+
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REP_BY_FACTION);
+                    stmt->setUInt32(0, newReputation);
+                    stmt->setUInt32(1, lowGuid);
+                    trans->Append(stmt);
+
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_REP_FACTION_CHANGE);
+                    stmt->setUInt16(0, uint16(newReputation));
+                    stmt->setInt32(1, newDBRep);
+                    stmt->setUInt16(2, uint16(oldReputation));
+                    stmt->setUInt32(3, lowGuid);
+                    trans->Append(stmt);
+                }
+            }
+
+            // Title conversion
+            if (!knownTitlesStr.empty())
+            {
+                const uint32 ktcount = KNOWN_TITLES_SIZE * 2;
+                uint32 knownTitles[ktcount];
+                Tokenizer tokens(knownTitlesStr, ' ', ktcount);
+
+                if (tokens.size() != ktcount)
+                {
+                    SendCharFactionChange(CHAR_CREATE_ERROR, factionChangeInfo);
+                    return;
+                }
+
+                for (uint32 index = 0; index < ktcount; ++index)
+                    knownTitles[index] = atoul(tokens[index]);
+
+                for (std::map<uint32, uint32>::const_iterator it = sObjectMgr->FactionChangeTitles.begin(); it != sObjectMgr->FactionChangeTitles.end(); ++it)
+                {
+                    uint32 title_alliance = it->first;
+                    uint32 title_horde = it->second;
+
+                    CharTitlesEntry const* atitleInfo = sCharTitlesStore.LookupEntry(title_alliance);
+                    CharTitlesEntry const* htitleInfo = sCharTitlesStore.LookupEntry(title_horde);
+                    // new team
+                    if (team == TEAM_ALLIANCE)
+                    {
+                        uint32 bitIndex = htitleInfo->bit_index;
+                        uint32 index = bitIndex / 32;
+                        uint32 old_flag = 1 << (bitIndex % 32);
+                        uint32 new_flag = 1 << (atitleInfo->bit_index % 32);
+                        if (knownTitles[index] & old_flag)
+                        {
+                            knownTitles[index] &= ~old_flag;
+                            // use index of the new title
+                            knownTitles[atitleInfo->bit_index / 32] |= new_flag;
+                        }
+                    }
+                    else
+                    {
+                        uint32 bitIndex = atitleInfo->bit_index;
+                        uint32 index = bitIndex / 32;
+                        uint32 old_flag = 1 << (bitIndex % 32);
+                        uint32 new_flag = 1 << (htitleInfo->bit_index % 32);
+                        if (knownTitles[index] & old_flag)
+                        {
+                            knownTitles[index] &= ~old_flag;
+                            // use index of the new title
+                            knownTitles[htitleInfo->bit_index / 32] |= new_flag;
+                        }
+                    }
+
+                    std::ostringstream ss;
+                    for (uint32 index = 0; index < ktcount; ++index)
+                        ss << knownTitles[index] << ' ';
+
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_TITLES_FACTION_CHANGE);
+                    stmt->setString(0, ss.str().c_str());
+                    stmt->setUInt32(1, lowGuid);
+                    trans->Append(stmt);
+
+                    // unset any currently chosen title
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_RES_CHAR_TITLES_FACTION_CHANGE);
+                    stmt->setUInt32(0, lowGuid);
+                    trans->Append(stmt);
+                }
+            }
+        }
+    }
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    TC_LOG_DEBUG("entities.player", "%s (IP: %s) changed race from %u to %u", GetPlayerInfo().c_str(), GetRemoteAddress().c_str(), oldRace, factionChangeInfo.Race);
+
+    SendCharFactionChange(RESPONSE_SUCCESS, factionChangeInfo);
+}
+
+void WorldSession::SendCharCreate(ResponseCodes result)
+{
+    WorldPacket data(SMSG_CHAR_CREATE, 1);
+    data << uint8(result);
+    SendPacket(&data);
+}
+
+void WorldSession::SendCharDelete(ResponseCodes result)
+{
+    WorldPacket data(SMSG_CHAR_DELETE, 1);
+    data << uint8(result);
+    SendPacket(&data);
+}
+
+void WorldSession::SendCharRename(ResponseCodes result, CharacterRenameInfo const& renameInfo)
+{
+    WorldPacket data(SMSG_CHAR_RENAME, 1 + 8 + renameInfo.Name.size() + 1);
+    data << uint8(result);
+    if (result == RESPONSE_SUCCESS)
+    {
+        data << renameInfo.Guid;
+        data << renameInfo.Name;
+    }
+    SendPacket(&data);
+}
+
+void WorldSession::SendCharCustomize(ResponseCodes result, CharacterCustomizeInfo const& customizeInfo)
+{
+    WorldPacket data(SMSG_CHAR_CUSTOMIZE, 1 + 8 + customizeInfo.Name.size() + 1 + 6);
+    data << uint8(result);
+    if (result == RESPONSE_SUCCESS)
+    {
+        data << customizeInfo.Guid;
+        data << customizeInfo.Name;
+        data << uint8(customizeInfo.Gender);
+        data << uint8(customizeInfo.Skin);
+        data << uint8(customizeInfo.Face);
+        data << uint8(customizeInfo.HairStyle);
+        data << uint8(customizeInfo.HairColor);
+        data << uint8(customizeInfo.FacialHair);
+    }
+    SendPacket(&data);
+}
+
+void WorldSession::SendCharFactionChange(ResponseCodes result, CharacterFactionChangeInfo const& factionChangeInfo)
+{
+    WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1 + 8 + factionChangeInfo.Name.size() + 1 + 7);
+    data << uint8(result);
+    if (result == RESPONSE_SUCCESS)
+    {
+        data << factionChangeInfo.Guid;
+        data << factionChangeInfo.Name;
+        data << uint8(factionChangeInfo.Gender);
+        data << uint8(factionChangeInfo.Skin);
+        data << uint8(factionChangeInfo.Face);
+        data << uint8(factionChangeInfo.HairStyle);
+        data << uint8(factionChangeInfo.HairColor);
+        data << uint8(factionChangeInfo.FacialHair);
+        data << uint8(factionChangeInfo.Race);
+    }
+    SendPacket(&data);
+}
+
+void WorldSession::SendSetPlayerDeclinedNamesResult(DeclinedNameResult result, ObjectGuid guid)
+{
+    WorldPacket data(SMSG_SET_PLAYER_DECLINED_NAMES_RESULT, 4 + 8);
+    data << uint32(result);
+    data << guid;
+    SendPacket(&data);
+}
+
+void WorldSession::SendBarberShopResult(BarberShopResult result)
+{
+    WorldPacket data(SMSG_BARBER_SHOP_RESULT, 4);
+    data << uint32(result);
+    SendPacket(&data);
+}
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index 3529877..32509a1 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -49,7 +49,8 @@
 // 68
 // 69
 // 70
-// 71
+// Playerbot mod
+#include "../../plugins/playerbot/playerbot.h"
 // 72
 // 73
 // 74
@@ -343,8 +344,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (receiver->getLevel() < sWorld->getIntConfig(CONFIG_CHAT_WHISPER_LEVEL_REQ) ||
                 (HasPermission(rbac::RBAC_PERM_CAN_FILTER_WHISPERS) && !sender->isAcceptWhispers() && !sender->IsInWhisperWhiteList(receiver->GetGUID())))
                 sender->AddWhisperWhiteList(receiver->GetGUID());
-
-            GetPlayer()->Whisper(msg, Language(lang), receiver);
+             // Playerbot mod: handle whispered command to bot
+             if (receiver->GetPlayerbotAI() && lang != LANG_ADDON)
+             {
+                 receiver->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                 receiver->m_speakTime = 0;
+                 receiver->m_speakCount = 0;
+             }
+             else
+             {
+                 GetPlayer()->Whisper(msg, Language(lang), receiver);
+             }
+             // END Playerbot mod
             break;
         }
         case CHAT_MSG_PARTY:
@@ -362,6 +373,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (type == CHAT_MSG_PARTY_LEADER && !group->IsLeader(sender->GetGUID()))
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -379,6 +403,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 
                     guild->BroadcastToGuild(this, false, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
                 }
+                // Playerbot mod: broadcast message to bot members
+                PlayerbotMgr *mgr = GetPlayer()->GetPlayerbotMgr();
+                if (mgr && lang != LANG_ADDON)
+                {
+                    for (PlayerBotMap::const_iterator it = mgr->GetPlayerBotsBegin(); it != mgr->GetPlayerBotsEnd(); ++it)
+                    {
+                        Player* const bot = it->second;
+                        if (bot->GetGuildId() == GetPlayer()->GetGuildId())
+                            bot->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    }
+                }
+                // END Playerbot mod
             }
             break;
         }
@@ -406,6 +442,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -424,6 +473,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -437,6 +499,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())) || group->isBGGroup())
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -488,6 +563,13 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             {
                 if (Channel* chn = cMgr->GetChannel(channel, sender))
                 {
+                    // Playerbot mod: broadcast message to bot members
+                    if (_player->GetPlayerbotMgr() && lang != LANG_ADDON && chn->GetFlags() & 0x18)
+                    {
+                        _player->GetPlayerbotMgr()->HandleCommand(type, msg);
+                    }
+                    sRandomPlayerbotMgr.HandleCommand(type, msg, *_player);
+                    // END Playerbot mod
                     sScriptMgr->OnPlayerChat(sender, type, lang, msg, chn);
                     chn->Say(sender->GetGUID(), msg.c_str(), lang);
                 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 3ecd3f2..8667417 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -48,6 +48,9 @@
 
 #include <zlib.h>
 
+// Playerbot mod
+#include "../../plugins/playerbot/playerbot.h"
+
 namespace {
 
 std::string const DefaultPlayerName = "<none>";
@@ -193,6 +196,13 @@ ObjectGuid::LowType WorldSession::GetGUIDLow() const
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
     ASSERT(packet->GetOpcode() != NULL_OPCODE);
+     // Playerbot mod: send packet to bot AI
+     if (GetPlayer()) {
+         if (GetPlayer()->GetPlayerbotAI())
+             GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+         else if (GetPlayer()->GetPlayerbotMgr())
+             GetPlayer()->GetPlayerbotMgr()->HandleMasterOutgoingPacket(*packet);
+     }
 
     if (!m_Socket)
         return;
@@ -264,6 +274,8 @@ void WorldSession::LogUnprocessedTail(WorldPacket* packet)
 /// Update the WorldSession (triggered by World update)
 bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 {
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI()) return true;
+
     /// Update Timeout timer.
     UpdateTimeOutTime(diff);
 
@@ -307,6 +319,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                         sScriptMgr->OnPacketReceive(this, *packet);
                         opHandle->Call(this, *packet);
                         LogUnprocessedTail(packet);
+
+                            // playerbot mod
+                            if (_player && _player->GetPlayerbotMgr())
+                                _player->GetPlayerbotMgr()->HandleMasterIncomingPacket(*packet);
+                            // playerbot mod end
                     }
                     // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                     break;
@@ -394,6 +411,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 
     _recvQueue.readd(requeuePackets.begin(), requeuePackets.end());
 
+    // playerbot mod
+    if (GetPlayer() && GetPlayer()->GetPlayerbotMgr())
+        GetPlayer()->GetPlayerbotMgr()->UpdateSessions(0);
+    // end of playerbot mod
+
     if (m_Socket && m_Socket->IsOpen() && _warden)
         _warden->Update();
 
@@ -443,6 +465,11 @@ void WorldSession::LogoutPlayer(bool save)
         if (ObjectGuid lguid = _player->GetLootGUID())
             DoLootRelease(lguid);
 
+        // Playerbot mod: log out all player bots owned by this toon
+        if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->LogoutAllBots();
+        sRandomPlayerbotMgr.OnPlayerLogout(_player);
+
         ///- If the player just died before logging out, make him appear as a ghost
         if (_player->GetDeathTimer())
         {
@@ -527,7 +554,8 @@ void WorldSession::LogoutPlayer(bool save)
         _player->CleanupChannels();
 
         ///- If the player is in a group (or invited), remove him. If the group if then only 1 person, disband the group.
-        _player->UninviteFromGroup();
+        // playerbot mod
+        //_player->UninviteFromGroup();
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
@@ -1594,3 +1622,16 @@ uint32 WorldSession::DosProtection::GetMaxPacketCounterAllowed(uint16 opcode) co
 
     return maxPacketCounterAllowed;
 }
+
+void WorldSession::HandleBotPackets()
+{
+    WorldPacket* packet;
+    while (_recvQueue.next(packet))
+    {
+        ClientOpcodeHandler const* opHandle = opcodeTable[static_cast<OpcodeClient>(packet->GetOpcode())];
+        //OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+        //(this->*opHandle->handler)(*packet);
+        opHandle->Call(this, *packet);
+        delete packet;
+    }
+}
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 4e68eca..3745f76 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -192,7 +192,8 @@ class CharacterCreateInfo
     friend class WorldSession;
     friend class Player;
 
-    protected:
+    // playerbot mod
+    public:
         /// User specified variables
         std::string Name;
         uint8 Race       = 0;
@@ -821,6 +822,10 @@ class TC_GAME_API WorldSession
         void HandleBattlemasterJoinArena(WorldPacket& recvData);
         void HandleReportPvPAFK(WorldPacket& recvData);
 
+        // playerbot mod
+        void HandleBotPackets();
+        // end of playerbot mod
+
         // Battlefield
         void SendBfInvitePlayerToWar(uint32 battleId, uint32 zoneId, uint32 time);
         void SendBfInvitePlayerToQueue(uint32 battleId);
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index ad29af4..9a8c395 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -94,6 +94,11 @@
 // End of prepatch
 TC_GAME_API std::atomic<bool> World::m_stopEvent(false);
 TC_GAME_API uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
+// playerbot mod
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
+#include "../../plugins/playerbot/RandomPlayerbotMgr.h"
+
 
 TC_GAME_API std::atomic<uint32> World::m_worldLoopCounter(0);
 
@@ -2036,6 +2041,11 @@ void World::SetInitialWorldSettings()
 
     if (uint32 realmId = sConfigMgr->GetIntDefault("RealmID", 0)) // 0 reserved for auth
         sLog->SetRealmId(realmId);
+
+    TC_LOG_INFO("server.loading", "Initializing AuctionHouseBot...");
+    auctionbot.Init();
+
+    sPlayerbotAIConfig.Initialize();
 }
 
 void World::DetectDBCLang()
@@ -2205,8 +2215,15 @@ void World::Update(uint32 diff)
 
         ///- Handle expired auctions
         sAuctionMgr->Update();
+
+        // ahbot mod
+        auctionbot.Update();
     }
 
+    // playerbot mod
+    sRandomPlayerbotMgr.UpdateAI(diff);
+    sRandomPlayerbotMgr.UpdateSessions(diff);
+    
     if (m_timers[WUPDATE_AUCTIONS_PENDING].Passed())
     {
         m_timers[WUPDATE_AUCTIONS_PENDING].Reset();
@@ -2215,11 +2232,12 @@ void World::Update(uint32 diff)
     }
 
     /// <li> Handle AHBot operations
-    if (m_timers[WUPDATE_AHBOT].Passed())
-    {
-        sAuctionBot->Update();
-        m_timers[WUPDATE_AHBOT].Reset();
-    }
+    // if (m_timers[WUPDATE_AHBOT].Passed())
+    //{
+    //    sAuctionBot->Update();
+    //    m_timers[WUPDATE_AHBOT].Reset();
+    //}
+    // end of playerbot mod
 
     /// <li> Handle file changes
     if (m_timers[WUPDATE_CHECK_FILECHANGES].Passed())
@@ -2796,6 +2814,10 @@ void World::ShutdownServ(uint32 time, uint32 options, uint8 exitcode, const std:
         ShutdownMsg(true, nullptr, reason);
     }
 
+    // playerbot mod
+    sRandomPlayerbotMgr.LogoutAllBots();
+    // end of playerbot mod
+
     sScriptMgr->OnShutdownInitiate(ShutdownExitCode(exitcode), ShutdownMask(options));
 }
 
diff --git a/src/server/game/World/World.cpp.orig b/src/server/game/World/World.cpp.orig
new file mode 100644
index 0000000..ad29af4
--- /dev/null
+++ b/src/server/game/World/World.cpp.orig
@@ -0,0 +1,3456 @@
+/*
+ * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** \file
+    \ingroup world
+*/
+
+#include "World.h"
+#include "AchievementMgr.h"
+#include "ArenaTeamMgr.h"
+#include "AuctionHouseBot.h"
+#include "AuctionHouseMgr.h"
+#include "BattlefieldMgr.h"
+#include "BattlegroundMgr.h"
+#include "CalendarMgr.h"
+#include "Channel.h"
+#include "CharacterDatabaseCleaner.h"
+#include "Chat.h"
+#include "Config.h"
+#include "CreatureAIRegistry.h"
+#include "CreatureGroups.h"
+#include "CreatureTextMgr.h"
+#include "DatabaseEnv.h"
+#include "DisableMgr.h"
+#include "GameEventMgr.h"
+#include "GameObjectModel.h"
+#include "GridNotifiersImpl.h"
+#include "GroupMgr.h"
+#include "GuildMgr.h"
+#include "InstanceSaveMgr.h"
+#include "Language.h"
+#include "LFGMgr.h"
+#include "MapManager.h"
+#include "Memory.h"
+#include "MMapFactory.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "PoolMgr.h"
+#include "GitRevision.h"
+#include "ScriptMgr.h"
+#include "ScriptReloadMgr.h"
+#include "SkillDiscovery.h"
+#include "SkillExtraItems.h"
+#include "SmartAI.h"
+#include "Metric.h"
+#include "TicketMgr.h"
+#include "TransportMgr.h"
+#include "Unit.h"
+#include "VMapFactory.h"
+#include "WardenCheckMgr.h"
+#include "WaypointMovementGenerator.h"
+#include "WeatherMgr.h"
+#include "WorldSession.h"
+#include "M2Stores.h"
+// Prepatch by LordPsyan
+// 01
+// 02
+// 03
+// 04
+// 05
+// 06
+// 07
+// 08
+// 09
+// 10
+// 11
+// 12
+// 13
+// 14
+// 15
+// 16
+// 17
+// 18
+// 19
+// 20
+// Visit http://www.realmsofwarcraft.com/bb for forums and information
+//
+// End of prepatch
+TC_GAME_API std::atomic<bool> World::m_stopEvent(false);
+TC_GAME_API uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
+
+TC_GAME_API std::atomic<uint32> World::m_worldLoopCounter(0);
+
+TC_GAME_API float World::m_MaxVisibleDistanceOnContinents = DEFAULT_VISIBILITY_DISTANCE;
+TC_GAME_API float World::m_MaxVisibleDistanceInInstances  = DEFAULT_VISIBILITY_INSTANCE;
+TC_GAME_API float World::m_MaxVisibleDistanceInBGArenas   = DEFAULT_VISIBILITY_BGARENAS;
+
+TC_GAME_API int32 World::m_visibility_notify_periodOnContinents = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
+TC_GAME_API int32 World::m_visibility_notify_periodInInstances  = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
+TC_GAME_API int32 World::m_visibility_notify_periodInBGArenas   = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
+
+/// World constructor
+World::World()
+{
+    m_playerLimit = 0;
+    m_allowedSecurityLevel = SEC_PLAYER;
+    m_allowMovement = true;
+    m_ShutdownMask = 0;
+    m_ShutdownTimer = 0;
+    m_gameTime = time(NULL);
+    m_startTime = m_gameTime;
+    m_maxActiveSessionCount = 0;
+    m_maxQueuedSessionCount = 0;
+    m_PlayerCount = 0;
+    m_MaxPlayerCount = 0;
+    m_NextDailyQuestReset = 0;
+    m_NextWeeklyQuestReset = 0;
+    m_NextMonthlyQuestReset = 0;
+    m_NextRandomBGReset = 0;
+    m_NextGuildReset = 0;
+
+    m_defaultDbcLocale = LOCALE_enUS;
+    m_availableDbcLocaleMask = 0;
+
+    mail_timer = 0;
+    mail_timer_expires = 0;
+    m_updateTime = 0;
+    m_updateTimeSum = 0;
+    m_updateTimeCount = 0;
+    m_currentTime = 0;
+
+    m_isClosed = false;
+
+    m_CleaningFlags = 0;
+
+    memset(rate_values, 0, sizeof(rate_values));
+    memset(m_int_configs, 0, sizeof(m_int_configs));
+    memset(m_bool_configs, 0, sizeof(m_bool_configs));
+    memset(m_float_configs, 0, sizeof(m_float_configs));
+}
+
+/// World destructor
+World::~World()
+{
+    ///- Empty the kicked session set
+    while (!m_sessions.empty())
+    {
+        // not remove from queue, prevent loading new sessions
+        delete m_sessions.begin()->second;
+        m_sessions.erase(m_sessions.begin());
+    }
+
+    CliCommandHolder* command = NULL;
+    while (cliCmdQueue.next(command))
+        delete command;
+
+    VMAP::VMapFactory::clear();
+    MMAP::MMapFactory::clear();
+
+    /// @todo free addSessQueue
+}
+
+World* World::instance()
+{
+    static World instance;
+    return &instance;
+}
+
+/// Find a player in a specified zone
+Player* World::FindPlayerInZone(uint32 zone)
+{
+    ///- circle through active sessions and return the first player found in the zone
+    SessionMap::const_iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second)
+            continue;
+
+        Player* player = itr->second->GetPlayer();
+        if (!player)
+            continue;
+
+        if (player->IsInWorld() && player->GetZoneId() == zone)
+            return player;
+    }
+    return NULL;
+}
+
+bool World::IsClosed() const
+{
+    return m_isClosed;
+}
+
+void World::SetClosed(bool val)
+{
+    m_isClosed = val;
+
+    // Invert the value, for simplicity for scripters.
+    sScriptMgr->OnOpenStateChange(!val);
+}
+
+void World::SetMotd(const std::string& motd)
+{
+    m_motd = motd;
+
+    sScriptMgr->OnMotdChange(m_motd);
+}
+
+const char* World::GetMotd() const
+{
+    return m_motd.c_str();
+}
+
+/// Find a session by its id
+WorldSession* World::FindSession(uint32 id) const
+{
+    SessionMap::const_iterator itr = m_sessions.find(id);
+
+    if (itr != m_sessions.end())
+        return itr->second;                                 // also can return NULL for kicked session
+    else
+        return NULL;
+}
+
+/// Remove a given session
+bool World::RemoveSession(uint32 id)
+{
+    ///- Find the session, kick the user, but we can't delete session at this moment to prevent iterator invalidation
+    SessionMap::const_iterator itr = m_sessions.find(id);
+
+    if (itr != m_sessions.end() && itr->second)
+    {
+        if (itr->second->PlayerLoading())
+            return false;
+
+        itr->second->KickPlayer();
+    }
+
+    return true;
+}
+
+void World::AddSession(WorldSession* s)
+{
+    addSessQueue.add(s);
+}
+
+void World::AddSession_(WorldSession* s)
+{
+    ASSERT(s);
+
+    //NOTE - Still there is race condition in WorldSession* being used in the Sockets
+
+    ///- kick already loaded player with same account (if any) and remove session
+    ///- if player is in loading and want to load again, return
+    if (!RemoveSession (s->GetAccountId()))
+    {
+        s->KickPlayer();
+        delete s;                                           // session not added yet in session list, so not listed in queue
+        return;
+    }
+
+    // decrease session counts only at not reconnection case
+    bool decrease_session = true;
+
+    // if session already exist, prepare to it deleting at next world update
+    // NOTE - KickPlayer() should be called on "old" in RemoveSession()
+    {
+        SessionMap::const_iterator old = m_sessions.find(s->GetAccountId());
+
+        if (old != m_sessions.end())
+        {
+            // prevent decrease sessions count if session queued
+            if (RemoveQueuedPlayer(old->second))
+                decrease_session = false;
+            // not remove replaced session form queue if listed
+            delete old->second;
+        }
+    }
+
+    m_sessions[s->GetAccountId()] = s;
+
+    uint32 Sessions = GetActiveAndQueuedSessionCount();
+    uint32 pLimit = GetPlayerAmountLimit();
+    uint32 QueueSize = GetQueuedSessionCount(); //number of players in the queue
+
+    //so we don't count the user trying to
+    //login as a session and queue the socket that we are using
+    if (decrease_session)
+        --Sessions;
+
+    if (pLimit > 0 && Sessions >= pLimit && !s->HasPermission(rbac::RBAC_PERM_SKIP_QUEUE) && !HasRecentlyDisconnected(s))
+    {
+        AddQueuedPlayer(s);
+        UpdateMaxSessionCounters();
+        TC_LOG_INFO("misc", "PlayerQueue: Account id %u is in Queue Position (%u).", s->GetAccountId(), ++QueueSize);
+        return;
+    }
+
+    s->InitializeSession();
+
+    UpdateMaxSessionCounters();
+
+    // Updates the population
+    if (pLimit > 0)
+    {
+        float popu = (float)GetActiveSessionCount();              // updated number of users on the server
+        popu /= pLimit;
+        popu *= 2;
+        TC_LOG_INFO("misc", "Server Population (%f).", popu);
+    }
+}
+
+bool World::HasRecentlyDisconnected(WorldSession* session)
+{
+    if (!session)
+        return false;
+
+    if (uint32 tolerance = getIntConfig(CONFIG_INTERVAL_DISCONNECT_TOLERANCE))
+    {
+        for (DisconnectMap::iterator i = m_disconnects.begin(); i != m_disconnects.end();)
+        {
+            if (difftime(i->second, time(NULL)) < tolerance)
+            {
+                if (i->first == session->GetAccountId())
+                    return true;
+                ++i;
+            }
+            else
+                m_disconnects.erase(i++);
+        }
+    }
+    return false;
+ }
+
+int32 World::GetQueuePos(WorldSession* sess)
+{
+    uint32 position = 1;
+
+    for (Queue::const_iterator iter = m_QueuedPlayer.begin(); iter != m_QueuedPlayer.end(); ++iter, ++position)
+        if ((*iter) == sess)
+            return position;
+
+    return 0;
+}
+
+void World::AddQueuedPlayer(WorldSession* sess)
+{
+    sess->SetInQueue(true);
+    m_QueuedPlayer.push_back(sess);
+
+    // The 1st SMSG_AUTH_RESPONSE needs to contain other info too.
+    sess->SendAuthResponse(AUTH_WAIT_QUEUE, false, GetQueuePos(sess));
+}
+
+bool World::RemoveQueuedPlayer(WorldSession* sess)
+{
+    // sessions count including queued to remove (if removed_session set)
+    uint32 sessions = GetActiveSessionCount();
+
+    uint32 position = 1;
+    Queue::iterator iter = m_QueuedPlayer.begin();
+
+    // search to remove and count skipped positions
+    bool found = false;
+
+    for (; iter != m_QueuedPlayer.end(); ++iter, ++position)
+    {
+        if (*iter == sess)
+        {
+            sess->SetInQueue(false);
+            sess->ResetTimeOutTime();
+            iter = m_QueuedPlayer.erase(iter);
+            found = true;                                   // removing queued session
+            break;
+        }
+    }
+
+    // iter point to next socked after removed or end()
+    // position store position of removed socket and then new position next socket after removed
+
+    // if session not queued then we need decrease sessions count
+    if (!found && sessions)
+        --sessions;
+
+    // accept first in queue
+    if ((!m_playerLimit || sessions < m_playerLimit) && !m_QueuedPlayer.empty())
+    {
+        WorldSession* pop_sess = m_QueuedPlayer.front();
+        pop_sess->InitializeSession();
+        m_QueuedPlayer.pop_front();
+
+        // update iter to point first queued socket or end() if queue is empty now
+        iter = m_QueuedPlayer.begin();
+        position = 1;
+    }
+
+    // update position from iter to end()
+    // iter point to first not updated socket, position store new position
+    for (; iter != m_QueuedPlayer.end(); ++iter, ++position)
+        (*iter)->SendAuthWaitQue(position);
+
+    return found;
+}
+
+/// Initialize config values
+void World::LoadConfigSettings(bool reload)
+{
+    if (reload)
+    {
+        std::string configError;
+        if (!sConfigMgr->Reload(configError))
+        {
+            TC_LOG_ERROR("misc", "World settings reload fail: %s.", configError.c_str());
+            return;
+        }
+        sLog->LoadFromConfig();
+        sMetric->LoadFromConfigs();
+    }
+
+    ///- Read the player limit and the Message of the day from the config file
+    SetPlayerAmountLimit(sConfigMgr->GetIntDefault("PlayerLimit", 100));
+    SetMotd(sConfigMgr->GetStringDefault("Motd", "Welcome to a Trinity Core Server."));
+
+    ///- Read ticket system setting from the config file
+    m_bool_configs[CONFIG_ALLOW_TICKETS] = sConfigMgr->GetBoolDefault("AllowTickets", true);
+    m_bool_configs[CONFIG_DELETE_CHARACTER_TICKET_TRACE] = sConfigMgr->GetBoolDefault("DeletedCharacterTicketTrace", false);
+
+    ///- Get string for new logins (newly created characters)
+    SetNewCharString(sConfigMgr->GetStringDefault("PlayerStart.String", ""));
+
+    ///- Send server info on login?
+    m_int_configs[CONFIG_ENABLE_SINFO_LOGIN] = sConfigMgr->GetIntDefault("Server.LoginInfo", 0);
+
+    ///- Read all rates from the config file
+    rate_values[RATE_HEALTH]      = sConfigMgr->GetFloatDefault("Rate.Health", 1.0f);
+    if (rate_values[RATE_HEALTH] < 0)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.Health (%f) must be > 0. Using 1 instead.", rate_values[RATE_HEALTH]);
+        rate_values[RATE_HEALTH] = 1;
+    }
+    rate_values[RATE_POWER_MANA]  = sConfigMgr->GetFloatDefault("Rate.Mana", 1.0f);
+    if (rate_values[RATE_POWER_MANA] < 0)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.Mana (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_MANA]);
+        rate_values[RATE_POWER_MANA] = 1;
+    }
+    rate_values[RATE_POWER_RAGE_INCOME] = sConfigMgr->GetFloatDefault("Rate.Rage.Income", 1.0f);
+    rate_values[RATE_POWER_RAGE_LOSS]   = sConfigMgr->GetFloatDefault("Rate.Rage.Loss", 1.0f);
+    if (rate_values[RATE_POWER_RAGE_LOSS] < 0)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.Rage.Loss (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_RAGE_LOSS]);
+        rate_values[RATE_POWER_RAGE_LOSS] = 1;
+    }
+    rate_values[RATE_POWER_RUNICPOWER_INCOME] = sConfigMgr->GetFloatDefault("Rate.RunicPower.Income", 1.0f);
+    rate_values[RATE_POWER_RUNICPOWER_LOSS]   = sConfigMgr->GetFloatDefault("Rate.RunicPower.Loss", 1.0f);
+    if (rate_values[RATE_POWER_RUNICPOWER_LOSS] < 0)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.RunicPower.Loss (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_RUNICPOWER_LOSS]);
+        rate_values[RATE_POWER_RUNICPOWER_LOSS] = 1;
+    }
+    rate_values[RATE_POWER_FOCUS]  = sConfigMgr->GetFloatDefault("Rate.Focus", 1.0f);
+    rate_values[RATE_POWER_ENERGY] = sConfigMgr->GetFloatDefault("Rate.Energy", 1.0f);
+
+    rate_values[RATE_SKILL_DISCOVERY]      = sConfigMgr->GetFloatDefault("Rate.Skill.Discovery", 1.0f);
+
+    rate_values[RATE_DROP_ITEM_POOR]       = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Poor", 1.0f);
+    rate_values[RATE_DROP_ITEM_NORMAL]     = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Normal", 1.0f);
+    rate_values[RATE_DROP_ITEM_UNCOMMON]   = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Uncommon", 1.0f);
+    rate_values[RATE_DROP_ITEM_RARE]       = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Rare", 1.0f);
+    rate_values[RATE_DROP_ITEM_EPIC]       = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Epic", 1.0f);
+    rate_values[RATE_DROP_ITEM_LEGENDARY]  = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Legendary", 1.0f);
+    rate_values[RATE_DROP_ITEM_ARTIFACT]   = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Artifact", 1.0f);
+    rate_values[RATE_DROP_ITEM_REFERENCED] = sConfigMgr->GetFloatDefault("Rate.Drop.Item.Referenced", 1.0f);
+    rate_values[RATE_DROP_ITEM_REFERENCED_AMOUNT] = sConfigMgr->GetFloatDefault("Rate.Drop.Item.ReferencedAmount", 1.0f);
+    rate_values[RATE_DROP_MONEY]  = sConfigMgr->GetFloatDefault("Rate.Drop.Money", 1.0f);
+    rate_values[RATE_XP_KILL]     = sConfigMgr->GetFloatDefault("Rate.XP.Kill", 1.0f);
+    rate_values[RATE_XP_BG_KILL]  = sConfigMgr->GetFloatDefault("Rate.XP.BattlegroundKill", 1.0f);
+    rate_values[RATE_XP_QUEST]    = sConfigMgr->GetFloatDefault("Rate.XP.Quest", 1.0f);
+    rate_values[RATE_XP_EXPLORE]  = sConfigMgr->GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_REPAIRCOST]  = sConfigMgr->GetFloatDefault("Rate.RepairCost", 1.0f);
+    if (rate_values[RATE_REPAIRCOST] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.RepairCost (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_REPAIRCOST]);
+        rate_values[RATE_REPAIRCOST] = 0.0f;
+    }
+    rate_values[RATE_REPUTATION_GAIN]  = sConfigMgr->GetFloatDefault("Rate.Reputation.Gain", 1.0f);
+    rate_values[RATE_REPUTATION_LOWLEVEL_KILL]  = sConfigMgr->GetFloatDefault("Rate.Reputation.LowLevel.Kill", 1.0f);
+    rate_values[RATE_REPUTATION_LOWLEVEL_QUEST]  = sConfigMgr->GetFloatDefault("Rate.Reputation.LowLevel.Quest", 1.0f);
+    rate_values[RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS] = sConfigMgr->GetFloatDefault("Rate.Reputation.RecruitAFriendBonus", 0.1f);
+    rate_values[RATE_CREATURE_NORMAL_DAMAGE]          = sConfigMgr->GetFloatDefault("Rate.Creature.Normal.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_DAMAGE]     = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.Elite.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_DAMAGE] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RAREELITE.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_DAMAGE] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_DAMAGE]      = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RARE.Damage", 1.0f);
+    rate_values[RATE_CREATURE_NORMAL_HP]          = sConfigMgr->GetFloatDefault("Rate.Creature.Normal.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_HP]     = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.Elite.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_HP] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RAREELITE.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_HP] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_HP]      = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RARE.HP", 1.0f);
+    rate_values[RATE_CREATURE_NORMAL_SPELLDAMAGE]          = sConfigMgr->GetFloatDefault("Rate.Creature.Normal.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_SPELLDAMAGE]     = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.Elite.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_SPELLDAMAGE] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RAREELITE.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_SPELLDAMAGE] = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_SPELLDAMAGE]      = sConfigMgr->GetFloatDefault("Rate.Creature.Elite.RARE.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_AGGRO]  = sConfigMgr->GetFloatDefault("Rate.Creature.Aggro", 1.0f);
+    rate_values[RATE_REST_INGAME]                    = sConfigMgr->GetFloatDefault("Rate.Rest.InGame", 1.0f);
+    rate_values[RATE_REST_OFFLINE_IN_TAVERN_OR_CITY] = sConfigMgr->GetFloatDefault("Rate.Rest.Offline.InTavernOrCity", 1.0f);
+    rate_values[RATE_REST_OFFLINE_IN_WILDERNESS]     = sConfigMgr->GetFloatDefault("Rate.Rest.Offline.InWilderness", 1.0f);
+    rate_values[RATE_DAMAGE_FALL]  = sConfigMgr->GetFloatDefault("Rate.Damage.Fall", 1.0f);
+    rate_values[RATE_AUCTION_TIME]  = sConfigMgr->GetFloatDefault("Rate.Auction.Time", 1.0f);
+    rate_values[RATE_AUCTION_DEPOSIT] = sConfigMgr->GetFloatDefault("Rate.Auction.Deposit", 1.0f);
+    rate_values[RATE_AUCTION_CUT] = sConfigMgr->GetFloatDefault("Rate.Auction.Cut", 1.0f);
+    rate_values[RATE_HONOR] = sConfigMgr->GetFloatDefault("Rate.Honor", 1.0f);
+    rate_values[RATE_ARENA_POINTS] = sConfigMgr->GetFloatDefault("Rate.ArenaPoints", 1.0f);
+    rate_values[RATE_INSTANCE_RESET_TIME] = sConfigMgr->GetFloatDefault("Rate.InstanceResetTime", 1.0f);
+    rate_values[RATE_TALENT] = sConfigMgr->GetFloatDefault("Rate.Talent", 1.0f);
+    if (rate_values[RATE_TALENT] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.Talent (%f) must be > 0. Using 1 instead.", rate_values[RATE_TALENT]);
+        rate_values[RATE_TALENT] = 1.0f;
+    }
+    rate_values[RATE_MOVESPEED] = sConfigMgr->GetFloatDefault("Rate.MoveSpeed", 1.0f);
+    if (rate_values[RATE_MOVESPEED] < 0)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.MoveSpeed (%f) must be > 0. Using 1 instead.", rate_values[RATE_MOVESPEED]);
+        rate_values[RATE_MOVESPEED] = 1.0f;
+    }
+    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i) playerBaseMoveSpeed[i] = baseMoveSpeed[i] * rate_values[RATE_MOVESPEED];
+    rate_values[RATE_CORPSE_DECAY_LOOTED] = sConfigMgr->GetFloatDefault("Rate.Corpse.Decay.Looted", 0.5f);
+
+    rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = sConfigMgr->GetFloatDefault("TargetPosRecalculateRange", 1.5f);
+    if (rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] < CONTACT_DISTANCE)
+    {
+        TC_LOG_ERROR("server.loading", "TargetPosRecalculateRange (%f) must be >= %f. Using %f instead.", rate_values[RATE_TARGET_POS_RECALCULATION_RANGE], CONTACT_DISTANCE, CONTACT_DISTANCE);
+        rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = CONTACT_DISTANCE;
+    }
+    else if (rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] > NOMINAL_MELEE_RANGE)
+    {
+        TC_LOG_ERROR("server.loading", "TargetPosRecalculateRange (%f) must be <= %f. Using %f instead.",
+            rate_values[RATE_TARGET_POS_RECALCULATION_RANGE], NOMINAL_MELEE_RANGE, NOMINAL_MELEE_RANGE);
+        rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = NOMINAL_MELEE_RANGE;
+    }
+
+    rate_values[RATE_DURABILITY_LOSS_ON_DEATH]  = sConfigMgr->GetFloatDefault("DurabilityLoss.OnDeath", 10.0f);
+    if (rate_values[RATE_DURABILITY_LOSS_ON_DEATH] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "DurabilityLoss.OnDeath (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_ON_DEATH]);
+        rate_values[RATE_DURABILITY_LOSS_ON_DEATH] = 0.0f;
+    }
+    if (rate_values[RATE_DURABILITY_LOSS_ON_DEATH] > 100.0f)
+    {
+        TC_LOG_ERROR("server.loading", "DurabilityLoss.OnDeath (%f) must be <= 100. Using 100.0 instead.", rate_values[RATE_DURABILITY_LOSS_ON_DEATH]);
+        rate_values[RATE_DURABILITY_LOSS_ON_DEATH] = 0.0f;
+    }
+    rate_values[RATE_DURABILITY_LOSS_ON_DEATH] = rate_values[RATE_DURABILITY_LOSS_ON_DEATH] / 100.0f;
+
+    rate_values[RATE_DURABILITY_LOSS_DAMAGE] = sConfigMgr->GetFloatDefault("DurabilityLossChance.Damage", 0.5f);
+    if (rate_values[RATE_DURABILITY_LOSS_DAMAGE] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "DurabilityLossChance.Damage (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_DAMAGE]);
+        rate_values[RATE_DURABILITY_LOSS_DAMAGE] = 0.0f;
+    }
+    rate_values[RATE_DURABILITY_LOSS_ABSORB] = sConfigMgr->GetFloatDefault("DurabilityLossChance.Absorb", 0.5f);
+    if (rate_values[RATE_DURABILITY_LOSS_ABSORB] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "DurabilityLossChance.Absorb (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_ABSORB]);
+        rate_values[RATE_DURABILITY_LOSS_ABSORB] = 0.0f;
+    }
+    rate_values[RATE_DURABILITY_LOSS_PARRY] = sConfigMgr->GetFloatDefault("DurabilityLossChance.Parry", 0.05f);
+    if (rate_values[RATE_DURABILITY_LOSS_PARRY] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "DurabilityLossChance.Parry (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_PARRY]);
+        rate_values[RATE_DURABILITY_LOSS_PARRY] = 0.0f;
+    }
+    rate_values[RATE_DURABILITY_LOSS_BLOCK] = sConfigMgr->GetFloatDefault("DurabilityLossChance.Block", 0.05f);
+    if (rate_values[RATE_DURABILITY_LOSS_BLOCK] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "DurabilityLossChance.Block (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_BLOCK]);
+        rate_values[RATE_DURABILITY_LOSS_BLOCK] = 0.0f;
+    }
+    rate_values[RATE_MONEY_QUEST] = sConfigMgr->GetFloatDefault("Rate.Quest.Money.Reward", 1.0f);
+    if (rate_values[RATE_MONEY_QUEST] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.Quest.Money.Reward (%f) must be >=0. Using 0 instead.", rate_values[RATE_MONEY_QUEST]);
+        rate_values[RATE_MONEY_QUEST] = 0.0f;
+    }
+    rate_values[RATE_MONEY_MAX_LEVEL_QUEST] = sConfigMgr->GetFloatDefault("Rate.Quest.Money.Max.Level.Reward", 1.0f);
+    if (rate_values[RATE_MONEY_MAX_LEVEL_QUEST] < 0.0f)
+    {
+        TC_LOG_ERROR("server.loading", "Rate.Quest.Money.Max.Level.Reward (%f) must be >=0. Using 0 instead.", rate_values[RATE_MONEY_MAX_LEVEL_QUEST]);
+        rate_values[RATE_MONEY_MAX_LEVEL_QUEST] = 0.0f;
+    }
+    ///- Read other configuration items from the config file
+
+    m_bool_configs[CONFIG_DURABILITY_LOSS_IN_PVP] = sConfigMgr->GetBoolDefault("DurabilityLoss.InPvP", false);
+
+    m_int_configs[CONFIG_COMPRESSION] = sConfigMgr->GetIntDefault("Compression", 1);
+    if (m_int_configs[CONFIG_COMPRESSION] < 1 || m_int_configs[CONFIG_COMPRESSION] > 9)
+    {
+        TC_LOG_ERROR("server.loading", "Compression level (%i) must be in range 1..9. Using default compression level (1).", m_int_configs[CONFIG_COMPRESSION]);
+        m_int_configs[CONFIG_COMPRESSION] = 1;
+    }
+    m_bool_configs[CONFIG_ADDON_CHANNEL] = sConfigMgr->GetBoolDefault("AddonChannel", true);
+    m_bool_configs[CONFIG_CLEAN_CHARACTER_DB] = sConfigMgr->GetBoolDefault("CleanCharacterDB", false);
+    m_int_configs[CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS] = sConfigMgr->GetIntDefault("PersistentCharacterCleanFlags", 0);
+    m_int_configs[CONFIG_AUCTION_GETALL_DELAY] = sConfigMgr->GetIntDefault("Auction.GetAllScanDelay", 900);
+    m_int_configs[CONFIG_AUCTION_SEARCH_DELAY] = sConfigMgr->GetIntDefault("Auction.SearchDelay", 300);
+    if (m_int_configs[CONFIG_AUCTION_SEARCH_DELAY] < 100 || m_int_configs[CONFIG_AUCTION_SEARCH_DELAY] > 10000)
+    {
+        TC_LOG_ERROR("server.loading", "Auction.SearchDelay (%i) must be between 100 and 10000. Using default of 300ms", m_int_configs[CONFIG_AUCTION_SEARCH_DELAY]);
+        m_int_configs[CONFIG_AUCTION_SEARCH_DELAY] = 300;
+    }
+    m_int_configs[CONFIG_CHAT_CHANNEL_LEVEL_REQ] = sConfigMgr->GetIntDefault("ChatLevelReq.Channel", 1);
+    m_int_configs[CONFIG_CHAT_WHISPER_LEVEL_REQ] = sConfigMgr->GetIntDefault("ChatLevelReq.Whisper", 1);
+    m_int_configs[CONFIG_CHAT_EMOTE_LEVEL_REQ] = sConfigMgr->GetIntDefault("ChatLevelReq.Emote", 1);
+    m_int_configs[CONFIG_CHAT_SAY_LEVEL_REQ] = sConfigMgr->GetIntDefault("ChatLevelReq.Say", 1);
+    m_int_configs[CONFIG_CHAT_YELL_LEVEL_REQ] = sConfigMgr->GetIntDefault("ChatLevelReq.Yell", 1);
+    m_int_configs[CONFIG_PARTY_LEVEL_REQ] = sConfigMgr->GetIntDefault("PartyLevelReq", 1);
+    m_int_configs[CONFIG_TRADE_LEVEL_REQ] = sConfigMgr->GetIntDefault("LevelReq.Trade", 1);
+    m_int_configs[CONFIG_TICKET_LEVEL_REQ] = sConfigMgr->GetIntDefault("LevelReq.Ticket", 1);
+    m_int_configs[CONFIG_AUCTION_LEVEL_REQ] = sConfigMgr->GetIntDefault("LevelReq.Auction", 1);
+    m_int_configs[CONFIG_MAIL_LEVEL_REQ] = sConfigMgr->GetIntDefault("LevelReq.Mail", 1);
+    m_bool_configs[CONFIG_PRESERVE_CUSTOM_CHANNELS] = sConfigMgr->GetBoolDefault("PreserveCustomChannels", false);
+    m_int_configs[CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION] = sConfigMgr->GetIntDefault("PreserveCustomChannelDuration", 14);
+    m_bool_configs[CONFIG_GRID_UNLOAD] = sConfigMgr->GetBoolDefault("GridUnload", true);
+    m_bool_configs[CONFIG_BASEMAP_LOAD_GRIDS] = sConfigMgr->GetBoolDefault("BaseMapLoadAllGrids", false);
+    if (m_bool_configs[CONFIG_BASEMAP_LOAD_GRIDS] && m_bool_configs[CONFIG_GRID_UNLOAD])
+    {
+        TC_LOG_ERROR("server.loading", "BaseMapLoadAllGrids enabled, but GridUnload also enabled. GridUnload must be disabled to enable base map pre-loading. Base map pre-loading disabled");
+        m_bool_configs[CONFIG_BASEMAP_LOAD_GRIDS] = false;
+    }
+    m_bool_configs[CONFIG_INSTANCEMAP_LOAD_GRIDS] = sConfigMgr->GetBoolDefault("InstanceMapLoadAllGrids", false);
+    if (m_bool_configs[CONFIG_INSTANCEMAP_LOAD_GRIDS] && m_bool_configs[CONFIG_GRID_UNLOAD])
+    {
+        TC_LOG_ERROR("server.loading", "InstanceMapLoadAllGrids enabled, but GridUnload also enabled. GridUnload must be disabled to enable instance map pre-loading. Instance map pre-loading disabled");
+        m_bool_configs[CONFIG_INSTANCEMAP_LOAD_GRIDS] = false;
+    }
+    m_int_configs[CONFIG_INTERVAL_SAVE] = sConfigMgr->GetIntDefault("PlayerSaveInterval", 15 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_INTERVAL_DISCONNECT_TOLERANCE] = sConfigMgr->GetIntDefault("DisconnectToleranceInterval", 0);
+    m_bool_configs[CONFIG_STATS_SAVE_ONLY_ON_LOGOUT] = sConfigMgr->GetBoolDefault("PlayerSave.Stats.SaveOnlyOnLogout", true);
+
+    m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] = sConfigMgr->GetIntDefault("PlayerSave.Stats.MinLevel", 0);
+    if (m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] > MAX_LEVEL)
+    {
+        TC_LOG_ERROR("server.loading", "PlayerSave.Stats.MinLevel (%i) must be in range 0..80. Using default, do not save character stats (0).", m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE]);
+        m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] = 0;
+    }
+
+    m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] = sConfigMgr->GetIntDefault("GridCleanUpDelay", 5 * MINUTE * IN_MILLISECONDS);
+    if (m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] < MIN_GRID_DELAY)
+    {
+        TC_LOG_ERROR("server.loading", "GridCleanUpDelay (%i) must be greater %u. Use this minimal value.", m_int_configs[CONFIG_INTERVAL_GRIDCLEAN], MIN_GRID_DELAY);
+        m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] = MIN_GRID_DELAY;
+    }
+    if (reload)
+        sMapMgr->SetGridCleanUpDelay(m_int_configs[CONFIG_INTERVAL_GRIDCLEAN]);
+
+    m_int_configs[CONFIG_INTERVAL_MAPUPDATE] = sConfigMgr->GetIntDefault("MapUpdateInterval", 100);
+    if (m_int_configs[CONFIG_INTERVAL_MAPUPDATE] < MIN_MAP_UPDATE_DELAY)
+    {
+        TC_LOG_ERROR("server.loading", "MapUpdateInterval (%i) must be greater %u. Use this minimal value.", m_int_configs[CONFIG_INTERVAL_MAPUPDATE], MIN_MAP_UPDATE_DELAY);
+        m_int_configs[CONFIG_INTERVAL_MAPUPDATE] = MIN_MAP_UPDATE_DELAY;
+    }
+    if (reload)
+        sMapMgr->SetMapUpdateInterval(m_int_configs[CONFIG_INTERVAL_MAPUPDATE]);
+
+    m_int_configs[CONFIG_INTERVAL_CHANGEWEATHER] = sConfigMgr->GetIntDefault("ChangeWeatherInterval", 10 * MINUTE * IN_MILLISECONDS);
+
+    if (reload)
+    {
+        uint32 val = sConfigMgr->GetIntDefault("WorldServerPort", 8085);
+        if (val != m_int_configs[CONFIG_PORT_WORLD])
+            TC_LOG_ERROR("server.loading", "WorldServerPort option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_PORT_WORLD]);
+    }
+    else
+        m_int_configs[CONFIG_PORT_WORLD] = sConfigMgr->GetIntDefault("WorldServerPort", 8085);
+
+    m_int_configs[CONFIG_SOCKET_TIMEOUTTIME] = sConfigMgr->GetIntDefault("SocketTimeOutTime", 900000);
+    m_int_configs[CONFIG_SESSION_ADD_DELAY] = sConfigMgr->GetIntDefault("SessionAddDelay", 10000);
+
+    m_float_configs[CONFIG_GROUP_XP_DISTANCE] = sConfigMgr->GetFloatDefault("MaxGroupXPDistance", 74.0f);
+    m_float_configs[CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE] = sConfigMgr->GetFloatDefault("MaxRecruitAFriendBonusDistance", 100.0f);
+
+    /// @todo Add MonsterSight (with meaning) in worldserver.conf or put them as define
+    m_float_configs[CONFIG_SIGHT_MONSTER] = sConfigMgr->GetFloatDefault("MonsterSight", 50.0f);
+
+    if (reload)
+    {
+        uint32 val = sConfigMgr->GetIntDefault("GameType", 0);
+        if (val != m_int_configs[CONFIG_GAME_TYPE])
+            TC_LOG_ERROR("server.loading", "GameType option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_GAME_TYPE]);
+    }
+    else
+        m_int_configs[CONFIG_GAME_TYPE] = sConfigMgr->GetIntDefault("GameType", 0);
+
+    if (reload)
+    {
+        uint32 val = sConfigMgr->GetIntDefault("RealmZone", REALM_ZONE_DEVELOPMENT);
+        if (val != m_int_configs[CONFIG_REALM_ZONE])
+            TC_LOG_ERROR("server.loading", "RealmZone option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_REALM_ZONE]);
+    }
+    else
+        m_int_configs[CONFIG_REALM_ZONE] = sConfigMgr->GetIntDefault("RealmZone", REALM_ZONE_DEVELOPMENT);
+
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CALENDAR]= sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Calendar", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHANNEL] = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Channel", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP]   = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Group", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD]   = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Guild", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION] = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Auction", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_TRADE]               = sConfigMgr->GetBoolDefault("AllowTwoSide.Trade", false);
+    m_int_configs[CONFIG_STRICT_PLAYER_NAMES]                 = sConfigMgr->GetIntDefault ("StrictPlayerNames",  0);
+    m_int_configs[CONFIG_STRICT_CHARTER_NAMES]                = sConfigMgr->GetIntDefault ("StrictCharterNames", 0);
+    m_int_configs[CONFIG_STRICT_PET_NAMES]                    = sConfigMgr->GetIntDefault ("StrictPetNames",     0);
+
+    m_int_configs[CONFIG_MIN_PLAYER_NAME]                     = sConfigMgr->GetIntDefault ("MinPlayerName",  2);
+    if (m_int_configs[CONFIG_MIN_PLAYER_NAME] < 1 || m_int_configs[CONFIG_MIN_PLAYER_NAME] > MAX_PLAYER_NAME)
+    {
+        TC_LOG_ERROR("server.loading", "MinPlayerName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_PLAYER_NAME], MAX_PLAYER_NAME);
+        m_int_configs[CONFIG_MIN_PLAYER_NAME] = 2;
+    }
+
+    m_int_configs[CONFIG_MIN_CHARTER_NAME]                    = sConfigMgr->GetIntDefault ("MinCharterName", 2);
+    if (m_int_configs[CONFIG_MIN_CHARTER_NAME] < 1 || m_int_configs[CONFIG_MIN_CHARTER_NAME] > MAX_CHARTER_NAME)
+    {
+        TC_LOG_ERROR("server.loading", "MinCharterName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_CHARTER_NAME], MAX_CHARTER_NAME);
+        m_int_configs[CONFIG_MIN_CHARTER_NAME] = 2;
+    }
+
+    m_int_configs[CONFIG_MIN_PET_NAME]                        = sConfigMgr->GetIntDefault ("MinPetName",     2);
+    if (m_int_configs[CONFIG_MIN_PET_NAME] < 1 || m_int_configs[CONFIG_MIN_PET_NAME] > MAX_PET_NAME)
+    {
+        TC_LOG_ERROR("server.loading", "MinPetName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_PET_NAME], MAX_PET_NAME);
+        m_int_configs[CONFIG_MIN_PET_NAME] = 2;
+    }
+
+    m_int_configs[CONFIG_CHARTER_COST_GUILD] = sConfigMgr->GetIntDefault("Guild.CharterCost", 1000);
+    m_int_configs[CONFIG_CHARTER_COST_ARENA_2v2] = sConfigMgr->GetIntDefault("ArenaTeam.CharterCost.2v2", 800000);
+    m_int_configs[CONFIG_CHARTER_COST_ARENA_3v3] = sConfigMgr->GetIntDefault("ArenaTeam.CharterCost.3v3", 1200000);
+    m_int_configs[CONFIG_CHARTER_COST_ARENA_5v5] = sConfigMgr->GetIntDefault("ArenaTeam.CharterCost.5v5", 2000000);
+
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED] = sConfigMgr->GetIntDefault("CharacterCreating.Disabled", 0);
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED_RACEMASK] = sConfigMgr->GetIntDefault("CharacterCreating.Disabled.RaceMask", 0);
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED_CLASSMASK] = sConfigMgr->GetIntDefault("CharacterCreating.Disabled.ClassMask", 0);
+
+    m_int_configs[CONFIG_CHARACTERS_PER_REALM] = sConfigMgr->GetIntDefault("CharactersPerRealm", 10);
+    if (m_int_configs[CONFIG_CHARACTERS_PER_REALM] < 1 || m_int_configs[CONFIG_CHARACTERS_PER_REALM] > 10)
+    {
+        TC_LOG_ERROR("server.loading", "CharactersPerRealm (%i) must be in range 1..10. Set to 10.", m_int_configs[CONFIG_CHARACTERS_PER_REALM]);
+        m_int_configs[CONFIG_CHARACTERS_PER_REALM] = 10;
+    }
+
+    // must be after CONFIG_CHARACTERS_PER_REALM
+    m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] = sConfigMgr->GetIntDefault("CharactersPerAccount", 50);
+    if (m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] < m_int_configs[CONFIG_CHARACTERS_PER_REALM])
+    {
+        TC_LOG_ERROR("server.loading", "CharactersPerAccount (%i) can't be less than CharactersPerRealm (%i).", m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT], m_int_configs[CONFIG_CHARACTERS_PER_REALM]);
+        m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] = m_int_configs[CONFIG_CHARACTERS_PER_REALM];
+    }
+
+    m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] = sConfigMgr->GetIntDefault("HeroicCharactersPerRealm", 1);
+    if (int32(m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM]) < 0 || m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] > 10)
+    {
+        TC_LOG_ERROR("server.loading", "HeroicCharactersPerRealm (%i) must be in range 0..10. Set to 1.", m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM]);
+        m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] = 1;
+    }
+
+    m_int_configs[CONFIG_CHARACTER_CREATING_MIN_LEVEL_FOR_HEROIC_CHARACTER] = sConfigMgr->GetIntDefault("CharacterCreating.MinLevelForHeroicCharacter", 55);
+
+    m_int_configs[CONFIG_SKIP_CINEMATICS] = sConfigMgr->GetIntDefault("SkipCinematics", 0);
+    if (int32(m_int_configs[CONFIG_SKIP_CINEMATICS]) < 0 || m_int_configs[CONFIG_SKIP_CINEMATICS] > 2)
+    {
+        TC_LOG_ERROR("server.loading", "SkipCinematics (%i) must be in range 0..2. Set to 0.", m_int_configs[CONFIG_SKIP_CINEMATICS]);
+        m_int_configs[CONFIG_SKIP_CINEMATICS] = 0;
+    }
+
+    if (reload)
+    {
+        uint32 val = sConfigMgr->GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
+        if (val != m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+            TC_LOG_ERROR("server.loading", "MaxPlayerLevel option can't be changed at config reload, using current value (%u).", m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+    }
+    else
+        m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = sConfigMgr->GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
+
+    if (m_int_configs[CONFIG_MAX_PLAYER_LEVEL] > MAX_LEVEL)
+    {
+        TC_LOG_ERROR("server.loading", "MaxPlayerLevel (%i) must be in range 1..%u. Set to %u.", m_int_configs[CONFIG_MAX_PLAYER_LEVEL], MAX_LEVEL, MAX_LEVEL);
+        m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = MAX_LEVEL;
+    }
+
+    m_int_configs[CONFIG_MIN_DUALSPEC_LEVEL] = sConfigMgr->GetIntDefault("MinDualSpecLevel", 40);
+
+    m_int_configs[CONFIG_START_PLAYER_LEVEL] = sConfigMgr->GetIntDefault("StartPlayerLevel", 1);
+    if (m_int_configs[CONFIG_START_PLAYER_LEVEL] < 1)
+    {
+        TC_LOG_ERROR("server.loading", "StartPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to 1.", m_int_configs[CONFIG_START_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_PLAYER_LEVEL] = 1;
+    }
+    else if (m_int_configs[CONFIG_START_PLAYER_LEVEL] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+    {
+        TC_LOG_ERROR("server.loading", "StartPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to %u.", m_int_configs[CONFIG_START_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_PLAYER_LEVEL] = m_int_configs[CONFIG_MAX_PLAYER_LEVEL];
+    }
+
+    m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = sConfigMgr->GetIntDefault("StartHeroicPlayerLevel", 55);
+    if (m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] < 1)
+    {
+        TC_LOG_ERROR("server.loading", "StartHeroicPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to 55.",
+            m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = 55;
+    }
+    else if (m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+    {
+        TC_LOG_ERROR("server.loading", "StartHeroicPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to %u.",
+            m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = m_int_configs[CONFIG_MAX_PLAYER_LEVEL];
+    }
+
+    m_int_configs[CONFIG_START_PLAYER_MONEY] = sConfigMgr->GetIntDefault("StartPlayerMoney", 0);
+    if (int32(m_int_configs[CONFIG_START_PLAYER_MONEY]) < 0)
+    {
+        TC_LOG_ERROR("server.loading", "StartPlayerMoney (%i) must be in range 0..%u. Set to %u.", m_int_configs[CONFIG_START_PLAYER_MONEY], MAX_MONEY_AMOUNT, 0);
+        m_int_configs[CONFIG_START_PLAYER_MONEY] = 0;
+    }
+    else if (m_int_configs[CONFIG_START_PLAYER_MONEY] > MAX_MONEY_AMOUNT)
+    {
+        TC_LOG_ERROR("server.loading", "StartPlayerMoney (%i) must be in range 0..%u. Set to %u.",
+            m_int_configs[CONFIG_START_PLAYER_MONEY], MAX_MONEY_AMOUNT, MAX_MONEY_AMOUNT);
+        m_int_configs[CONFIG_START_PLAYER_MONEY] = MAX_MONEY_AMOUNT;
+    }
+
+    m_int_configs[CONFIG_MAX_HONOR_POINTS] = sConfigMgr->GetIntDefault("MaxHonorPoints", 75000);
+    if (int32(m_int_configs[CONFIG_MAX_HONOR_POINTS]) < 0)
+    {
+        TC_LOG_ERROR("server.loading", "MaxHonorPoints (%i) can't be negative. Set to 0.", m_int_configs[CONFIG_MAX_HONOR_POINTS]);
+        m_int_configs[CONFIG_MAX_HONOR_POINTS] = 0;
+    }
+
+    m_int_configs[CONFIG_START_HONOR_POINTS] = sConfigMgr->GetIntDefault("StartHonorPoints", 0);
+    if (int32(m_int_configs[CONFIG_START_HONOR_POINTS]) < 0)
+    {
+        TC_LOG_ERROR("server.loading", "StartHonorPoints (%i) must be in range 0..MaxHonorPoints(%u). Set to %u.",
+            m_int_configs[CONFIG_START_HONOR_POINTS], m_int_configs[CONFIG_MAX_HONOR_POINTS], 0);
+        m_int_configs[CONFIG_START_HONOR_POINTS] = 0;
+    }
+    else if (m_int_configs[CONFIG_START_HONOR_POINTS] > m_int_configs[CONFIG_MAX_HONOR_POINTS])
+    {
+        TC_LOG_ERROR("server.loading", "StartHonorPoints (%i) must be in range 0..MaxHonorPoints(%u). Set to %u.",
+            m_int_configs[CONFIG_START_HONOR_POINTS], m_int_configs[CONFIG_MAX_HONOR_POINTS], m_int_configs[CONFIG_MAX_HONOR_POINTS]);
+        m_int_configs[CONFIG_START_HONOR_POINTS] = m_int_configs[CONFIG_MAX_HONOR_POINTS];
+    }
+
+    m_int_configs[CONFIG_MAX_ARENA_POINTS] = sConfigMgr->GetIntDefault("MaxArenaPoints", 10000);
+    if (int32(m_int_configs[CONFIG_MAX_ARENA_POINTS]) < 0)
+    {
+        TC_LOG_ERROR("server.loading", "MaxArenaPoints (%i) can't be negative. Set to 0.", m_int_configs[CONFIG_MAX_ARENA_POINTS]);
+        m_int_configs[CONFIG_MAX_ARENA_POINTS] = 0;
+    }
+
+    m_int_configs[CONFIG_START_ARENA_POINTS] = sConfigMgr->GetIntDefault("StartArenaPoints", 0);
+    if (int32(m_int_configs[CONFIG_START_ARENA_POINTS]) < 0)
+    {
+        TC_LOG_ERROR("server.loading", "StartArenaPoints (%i) must be in range 0..MaxArenaPoints(%u). Set to %u.",
+            m_int_configs[CONFIG_START_ARENA_POINTS], m_int_configs[CONFIG_MAX_ARENA_POINTS], 0);
+        m_int_configs[CONFIG_START_ARENA_POINTS] = 0;
+    }
+    else if (m_int_configs[CONFIG_START_ARENA_POINTS] > m_int_configs[CONFIG_MAX_ARENA_POINTS])
+    {
+        TC_LOG_ERROR("server.loading", "StartArenaPoints (%i) must be in range 0..MaxArenaPoints(%u). Set to %u.",
+            m_int_configs[CONFIG_START_ARENA_POINTS], m_int_configs[CONFIG_MAX_ARENA_POINTS], m_int_configs[CONFIG_MAX_ARENA_POINTS]);
+        m_int_configs[CONFIG_START_ARENA_POINTS] = m_int_configs[CONFIG_MAX_ARENA_POINTS];
+    }
+
+    m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] = sConfigMgr->GetIntDefault("RecruitAFriend.MaxLevel", 60);
+    if (m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+    {
+        TC_LOG_ERROR("server.loading", "RecruitAFriend.MaxLevel (%i) must be in the range 0..MaxLevel(%u). Set to %u.",
+            m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL], 60);
+        m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] = 60;
+    }
+
+    m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE] = sConfigMgr->GetIntDefault("RecruitAFriend.MaxDifference", 4);
+    m_bool_configs[CONFIG_ALL_TAXI_PATHS] = sConfigMgr->GetBoolDefault("AllFlightPaths", false);
+    m_bool_configs[CONFIG_INSTANT_TAXI] = sConfigMgr->GetBoolDefault("InstantFlightPaths", false);
+
+    m_bool_configs[CONFIG_INSTANCE_IGNORE_LEVEL] = sConfigMgr->GetBoolDefault("Instance.IgnoreLevel", false);
+    m_bool_configs[CONFIG_INSTANCE_IGNORE_RAID]  = sConfigMgr->GetBoolDefault("Instance.IgnoreRaid", false);
+
+    m_bool_configs[CONFIG_CAST_UNSTUCK] = sConfigMgr->GetBoolDefault("CastUnstuck", true);
+    m_int_configs[CONFIG_INSTANCE_RESET_TIME_HOUR]  = sConfigMgr->GetIntDefault("Instance.ResetTimeHour", 4);
+    m_int_configs[CONFIG_INSTANCE_UNLOAD_DELAY] = sConfigMgr->GetIntDefault("Instance.UnloadDelay", 30 * MINUTE * IN_MILLISECONDS);
+
+    m_int_configs[CONFIG_MAX_PRIMARY_TRADE_SKILL] = sConfigMgr->GetIntDefault("MaxPrimaryTradeSkill", 2);
+    m_int_configs[CONFIG_MIN_PETITION_SIGNS] = sConfigMgr->GetIntDefault("MinPetitionSigns", 9);
+    if (m_int_configs[CONFIG_MIN_PETITION_SIGNS] > 9)
+    {
+        TC_LOG_ERROR("server.loading", "MinPetitionSigns (%i) must be in range 0..9. Set to 9.", m_int_configs[CONFIG_MIN_PETITION_SIGNS]);
+        m_int_configs[CONFIG_MIN_PETITION_SIGNS] = 9;
+    }
+
+    m_int_configs[CONFIG_GM_LOGIN_STATE]        = sConfigMgr->GetIntDefault("GM.LoginState", 2);
+    m_int_configs[CONFIG_GM_VISIBLE_STATE]      = sConfigMgr->GetIntDefault("GM.Visible", 2);
+    m_int_configs[CONFIG_GM_CHAT]               = sConfigMgr->GetIntDefault("GM.Chat", 2);
+    m_int_configs[CONFIG_GM_WHISPERING_TO]      = sConfigMgr->GetIntDefault("GM.WhisperingTo", 2);
+    m_int_configs[CONFIG_GM_FREEZE_DURATION]    = sConfigMgr->GetIntDefault("GM.FreezeAuraDuration", 0);
+
+    m_int_configs[CONFIG_GM_LEVEL_IN_GM_LIST]   = sConfigMgr->GetIntDefault("GM.InGMList.Level", SEC_ADMINISTRATOR);
+    m_int_configs[CONFIG_GM_LEVEL_IN_WHO_LIST]  = sConfigMgr->GetIntDefault("GM.InWhoList.Level", SEC_ADMINISTRATOR);
+    m_int_configs[CONFIG_START_GM_LEVEL]        = sConfigMgr->GetIntDefault("GM.StartLevel", 1);
+    if (m_int_configs[CONFIG_START_GM_LEVEL] < m_int_configs[CONFIG_START_PLAYER_LEVEL])
+    {
+        TC_LOG_ERROR("server.loading", "GM.StartLevel (%i) must be in range StartPlayerLevel(%u)..%u. Set to %u.",
+            m_int_configs[CONFIG_START_GM_LEVEL], m_int_configs[CONFIG_START_PLAYER_LEVEL], MAX_LEVEL, m_int_configs[CONFIG_START_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_GM_LEVEL] = m_int_configs[CONFIG_START_PLAYER_LEVEL];
+    }
+    else if (m_int_configs[CONFIG_START_GM_LEVEL] > MAX_LEVEL)
+    {
+        TC_LOG_ERROR("server.loading", "GM.StartLevel (%i) must be in range 1..%u. Set to %u.", m_int_configs[CONFIG_START_GM_LEVEL], MAX_LEVEL, MAX_LEVEL);
+        m_int_configs[CONFIG_START_GM_LEVEL] = MAX_LEVEL;
+    }
+    m_bool_configs[CONFIG_ALLOW_GM_GROUP]       = sConfigMgr->GetBoolDefault("GM.AllowInvite", false);
+    m_bool_configs[CONFIG_GM_LOWER_SECURITY] = sConfigMgr->GetBoolDefault("GM.LowerSecurity", false);
+    m_float_configs[CONFIG_CHANCE_OF_GM_SURVEY] = sConfigMgr->GetFloatDefault("GM.TicketSystem.ChanceOfGMSurvey", 50.0f);
+    m_int_configs[CONFIG_FORCE_SHUTDOWN_THRESHOLD] = sConfigMgr->GetIntDefault("GM.ForceShutdownThreshold", 30);
+
+    m_int_configs[CONFIG_GROUP_VISIBILITY] = sConfigMgr->GetIntDefault("Visibility.GroupMode", 1);
+
+    m_int_configs[CONFIG_MAIL_DELIVERY_DELAY] = sConfigMgr->GetIntDefault("MailDeliveryDelay", HOUR);
+
+    m_int_configs[CONFIG_UPTIME_UPDATE] = sConfigMgr->GetIntDefault("UpdateUptimeInterval", 10);
+    if (int32(m_int_configs[CONFIG_UPTIME_UPDATE]) <= 0)
+    {
+        TC_LOG_ERROR("server.loading", "UpdateUptimeInterval (%i) must be > 0, set to default 10.", m_int_configs[CONFIG_UPTIME_UPDATE]);
+        m_int_configs[CONFIG_UPTIME_UPDATE] = 10;
+    }
+    if (reload)
+    {
+        m_timers[WUPDATE_UPTIME].SetInterval(m_int_configs[CONFIG_UPTIME_UPDATE]*MINUTE*IN_MILLISECONDS);
+        m_timers[WUPDATE_UPTIME].Reset();
+    }
+
+    // log db cleanup interval
+    m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] = sConfigMgr->GetIntDefault("LogDB.Opt.ClearInterval", 10);
+    if (int32(m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]) <= 0)
+    {
+        TC_LOG_ERROR("server.loading", "LogDB.Opt.ClearInterval (%i) must be > 0, set to default 10.", m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]);
+        m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] = 10;
+    }
+    if (reload)
+    {
+        m_timers[WUPDATE_CLEANDB].SetInterval(m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] * MINUTE * IN_MILLISECONDS);
+        m_timers[WUPDATE_CLEANDB].Reset();
+    }
+    m_int_configs[CONFIG_LOGDB_CLEARTIME] = sConfigMgr->GetIntDefault("LogDB.Opt.ClearTime", 1209600); // 14 days default
+    TC_LOG_INFO("server.loading", "Will clear `logs` table of entries older than %i seconds every %u minutes.",
+        m_int_configs[CONFIG_LOGDB_CLEARTIME], m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]);
+
+    m_int_configs[CONFIG_SKILL_CHANCE_ORANGE] = sConfigMgr->GetIntDefault("SkillChance.Orange", 100);
+    m_int_configs[CONFIG_SKILL_CHANCE_YELLOW] = sConfigMgr->GetIntDefault("SkillChance.Yellow", 75);
+    m_int_configs[CONFIG_SKILL_CHANCE_GREEN]  = sConfigMgr->GetIntDefault("SkillChance.Green", 25);
+    m_int_configs[CONFIG_SKILL_CHANCE_GREY]   = sConfigMgr->GetIntDefault("SkillChance.Grey", 0);
+
+    m_int_configs[CONFIG_SKILL_CHANCE_MINING_STEPS]  = sConfigMgr->GetIntDefault("SkillChance.MiningSteps", 75);
+    m_int_configs[CONFIG_SKILL_CHANCE_SKINNING_STEPS]   = sConfigMgr->GetIntDefault("SkillChance.SkinningSteps", 75);
+
+    m_bool_configs[CONFIG_SKILL_PROSPECTING] = sConfigMgr->GetBoolDefault("SkillChance.Prospecting", false);
+    m_bool_configs[CONFIG_SKILL_MILLING] = sConfigMgr->GetBoolDefault("SkillChance.Milling", false);
+
+    m_int_configs[CONFIG_SKILL_GAIN_CRAFTING]  = sConfigMgr->GetIntDefault("SkillGain.Crafting", 1);
+
+    m_int_configs[CONFIG_SKILL_GAIN_DEFENSE]  = sConfigMgr->GetIntDefault("SkillGain.Defense", 1);
+
+    m_int_configs[CONFIG_SKILL_GAIN_GATHERING]  = sConfigMgr->GetIntDefault("SkillGain.Gathering", 1);
+
+    m_int_configs[CONFIG_SKILL_GAIN_WEAPON]  = sConfigMgr->GetIntDefault("SkillGain.Weapon", 1);
+
+    m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] = sConfigMgr->GetIntDefault("MaxOverspeedPings", 2);
+    if (m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] != 0 && m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] < 2)
+    {
+        TC_LOG_ERROR("server.loading", "MaxOverspeedPings (%i) must be in range 2..infinity (or 0 to disable check). Set to 2.", m_int_configs[CONFIG_MAX_OVERSPEED_PINGS]);
+        m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] = 2;
+    }
+
+    m_bool_configs[CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY] = sConfigMgr->GetBoolDefault("SaveRespawnTimeImmediately", true);
+    if (!m_bool_configs[CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY])
+    {
+        TC_LOG_WARN("server.loading", "SaveRespawnTimeImmediately triggers assertions when disabled, overridden to Enabled");
+        m_bool_configs[CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY] = true;
+    }
+
+    m_bool_configs[CONFIG_WEATHER] = sConfigMgr->GetBoolDefault("ActivateWeather", true);
+
+    m_int_configs[CONFIG_DISABLE_BREATHING] = sConfigMgr->GetIntDefault("DisableWaterBreath", SEC_CONSOLE);
+
+    m_bool_configs[CONFIG_ALWAYS_MAX_SKILL_FOR_LEVEL] = sConfigMgr->GetBoolDefault("AlwaysMaxSkillForLevel", false);
+
+    if (reload)
+    {
+        uint32 val = sConfigMgr->GetIntDefault("Expansion", 2);
+        if (val != m_int_configs[CONFIG_EXPANSION])
+            TC_LOG_ERROR("server.loading", "Expansion option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_EXPANSION]);
+    }
+    else
+        m_int_configs[CONFIG_EXPANSION] = sConfigMgr->GetIntDefault("Expansion", 2);
+
+    m_int_configs[CONFIG_CHATFLOOD_MESSAGE_COUNT] = sConfigMgr->GetIntDefault("ChatFlood.MessageCount", 10);
+    m_int_configs[CONFIG_CHATFLOOD_MESSAGE_DELAY] = sConfigMgr->GetIntDefault("ChatFlood.MessageDelay", 1);
+    m_int_configs[CONFIG_CHATFLOOD_MUTE_TIME]     = sConfigMgr->GetIntDefault("ChatFlood.MuteTime", 10);
+
+    m_bool_configs[CONFIG_EVENT_ANNOUNCE] = sConfigMgr->GetBoolDefault("Event.Announce", false);
+
+    m_float_configs[CONFIG_CREATURE_FAMILY_FLEE_ASSISTANCE_RADIUS] = sConfigMgr->GetFloatDefault("CreatureFamilyFleeAssistanceRadius", 30.0f);
+    m_float_configs[CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS] = sConfigMgr->GetFloatDefault("CreatureFamilyAssistanceRadius", 10.0f);
+    m_int_configs[CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY]  = sConfigMgr->GetIntDefault("CreatureFamilyAssistanceDelay", 1500);
+    m_int_configs[CONFIG_CREATURE_FAMILY_FLEE_DELAY]        = sConfigMgr->GetIntDefault("CreatureFamilyFleeDelay", 7000);
+
+    m_int_configs[CONFIG_WORLD_BOSS_LEVEL_DIFF] = sConfigMgr->GetIntDefault("WorldBossLevelDiff", 3);
+
+    m_bool_configs[CONFIG_QUEST_ENABLE_QUEST_TRACKER] = sConfigMgr->GetBoolDefault("Quests.EnableQuestTracker", false);
+
+    // note: disable value (-1) will assigned as 0xFFFFFFF, to prevent overflow at calculations limit it to max possible player level MAX_LEVEL(100)
+    m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] = sConfigMgr->GetIntDefault("Quests.LowLevelHideDiff", 4);
+    if (m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] > MAX_LEVEL)
+        m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] = MAX_LEVEL;
+    m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] = sConfigMgr->GetIntDefault("Quests.HighLevelHideDiff", 7);
+    if (m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] > MAX_LEVEL)
+        m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] = MAX_LEVEL;
+    m_bool_configs[CONFIG_QUEST_IGNORE_RAID] = sConfigMgr->GetBoolDefault("Quests.IgnoreRaid", false);
+    m_bool_configs[CONFIG_QUEST_IGNORE_AUTO_ACCEPT] = sConfigMgr->GetBoolDefault("Quests.IgnoreAutoAccept", false);
+    m_bool_configs[CONFIG_QUEST_IGNORE_AUTO_COMPLETE] = sConfigMgr->GetBoolDefault("Quests.IgnoreAutoComplete", false);
+
+    m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] = sConfigMgr->GetIntDefault("Battleground.Random.ResetHour", 6);
+    if (m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] > 23)
+    {
+        TC_LOG_ERROR("server.loading", "Battleground.Random.ResetHour (%i) can't be load. Set to 6.", m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR]);
+        m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] = 6;
+    }
+
+    m_int_configs[CONFIG_GUILD_RESET_HOUR] = sConfigMgr->GetIntDefault("Guild.ResetHour", 6);
+    if (m_int_configs[CONFIG_GUILD_RESET_HOUR] > 23)
+    {
+        TC_LOG_ERROR("misc", "Guild.ResetHour (%i) can't be load. Set to 6.", m_int_configs[CONFIG_GUILD_RESET_HOUR]);
+        m_int_configs[CONFIG_GUILD_RESET_HOUR] = 6;
+    }
+
+    m_bool_configs[CONFIG_DETECT_POS_COLLISION] = sConfigMgr->GetBoolDefault("DetectPosCollision", true);
+
+    m_bool_configs[CONFIG_RESTRICTED_LFG_CHANNEL]      = sConfigMgr->GetBoolDefault("Channel.RestrictedLfg", true);
+    m_int_configs[CONFIG_TALENTS_INSPECTING]           = sConfigMgr->GetIntDefault("TalentsInspecting", 1);
+    m_bool_configs[CONFIG_CHAT_FAKE_MESSAGE_PREVENTING] = sConfigMgr->GetBoolDefault("ChatFakeMessagePreventing", false);
+    m_int_configs[CONFIG_CHAT_STRICT_LINK_CHECKING_SEVERITY] = sConfigMgr->GetIntDefault("ChatStrictLinkChecking.Severity", 0);
+    m_int_configs[CONFIG_CHAT_STRICT_LINK_CHECKING_KICK] = sConfigMgr->GetIntDefault("ChatStrictLinkChecking.Kick", 0);
+
+    m_int_configs[CONFIG_CORPSE_DECAY_NORMAL]    = sConfigMgr->GetIntDefault("Corpse.Decay.NORMAL", 60);
+    m_int_configs[CONFIG_CORPSE_DECAY_RARE]      = sConfigMgr->GetIntDefault("Corpse.Decay.RARE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_ELITE]     = sConfigMgr->GetIntDefault("Corpse.Decay.ELITE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_RAREELITE] = sConfigMgr->GetIntDefault("Corpse.Decay.RAREELITE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_WORLDBOSS] = sConfigMgr->GetIntDefault("Corpse.Decay.WORLDBOSS", 3600);
+
+    m_int_configs[CONFIG_DEATH_SICKNESS_LEVEL]           = sConfigMgr->GetIntDefault ("Death.SicknessLevel", 11);
+    m_bool_configs[CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP] = sConfigMgr->GetBoolDefault("Death.CorpseReclaimDelay.PvP", true);
+    m_bool_configs[CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE] = sConfigMgr->GetBoolDefault("Death.CorpseReclaimDelay.PvE", true);
+    m_bool_configs[CONFIG_DEATH_BONES_WORLD]              = sConfigMgr->GetBoolDefault("Death.Bones.World", true);
+    m_bool_configs[CONFIG_DEATH_BONES_BG_OR_ARENA]        = sConfigMgr->GetBoolDefault("Death.Bones.BattlegroundOrArena", true);
+
+    m_bool_configs[CONFIG_DIE_COMMAND_MODE] = sConfigMgr->GetBoolDefault("Die.Command.Mode", true);
+
+    m_float_configs[CONFIG_THREAT_RADIUS] = sConfigMgr->GetFloatDefault("ThreatRadius", 60.0f);
+
+    // always use declined names in the russian client
+    m_bool_configs[CONFIG_DECLINED_NAMES_USED] =
+        (m_int_configs[CONFIG_REALM_ZONE] == REALM_ZONE_RUSSIAN) ? true : sConfigMgr->GetBoolDefault("DeclinedNames", false);
+
+    m_float_configs[CONFIG_LISTEN_RANGE_SAY]       = sConfigMgr->GetFloatDefault("ListenRange.Say", 25.0f);
+    m_float_configs[CONFIG_LISTEN_RANGE_TEXTEMOTE] = sConfigMgr->GetFloatDefault("ListenRange.TextEmote", 25.0f);
+    m_float_configs[CONFIG_LISTEN_RANGE_YELL]      = sConfigMgr->GetFloatDefault("ListenRange.Yell", 300.0f);
+
+    m_bool_configs[CONFIG_BATTLEGROUND_CAST_DESERTER]                = sConfigMgr->GetBoolDefault("Battleground.CastDeserter", true);
+    m_bool_configs[CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE]       = sConfigMgr->GetBoolDefault("Battleground.QueueAnnouncer.Enable", false);
+    m_bool_configs[CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY]   = sConfigMgr->GetBoolDefault("Battleground.QueueAnnouncer.PlayerOnly", false);
+    m_bool_configs[CONFIG_BATTLEGROUND_STORE_STATISTICS_ENABLE]      = sConfigMgr->GetBoolDefault("Battleground.StoreStatistics.Enable", false);
+    m_bool_configs[CONFIG_BATTLEGROUND_TRACK_DESERTERS]              = sConfigMgr->GetBoolDefault("Battleground.TrackDeserters.Enable", false);
+    m_int_configs[CONFIG_BATTLEGROUND_REPORT_AFK]                    = sConfigMgr->GetIntDefault("Battleground.ReportAFK", 3);
+    if (m_int_configs[CONFIG_BATTLEGROUND_REPORT_AFK] < 1)
+    {
+        TC_LOG_ERROR("server.loading", "Battleground.ReportAFK (%d) must be >0. Using 3 instead.", m_int_configs[CONFIG_BATTLEGROUND_REPORT_AFK]);
+        m_int_configs[CONFIG_BATTLEGROUND_REPORT_AFK] = 3;
+    }
+    if (m_int_configs[CONFIG_BATTLEGROUND_REPORT_AFK] > 9)
+    {
+        TC_LOG_ERROR("server.loading", "Battleground.ReportAFK (%d) must be <10. Using 3 instead.", m_int_configs[CONFIG_BATTLEGROUND_REPORT_AFK]);
+        m_int_configs[CONFIG_BATTLEGROUND_REPORT_AFK] = 3;
+    }
+    m_int_configs[CONFIG_BATTLEGROUND_INVITATION_TYPE]               = sConfigMgr->GetIntDefault ("Battleground.InvitationType", 0);
+    m_int_configs[CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER]        = sConfigMgr->GetIntDefault ("Battleground.PrematureFinishTimer", 5 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_BATTLEGROUND_PREMADE_GROUP_WAIT_FOR_MATCH]  = sConfigMgr->GetIntDefault ("Battleground.PremadeGroupWaitForMatch", 30 * MINUTE * IN_MILLISECONDS);
+    m_bool_configs[CONFIG_BG_XP_FOR_KILL]                            = sConfigMgr->GetBoolDefault("Battleground.GiveXPForKills", false);
+    m_int_configs[CONFIG_ARENA_MAX_RATING_DIFFERENCE]                = sConfigMgr->GetIntDefault ("Arena.MaxRatingDifference", 150);
+    m_int_configs[CONFIG_ARENA_RATING_DISCARD_TIMER]                 = sConfigMgr->GetIntDefault ("Arena.RatingDiscardTimer", 10 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_ARENA_RATED_UPDATE_TIMER]                   = sConfigMgr->GetIntDefault ("Arena.RatedUpdateTimer", 5 * IN_MILLISECONDS);
+    m_bool_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS]              = sConfigMgr->GetBoolDefault("Arena.AutoDistributePoints", false);
+    m_int_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS]        = sConfigMgr->GetIntDefault ("Arena.AutoDistributeInterval", 7);
+    m_bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE]              = sConfigMgr->GetBoolDefault("Arena.QueueAnnouncer.Enable", false);
+    m_int_configs[CONFIG_ARENA_SEASON_ID]                            = sConfigMgr->GetIntDefault ("Arena.ArenaSeason.ID", 1);
+    m_int_configs[CONFIG_ARENA_START_RATING]                         = sConfigMgr->GetIntDefault ("Arena.ArenaStartRating", 0);
+    m_int_configs[CONFIG_ARENA_START_PERSONAL_RATING]                = sConfigMgr->GetIntDefault ("Arena.ArenaStartPersonalRating", 1000);
+    m_int_configs[CONFIG_ARENA_START_MATCHMAKER_RATING]              = sConfigMgr->GetIntDefault ("Arena.ArenaStartMatchmakerRating", 1500);
+    m_bool_configs[CONFIG_ARENA_SEASON_IN_PROGRESS]                  = sConfigMgr->GetBoolDefault("Arena.ArenaSeason.InProgress", true);
+    m_bool_configs[CONFIG_ARENA_LOG_EXTENDED_INFO]                   = sConfigMgr->GetBoolDefault("ArenaLog.ExtendedInfo", false);
+    m_float_configs[CONFIG_ARENA_WIN_RATING_MODIFIER_1]              = sConfigMgr->GetFloatDefault("Arena.ArenaWinRatingModifier1", 48.0f);
+    m_float_configs[CONFIG_ARENA_WIN_RATING_MODIFIER_2]              = sConfigMgr->GetFloatDefault("Arena.ArenaWinRatingModifier2", 24.0f);
+    m_float_configs[CONFIG_ARENA_LOSE_RATING_MODIFIER]               = sConfigMgr->GetFloatDefault("Arena.ArenaLoseRatingModifier", 24.0f);
+    m_float_configs[CONFIG_ARENA_MATCHMAKER_RATING_MODIFIER]         = sConfigMgr->GetFloatDefault("Arena.ArenaMatchmakerRatingModifier", 24.0f);
+
+    m_bool_configs[CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN]            = sConfigMgr->GetBoolDefault("OffhandCheckAtSpellUnlearn", true);
+
+    m_int_configs[CONFIG_CREATURE_PICKPOCKET_REFILL] = sConfigMgr->GetIntDefault("Creature.PickPocketRefillDelay", 10 * MINUTE);
+    m_int_configs[CONFIG_CREATURE_STOP_FOR_PLAYER] = sConfigMgr->GetIntDefault("Creature.MovingStopTimeForPlayer", 3 * MINUTE * IN_MILLISECONDS);
+
+    if (int32 clientCacheId = sConfigMgr->GetIntDefault("ClientCacheVersion", 0))
+    {
+        // overwrite DB/old value
+        if (clientCacheId > 0)
+        {
+            m_int_configs[CONFIG_CLIENTCACHE_VERSION] = clientCacheId;
+            TC_LOG_INFO("server.loading", "Client cache version set to: %u", clientCacheId);
+        }
+        else
+            TC_LOG_ERROR("server.loading", "ClientCacheVersion can't be negative %d, ignored.", clientCacheId);
+    }
+
+    m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] = sConfigMgr->GetIntDefault("Guild.EventLogRecordsCount", GUILD_EVENTLOG_MAX_RECORDS);
+    if (m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] > GUILD_EVENTLOG_MAX_RECORDS)
+        m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] = GUILD_EVENTLOG_MAX_RECORDS;
+    m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = sConfigMgr->GetIntDefault("Guild.BankEventLogRecordsCount", GUILD_BANKLOG_MAX_RECORDS);
+    if (m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] > GUILD_BANKLOG_MAX_RECORDS)
+        m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = GUILD_BANKLOG_MAX_RECORDS;
+
+    //visibility on continents
+    m_MaxVisibleDistanceOnContinents = sConfigMgr->GetFloatDefault("Visibility.Distance.Continents", DEFAULT_VISIBILITY_DISTANCE);
+    if (m_MaxVisibleDistanceOnContinents < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
+    {
+        TC_LOG_ERROR("server.loading", "Visibility.Distance.Continents can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
+        m_MaxVisibleDistanceOnContinents = 45*sWorld->getRate(RATE_CREATURE_AGGRO);
+    }
+    else if (m_MaxVisibleDistanceOnContinents > MAX_VISIBILITY_DISTANCE)
+    {
+        TC_LOG_ERROR("server.loading", "Visibility.Distance.Continents can't be greater %f", MAX_VISIBILITY_DISTANCE);
+        m_MaxVisibleDistanceOnContinents = MAX_VISIBILITY_DISTANCE;
+    }
+
+    //visibility in instances
+    m_MaxVisibleDistanceInInstances = sConfigMgr->GetFloatDefault("Visibility.Distance.Instances", DEFAULT_VISIBILITY_INSTANCE);
+    if (m_MaxVisibleDistanceInInstances < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
+    {
+        TC_LOG_ERROR("server.loading", "Visibility.Distance.Instances can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
+        m_MaxVisibleDistanceInInstances = 45*sWorld->getRate(RATE_CREATURE_AGGRO);
+    }
+    else if (m_MaxVisibleDistanceInInstances > MAX_VISIBILITY_DISTANCE)
+    {
+        TC_LOG_ERROR("server.loading", "Visibility.Distance.Instances can't be greater %f", MAX_VISIBILITY_DISTANCE);
+        m_MaxVisibleDistanceInInstances = MAX_VISIBILITY_DISTANCE;
+    }
+
+    //visibility in BG/Arenas
+    m_MaxVisibleDistanceInBGArenas = sConfigMgr->GetFloatDefault("Visibility.Distance.BGArenas", DEFAULT_VISIBILITY_BGARENAS);
+    if (m_MaxVisibleDistanceInBGArenas < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
+    {
+        TC_LOG_ERROR("server.loading", "Visibility.Distance.BGArenas can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
+        m_MaxVisibleDistanceInBGArenas = 45*sWorld->getRate(RATE_CREATURE_AGGRO);
+    }
+    else if (m_MaxVisibleDistanceInBGArenas > MAX_VISIBILITY_DISTANCE)
+    {
+        TC_LOG_ERROR("server.loading", "Visibility.Distance.BGArenas can't be greater %f", MAX_VISIBILITY_DISTANCE);
+        m_MaxVisibleDistanceInBGArenas = MAX_VISIBILITY_DISTANCE;
+    }
+
+    m_visibility_notify_periodOnContinents = sConfigMgr->GetIntDefault("Visibility.Notify.Period.OnContinents", DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+    m_visibility_notify_periodInInstances = sConfigMgr->GetIntDefault("Visibility.Notify.Period.InInstances",   DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+    m_visibility_notify_periodInBGArenas = sConfigMgr->GetIntDefault("Visibility.Notify.Period.InBGArenas",    DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+    // Prepatch by LordPsyan
+    // 01
+    // 02
+    // 03
+    // 04
+    // 05
+    // 06
+    // 07
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    // 15
+    // 16
+    // 17
+    // 18
+    // 19
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
+    ///- Load the CharDelete related config options
+    m_int_configs[CONFIG_CHARDELETE_METHOD] = sConfigMgr->GetIntDefault("CharDelete.Method", 0);
+    m_int_configs[CONFIG_CHARDELETE_MIN_LEVEL] = sConfigMgr->GetIntDefault("CharDelete.MinLevel", 0);
+    m_int_configs[CONFIG_CHARDELETE_HEROIC_MIN_LEVEL] = sConfigMgr->GetIntDefault("CharDelete.Heroic.MinLevel", 0);
+    m_int_configs[CONFIG_CHARDELETE_KEEP_DAYS] = sConfigMgr->GetIntDefault("CharDelete.KeepDays", 30);
+
+    // No aggro from gray mobs
+    m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE] = sConfigMgr->GetIntDefault("NoGrayAggro.Above", 0);
+    m_int_configs[CONFIG_NO_GRAY_AGGRO_BELOW] = sConfigMgr->GetIntDefault("NoGrayAggro.Below", 0);
+    if (m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+    {
+       TC_LOG_ERROR("server.loading", "NoGrayAggro.Above (%i) must be in range 0..%u. Set to %u.", m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE], m_int_configs[CONFIG_MAX_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+       m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE] = m_int_configs[CONFIG_MAX_PLAYER_LEVEL];
+    }
+    if (m_int_configs[CONFIG_NO_GRAY_AGGRO_BELOW] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+    {
+       TC_LOG_ERROR("server.loading", "NoGrayAggro.Below (%i) must be in range 0..%u. Set to %u.", m_int_configs[CONFIG_NO_GRAY_AGGRO_BELOW], m_int_configs[CONFIG_MAX_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+       m_int_configs[CONFIG_NO_GRAY_AGGRO_BELOW] = m_int_configs[CONFIG_MAX_PLAYER_LEVEL];
+    }
+    if (m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE] > 0 && m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE] < m_int_configs[CONFIG_NO_GRAY_AGGRO_BELOW])
+    {
+       TC_LOG_ERROR("server.loading", "NoGrayAggro.Below (%i) cannot be greater than NoGrayAggro.Above (%i). Set to %i.", m_int_configs[CONFIG_NO_GRAY_AGGRO_BELOW], m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE], m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE]);
+       m_int_configs[CONFIG_NO_GRAY_AGGRO_BELOW] = m_int_configs[CONFIG_NO_GRAY_AGGRO_ABOVE];
+    }
+
+    ///- Read the "Data" directory from the config file
+    std::string dataPath = sConfigMgr->GetStringDefault("DataDir", "./");
+    if (dataPath.empty() || (dataPath.at(dataPath.length()-1) != '/' && dataPath.at(dataPath.length()-1) != '\\'))
+        dataPath.push_back('/');
+
+#if PLATFORM == PLATFORM_UNIX || PLATFORM == PLATFORM_APPLE
+    if (dataPath[0] == '~')
+    {
+        const char* home = getenv("HOME");
+        if (home)
+            dataPath.replace(0, 1, home);
+    }
+#endif
+
+    if (reload)
+    {
+        if (dataPath != m_dataPath)
+            TC_LOG_ERROR("server.loading", "DataDir option can't be changed at worldserver.conf reload, using current value (%s).", m_dataPath.c_str());
+    }
+    else
+    {
+        m_dataPath = dataPath;
+        TC_LOG_INFO("server.loading", "Using DataDir %s", m_dataPath.c_str());
+    }
+
+    m_bool_configs[CONFIG_ENABLE_MMAPS] = sConfigMgr->GetBoolDefault("mmap.enablePathFinding", false);
+    TC_LOG_INFO("server.loading", "WORLD: MMap data directory is: %smmaps", m_dataPath.c_str());
+
+    m_bool_configs[CONFIG_VMAP_INDOOR_CHECK] = sConfigMgr->GetBoolDefault("vmap.enableIndoorCheck", 0);
+    bool enableIndoor = sConfigMgr->GetBoolDefault("vmap.enableIndoorCheck", true);
+    bool enableLOS = sConfigMgr->GetBoolDefault("vmap.enableLOS", true);
+    bool enableHeight = sConfigMgr->GetBoolDefault("vmap.enableHeight", true);
+
+    if (!enableHeight)
+        TC_LOG_ERROR("server.loading", "VMap height checking disabled! Creatures movements and other various things WILL be broken! Expect no support.");
+
+    VMAP::VMapFactory::createOrGetVMapManager()->setEnableLineOfSightCalc(enableLOS);
+    VMAP::VMapFactory::createOrGetVMapManager()->setEnableHeightCalc(enableHeight);
+    TC_LOG_INFO("server.loading", "VMap support included. LineOfSight: %i, getHeight: %i, indoorCheck: %i", enableLOS, enableHeight, enableIndoor);
+    TC_LOG_INFO("server.loading", "VMap data directory is: %svmaps", m_dataPath.c_str());
+
+    m_int_configs[CONFIG_MAX_WHO] = sConfigMgr->GetIntDefault("MaxWhoListReturns", 49);
+    m_bool_configs[CONFIG_START_ALL_SPELLS] = sConfigMgr->GetBoolDefault("PlayerStart.AllSpells", false);
+    m_int_configs[CONFIG_HONOR_AFTER_DUEL] = sConfigMgr->GetIntDefault("HonorPointsAfterDuel", 0);
+    m_bool_configs[CONFIG_RESET_DUEL_COOLDOWNS] = sConfigMgr->GetBoolDefault("ResetDuelCooldowns", false);
+    m_bool_configs[CONFIG_RESET_DUEL_HEALTH_MANA] = sConfigMgr->GetBoolDefault("ResetDuelHealthMana", false);
+    m_bool_configs[CONFIG_START_ALL_EXPLORED] = sConfigMgr->GetBoolDefault("PlayerStart.MapsExplored", false);
+    m_bool_configs[CONFIG_START_ALL_REP] = sConfigMgr->GetBoolDefault("PlayerStart.AllReputation", false);
+    m_bool_configs[CONFIG_ALWAYS_MAXSKILL] = sConfigMgr->GetBoolDefault("AlwaysMaxWeaponSkill", false);
+    m_bool_configs[CONFIG_PVP_TOKEN_ENABLE] = sConfigMgr->GetBoolDefault("PvPToken.Enable", false);
+    m_int_configs[CONFIG_PVP_TOKEN_MAP_TYPE] = sConfigMgr->GetIntDefault("PvPToken.MapAllowType", 4);
+    m_int_configs[CONFIG_PVP_TOKEN_ID] = sConfigMgr->GetIntDefault("PvPToken.ItemID", 29434);
+    m_int_configs[CONFIG_PVP_TOKEN_COUNT] = sConfigMgr->GetIntDefault("PvPToken.ItemCount", 1);
+    if (m_int_configs[CONFIG_PVP_TOKEN_COUNT] < 1)
+        m_int_configs[CONFIG_PVP_TOKEN_COUNT] = 1;
+
+    m_bool_configs[CONFIG_ALLOW_TRACK_BOTH_RESOURCES] = sConfigMgr->GetBoolDefault("AllowTrackBothResources", false);
+    m_bool_configs[CONFIG_NO_RESET_TALENT_COST] = sConfigMgr->GetBoolDefault("NoResetTalentsCost", false);
+    m_bool_configs[CONFIG_SHOW_KICK_IN_WORLD] = sConfigMgr->GetBoolDefault("ShowKickInWorld", false);
+    m_bool_configs[CONFIG_SHOW_MUTE_IN_WORLD] = sConfigMgr->GetBoolDefault("ShowMuteInWorld", false);
+    m_bool_configs[CONFIG_SHOW_BAN_IN_WORLD] = sConfigMgr->GetBoolDefault("ShowBanInWorld", false);
+    m_int_configs[CONFIG_INTERVAL_LOG_UPDATE] = sConfigMgr->GetIntDefault("RecordUpdateTimeDiffInterval", 60000);
+    m_int_configs[CONFIG_MIN_LOG_UPDATE] = sConfigMgr->GetIntDefault("MinRecordUpdateTimeDiff", 100);
+    m_int_configs[CONFIG_NUMTHREADS] = sConfigMgr->GetIntDefault("MapUpdate.Threads", 1);
+    m_int_configs[CONFIG_MAX_RESULTS_LOOKUP_COMMANDS] = sConfigMgr->GetIntDefault("Command.LookupMaxResults", 0);
+
+    // Warden
+    m_bool_configs[CONFIG_WARDEN_ENABLED]              = sConfigMgr->GetBoolDefault("Warden.Enabled", false);
+    m_int_configs[CONFIG_WARDEN_NUM_MEM_CHECKS]        = sConfigMgr->GetIntDefault("Warden.NumMemChecks", 3);
+    m_int_configs[CONFIG_WARDEN_NUM_OTHER_CHECKS]      = sConfigMgr->GetIntDefault("Warden.NumOtherChecks", 7);
+    m_int_configs[CONFIG_WARDEN_CLIENT_BAN_DURATION]   = sConfigMgr->GetIntDefault("Warden.BanDuration", 86400);
+    m_int_configs[CONFIG_WARDEN_CLIENT_CHECK_HOLDOFF]  = sConfigMgr->GetIntDefault("Warden.ClientCheckHoldOff", 30);
+    m_int_configs[CONFIG_WARDEN_CLIENT_FAIL_ACTION]    = sConfigMgr->GetIntDefault("Warden.ClientCheckFailAction", 0);
+    m_int_configs[CONFIG_WARDEN_CLIENT_RESPONSE_DELAY] = sConfigMgr->GetIntDefault("Warden.ClientResponseDelay", 600);
+
+    // Dungeon finder
+    m_int_configs[CONFIG_LFG_OPTIONSMASK] = sConfigMgr->GetIntDefault("DungeonFinder.OptionsMask", 1);
+
+    // DBC_ItemAttributes
+    m_bool_configs[CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES] = sConfigMgr->GetBoolDefault("DBC.EnforceItemAttributes", true);
+
+    // Accountpassword Secruity
+    m_int_configs[CONFIG_ACC_PASSCHANGESEC] = sConfigMgr->GetIntDefault("Account.PasswordChangeSecurity", 0);
+
+    // Random Battleground Rewards
+    m_int_configs[CONFIG_BG_REWARD_WINNER_HONOR_FIRST] = sConfigMgr->GetIntDefault("Battleground.RewardWinnerHonorFirst", 30);
+    m_int_configs[CONFIG_BG_REWARD_WINNER_ARENA_FIRST] = sConfigMgr->GetIntDefault("Battleground.RewardWinnerArenaFirst", 25);
+    m_int_configs[CONFIG_BG_REWARD_WINNER_HONOR_LAST]  = sConfigMgr->GetIntDefault("Battleground.RewardWinnerHonorLast", 15);
+    m_int_configs[CONFIG_BG_REWARD_WINNER_ARENA_LAST]  = sConfigMgr->GetIntDefault("Battleground.RewardWinnerArenaLast", 0);
+    m_int_configs[CONFIG_BG_REWARD_LOSER_HONOR_FIRST]  = sConfigMgr->GetIntDefault("Battleground.RewardLoserHonorFirst", 5);
+    m_int_configs[CONFIG_BG_REWARD_LOSER_HONOR_LAST]   = sConfigMgr->GetIntDefault("Battleground.RewardLoserHonorLast", 5);
+
+    // Max instances per hour
+    m_int_configs[CONFIG_MAX_INSTANCES_PER_HOUR] = sConfigMgr->GetIntDefault("AccountInstancesPerHour", 5);
+
+    // Anounce reset of instance to whole party
+    m_bool_configs[CONFIG_INSTANCES_RESET_ANNOUNCE] = sConfigMgr->GetBoolDefault("InstancesResetAnnounce", false);
+
+    // AutoBroadcast
+    m_bool_configs[CONFIG_AUTOBROADCAST] = sConfigMgr->GetBoolDefault("AutoBroadcast.On", false);
+    m_int_configs[CONFIG_AUTOBROADCAST_CENTER] = sConfigMgr->GetIntDefault("AutoBroadcast.Center", 0);
+    m_int_configs[CONFIG_AUTOBROADCAST_INTERVAL] = sConfigMgr->GetIntDefault("AutoBroadcast.Timer", 60000);
+    if (reload)
+    {
+        m_timers[WUPDATE_AUTOBROADCAST].SetInterval(m_int_configs[CONFIG_AUTOBROADCAST_INTERVAL]);
+        m_timers[WUPDATE_AUTOBROADCAST].Reset();
+    }
+
+    // MySQL ping time interval
+    m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfigMgr->GetIntDefault("MaxPingTime", 30);
+
+    // misc
+    m_bool_configs[CONFIG_PDUMP_NO_PATHS] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowPaths", true);
+    m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowOverwrite", true);
+    m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = sConfigMgr->GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
+
+    // Wintergrasp battlefield
+    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfigMgr->GetBoolDefault("Wintergrasp.Enable", false);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMax", 100);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMin", 0);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
+    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfigMgr->GetIntDefault("Wintergrasp.BattleTimer", 30);
+    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfigMgr->GetIntDefault("Wintergrasp.NoBattleTimer", 150);
+    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = sConfigMgr->GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
+
+    // Stats limits
+    m_bool_configs[CONFIG_STATS_LIMITS_ENABLE] = sConfigMgr->GetBoolDefault("Stats.Limits.Enable", false);
+    m_float_configs[CONFIG_STATS_LIMITS_DODGE] = sConfigMgr->GetFloatDefault("Stats.Limits.Dodge", 95.0f);
+    m_float_configs[CONFIG_STATS_LIMITS_PARRY] = sConfigMgr->GetFloatDefault("Stats.Limits.Parry", 95.0f);
+    m_float_configs[CONFIG_STATS_LIMITS_BLOCK] = sConfigMgr->GetFloatDefault("Stats.Limits.Block", 95.0f);
+    m_float_configs[CONFIG_STATS_LIMITS_CRIT] = sConfigMgr->GetFloatDefault("Stats.Limits.Crit", 95.0f);
+
+    //packet spoof punishment
+    m_int_configs[CONFIG_PACKET_SPOOF_POLICY] = sConfigMgr->GetIntDefault("PacketSpoof.Policy", (uint32)WorldSession::DosProtection::POLICY_KICK);
+    m_int_configs[CONFIG_PACKET_SPOOF_BANMODE] = sConfigMgr->GetIntDefault("PacketSpoof.BanMode", (uint32)BAN_ACCOUNT);
+    if (m_int_configs[CONFIG_PACKET_SPOOF_BANMODE] == BAN_CHARACTER || m_int_configs[CONFIG_PACKET_SPOOF_BANMODE] > BAN_IP)
+        m_int_configs[CONFIG_PACKET_SPOOF_BANMODE] = BAN_ACCOUNT;
+
+    m_int_configs[CONFIG_PACKET_SPOOF_BANDURATION] = sConfigMgr->GetIntDefault("PacketSpoof.BanDuration", 86400);
+
+    m_int_configs[CONFIG_BIRTHDAY_TIME] = sConfigMgr->GetIntDefault("BirthdayTime", 1222964635);
+
+    m_bool_configs[CONFIG_IP_BASED_ACTION_LOGGING] = sConfigMgr->GetBoolDefault("Allow.IP.Based.Action.Logging", false);
+
+    // AHBot
+    m_int_configs[CONFIG_AHBOT_UPDATE_INTERVAL] = sConfigMgr->GetIntDefault("AuctionHouseBot.Update.Interval", 20);
+
+    m_bool_configs[CONFIG_CALCULATE_CREATURE_ZONE_AREA_DATA] = sConfigMgr->GetBoolDefault("Calculate.Creature.Zone.Area.Data", false);
+    m_bool_configs[CONFIG_CALCULATE_GAMEOBJECT_ZONE_AREA_DATA] = sConfigMgr->GetBoolDefault("Calculate.Gameoject.Zone.Area.Data", false);
+
+    // HotSwap
+    m_bool_configs[CONFIG_HOTSWAP_ENABLED] = sConfigMgr->GetBoolDefault("HotSwap.Enabled", true);
+    m_bool_configs[CONFIG_HOTSWAP_RECOMPILER_ENABLED] = sConfigMgr->GetBoolDefault("HotSwap.EnableReCompiler", true);
+    m_bool_configs[CONFIG_HOTSWAP_EARLY_TERMINATION_ENABLED] = sConfigMgr->GetBoolDefault("HotSwap.EnableEarlyTermination", true);
+    m_bool_configs[CONFIG_HOTSWAP_BUILD_FILE_RECREATION_ENABLED] = sConfigMgr->GetBoolDefault("HotSwap.EnableBuildFileRecreation", true);
+    m_bool_configs[CONFIG_HOTSWAP_INSTALL_ENABLED] = sConfigMgr->GetBoolDefault("HotSwap.EnableInstall", true);
+    m_bool_configs[CONFIG_HOTSWAP_PREFIX_CORRECTION_ENABLED] = sConfigMgr->GetBoolDefault("HotSwap.EnablePrefixCorrection", true);
+
+    // prevent character rename on character customization
+    m_bool_configs[CONFIG_PREVENT_RENAME_CUSTOMIZATION] = sConfigMgr->GetBoolDefault("PreventRenameCharacterOnCustomization", false);
+
+// Prepatch by LordPsyan
+// 01
+// 02
+// 03
+// 04
+// 05
+// 06
+// 07
+// 08
+// 09
+// 10
+// 11
+// 12
+// 13
+// 14
+// 15
+// 16
+// 17
+// 18
+// 19
+// 20
+// Visit http://www.realmsofwarcraft.com/bb for forums and information
+//
+// End of prepatch
+    // call ScriptMgr if we're reloading the configuration
+    if (reload)
+        sScriptMgr->OnConfigLoad(reload);
+}
+
+/// Initialize the World
+void World::SetInitialWorldSettings()
+{
+    ///- Server startup begin
+    uint32 startupBegin = getMSTime();
+
+    ///- Initialize the random number generator
+    srand((unsigned int)time(NULL));
+
+    ///- Initialize detour memory management
+    dtAllocSetCustom(dtCustomAlloc, dtCustomFree);
+
+    ///- Initialize VMapManager function pointers (to untangle game/collision circular deps)
+    if (VMAP::VMapManager2* vmmgr2 = dynamic_cast<VMAP::VMapManager2*>(VMAP::VMapFactory::createOrGetVMapManager()))
+    {
+        vmmgr2->GetLiquidFlagsPtr = &GetLiquidFlags;
+        vmmgr2->IsVMAPDisabledForPtr = &DisableMgr::IsVMAPDisabledFor;
+    }
+
+    ///- Initialize config settings
+    LoadConfigSettings();
+
+    ///- Initialize Allowed Security Level
+    LoadDBAllowedSecurityLevel();
+
+    ///- Init highest guids before any table loading to prevent using not initialized guids in some code.
+    sObjectMgr->SetHighestGuids();
+
+    ///- Check the existence of the map files for all races' startup areas.
+    if (!MapManager::ExistMapAndVMap(0, -6240.32f, 331.033f)
+        || !MapManager::ExistMapAndVMap(0, -8949.95f, -132.493f)
+        || !MapManager::ExistMapAndVMap(1, -618.518f, -4251.67f)
+        || !MapManager::ExistMapAndVMap(0, 1676.35f, 1677.45f)
+        || !MapManager::ExistMapAndVMap(1, 10311.3f, 832.463f)
+        || !MapManager::ExistMapAndVMap(1, -2917.58f, -257.98f)
+        || (m_int_configs[CONFIG_EXPANSION] && (
+            !MapManager::ExistMapAndVMap(530, 10349.6f, -6357.29f) ||
+            !MapManager::ExistMapAndVMap(530, -3961.64f, -13931.2f))))
+    {
+        TC_LOG_FATAL("server.loading", "Unable to load critical files - server shutting down !!!");
+        exit(1);
+    }
+
+    ///- Initialize pool manager
+    sPoolMgr->Initialize();
+
+    ///- Initialize game event manager
+    sGameEventMgr->Initialize();
+
+    ///- Loading strings. Getting no records means core load has to be canceled because no error message can be output.
+
+    TC_LOG_INFO("server.loading", "Loading Trinity strings...");
+    if (!sObjectMgr->LoadTrinityStrings())
+        exit(1);                                            // Error message displayed in function already
+
+    ///- Update the realm entry in the database with the realm type from the config file
+    //No SQL injection as values are treated as integers
+
+    // not send custom type REALM_FFA_PVP to realm list
+    uint32 server_type = IsFFAPvPRealm() ? uint32(REALM_TYPE_PVP) : getIntConfig(CONFIG_GAME_TYPE);
+    uint32 realm_zone = getIntConfig(CONFIG_REALM_ZONE);
+
+    LoginDatabase.PExecute("UPDATE realmlist SET icon = %u, timezone = %u WHERE id = '%d'", server_type, realm_zone, realm.Id.Realm);      // One-time query
+
+    ///- Load the DBC files
+    TC_LOG_INFO("server.loading", "Initialize data stores...");
+    LoadDBCStores(m_dataPath);
+    DetectDBCLang();
+
+    // Load cinematic cameras
+    LoadM2Cameras(m_dataPath);
+
+    std::vector<uint32> mapIds;
+    for (uint32 mapId = 0; mapId < sMapStore.GetNumRows(); mapId++)
+        if (sMapStore.LookupEntry(mapId))
+            mapIds.push_back(mapId);
+
+    if (VMAP::VMapManager2* vmmgr2 = dynamic_cast<VMAP::VMapManager2*>(VMAP::VMapFactory::createOrGetVMapManager()))
+        vmmgr2->InitializeThreadUnsafe(mapIds);
+
+    MMAP::MMapManager* mmmgr = MMAP::MMapFactory::createOrGetMMapManager();
+    mmmgr->InitializeThreadUnsafe(mapIds);
+
+    TC_LOG_INFO("server.loading", "Loading SpellInfo store...");
+    sSpellMgr->LoadSpellInfoStore();
+
+    TC_LOG_INFO("server.loading", "Loading SpellInfo corrections...");
+    sSpellMgr->LoadSpellInfoCorrections();
+
+    TC_LOG_INFO("server.loading", "Loading SkillLineAbilityMultiMap Data...");
+    sSpellMgr->LoadSkillLineAbilityMap();
+
+    TC_LOG_INFO("server.loading", "Loading SpellInfo custom attributes...");
+    sSpellMgr->LoadSpellInfoCustomAttributes();
+
+    TC_LOG_INFO("server.loading", "Loading GameObject models...");
+    LoadGameObjectModelList(m_dataPath);
+
+    TC_LOG_INFO("server.loading", "Loading Script Names...");
+    sObjectMgr->LoadScriptNames();
+
+    TC_LOG_INFO("server.loading", "Loading Instance Template...");
+    sObjectMgr->LoadInstanceTemplate();
+
+    // Must be called before `creature_respawn`/`gameobject_respawn` tables
+    TC_LOG_INFO("server.loading", "Loading instances...");
+    sInstanceSaveMgr->LoadInstances();
+
+    TC_LOG_INFO("server.loading", "Loading Broadcast texts...");
+    sObjectMgr->LoadBroadcastTexts();
+    sObjectMgr->LoadBroadcastTextLocales();
+
+    TC_LOG_INFO("server.loading", "Loading Localization strings...");
+    uint32 oldMSTime = getMSTime();
+    sObjectMgr->LoadCreatureLocales();
+    sObjectMgr->LoadGameObjectLocales();
+    sObjectMgr->LoadItemLocales();
+    sObjectMgr->LoadItemSetNameLocales();
+    sObjectMgr->LoadQuestLocales();
+    sObjectMgr->LoadNpcTextLocales();
+    sObjectMgr->LoadPageTextLocales();
+    sObjectMgr->LoadGossipMenuItemsLocales();
+    sObjectMgr->LoadPointOfInterestLocales();
+
+    sObjectMgr->SetDBCLocaleIndex(GetDefaultDbcLocale());        // Get once for all the locale index of DBC language (console/broadcasts)
+    TC_LOG_INFO("server.loading", ">> Localization strings loaded in %u ms", GetMSTimeDiffToNow(oldMSTime));
+
+    TC_LOG_INFO("server.loading", "Loading Account Roles and Permissions...");
+    sAccountMgr->LoadRBAC();
+
+    TC_LOG_INFO("server.loading", "Loading Page Texts...");
+    sObjectMgr->LoadPageTexts();
+
+    TC_LOG_INFO("server.loading", "Loading Game Object Templates...");         // must be after LoadPageTexts
+    sObjectMgr->LoadGameObjectTemplate();
+
+    TC_LOG_INFO("server.loading", "Loading Game Object template addons...");
+    sObjectMgr->LoadGameObjectTemplateAddons();
+
+    TC_LOG_INFO("server.loading", "Loading Transport templates...");
+    sTransportMgr->LoadTransportTemplates();
+
+    TC_LOG_INFO("server.loading", "Loading Spell Rank Data...");
+    sSpellMgr->LoadSpellRanks();
+
+    TC_LOG_INFO("server.loading", "Loading Spell Required Data...");
+    sSpellMgr->LoadSpellRequired();
+
+    TC_LOG_INFO("server.loading", "Loading Spell Group types...");
+    sSpellMgr->LoadSpellGroups();
+
+    TC_LOG_INFO("server.loading", "Loading Spell Learn Skills...");
+    sSpellMgr->LoadSpellLearnSkills();                           // must be after LoadSpellRanks
+
+    TC_LOG_INFO("server.loading", "Loading Spell Learn Spells...");
+    sSpellMgr->LoadSpellLearnSpells();
+
+    TC_LOG_INFO("server.loading", "Loading Spell Proc Event conditions...");
+    sSpellMgr->LoadSpellProcEvents();
+
+    TC_LOG_INFO("server.loading", "Loading Spell Proc conditions and data...");
+    sSpellMgr->LoadSpellProcs();
+
+    TC_LOG_INFO("server.loading", "Loading Spell Bonus Data...");
+    sSpellMgr->LoadSpellBonusess();
+
+    TC_LOG_INFO("server.loading", "Loading Aggro Spells Definitions...");
+    sSpellMgr->LoadSpellThreats();
+
+    TC_LOG_INFO("server.loading", "Loading Spell Group Stack Rules...");
+    sSpellMgr->LoadSpellGroupStackRules();
+
+    TC_LOG_INFO("server.loading", "Loading NPC Texts...");
+    sObjectMgr->LoadGossipText();
+
+    TC_LOG_INFO("server.loading", "Loading Enchant Spells Proc datas...");
+    sSpellMgr->LoadSpellEnchantProcData();
+
+    TC_LOG_INFO("server.loading", "Loading Item Random Enchantments Table...");
+    LoadRandomEnchantmentsTable();
+
+    TC_LOG_INFO("server.loading", "Loading Disables");                         // must be before loading quests and items
+    DisableMgr::LoadDisables();
+
+    TC_LOG_INFO("server.loading", "Loading Items...");                         // must be after LoadRandomEnchantmentsTable and LoadPageTexts
+    sObjectMgr->LoadItemTemplates();
+
+    TC_LOG_INFO("server.loading", "Loading Item set names...");                // must be after LoadItemPrototypes
+    sObjectMgr->LoadItemSetNames();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Model Based Info Data...");
+    sObjectMgr->LoadCreatureModelInfo();
+
+    TC_LOG_INFO("server.loading", "Loading Creature templates...");
+    sObjectMgr->LoadCreatureTemplates();
+
+    TC_LOG_INFO("server.loading", "Loading Equipment templates...");           // must be after LoadCreatureTemplates
+    sObjectMgr->LoadEquipmentTemplates();
+
+    TC_LOG_INFO("server.loading", "Loading Creature template addons...");
+    sObjectMgr->LoadCreatureTemplateAddons();
+
+    TC_LOG_INFO("server.loading", "Loading Reputation Reward Rates...");
+    sObjectMgr->LoadReputationRewardRate();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Reputation OnKill Data...");
+    sObjectMgr->LoadReputationOnKill();
+
+    TC_LOG_INFO("server.loading", "Loading Reputation Spillover Data...");
+    sObjectMgr->LoadReputationSpilloverTemplate();
+
+    TC_LOG_INFO("server.loading", "Loading Points Of Interest Data...");
+    sObjectMgr->LoadPointsOfInterest();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Base Stats...");
+    sObjectMgr->LoadCreatureClassLevelStats();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Data...");
+    sObjectMgr->LoadCreatures();
+
+    TC_LOG_INFO("server.loading", "Loading Temporary Summon Data...");
+    sObjectMgr->LoadTempSummons();                               // must be after LoadCreatureTemplates() and LoadGameObjectTemplates()
+
+    TC_LOG_INFO("server.loading", "Loading pet levelup spells...");
+    sSpellMgr->LoadPetLevelupSpellMap();
+
+    TC_LOG_INFO("server.loading", "Loading pet default spells additional to levelup spells...");
+    sSpellMgr->LoadPetDefaultSpells();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Addon Data...");
+    sObjectMgr->LoadCreatureAddons();                            // must be after LoadCreatureTemplates() and LoadCreatures()
+
+    TC_LOG_INFO("server.loading", "Loading Gameobject Data...");
+    sObjectMgr->LoadGameobjects();
+
+    TC_LOG_INFO("server.loading", "Loading GameObject Addon Data...");
+    sObjectMgr->LoadGameObjectAddons();                          // must be after LoadGameObjectTemplate() and LoadGameobjects()
+
+    TC_LOG_INFO("server.loading", "Loading GameObject Quest Items...");
+    sObjectMgr->LoadGameObjectQuestItems();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Quest Items...");
+    sObjectMgr->LoadCreatureQuestItems();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Linked Respawn...");
+    sObjectMgr->LoadLinkedRespawn();                             // must be after LoadCreatures(), LoadGameObjects()
+
+    TC_LOG_INFO("server.loading", "Loading Weather Data...");
+    WeatherMgr::LoadWeatherData();
+
+    TC_LOG_INFO("server.loading", "Loading Quests...");
+    sObjectMgr->LoadQuests();                                    // must be loaded after DBCs, creature_template, item_template, gameobject tables
+
+    TC_LOG_INFO("server.loading", "Checking Quest Disables");
+    DisableMgr::CheckQuestDisables();                           // must be after loading quests
+
+    TC_LOG_INFO("server.loading", "Loading Quest POI");
+    sObjectMgr->LoadQuestPOI();
+
+    TC_LOG_INFO("server.loading", "Loading Quests Starters and Enders...");
+    sObjectMgr->LoadQuestStartersAndEnders();                    // must be after quest load
+
+    TC_LOG_INFO("server.loading", "Loading Objects Pooling Data...");
+    sPoolMgr->LoadFromDB();
+
+    TC_LOG_INFO("server.loading", "Loading Game Event Data...");               // must be after loading pools fully
+    sGameEventMgr->LoadFromDB();
+
+    TC_LOG_INFO("server.loading", "Loading UNIT_NPC_FLAG_SPELLCLICK Data..."); // must be after LoadQuests
+    sObjectMgr->LoadNPCSpellClickSpells();
+
+    TC_LOG_INFO("server.loading", "Loading Vehicle Template Accessories...");
+    sObjectMgr->LoadVehicleTemplateAccessories();                // must be after LoadCreatureTemplates() and LoadNPCSpellClickSpells()
+
+    TC_LOG_INFO("server.loading", "Loading Vehicle Accessories...");
+    sObjectMgr->LoadVehicleAccessories();                       // must be after LoadCreatureTemplates() and LoadNPCSpellClickSpells()
+
+    TC_LOG_INFO("server.loading", "Loading SpellArea Data...");                // must be after quest load
+    sSpellMgr->LoadSpellAreas();
+
+    TC_LOG_INFO("server.loading", "Loading AreaTrigger definitions...");
+    sObjectMgr->LoadAreaTriggerTeleports();
+
+    TC_LOG_INFO("server.loading", "Loading Access Requirements...");
+    sObjectMgr->LoadAccessRequirements();                        // must be after item template load
+
+    TC_LOG_INFO("server.loading", "Loading Quest Area Triggers...");
+    sObjectMgr->LoadQuestAreaTriggers();                         // must be after LoadQuests
+
+    TC_LOG_INFO("server.loading", "Loading Tavern Area Triggers...");
+    sObjectMgr->LoadTavernAreaTriggers();
+
+    TC_LOG_INFO("server.loading", "Loading AreaTrigger script names...");
+    sObjectMgr->LoadAreaTriggerScripts();
+
+    TC_LOG_INFO("server.loading", "Loading LFG entrance positions..."); // Must be after areatriggers
+    sLFGMgr->LoadLFGDungeons();
+
+    TC_LOG_INFO("server.loading", "Loading Dungeon boss data...");
+    sObjectMgr->LoadInstanceEncounters();
+
+    TC_LOG_INFO("server.loading", "Loading LFG rewards...");
+    sLFGMgr->LoadRewards();
+
+    TC_LOG_INFO("server.loading", "Loading Graveyard-zone links...");
+    sObjectMgr->LoadGraveyardZones();
+
+    TC_LOG_INFO("server.loading", "Loading spell pet auras...");
+    sSpellMgr->LoadSpellPetAuras();
+
+    TC_LOG_INFO("server.loading", "Loading Spell target coordinates...");
+    sSpellMgr->LoadSpellTargetPositions();
+
+    TC_LOG_INFO("server.loading", "Loading enchant custom attributes...");
+    sSpellMgr->LoadEnchantCustomAttr();
+
+    TC_LOG_INFO("server.loading", "Loading linked spells...");
+    sSpellMgr->LoadSpellLinked();
+
+    TC_LOG_INFO("server.loading", "Loading Player Create Data...");
+    sObjectMgr->LoadPlayerInfo();
+
+    TC_LOG_INFO("server.loading", "Loading Exploration BaseXP Data...");
+    sObjectMgr->LoadExplorationBaseXP();
+
+    TC_LOG_INFO("server.loading", "Loading Pet Name Parts...");
+    sObjectMgr->LoadPetNames();
+
+    CharacterDatabaseCleaner::CleanDatabase();
+
+    TC_LOG_INFO("server.loading", "Loading the max pet number...");
+    sObjectMgr->LoadPetNumber();
+
+    TC_LOG_INFO("server.loading", "Loading pet level stats...");
+    sObjectMgr->LoadPetLevelInfo();
+
+    TC_LOG_INFO("server.loading", "Loading Player level dependent mail rewards...");
+    sObjectMgr->LoadMailLevelRewards();
+
+    // Loot tables
+    LoadLootTables();
+
+    TC_LOG_INFO("server.loading", "Loading Skill Discovery Table...");
+    LoadSkillDiscoveryTable();
+
+    TC_LOG_INFO("server.loading", "Loading Skill Extra Item Table...");
+    LoadSkillExtraItemTable();
+
+    TC_LOG_INFO("server.loading", "Loading Skill Perfection Data Table...");
+    LoadSkillPerfectItemTable();
+
+    TC_LOG_INFO("server.loading", "Loading Skill Fishing base level requirements...");
+    sObjectMgr->LoadFishingBaseSkillLevel();
+
+    TC_LOG_INFO("server.loading", "Loading Achievements...");
+    sAchievementMgr->LoadAchievementReferenceList();
+    TC_LOG_INFO("server.loading", "Loading Achievement Criteria Lists...");
+    sAchievementMgr->LoadAchievementCriteriaList();
+    TC_LOG_INFO("server.loading", "Loading Achievement Criteria Data...");
+    sAchievementMgr->LoadAchievementCriteriaData();
+    TC_LOG_INFO("server.loading", "Loading Achievement Rewards...");
+    sAchievementMgr->LoadRewards();
+    TC_LOG_INFO("server.loading", "Loading Achievement Reward Locales...");
+    sAchievementMgr->LoadRewardLocales();
+    TC_LOG_INFO("server.loading", "Loading Completed Achievements...");
+    sAchievementMgr->LoadCompletedAchievements();
+
+    ///- Load dynamic data tables from the database
+    TC_LOG_INFO("server.loading", "Loading Item Auctions...");
+    sAuctionMgr->LoadAuctionItems();
+
+    TC_LOG_INFO("server.loading", "Loading Auctions...");
+    sAuctionMgr->LoadAuctions();
+
+    TC_LOG_INFO("server.loading", "Loading Guilds...");
+    sGuildMgr->LoadGuilds();
+
+    TC_LOG_INFO("server.loading", "Loading ArenaTeams...");
+    sArenaTeamMgr->LoadArenaTeams();
+
+    TC_LOG_INFO("server.loading", "Loading Groups...");
+    sGroupMgr->LoadGroups();
+
+    TC_LOG_INFO("server.loading", "Loading ReservedNames...");
+    sObjectMgr->LoadReservedPlayersNames();
+
+    TC_LOG_INFO("server.loading", "Loading GameObjects for quests...");
+    sObjectMgr->LoadGameObjectForQuests();
+
+    TC_LOG_INFO("server.loading", "Loading BattleMasters...");
+    sBattlegroundMgr->LoadBattleMastersEntry();                 // must be after load CreatureTemplate
+
+    TC_LOG_INFO("server.loading", "Loading GameTeleports...");
+    sObjectMgr->LoadGameTele();
+
+    TC_LOG_INFO("server.loading", "Loading Gossip menu...");
+    sObjectMgr->LoadGossipMenu();
+
+    TC_LOG_INFO("server.loading", "Loading Gossip menu options...");
+    sObjectMgr->LoadGossipMenuItems();
+
+    TC_LOG_INFO("server.loading", "Loading Vendors...");
+    sObjectMgr->LoadVendors();                                   // must be after load CreatureTemplate and ItemTemplate
+
+    TC_LOG_INFO("server.loading", "Loading Trainers...");
+    sObjectMgr->LoadTrainerSpell();                              // must be after load CreatureTemplate
+
+    TC_LOG_INFO("server.loading", "Loading Waypoints...");
+    sWaypointMgr->Load();
+
+    TC_LOG_INFO("server.loading", "Loading SmartAI Waypoints...");
+    sSmartWaypointMgr->LoadFromDB();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Formations...");
+    sFormationMgr->LoadCreatureFormations();
+
+    TC_LOG_INFO("server.loading", "Loading World States...");              // must be loaded before battleground, outdoor PvP and conditions
+    LoadWorldStates();
+
+    TC_LOG_INFO("server.loading", "Loading Conditions...");
+    sConditionMgr->LoadConditions();
+
+    TC_LOG_INFO("server.loading", "Loading faction change achievement pairs...");
+    sObjectMgr->LoadFactionChangeAchievements();
+
+    TC_LOG_INFO("server.loading", "Loading faction change spell pairs...");
+    sObjectMgr->LoadFactionChangeSpells();
+
+    TC_LOG_INFO("server.loading", "Loading faction change quest pairs...");
+    sObjectMgr->LoadFactionChangeQuests();
+
+    TC_LOG_INFO("server.loading", "Loading faction change item pairs...");
+    sObjectMgr->LoadFactionChangeItems();
+
+    TC_LOG_INFO("server.loading", "Loading faction change reputation pairs...");
+    sObjectMgr->LoadFactionChangeReputations();
+
+    TC_LOG_INFO("server.loading", "Loading faction change title pairs...");
+    sObjectMgr->LoadFactionChangeTitles();
+
+    TC_LOG_INFO("server.loading", "Loading GM tickets...");
+    sTicketMgr->LoadTickets();
+
+    TC_LOG_INFO("server.loading", "Loading GM surveys...");
+    sTicketMgr->LoadSurveys();
+
+    TC_LOG_INFO("server.loading", "Loading client addons...");
+    AddonMgr::LoadFromDB();
+
+    ///- Handle outdated emails (delete/return)
+    TC_LOG_INFO("server.loading", "Returning old mails...");
+    sObjectMgr->ReturnOrDeleteOldMails(false);
+
+    TC_LOG_INFO("server.loading", "Loading Autobroadcasts...");
+    LoadAutobroadcasts();
+
+    ///- Load and initialize scripts
+    sObjectMgr->LoadSpellScripts();                              // must be after load Creature/Gameobject(Template/Data)
+    sObjectMgr->LoadEventScripts();                              // must be after load Creature/Gameobject(Template/Data)
+    sObjectMgr->LoadWaypointScripts();
+
+    TC_LOG_INFO("server.loading", "Loading spell script names...");
+    sObjectMgr->LoadSpellScriptNames();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Texts...");
+    sCreatureTextMgr->LoadCreatureTexts();
+
+    TC_LOG_INFO("server.loading", "Loading Creature Text Locales...");
+    sCreatureTextMgr->LoadCreatureTextLocales();
+
+    TC_LOG_INFO("server.loading", "Initializing Scripts...");
+    sScriptMgr->Initialize();
+    sScriptMgr->OnConfigLoad(false);                                // must be done after the ScriptMgr has been properly initialized
+
+    TC_LOG_INFO("server.loading", "Validating spell scripts...");
+    sObjectMgr->ValidateSpellScripts();
+
+    TC_LOG_INFO("server.loading", "Loading SmartAI scripts...");
+    sSmartScriptMgr->LoadSmartAIFromDB();
+
+    TC_LOG_INFO("server.loading", "Loading Calendar data...");
+    sCalendarMgr->LoadFromDB();
+
+    ///- Initialize game time and timers
+    TC_LOG_INFO("server.loading", "Initialize game time and timers");
+    m_gameTime = time(NULL);
+    m_startTime = m_gameTime;
+
+    LoginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, uptime, revision) VALUES(%u, %u, 0, '%s')",
+                            realm.Id.Realm, uint32(m_startTime), GitRevision::GetFullVersion());       // One-time query
+
+    m_timers[WUPDATE_WEATHERS].SetInterval(1*IN_MILLISECONDS);
+    m_timers[WUPDATE_AUCTIONS].SetInterval(MINUTE*IN_MILLISECONDS);
+    m_timers[WUPDATE_AUCTIONS_PENDING].SetInterval(250);
+    m_timers[WUPDATE_UPTIME].SetInterval(m_int_configs[CONFIG_UPTIME_UPDATE]*MINUTE*IN_MILLISECONDS);
+                                                            //Update "uptime" table based on configuration entry in minutes.
+    m_timers[WUPDATE_CORPSES].SetInterval(20 * MINUTE * IN_MILLISECONDS);
+                                                            //erase corpses every 20 minutes
+    m_timers[WUPDATE_CLEANDB].SetInterval(m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]*MINUTE*IN_MILLISECONDS);
+                                                            // clean logs table every 14 days by default
+    m_timers[WUPDATE_AUTOBROADCAST].SetInterval(getIntConfig(CONFIG_AUTOBROADCAST_INTERVAL));
+    m_timers[WUPDATE_DELETECHARS].SetInterval(DAY*IN_MILLISECONDS); // check for chars to delete every day
+
+    // for AhBot
+    m_timers[WUPDATE_AHBOT].SetInterval(getIntConfig(CONFIG_AHBOT_UPDATE_INTERVAL) * IN_MILLISECONDS); // every 20 sec
+
+    m_timers[WUPDATE_PINGDB].SetInterval(getIntConfig(CONFIG_DB_PING_INTERVAL)*MINUTE*IN_MILLISECONDS);    // Mysql ping time in minutes
+
+    m_timers[WUPDATE_CHECK_FILECHANGES].SetInterval(500);
+
+    //to set mailtimer to return mails every day between 4 and 5 am
+    //mailtimer is increased when updating auctions
+    //one second is 1000 -(tested on win system)
+    /// @todo Get rid of magic numbers
+    tm localTm;
+    localtime_r(&m_gameTime, &localTm);
+    mail_timer = ((((localTm.tm_hour + 20) % 24)* HOUR * IN_MILLISECONDS) / m_timers[WUPDATE_AUCTIONS].GetInterval());
+                                                            //1440
+    mail_timer_expires = ((DAY * IN_MILLISECONDS) / (m_timers[WUPDATE_AUCTIONS].GetInterval()));
+    TC_LOG_INFO("server.loading", "Mail timer set to: " UI64FMTD ", mail return is called every " UI64FMTD " minutes", uint64(mail_timer), uint64(mail_timer_expires));
+
+    ///- Initilize static helper structures
+    AIRegistry::Initialize();
+
+    ///- Initialize MapManager
+    TC_LOG_INFO("server.loading", "Starting Map System");
+    sMapMgr->Initialize();
+
+    TC_LOG_INFO("server.loading", "Starting Game Event system...");
+    uint32 nextGameEvent = sGameEventMgr->StartSystem();
+    m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    //depend on next event
+
+    // Delete all characters which have been deleted X days before
+    Player::DeleteOldCharacters();
+
+    TC_LOG_INFO("server.loading", "Initialize AuctionHouseBot...");
+    sAuctionBot->Initialize();
+
+    // Delete all custom channels which haven't been used for PreserveCustomChannelDuration days.
+    Channel::CleanOldChannelsInDB();
+
+    TC_LOG_INFO("server.loading", "Initializing Opcodes...");
+    opcodeTable.Initialize();
+
+    TC_LOG_INFO("server.loading", "Starting Arena Season...");
+    sGameEventMgr->StartArenaSeason();
+
+    sTicketMgr->Initialize();
+
+    ///- Initialize Battlegrounds
+    TC_LOG_INFO("server.loading", "Starting Battleground System");
+    sBattlegroundMgr->LoadBattlegroundTemplates();
+    sBattlegroundMgr->InitAutomaticArenaPointDistribution();
+
+    ///- Initialize outdoor pvp
+    TC_LOG_INFO("server.loading", "Starting Outdoor PvP System");
+    sOutdoorPvPMgr->InitOutdoorPvP();
+
+    ///- Initialize Battlefield
+    TC_LOG_INFO("server.loading", "Starting Battlefield System");
+    sBattlefieldMgr->InitBattlefield();
+
+    TC_LOG_INFO("server.loading", "Loading Transports...");
+    sTransportMgr->SpawnContinentTransports();
+
+    ///- Initialize Warden
+    TC_LOG_INFO("server.loading", "Loading Warden Checks...");
+    sWardenCheckMgr->LoadWardenChecks();
+
+    TC_LOG_INFO("server.loading", "Loading Warden Action Overrides...");
+    sWardenCheckMgr->LoadWardenOverrides();
+
+    TC_LOG_INFO("server.loading", "Deleting expired bans...");
+    LoginDatabase.Execute("DELETE FROM ip_banned WHERE unbandate <= UNIX_TIMESTAMP() AND unbandate<>bandate");      // One-time query
+
+    TC_LOG_INFO("server.loading", "Calculate next daily quest reset time...");
+    InitDailyQuestResetTime();
+
+    TC_LOG_INFO("server.loading", "Calculate next weekly quest reset time...");
+    InitWeeklyQuestResetTime();
+
+    TC_LOG_INFO("server.loading", "Calculate next monthly quest reset time...");
+    InitMonthlyQuestResetTime();
+
+    TC_LOG_INFO("server.loading", "Calculate random battleground reset time...");
+    InitRandomBGResetTime();
+
+    TC_LOG_INFO("server.loading", "Calculate guild limitation(s) reset time...");
+    InitGuildResetTime();
+
+    LoadCharacterInfoStore();
+
+    // Preload all cells, if required for the base maps
+    if (sWorld->getBoolConfig(CONFIG_BASEMAP_LOAD_GRIDS))
+    {
+        sMapMgr->DoForAllMaps([](Map* map)
+        {
+            if (!map->Instanceable())
+            {
+                TC_LOG_INFO("server.loading", "Pre-loading base map data for map %u", map->GetId());
+                map->LoadAllCells();
+            }
+        });
+    }
+
+    uint32 startupDuration = GetMSTimeDiffToNow(startupBegin);
+
+    TC_LOG_INFO("server.worldserver", "World initialized in %u minutes %u seconds", (startupDuration / 60000), ((startupDuration % 60000) / 1000));
+
+    TC_METRIC_EVENT("events", "World initialized", "World initialized in " + std::to_string(startupDuration / 60000) + " minutes " + std::to_string((startupDuration % 60000) / 1000) + " seconds");
+
+    if (uint32 realmId = sConfigMgr->GetIntDefault("RealmID", 0)) // 0 reserved for auth
+        sLog->SetRealmId(realmId);
+}
+
+void World::DetectDBCLang()
+{
+    uint8 m_lang_confid = sConfigMgr->GetIntDefault("DBC.Locale", 255);
+
+    if (m_lang_confid != 255 && m_lang_confid >= TOTAL_LOCALES)
+    {
+        TC_LOG_ERROR("server.loading", "Incorrect DBC.Locale! Must be >= 0 and < %d (set to 0)", TOTAL_LOCALES);
+        m_lang_confid = LOCALE_enUS;
+    }
+
+    ChrRacesEntry const* race = sChrRacesStore.LookupEntry(1);
+
+    std::string availableLocalsStr;
+
+    uint8 default_locale = TOTAL_LOCALES;
+    for (uint8 i = default_locale-1; i < TOTAL_LOCALES; --i)  // -1 will be 255 due to uint8
+    {
+        if (race->name[i][0] != '\0')                     // check by race names
+        {
+            default_locale = i;
+            m_availableDbcLocaleMask |= (1 << i);
+            availableLocalsStr += localeNames[i];
+            availableLocalsStr += " ";
+        }
+    }
+
+    if (default_locale != m_lang_confid && m_lang_confid < TOTAL_LOCALES &&
+        (m_availableDbcLocaleMask & (1 << m_lang_confid)))
+    {
+        default_locale = m_lang_confid;
+    }
+
+    if (default_locale >= TOTAL_LOCALES)
+    {
+        TC_LOG_ERROR("server.loading", "Unable to determine your DBC Locale! (corrupt DBC?)");
+        exit(1);
+    }
+
+    m_defaultDbcLocale = LocaleConstant(default_locale);
+
+    TC_LOG_INFO("server.loading", "Using %s DBC Locale as default. All available DBC locales: %s", localeNames[m_defaultDbcLocale], availableLocalsStr.empty() ? "<none>" : availableLocalsStr.c_str());
+}
+
+void World::ResetTimeDiffRecord()
+{
+    if (m_updateTimeCount != 1)
+        return;
+
+    m_currentTime = getMSTime();
+}
+
+void World::RecordTimeDiff(std::string const& text)
+{
+    if (m_updateTimeCount != 1)
+        return;
+
+    uint32 thisTime = getMSTime();
+    uint32 diff = getMSTimeDiff(m_currentTime, thisTime);
+
+    if (diff > m_int_configs[CONFIG_MIN_LOG_UPDATE])
+        TC_LOG_INFO("misc", "Difftime %s: %u.", text.c_str(), diff);
+
+    m_currentTime = thisTime;
+}
+
+void World::LoadAutobroadcasts()
+{
+    uint32 oldMSTime = getMSTime();
+
+    m_Autobroadcasts.clear();
+    m_AutobroadcastsWeights.clear();
+
+    uint32 realmId = sConfigMgr->GetIntDefault("RealmID", 0);
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_AUTOBROADCAST);
+    stmt->setInt32(0, realmId);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.loading", ">> Loaded 0 autobroadcasts definitions. DB table `autobroadcast` is empty for this realm!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+        uint8 id = fields[0].GetUInt8();
+
+        m_Autobroadcasts[id] = fields[2].GetString();
+        m_AutobroadcastsWeights[id] = fields[1].GetUInt8();
+
+        ++count;
+    } while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u autobroadcast definitions in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+/// Update the World !
+void World::Update(uint32 diff)
+{
+    m_updateTime = diff;
+
+    if (m_int_configs[CONFIG_INTERVAL_LOG_UPDATE] && diff > m_int_configs[CONFIG_MIN_LOG_UPDATE])
+    {
+        if (m_updateTimeSum > m_int_configs[CONFIG_INTERVAL_LOG_UPDATE])
+        {
+            TC_LOG_DEBUG("misc", "Update time diff: %u. Players online: %u.", m_updateTimeSum / m_updateTimeCount, GetActiveSessionCount());
+            m_updateTimeSum = m_updateTime;
+            m_updateTimeCount = 1;
+        }
+        else
+        {
+            m_updateTimeSum += m_updateTime;
+            ++m_updateTimeCount;
+        }
+    }
+
+    ///- Update the different timers
+    for (int i = 0; i < WUPDATE_COUNT; ++i)
+    {
+        if (m_timers[i].GetCurrent() >= 0)
+            m_timers[i].Update(diff);
+        else
+            m_timers[i].SetCurrent(0);
+    }
+
+    ///- Update the game time and check for shutdown time
+    _UpdateGameTime();
+
+    /// Handle daily quests reset time
+    if (m_gameTime > m_NextDailyQuestReset)
+    {
+        ResetDailyQuests();
+        m_NextDailyQuestReset += DAY;
+    }
+
+    /// Handle weekly quests reset time
+    if (m_gameTime > m_NextWeeklyQuestReset)
+        ResetWeeklyQuests();
+
+    /// Handle monthly quests reset time
+    if (m_gameTime > m_NextMonthlyQuestReset)
+        ResetMonthlyQuests();
+
+    if (m_gameTime > m_NextRandomBGReset)
+        ResetRandomBG();
+
+    if (m_gameTime > m_NextGuildReset)
+        ResetGuildCap();
+
+    /// <ul><li> Handle auctions when the timer has passed
+    if (m_timers[WUPDATE_AUCTIONS].Passed())
+    {
+        m_timers[WUPDATE_AUCTIONS].Reset();
+
+        ///- Update mails (return old mails with item, or delete them)
+        //(tested... works on win)
+        if (++mail_timer > mail_timer_expires)
+        {
+            mail_timer = 0;
+            sObjectMgr->ReturnOrDeleteOldMails(true);
+        }
+
+        ///- Handle expired auctions
+        sAuctionMgr->Update();
+    }
+
+    if (m_timers[WUPDATE_AUCTIONS_PENDING].Passed())
+    {
+        m_timers[WUPDATE_AUCTIONS_PENDING].Reset();
+
+        sAuctionMgr->UpdatePendingAuctions();
+    }
+
+    /// <li> Handle AHBot operations
+    if (m_timers[WUPDATE_AHBOT].Passed())
+    {
+        sAuctionBot->Update();
+        m_timers[WUPDATE_AHBOT].Reset();
+    }
+
+    /// <li> Handle file changes
+    if (m_timers[WUPDATE_CHECK_FILECHANGES].Passed())
+    {
+        sScriptReloadMgr->Update();
+        m_timers[WUPDATE_CHECK_FILECHANGES].Reset();
+    }
+
+    /// <li> Handle session updates when the timer has passed
+    ResetTimeDiffRecord();
+    UpdateSessions(diff);
+    RecordTimeDiff("UpdateSessions");
+
+    /// <li> Handle weather updates when the timer has passed
+    if (m_timers[WUPDATE_WEATHERS].Passed())
+    {
+        m_timers[WUPDATE_WEATHERS].Reset();
+        WeatherMgr::Update(uint32(m_timers[WUPDATE_WEATHERS].GetInterval()));
+    }
+
+    /// <li> Update uptime table
+    if (m_timers[WUPDATE_UPTIME].Passed())
+    {
+        uint32 tmpDiff = uint32(m_gameTime - m_startTime);
+        uint32 maxOnlinePlayers = GetMaxPlayerCount();
+
+        m_timers[WUPDATE_UPTIME].Reset();
+
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_UPTIME_PLAYERS);
+
+        stmt->setUInt32(0, tmpDiff);
+        stmt->setUInt16(1, uint16(maxOnlinePlayers));
+        stmt->setUInt32(2, realm.Id.Realm);
+        stmt->setUInt32(3, uint32(m_startTime));
+
+        LoginDatabase.Execute(stmt);
+    }
+
+    /// <li> Clean logs table
+    if (sWorld->getIntConfig(CONFIG_LOGDB_CLEARTIME) > 0) // if not enabled, ignore the timer
+    {
+        if (m_timers[WUPDATE_CLEANDB].Passed())
+        {
+            m_timers[WUPDATE_CLEANDB].Reset();
+
+            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_OLD_LOGS);
+
+            stmt->setUInt32(0, sWorld->getIntConfig(CONFIG_LOGDB_CLEARTIME));
+            stmt->setUInt32(1, uint32(time(0)));
+            stmt->setUInt32(2, realm.Id.Realm);
+
+            LoginDatabase.Execute(stmt);
+        }
+    }
+
+    /// <li> Handle all other objects
+    ///- Update objects when the timer has passed (maps, transport, creatures, ...)
+    ResetTimeDiffRecord();
+    sMapMgr->Update(diff);
+    RecordTimeDiff("UpdateMapMgr");
+
+    if (sWorld->getBoolConfig(CONFIG_AUTOBROADCAST))
+    {
+        if (m_timers[WUPDATE_AUTOBROADCAST].Passed())
+        {
+            m_timers[WUPDATE_AUTOBROADCAST].Reset();
+            SendAutoBroadcast();
+        }
+    }
+
+    sBattlegroundMgr->Update(diff);
+    RecordTimeDiff("UpdateBattlegroundMgr");
+
+    sOutdoorPvPMgr->Update(diff);
+    RecordTimeDiff("UpdateOutdoorPvPMgr");
+
+    sBattlefieldMgr->Update(diff);
+    RecordTimeDiff("BattlefieldMgr");
+
+    ///- Delete all characters which have been deleted X days before
+    if (m_timers[WUPDATE_DELETECHARS].Passed())
+    {
+        m_timers[WUPDATE_DELETECHARS].Reset();
+        Player::DeleteOldCharacters();
+    }
+
+    sLFGMgr->Update(diff);
+    RecordTimeDiff("UpdateLFGMgr");
+
+    // execute callbacks from sql queries that were queued recently
+    ProcessQueryCallbacks();
+    RecordTimeDiff("ProcessQueryCallbacks");
+
+    ///- Erase corpses once every 20 minutes
+    if (m_timers[WUPDATE_CORPSES].Passed())
+    {
+        m_timers[WUPDATE_CORPSES].Reset();
+        sMapMgr->DoForAllMaps([](Map* map)
+        {
+            map->RemoveOldCorpses();
+        });
+    }
+
+    ///- Process Game events when necessary
+    if (m_timers[WUPDATE_EVENTS].Passed())
+    {
+        m_timers[WUPDATE_EVENTS].Reset();                   // to give time for Update() to be processed
+        uint32 nextGameEvent = sGameEventMgr->Update();
+        m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);
+        m_timers[WUPDATE_EVENTS].Reset();
+    }
+
+    ///- Ping to keep MySQL connections alive
+    if (m_timers[WUPDATE_PINGDB].Passed())
+    {
+        m_timers[WUPDATE_PINGDB].Reset();
+        TC_LOG_DEBUG("misc", "Ping MySQL to keep connection alive");
+        CharacterDatabase.KeepAlive();
+        LoginDatabase.KeepAlive();
+        WorldDatabase.KeepAlive();
+    }
+
+    // update the instance reset times
+    sInstanceSaveMgr->Update();
+
+    // And last, but not least handle the issued cli commands
+    ProcessCliCommands();
+
+    sScriptMgr->OnWorldUpdate(diff);
+
+    // Stats logger update
+    sMetric->Update();
+    TC_METRIC_VALUE("update_time_diff", diff);
+}
+
+void World::ForceGameEventUpdate()
+{
+    m_timers[WUPDATE_EVENTS].Reset();                   // to give time for Update() to be processed
+    uint32 nextGameEvent = sGameEventMgr->Update();
+    m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);
+    m_timers[WUPDATE_EVENTS].Reset();
+}
+
+/// Send a packet to all players (except self if mentioned)
+void World::SendGlobalMessage(WorldPacket* packet, WorldSession* self, uint32 team)
+{
+    SessionMap::const_iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (itr->second &&
+            itr->second->GetPlayer() &&
+            itr->second->GetPlayer()->IsInWorld() &&
+            itr->second != self &&
+            (team == 0 || itr->second->GetPlayer()->GetTeam() == team))
+        {
+            itr->second->SendPacket(packet);
+        }
+    }
+}
+
+/// Send a packet to all GMs (except self if mentioned)
+void World::SendGlobalGMMessage(WorldPacket* packet, WorldSession* self, uint32 team)
+{
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        // check if session and can receive global GM Messages and its not self
+        WorldSession* session = itr->second;
+        if (!session || session == self || !session->HasPermission(rbac::RBAC_PERM_RECEIVE_GLOBAL_GM_TEXTMESSAGE))
+            continue;
+
+        // Player should be in world
+        Player* player = session->GetPlayer();
+        if (!player || !player->IsInWorld())
+            continue;
+
+        // Send only to same team, if team is given
+        if (!team || player->GetTeam() == team)
+            session->SendPacket(packet);
+    }
+}
+
+namespace Trinity
+{
+    class WorldWorldTextBuilder
+    {
+        public:
+            typedef std::vector<WorldPacket*> WorldPacketList;
+            explicit WorldWorldTextBuilder(uint32 textId, va_list* args = NULL) : i_textId(textId), i_args(args) { }
+            void operator()(WorldPacketList& data_list, LocaleConstant loc_idx)
+            {
+                char const* text = sObjectMgr->GetTrinityString(i_textId, loc_idx);
+
+                if (i_args)
+                {
+                    // we need copy va_list before use or original va_list will corrupted
+                    va_list ap;
+                    va_copy(ap, *i_args);
+
+                    char str[2048];
+                    vsnprintf(str, 2048, text, ap);
+                    va_end(ap);
+
+                    do_helper(data_list, &str[0]);
+                }
+                else
+                    do_helper(data_list, (char*)text);
+            }
+        private:
+            char* lineFromMessage(char*& pos) { char* start = strtok(pos, "\n"); pos = NULL; return start; }
+            void do_helper(WorldPacketList& data_list, char* text)
+            {
+                char* pos = text;
+                while (char* line = lineFromMessage(pos))
+                {
+                    WorldPacket* data = new WorldPacket();
+                    ChatHandler::BuildChatPacket(*data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, line);
+                    data_list.push_back(data);
+                }
+            }
+
+            uint32 i_textId;
+            va_list* i_args;
+    };
+}                                                           // namespace Trinity
+
+/// Send a System Message to all players (except self if mentioned)
+void World::SendWorldText(uint32 string_id, ...)
+{
+    va_list ap;
+    va_start(ap, string_id);
+
+    Trinity::WorldWorldTextBuilder wt_builder(string_id, &ap);
+    Trinity::LocalizedPacketListDo<Trinity::WorldWorldTextBuilder> wt_do(wt_builder);
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld())
+            continue;
+
+        wt_do(itr->second->GetPlayer());
+    }
+
+    va_end(ap);
+}
+
+/// Send a System Message to all GMs (except self if mentioned)
+void World::SendGMText(uint32 string_id, ...)
+{
+    va_list ap;
+    va_start(ap, string_id);
+
+    Trinity::WorldWorldTextBuilder wt_builder(string_id, &ap);
+    Trinity::LocalizedPacketListDo<Trinity::WorldWorldTextBuilder> wt_do(wt_builder);
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        // Session should have permissions to receive global gm messages
+        WorldSession* session = itr->second;
+        if (!session || !session->HasPermission(rbac::RBAC_PERM_RECEIVE_GLOBAL_GM_TEXTMESSAGE))
+            continue;
+
+        // Player should be in world
+        Player* player = session->GetPlayer();
+        if (!player || !player->IsInWorld())
+            continue;
+
+        wt_do(player);
+    }
+
+    va_end(ap);
+}
+
+/// DEPRECATED, only for debug purpose. Send a System Message to all players (except self if mentioned)
+void World::SendGlobalText(const char* text, WorldSession* self)
+{
+    WorldPacket data;
+
+    // need copy to prevent corruption by strtok call in LineFromMessage original string
+    char* buf = strdup(text);
+    char* pos = buf;
+
+    while (char* line = ChatHandler::LineFromMessage(pos))
+    {
+        ChatHandler::BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, line);
+        SendGlobalMessage(&data, self);
+    }
+
+    free(buf);
+}
+
+/// Send a packet to all players (or players selected team) in the zone (except self if mentioned)
+bool World::SendZoneMessage(uint32 zone, WorldPacket* packet, WorldSession* self, uint32 team)
+{
+    bool foundPlayerToSend = false;
+    SessionMap::const_iterator itr;
+
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (itr->second &&
+            itr->second->GetPlayer() &&
+            itr->second->GetPlayer()->IsInWorld() &&
+            itr->second->GetPlayer()->GetZoneId() == zone &&
+            itr->second != self &&
+            (team == 0 || itr->second->GetPlayer()->GetTeam() == team))
+        {
+            itr->second->SendPacket(packet);
+            foundPlayerToSend = true;
+        }
+    }
+
+    return foundPlayerToSend;
+}
+
+/// Send a System Message to all players in the zone (except self if mentioned)
+void World::SendZoneText(uint32 zone, const char* text, WorldSession* self, uint32 team)
+{
+    WorldPacket data;
+    ChatHandler::BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, text);
+    SendZoneMessage(zone, &data, self, team);
+}
+
+/// Kick (and save) all players
+void World::KickAll()
+{
+    m_QueuedPlayer.clear();                                 // prevent send queue update packet and login queued sessions
+
+    // session not removed at kick and will removed in next update tick
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        itr->second->KickPlayer();
+}
+
+/// Kick (and save) all players with security level less `sec`
+void World::KickAllLess(AccountTypes sec)
+{
+    // session not removed at kick and will removed in next update tick
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetSecurity() < sec)
+            itr->second->KickPlayer();
+}
+
+/// Ban an account or ban an IP address, duration will be parsed using TimeStringToSecs if it is positive, otherwise permban
+BanReturn World::BanAccount(BanMode mode, std::string const& nameOrIP, std::string const& duration, std::string const& reason, std::string const& author)
+{
+    uint32 duration_secs = TimeStringToSecs(duration);
+    return BanAccount(mode, nameOrIP, duration_secs, reason, author);
+}
+
+/// Ban an account or ban an IP address, duration is in seconds if positive, otherwise permban
+BanReturn World::BanAccount(BanMode mode, std::string const& nameOrIP, uint32 duration_secs, std::string const& reason, std::string const& author)
+{
+    PreparedQueryResult resultAccounts = PreparedQueryResult(NULL); //used for kicking
+    PreparedStatement* stmt = NULL;
+
+    ///- Update the database with ban information
+    switch (mode)
+    {
+        case BAN_IP:
+            // No SQL injection with prepared statements
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_BY_IP);
+            stmt->setString(0, nameOrIP);
+            resultAccounts = LoginDatabase.Query(stmt);
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_IP_BANNED);
+            stmt->setString(0, nameOrIP);
+            stmt->setUInt32(1, duration_secs);
+            stmt->setString(2, author);
+            stmt->setString(3, reason);
+            LoginDatabase.Execute(stmt);
+            break;
+        case BAN_ACCOUNT:
+            // No SQL injection with prepared statements
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_ID_BY_NAME);
+            stmt->setString(0, nameOrIP);
+            resultAccounts = LoginDatabase.Query(stmt);
+            break;
+        case BAN_CHARACTER:
+            // No SQL injection with prepared statements
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ACCOUNT_BY_NAME);
+            stmt->setString(0, nameOrIP);
+            resultAccounts = CharacterDatabase.Query(stmt);
+            break;
+        default:
+            return BAN_SYNTAX_ERROR;
+    }
+
+    if (!resultAccounts)
+    {
+        if (mode == BAN_IP)
+            return BAN_SUCCESS;                             // ip correctly banned but nobody affected (yet)
+        else
+            return BAN_NOTFOUND;                            // Nobody to ban
+    }
+
+    ///- Disconnect all affected players (for IP it can be several)
+    SQLTransaction trans = LoginDatabase.BeginTransaction();
+    do
+    {
+        Field* fieldsAccount = resultAccounts->Fetch();
+        uint32 account = fieldsAccount[0].GetUInt32();
+
+        if (mode != BAN_IP)
+        {
+            // make sure there is only one active ban
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_ACCOUNT_NOT_BANNED);
+            stmt->setUInt32(0, account);
+            trans->Append(stmt);
+            // No SQL injection with prepared statements
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_ACCOUNT_BANNED);
+            stmt->setUInt32(0, account);
+            stmt->setUInt32(1, duration_secs);
+            stmt->setString(2, author);
+            stmt->setString(3, reason);
+            trans->Append(stmt);
+        }
+
+        if (WorldSession* sess = FindSession(account))
+            if (std::string(sess->GetPlayerName()) != author)
+                sess->KickPlayer();
+    } while (resultAccounts->NextRow());
+
+    LoginDatabase.CommitTransaction(trans);
+
+    return BAN_SUCCESS;
+}
+
+/// Remove a ban from an account or IP address
+bool World::RemoveBanAccount(BanMode mode, std::string const& nameOrIP)
+{
+    PreparedStatement* stmt = NULL;
+    if (mode == BAN_IP)
+    {
+        stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_IP_NOT_BANNED);
+        stmt->setString(0, nameOrIP);
+        LoginDatabase.Execute(stmt);
+    }
+    else
+    {
+        uint32 account = 0;
+        if (mode == BAN_ACCOUNT)
+            account = AccountMgr::GetId(nameOrIP);
+        else if (mode == BAN_CHARACTER)
+            account = sObjectMgr->GetPlayerAccountIdByPlayerName(nameOrIP);
+
+        if (!account)
+            return false;
+
+        //NO SQL injection as account is uint32
+        stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_ACCOUNT_NOT_BANNED);
+        stmt->setUInt32(0, account);
+        LoginDatabase.Execute(stmt);
+    }
+    return true;
+}
+
+/// Ban an account or ban an IP address, duration will be parsed using TimeStringToSecs if it is positive, otherwise permban
+BanReturn World::BanCharacter(std::string const& name, std::string const& duration, std::string const& reason, std::string const& author)
+{
+    Player* pBanned = ObjectAccessor::FindConnectedPlayerByName(name);
+    ObjectGuid::LowType guid = 0;
+
+    uint32 duration_secs = TimeStringToSecs(duration);
+
+    /// Pick a player to ban if not online
+    if (!pBanned)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUID_BY_NAME);
+        stmt->setString(0, name);
+        PreparedQueryResult resultCharacter = CharacterDatabase.Query(stmt);
+
+        if (!resultCharacter)
+            return BAN_NOTFOUND;                                    // Nobody to ban
+
+        guid = (*resultCharacter)[0].GetUInt32();
+    }
+    else
+        guid = pBanned->GetGUID().GetCounter();
+
+    // make sure there is only one active ban
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_BAN);
+    stmt->setUInt32(0, guid);
+    CharacterDatabase.Execute(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_BAN);
+    stmt->setUInt32(0, guid);
+    stmt->setUInt32(1, duration_secs);
+    stmt->setString(2, author);
+    stmt->setString(3, reason);
+    CharacterDatabase.Execute(stmt);
+
+    if (pBanned)
+        pBanned->GetSession()->KickPlayer();
+
+    return BAN_SUCCESS;
+}
+
+/// Remove a ban from a character
+bool World::RemoveBanCharacter(std::string const& name)
+{
+    Player* pBanned = ObjectAccessor::FindConnectedPlayerByName(name);
+    ObjectGuid::LowType guid = 0;
+
+    /// Pick a player to ban if not online
+    if (!pBanned)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUID_BY_NAME);
+        stmt->setString(0, name);
+        PreparedQueryResult resultCharacter = CharacterDatabase.Query(stmt);
+
+        if (!resultCharacter)
+            return false;
+
+        guid = (*resultCharacter)[0].GetUInt32();
+    }
+    else
+        guid = pBanned->GetGUID().GetCounter();
+
+    if (!guid)
+        return false;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_BAN);
+    stmt->setUInt32(0, guid);
+    CharacterDatabase.Execute(stmt);
+    return true;
+}
+
+/// Update the game time
+void World::_UpdateGameTime()
+{
+    ///- update the time
+    time_t thisTime = time(NULL);
+    uint32 elapsed = uint32(thisTime - m_gameTime);
+    m_gameTime = thisTime;
+
+    ///- if there is a shutdown timer
+    if (!IsStopped() && m_ShutdownTimer > 0 && elapsed > 0)
+    {
+        ///- ... and it is overdue, stop the world (set m_stopEvent)
+        if (m_ShutdownTimer <= elapsed)
+        {
+            if (!(m_ShutdownMask & SHUTDOWN_MASK_IDLE) || GetActiveAndQueuedSessionCount() == 0)
+                m_stopEvent = true;                         // exist code already set
+            else
+                m_ShutdownTimer = 1;                        // minimum timer value to wait idle state
+        }
+        ///- ... else decrease it and if necessary display a shutdown countdown to the users
+        else
+        {
+            m_ShutdownTimer -= elapsed;
+
+            ShutdownMsg();
+        }
+    }
+}
+
+/// Shutdown the server
+void World::ShutdownServ(uint32 time, uint32 options, uint8 exitcode, const std::string& reason)
+{
+    // ignore if server shutdown at next tick
+    if (IsStopped())
+        return;
+
+    m_ShutdownMask = options;
+    m_ExitCode = exitcode;
+
+    ///- If the shutdown time is 0, set m_stopEvent (except if shutdown is 'idle' with remaining sessions)
+    if (time == 0)
+    {
+        if (!(options & SHUTDOWN_MASK_IDLE) || GetActiveAndQueuedSessionCount() == 0)
+            m_stopEvent = true;                             // exist code already set
+        else
+            m_ShutdownTimer = 1;                            //So that the session count is re-evaluated at next world tick
+    }
+    ///- Else set the shutdown timer and warn users
+    else
+    {
+        m_ShutdownTimer = time;
+        ShutdownMsg(true, nullptr, reason);
+    }
+
+    sScriptMgr->OnShutdownInitiate(ShutdownExitCode(exitcode), ShutdownMask(options));
+}
+
+/// Display a shutdown message to the user(s)
+void World::ShutdownMsg(bool show, Player* player, const std::string& reason)
+{
+    // not show messages for idle shutdown mode
+    if (m_ShutdownMask & SHUTDOWN_MASK_IDLE)
+        return;
+
+    ///- Display a message every 12 hours, hours, 5 minutes, minute, 5 seconds and finally seconds
+    if (show ||
+        (m_ShutdownTimer < 5* MINUTE && (m_ShutdownTimer % 15) == 0) || // < 5 min; every 15 sec
+        (m_ShutdownTimer < 15 * MINUTE && (m_ShutdownTimer % MINUTE) == 0) || // < 15 min ; every 1 min
+        (m_ShutdownTimer < 30 * MINUTE && (m_ShutdownTimer % (5 * MINUTE)) == 0) || // < 30 min ; every 5 min
+        (m_ShutdownTimer < 12 * HOUR && (m_ShutdownTimer % HOUR) == 0) || // < 12 h ; every 1 h
+        (m_ShutdownTimer > 12 * HOUR && (m_ShutdownTimer % (12 * HOUR)) == 0)) // > 12 h ; every 12 h
+    {
+        std::string str = secsToTimeString(m_ShutdownTimer);
+        if (!reason.empty())
+            str += " - " + reason;
+
+        ServerMessageType msgid = (m_ShutdownMask & SHUTDOWN_MASK_RESTART) ? SERVER_MSG_RESTART_TIME : SERVER_MSG_SHUTDOWN_TIME;
+
+        SendServerMessage(msgid, str.c_str(), player);
+        TC_LOG_DEBUG("misc", "Server is %s in %s", (m_ShutdownMask & SHUTDOWN_MASK_RESTART ? "restart" : "shuttingdown"), str.c_str());
+    }
+}
+
+/// Cancel a planned server shutdown
+uint32 World::ShutdownCancel()
+{
+    // nothing cancel or too later
+    if (!m_ShutdownTimer || m_stopEvent)
+        return 0;
+
+    ServerMessageType msgid = (m_ShutdownMask & SHUTDOWN_MASK_RESTART) ? SERVER_MSG_RESTART_CANCELLED : SERVER_MSG_SHUTDOWN_CANCELLED;
+
+    uint32 oldTimer = m_ShutdownTimer;
+    m_ShutdownMask = 0;
+    m_ShutdownTimer = 0;
+    m_ExitCode = SHUTDOWN_EXIT_CODE;                       // to default value
+    SendServerMessage(msgid);
+
+    TC_LOG_DEBUG("misc", "Server %s cancelled.", (m_ShutdownMask & SHUTDOWN_MASK_RESTART ? "restart" : "shutdown"));
+
+    sScriptMgr->OnShutdownCancel();
+    return oldTimer;
+}
+
+/// Send a server message to the user(s)
+void World::SendServerMessage(ServerMessageType type, const char *text, Player* player)
+{
+    WorldPacket data(SMSG_SERVER_MESSAGE, 50);              // guess size
+    data << uint32(type);
+    if (type <= SERVER_MSG_STRING)
+        data << text;
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        SendGlobalMessage(&data);
+}
+
+void World::UpdateSessions(uint32 diff)
+{
+    ///- Add new sessions
+    WorldSession* sess = NULL;
+    while (addSessQueue.next(sess))
+        AddSession_ (sess);
+
+    ///- Then send an update signal to remaining ones
+    for (SessionMap::iterator itr = m_sessions.begin(), next; itr != m_sessions.end(); itr = next)
+    {
+        next = itr;
+        ++next;
+
+        ///- and remove not active sessions from the list
+        WorldSession* pSession = itr->second;
+        WorldSessionFilter updater(pSession);
+
+        if (!pSession->Update(diff, updater))    // As interval = 0
+        {
+            if (!RemoveQueuedPlayer(itr->second) && itr->second && getIntConfig(CONFIG_INTERVAL_DISCONNECT_TOLERANCE))
+                m_disconnects[itr->second->GetAccountId()] = time(NULL);
+            RemoveQueuedPlayer(pSession);
+            m_sessions.erase(itr);
+            delete pSession;
+
+        }
+    }
+}
+
+// This handles the issued and queued CLI commands
+void World::ProcessCliCommands()
+{
+    CliCommandHolder::Print* zprint = NULL;
+    void* callbackArg = NULL;
+    CliCommandHolder* command = NULL;
+    while (cliCmdQueue.next(command))
+    {
+        TC_LOG_INFO("misc", "CLI command under processing...");
+        zprint = command->m_print;
+        callbackArg = command->m_callbackArg;
+        CliHandler handler(callbackArg, zprint);
+        handler.ParseCommands(command->m_command);
+        if (command->m_commandFinished)
+            command->m_commandFinished(callbackArg, !handler.HasSentErrorMessage());
+        delete command;
+    }
+}
+
+void World::SendAutoBroadcast()
+{
+    if (m_Autobroadcasts.empty())
+        return;
+
+    uint32 weight = 0;
+    AutobroadcastsWeightMap selectionWeights;
+    std::string msg;
+
+    for (AutobroadcastsWeightMap::const_iterator it = m_AutobroadcastsWeights.begin(); it != m_AutobroadcastsWeights.end(); ++it)
+    {
+        if (it->second)
+        {
+            weight += it->second;
+            selectionWeights[it->first] = it->second;
+        }
+    }
+
+    if (weight)
+    {
+        uint32 selectedWeight = urand(0, weight - 1);
+        weight = 0;
+        for (AutobroadcastsWeightMap::const_iterator it = selectionWeights.begin(); it != selectionWeights.end(); ++it)
+        {
+            weight += it->second;
+            if (selectedWeight < weight)
+            {
+                msg = m_Autobroadcasts[it->first];
+                break;
+            }
+        }
+    }
+    else
+        msg = m_Autobroadcasts[urand(0, m_Autobroadcasts.size())];
+
+    uint32 abcenter = sWorld->getIntConfig(CONFIG_AUTOBROADCAST_CENTER);
+
+    if (abcenter == 0)
+        sWorld->SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+    else if (abcenter == 1)
+    {
+        WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+        data << msg;
+        sWorld->SendGlobalMessage(&data);
+    }
+    else if (abcenter == 2)
+    {
+        sWorld->SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+        WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+        data << msg;
+        sWorld->SendGlobalMessage(&data);
+    }
+
+    TC_LOG_DEBUG("misc", "AutoBroadcast: '%s'", msg.c_str());
+}
+
+void World::UpdateRealmCharCount(uint32 accountId)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_COUNT);
+    stmt->setUInt32(0, accountId);
+    m_realmCharCallbacks.push_back(CharacterDatabase.AsyncQuery(stmt));
+}
+
+void World::_UpdateRealmCharCount(PreparedQueryResult resultCharCount)
+{
+    if (resultCharCount)
+    {
+        Field* fields = resultCharCount->Fetch();
+        uint32 accountId = fields[0].GetUInt32();
+        uint8 charCount = uint8(fields[1].GetUInt64());
+
+        SQLTransaction trans = LoginDatabase.BeginTransaction();
+
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_REALM_CHARACTERS_BY_REALM);
+        stmt->setUInt32(0, accountId);
+        stmt->setUInt32(1, realm.Id.Realm);
+        trans->Append(stmt);
+
+        stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_REALM_CHARACTERS);
+        stmt->setUInt8(0, charCount);
+        stmt->setUInt32(1, accountId);
+        stmt->setUInt32(2, realm.Id.Realm);
+        trans->Append(stmt);
+
+        LoginDatabase.CommitTransaction(trans);
+    }
+}
+
+void World::InitWeeklyQuestResetTime()
+{
+    time_t wstime = uint64(sWorld->getWorldState(WS_WEEKLY_QUEST_RESET_TIME));
+    time_t curtime = time(NULL);
+    m_NextWeeklyQuestReset = wstime < curtime ? curtime : time_t(wstime);
+}
+
+void World::InitDailyQuestResetTime()
+{
+    time_t mostRecentQuestTime;
+
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(time) FROM character_queststatus_daily");
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        mostRecentQuestTime = time_t(fields[0].GetUInt32());
+    }
+    else
+        mostRecentQuestTime = 0;
+
+    // client built-in time for reset is 6:00 AM
+    // FIX ME: client not show day start time
+    time_t curTime = time(NULL);
+    tm localTm;
+    localtime_r(&curTime, &localTm);
+    localTm.tm_hour = 6;
+    localTm.tm_min  = 0;
+    localTm.tm_sec  = 0;
+
+    // current day reset time
+    time_t curDayResetTime = mktime(&localTm);
+
+    // last reset time before current moment
+    time_t resetTime = (curTime < curDayResetTime) ? curDayResetTime - DAY : curDayResetTime;
+
+    // need reset (if we have quest time before last reset time (not processed by some reason)
+    if (mostRecentQuestTime && mostRecentQuestTime <= resetTime)
+        m_NextDailyQuestReset = mostRecentQuestTime;
+    else // plan next reset time
+        m_NextDailyQuestReset = (curTime >= curDayResetTime) ? curDayResetTime + DAY : curDayResetTime;
+}
+
+void World::InitMonthlyQuestResetTime()
+{
+    time_t wstime = uint64(sWorld->getWorldState(WS_MONTHLY_QUEST_RESET_TIME));
+    time_t curtime = time(NULL);
+    m_NextMonthlyQuestReset = wstime < curtime ? curtime : time_t(wstime);
+}
+
+void World::InitRandomBGResetTime()
+{
+    time_t bgtime = uint64(sWorld->getWorldState(WS_BG_DAILY_RESET_TIME));
+    if (!bgtime)
+        m_NextRandomBGReset = time_t(time(NULL));         // game time not yet init
+
+    // generate time by config
+    time_t curTime = time(NULL);
+    tm localTm;
+    localtime_r(&curTime, &localTm);
+    localTm.tm_hour = getIntConfig(CONFIG_RANDOM_BG_RESET_HOUR);
+    localTm.tm_min = 0;
+    localTm.tm_sec = 0;
+
+    // current day reset time
+    time_t nextDayResetTime = mktime(&localTm);
+
+    // next reset time before current moment
+    if (curTime >= nextDayResetTime)
+        nextDayResetTime += DAY;
+
+    // normalize reset time
+    m_NextRandomBGReset = bgtime < curTime ? nextDayResetTime - DAY : nextDayResetTime;
+
+    if (!bgtime)
+        sWorld->setWorldState(WS_BG_DAILY_RESET_TIME, uint64(m_NextRandomBGReset));
+}
+
+void World::InitGuildResetTime()
+{
+    time_t gtime = uint64(getWorldState(WS_GUILD_DAILY_RESET_TIME));
+    if (!gtime)
+        m_NextGuildReset = time_t(time(NULL));         // game time not yet init
+
+    // generate time by config
+    time_t curTime = time(NULL);
+    tm localTm;
+    localtime_r(&curTime, &localTm);
+    localTm.tm_hour = getIntConfig(CONFIG_GUILD_RESET_HOUR);
+    localTm.tm_min = 0;
+    localTm.tm_sec = 0;
+
+    // current day reset time
+    time_t nextDayResetTime = mktime(&localTm);
+
+    // next reset time before current moment
+    if (curTime >= nextDayResetTime)
+        nextDayResetTime += DAY;
+
+    // normalize reset time
+    m_NextGuildReset = gtime < curTime ? nextDayResetTime - DAY : nextDayResetTime;
+
+    if (!gtime)
+        sWorld->setWorldState(WS_GUILD_DAILY_RESET_TIME, uint64(m_NextGuildReset));
+}
+
+void World::ResetDailyQuests()
+{
+    TC_LOG_INFO("misc", "Daily quests reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_RESET_CHARACTER_QUESTSTATUS_DAILY);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetDailyQuestStatus();
+
+    // change available dailies
+    sPoolMgr->ChangeDailyQuests();
+}
+
+void World::LoadDBAllowedSecurityLevel()
+{
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_REALMLIST_SECURITY_LEVEL);
+    stmt->setInt32(0, int32(realm.Id.Realm));
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
+    if (result)
+        SetPlayerSecurityLimit(AccountTypes(result->Fetch()->GetUInt8()));
+}
+
+void World::SetPlayerSecurityLimit(AccountTypes _sec)
+{
+    AccountTypes sec = _sec < SEC_CONSOLE ? _sec : SEC_PLAYER;
+    bool update = sec > m_allowedSecurityLevel;
+    m_allowedSecurityLevel = sec;
+    if (update)
+        KickAllLess(m_allowedSecurityLevel);
+}
+
+void World::ResetWeeklyQuests()
+{
+    TC_LOG_INFO("misc", "Weekly quests reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_RESET_CHARACTER_QUESTSTATUS_WEEKLY);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetWeeklyQuestStatus();
+
+    m_NextWeeklyQuestReset = time_t(m_NextWeeklyQuestReset + WEEK);
+    sWorld->setWorldState(WS_WEEKLY_QUEST_RESET_TIME, uint64(m_NextWeeklyQuestReset));
+
+    // change available weeklies
+    sPoolMgr->ChangeWeeklyQuests();
+}
+
+void World::ResetMonthlyQuests()
+{
+    TC_LOG_INFO("misc", "Monthly quests reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_RESET_CHARACTER_QUESTSTATUS_MONTHLY);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetMonthlyQuestStatus();
+
+    // generate time
+    time_t curTime = time(NULL);
+    tm localTm;
+    localtime_r(&curTime, &localTm);
+
+    int month   = localTm.tm_mon;
+    int year    = localTm.tm_year;
+
+    ++month;
+
+    // month 11 is december, next is january (0)
+    if (month > 11)
+    {
+        month = 0;
+        year += 1;
+    }
+
+    // reset time for next month
+    localTm.tm_year     = year;
+    localTm.tm_mon      = month;
+    localTm.tm_mday     = 1;        // don't know if we really need config option for day / hour
+    localTm.tm_hour     = 0;
+    localTm.tm_min      = 0;
+    localTm.tm_sec      = 0;
+
+    time_t nextMonthResetTime = mktime(&localTm);
+
+    // plan next reset time
+    m_NextMonthlyQuestReset = (curTime >= nextMonthResetTime) ? nextMonthResetTime + MONTH : nextMonthResetTime;
+
+    sWorld->setWorldState(WS_MONTHLY_QUEST_RESET_TIME, uint64(m_NextMonthlyQuestReset));
+}
+
+void World::ResetEventSeasonalQuests(uint16 event_id)
+{
+    TC_LOG_INFO("misc", "Seasonal quests reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_RESET_CHARACTER_QUESTSTATUS_SEASONAL_BY_EVENT);
+    stmt->setUInt16(0, event_id);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetSeasonalQuestStatus(event_id);
+}
+
+void World::ResetRandomBG()
+{
+    TC_LOG_INFO("misc", "Random BG status reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_BATTLEGROUND_RANDOM_ALL);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->SetRandomWinner(false);
+
+    m_NextRandomBGReset = time_t(m_NextRandomBGReset + DAY);
+    sWorld->setWorldState(WS_BG_DAILY_RESET_TIME, uint64(m_NextRandomBGReset));
+}
+
+void World::ResetGuildCap()
+{
+    TC_LOG_INFO("misc", "Guild Daily Cap reset.");
+
+    m_NextGuildReset = time_t(m_NextGuildReset + DAY);
+    sWorld->setWorldState(WS_GUILD_DAILY_RESET_TIME, uint64(m_NextGuildReset));
+    sGuildMgr->ResetTimes();
+}
+
+void World::UpdateMaxSessionCounters()
+{
+    m_maxActiveSessionCount = std::max(m_maxActiveSessionCount, uint32(m_sessions.size()-m_QueuedPlayer.size()));
+    m_maxQueuedSessionCount = std::max(m_maxQueuedSessionCount, uint32(m_QueuedPlayer.size()));
+}
+
+void World::LoadDBVersion()
+{
+    QueryResult result = WorldDatabase.Query("SELECT db_version, cache_id FROM version LIMIT 1");
+    if (result)
+    {
+        Field* fields = result->Fetch();
+
+        m_DBVersion = fields[0].GetString();
+        // will be overwrite by config values if different and non-0
+        m_int_configs[CONFIG_CLIENTCACHE_VERSION] = fields[1].GetUInt32();
+    }
+
+    if (m_DBVersion.empty())
+        m_DBVersion = "Unknown world database.";
+}
+
+void World::UpdateAreaDependentAuras()
+{
+    SessionMap::const_iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second && itr->second->GetPlayer() && itr->second->GetPlayer()->IsInWorld())
+        {
+            itr->second->GetPlayer()->UpdateAreaDependentAuras(itr->second->GetPlayer()->GetAreaId());
+            itr->second->GetPlayer()->UpdateZoneDependentAuras(itr->second->GetPlayer()->GetZoneId());
+        }
+}
+
+void World::LoadWorldStates()
+{
+    uint32 oldMSTime = getMSTime();
+
+    QueryResult result = CharacterDatabase.Query("SELECT entry, value FROM worldstates");
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.loading", ">> Loaded 0 world states. DB table `worldstates` is empty!");
+
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+        m_worldstates[fields[0].GetUInt32()] = fields[1].GetUInt32();
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u world states in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+
+}
+
+// Setting a worldstate will save it to DB
+void World::setWorldState(uint32 index, uint64 value)
+{
+    WorldStatesMap::const_iterator it = m_worldstates.find(index);
+    if (it != m_worldstates.end())
+    {
+        if (it->second == value)
+            return;
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_WORLDSTATE);
+
+        stmt->setUInt32(0, uint32(value));
+        stmt->setUInt32(1, index);
+
+        CharacterDatabase.Execute(stmt);
+    }
+    else
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_WORLDSTATE);
+
+        stmt->setUInt32(0, index);
+        stmt->setUInt32(1, uint32(value));
+
+        CharacterDatabase.Execute(stmt);
+    }
+    m_worldstates[index] = value;
+}
+
+uint64 World::getWorldState(uint32 index) const
+{
+    WorldStatesMap::const_iterator it = m_worldstates.find(index);
+    return it != m_worldstates.end() ? it->second : 0;
+}
+
+void World::ProcessQueryCallbacks()
+{
+    PreparedQueryResult result;
+
+    for (std::deque<std::future<PreparedQueryResult>>::iterator itr = m_realmCharCallbacks.begin(); itr != m_realmCharCallbacks.end(); )
+    {
+        if ((*itr).wait_for(std::chrono::seconds(0)) != std::future_status::ready)
+        {
+            ++itr;
+            continue;
+        }
+
+        result = (*itr).get();
+        _UpdateRealmCharCount(result);
+        itr = m_realmCharCallbacks.erase(itr);
+    }
+}
+
+CharacterInfo const* World::GetCharacterInfo(ObjectGuid const& guid) const
+{
+    CharacterInfoContainer::const_iterator itr = _characterInfoStore.find(guid);
+    if (itr != _characterInfoStore.end())
+        return &itr->second;
+
+    return nullptr;
+}
+
+/**
+* @brief Loads several pieces of information on server startup with the GUID
+* There is no further database query necessary.
+* These are a number of methods that work into the calling function.
+*
+* @param guid Requires a guid to call
+* @return Name, Gender, Race, Class and Level of player character
+* Example Usage:
+* @code
+*    CharacterInfo const* characterInfo = sWorld->GetCharacterInfo(GUID);
+*    if (!characterInfo)
+*        return;
+*
+*    std::string playerName = characterInfo->Name;
+*    uint8 playerGender = characterInfo->Sex;
+*    uint8 playerRace = characterInfo->Race;
+*    uint8 playerClass = characterInfo->Class;
+*    uint8 playerLevel = characterInfo->Level;
+* @endcode
+**/
+
+void World::LoadCharacterInfoStore()
+{
+    TC_LOG_INFO("server.loading", "Loading character info store");
+
+    _characterInfoStore.clear();
+
+    QueryResult result = CharacterDatabase.Query("SELECT guid, name, account, race, gender, class, level FROM characters");
+    if (!result)
+    {
+        TC_LOG_INFO("server.loading", "No character name data loaded, empty query");
+        return;
+    }
+
+    do
+    {
+        Field* fields = result->Fetch();
+        AddCharacterInfo(ObjectGuid::Create<HighGuid::Player>(fields[0].GetUInt32()), fields[2].GetUInt32(), fields[1].GetString(),
+            fields[4].GetUInt8() /*gender*/, fields[3].GetUInt8() /*race*/, fields[5].GetUInt8() /*class*/, fields[6].GetUInt8() /*level*/);
+    } while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", "Loaded character infos for " SZFMTD " characters", _characterInfoStore.size());
+}
+
+void World::AddCharacterInfo(ObjectGuid const& guid, uint32 accountId, std::string const& name, uint8 gender, uint8 race, uint8 playerClass, uint8 level)
+{
+    CharacterInfo& data = _characterInfoStore[guid];
+    data.Name = name;
+    data.AccountId = accountId;
+    data.Race = race;
+    data.Sex = gender;
+    data.Class = playerClass;
+    data.Level = level;
+}
+
+void World::UpdateCharacterInfo(ObjectGuid const& guid, std::string const& name, uint8 gender /*= GENDER_NONE*/, uint8 race /*= RACE_NONE*/)
+{
+    CharacterInfoContainer::iterator itr = _characterInfoStore.find(guid);
+    if (itr == _characterInfoStore.end())
+        return;
+
+    itr->second.Name = name;
+
+    if (gender != GENDER_NONE)
+        itr->second.Sex = gender;
+
+    if (race != RACE_NONE)
+        itr->second.Race = race;
+
+    WorldPacket data(SMSG_INVALIDATE_PLAYER, 8);
+    data << guid;
+    SendGlobalMessage(&data);
+}
+
+void World::UpdateCharacterInfoLevel(ObjectGuid const& guid, uint8 level)
+{
+    CharacterInfoContainer::iterator itr = _characterInfoStore.find(guid);
+    if (itr == _characterInfoStore.end())
+        return;
+
+    itr->second.Level = level;
+}
+
+void World::ReloadRBAC()
+{
+    // Passive reload, we mark the data as invalidated and next time a permission is checked it will be reloaded
+    TC_LOG_INFO("rbac", "World::ReloadRBAC()");
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (WorldSession* session = itr->second)
+            session->InvalidateRBACData();
+}
+
+void World::RemoveOldCorpses()
+{
+    m_timers[WUPDATE_CORPSES].SetCurrent(m_timers[WUPDATE_CORPSES].GetInterval());
+}
+
+Realm realm;
diff --git a/src/server/scripts/Commands/cs_ahbot.cpp b/src/server/scripts/Commands/cs_ahbot.cpp
index 47553d0..6e622ba 100644
--- a/src/server/scripts/Commands/cs_ahbot.cpp
+++ b/src/server/scripts/Commands/cs_ahbot.cpp
@@ -241,5 +241,6 @@ template bool ahbot_commandscript::HandleAHBotItemsRatioHouseCommand<AUCTION_HOU
 
 void AddSC_ahbot_commandscript()
 {
-    new ahbot_commandscript();
+    // playerbot mod
+    // new ahbot_commandscript();
 }
diff --git a/src/server/scripts/Commands/cs_misc.cpp b/src/server/scripts/Commands/cs_misc.cpp
index 16217fb..233f40e 100644
--- a/src/server/scripts/Commands/cs_misc.cpp
+++ b/src/server/scripts/Commands/cs_misc.cpp
@@ -38,6 +38,10 @@
 #include "SpellHistory.h"
 #include "Transport.h"
 
+#include "../../../plugins/ahbot/AhBot.h"
+#include "../../../plugins/playerbot/playerbot.h"
+#include "../../../plugins/playerbot/GuildTaskMgr.h"
+
 class misc_commandscript : public CommandScript
 {
 public:
@@ -98,6 +102,11 @@ public:
             { "unstuck",          rbac::RBAC_PERM_COMMAND_UNSTUCK,           true, &HandleUnstuckCommand,          "" },
             { "wchange",          rbac::RBAC_PERM_COMMAND_WCHANGE,          false, &HandleChangeWeather,           "" },
             { "mailbox",          rbac::RBAC_PERM_COMMAND_MAILBOX,          false, &HandleMailBoxCommand,          "" },
+            // playerbot mod
+            { "ahbot",            rbac::RBAC_PERM_COMMAND_GM       ,          true,  &ahbot::AhBot::HandleAhBotCommand,                      "" },
+            { "rndbot",           rbac::RBAC_PERM_COMMAND_GM       ,          true,  &RandomPlayerbotMgr::HandlePlayerbotConsoleCommand,     "" },
+            { "bot",              195                              ,          false, &PlayerbotMgr::HandlePlayerbotMgrCommand,               "" },
+            { "gtask",            rbac::RBAC_PERM_COMMAND_GM       ,          true,  &GuildTaskMgr::HandleConsoleCommand,           "" },
         };
         return commandTable;
     }
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index 0de8d60..33c8dbd 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -49,6 +49,7 @@ target_link_libraries(worldserver
   PUBLIC
     scripts
     game
+    plugins
     gsoap
     readline)
 
diff --git a/src/test/AcceptAllQuestStrategyTestCase.cpp b/src/test/AcceptAllQuestStrategyTestCase.cpp
new file mode 100644
index 0000000..3b1a20e
--- /dev/null
+++ b/src/test/AcceptAllQuestStrategyTestCase.cpp
@@ -0,0 +1,68 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class AcceptAllQuestStrategyTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( AcceptAllQuestStrategyTestCase );
+      CPPUNIT_TEST( turn_in_quest );
+      CPPUNIT_TEST( accept_quest );
+      CPPUNIT_TEST( quest_share );
+      CPPUNIT_TEST( useGameObject );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "accept all quests", NULL);
+    }
+
+protected:
+    void useGameObject()
+    {
+        trigger("use game object");
+        tick();
+        tick();
+
+        assertActions(">S:talk to quest giver>S:accept all quests");
+    }
+
+    void turn_in_quest()
+    {
+        trigger("complete quest");
+        tick();
+        tick();
+
+        trigger("gossip hello");
+        tick();
+        tick();
+
+        assertActions(">S:talk to quest giver>S:accept all quests>S:talk to quest giver>S:accept all quests");
+    }
+
+    void accept_quest()
+    {
+        trigger("accept quest");
+        tick();
+
+        assertActions(">S:accept quest");
+    }
+
+    void quest_share()
+    {
+        trigger("quest share");
+        tick();
+
+        assertActions(">S:accept quest share");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( AcceptAllQuestStrategyTestCase );
diff --git a/src/test/AiObjectContextWrapper.h b/src/test/AiObjectContextWrapper.h
new file mode 100644
index 0000000..a64b4ab
--- /dev/null
+++ b/src/test/AiObjectContextWrapper.h
@@ -0,0 +1,289 @@
+#pragma once
+using namespace std;
+
+namespace ai
+{
+    class MockTargetValue : public ManualSetValue<Unit*>, public Qualified
+    {
+    public:
+        MockTargetValue(PlayerbotAI* const ai) : ManualSetValue<Unit*>(ai, NULL) {}
+    };
+
+    class MockStatsValue : public ManualSetValue<uint8>, public Qualified
+    {
+    public:
+        MockStatsValue(PlayerbotAI* const ai) : ManualSetValue<uint8>(ai, 0) {}
+    };
+
+    class MockFloatValue : public ManualSetValue<float>, public Qualified
+    {
+    public:
+        MockFloatValue(PlayerbotAI* const ai) : ManualSetValue<float>(ai, 0) {}
+    };
+
+    class MockStringValue : public ManualSetValue<string>, public Qualified
+    {
+    public:
+        MockStringValue(PlayerbotAI* const ai) : ManualSetValue<string>(ai, "") {}
+    };
+
+    class MockItemListValue : public ManualSetValue<list<Item*> >, public Qualified
+    {
+    public:
+        MockItemListValue(PlayerbotAI* const ai) : ManualSetValue<list<Item*> >(ai, list<Item*>()) {}
+    };
+
+    class MockItemValue : public ManualSetValue<Item*>, public Qualified
+    {
+    public:
+        MockItemValue(PlayerbotAI* const ai) : ManualSetValue<Item*>(ai, NULL) {}
+    };
+
+    class MockLogicalValue : public ManualSetValue<bool>, public Qualified
+    {
+    public:
+        MockLogicalValue(PlayerbotAI* const ai) : ManualSetValue<bool>(ai, false) {}
+    };
+
+    class AlwaysTrueValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        AlwaysTrueValue(PlayerbotAI* const ai) : BoolCalculatedValue(ai) {}
+        virtual bool Calculate() { return true; }
+    };
+
+    class MockPartyMemberWithoutAuraValue : public UnitCalculatedValue, public Qualified
+    {
+    public:
+        MockPartyMemberWithoutAuraValue(PlayerbotAI* const ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate()
+        {
+            string  spell = qualifier;
+            Unit* target = MockedTargets::GetPartyMember();
+            return ai->HasAura(spell, target) ? NULL : target;
+        }
+    };
+
+    class MockPartyMemberToHeal : public UnitCalculatedValue
+    {
+    public:
+        MockPartyMemberToHeal(PlayerbotAI* const ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate()
+        {
+            Unit* target = MockedTargets::GetPartyMember();
+            return AI_VALUE2(uint8, "health", "party member to heal") < 100.0f ? target : NULL;
+        }
+    };
+
+    class MockPartyMemberToDispel : public UnitCalculatedValue, public Qualified
+    {
+    public:
+        MockPartyMemberToDispel(PlayerbotAI* const ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate()
+        {
+            uint32 dispelType = atoi(qualifier.c_str());
+            Unit* target = MockedTargets::GetPartyMember();
+            return ai->HasAuraToDispel(target, dispelType) ? target : NULL;
+        }
+    };
+
+    class MockUnitListValue : public ManualSetValue<list<ObjectGuid>>
+    {
+    public:
+        MockUnitListValue(PlayerbotAI* const ai) : ManualSetValue<list<ObjectGuid>>(ai, list<ObjectGuid>()) {}
+    };
+
+    class MockSpellIdValue : public CalculatedValue<uint32>, public Qualified
+    {
+    public:
+        MockSpellIdValue(PlayerbotAI* ai) : CalculatedValue<uint32>(ai) {}
+
+    public:
+        virtual uint32 Calculate() { return 1; }
+
+    };
+
+    class MockValueContext : public NamedObjectContext<UntypedValue>
+    {
+    public:
+        MockValueContext() : NamedObjectContext<UntypedValue>()
+        {
+            creators["attacker without aura"] = &MockValueContext::mock;
+            creators["party member without aura"] = &MockValueContext::party_member_without_aura;
+            creators["party member to heal"] = &MockValueContext::party_member_to_heal;
+            creators["party member to dispel"] = &MockValueContext::party_member_to_dispel;
+            creators["party member to resurrect"] = &MockValueContext::mock;
+            creators["current target"] = &MockValueContext::mock;
+            creators["old target"] = &MockValueContext::mock;
+            creators["self target"] = &MockValueContext::mock;
+            creators["master target"] = &MockValueContext::mock;
+            creators["line target"] = &MockValueContext::mock;
+            creators["tank target"] = &MockValueContext::mock;
+            creators["dps target"] = &MockValueContext::mock;
+            creators["cc target"] = &MockValueContext::mock;
+            creators["current cc target"] = &MockValueContext::mock;
+            creators["pet target"] = &MockValueContext::mock;
+            creators["grind target"] = &MockValueContext::mock;
+            creators["least hp target"] = &MockValueContext::mock;
+            creators["rti target"] = &MockValueContext::mock;
+            creators["duel target"] = &MockValueContext::mock;
+            creators["enemy player target"] = &MockValueContext::mock;
+            creators["enemy healer target"] = &MockValueContext::mock;
+
+            creators["health"] = &MockValueContext::stats;
+            creators["rage"] = &MockValueContext::stats;
+            creators["energy"] = &MockValueContext::stats;
+            creators["mana"] = &MockValueContext::stats;
+            creators["combo"] = &MockValueContext::stats;
+            creators["dead"] = &MockValueContext::logical;
+            creators["has mana"] = &MockValueContext::logical;
+            creators["combat"] = &MockValueContext::logical;
+
+            creators["attacker count"] = &MockValueContext::stats;
+            creators["my attacker count"] = &MockValueContext::stats;
+            creators["has aggro"] = &MockValueContext::logical;
+            creators["balance"] = &MockValueContext::stats;
+            creators["mounted"] = &MockValueContext::logical;
+            creators["has available loot"] = &MockValueContext::logical;
+            creators["distance"] = &MockValueContext::floating;
+            creators["moving"] = &MockValueContext::logical;
+            creators["swimming"] = &MockValueContext::logical;
+            creators["behind"] = &MockValueContext::logical;
+            creators["facing"] = &MockValueContext::logical;
+            creators["item count"] = &MockValueContext::stats;
+            creators["inventory items"] = &MockValueContext::itemlist;
+            creators["item for spell"] = &MockValueContext::item;
+            creators["spell cast useful"] = &MockValueContext::always_true;
+            creators["can loot"] = &MockValueContext::logical;
+            creators["invalid target"] = &MockValueContext::logical;
+
+            creators["possible targets"] = &MockValueContext::units;
+            creators["nearest adds"] = &MockValueContext::units;
+            creators["attackers"] = &MockValueContext::units;
+            creators["has totem"] = &MockValueContext::logical;
+            creators["aoe heal"] = &MockValueContext::stats;
+
+            creators["rti"] = &MockValueContext::str;
+            creators["spell id"] = &MockValueContext::spell_id;
+            creators["threat"] = &MockValueContext::stats;
+            creators["bag space"] = &MockValueContext::stats;
+            creators["speed"] = &MockValueContext::stats;
+        }
+
+    private:
+        static UntypedValue* always_true(PlayerbotAI* ai) { return new AlwaysTrueValue(ai); }
+        static UntypedValue* stats(PlayerbotAI* ai) { return new MockStatsValue(ai); }
+        static UntypedValue* itemlist(PlayerbotAI* ai) { return new MockItemListValue(ai); }
+        static UntypedValue* item(PlayerbotAI* ai) { return new MockItemValue(ai); }
+        static UntypedValue* floating(PlayerbotAI* ai) { return new MockFloatValue(ai); }
+        static UntypedValue* str(PlayerbotAI* ai) { return new MockStringValue(ai); }
+        static UntypedValue* logical(PlayerbotAI* ai) { return new MockLogicalValue(ai); }
+        static UntypedValue* mock(PlayerbotAI* ai) { return new MockTargetValue(ai); }
+        static UntypedValue* party_member_without_aura(PlayerbotAI* ai) { return new MockPartyMemberWithoutAuraValue(ai); }
+        static UntypedValue* party_member_to_heal(PlayerbotAI* ai) { return new MockPartyMemberToHeal(ai); }
+        static UntypedValue* party_member_to_dispel(PlayerbotAI* ai) { return new MockPartyMemberToDispel(ai); }
+        static UntypedValue* units(PlayerbotAI* ai) { return new MockUnitListValue(ai); }
+        static UntypedValue* spell_id(PlayerbotAI* ai) { return new MockSpellIdValue(ai); }
+    };
+
+    class AiObjectContextWrapper : public AiObjectContext
+    {
+    public:
+        AiObjectContextWrapper(PlayerbotAI* const ai, AiObjectContext *realContext) :
+          AiObjectContext(ai), realContext(realContext)
+          {
+              GetValue<Unit*>("self target")->Set(MockedTargets::GetSelf());
+              GetValue<Unit*>("master target")->Set(MockedTargets::GetMaster());
+              GetValue<Unit*>("line target")->Set(MockedTargets::GetLineTarget());
+              GetValue<Unit*>("tank target")->Set(MockedTargets::GetTargetForTank());
+              GetValue<Unit*>("dps target")->Set(MockedTargets::GetTargetForDps());
+              GetValue<Unit*>("current cc target")->Set(NULL);
+              GetValue<Unit*>("current target")->Set(MockedTargets::GetCurrentTarget());
+              GetValue<Unit*>("old target")->Set(MockedTargets::GetCurrentTarget());
+              GetValue<Unit*>("pet target")->Set(MockedTargets::GetPet());
+              GetValue<Unit*>("least hp target")->Set(MockedTargets::GetLeastHpTarget());
+              GetValue<Unit*>("rti target")->Set(MockedTargets::GetRtiTarget());
+              GetValue<Unit*>("enemy player target")->Set(MockedTargets::GetEnemyPlayer());
+              GetValue<Unit*>("attacker without aura")->Set(NULL);
+
+              GetValue<uint8>("health", "self target")->Set(100);
+              GetValue<uint8>("health", "current target")->Set(100);
+              GetValue<uint8>("health", "pet target")->Set(100);
+              GetValue<uint8>("health", "party member to heal")->Set(100);
+              GetValue<uint8>("health", "party member to resurrect")->Set(100);
+
+              GetValue<bool>("dead", "current target")->Set(false);
+              GetValue<bool>("dead", "self target")->Set(false);
+
+              GetValue<uint8>("mana", "self target")->Set(100);
+              GetValue<uint8>("mana", "current target")->Set(100);
+              GetValue<uint8>("mana", "pet target")->Set(100);
+              GetValue<uint8>("mana", "party member to heal")->Set(100);
+              GetValue<uint8>("mana", "party member to resurrect")->Set(100);
+
+              GetValue<bool>("has mana", "self target")->Set(true);
+              GetValue<bool>("has mana", "current target")->Set(true);
+              GetValue<bool>("has mana", "pet target")->Set(true);
+              GetValue<bool>("has mana", "party member to heal")->Set(true);
+              GetValue<bool>("has mana", "party member to resurrect")->Set(true);
+
+              GetValue<bool>("combat", "self target")->Set(false);
+
+              GetValue<uint8>("attacker count")->Set(1);
+              GetValue<uint8>("my attacker count")->Set(1);
+              GetValue<uint8>("balance")->Set(100);
+              GetValue<float>("distance", "current target")->Set(15.0f);
+              GetValue<float>("distance", "loot target")->Set(0.0f);
+
+              GetValue<bool>("has aggro", "current target")->Set(true);
+              GetValue<bool>("can loot")->Set(false);
+
+              GetValue<bool>("facing", "current target")->Set(true);
+
+              list<Item*> items; items.push_back((Item*)(void*)0x01);
+              GetValue<list<Item*> >("inventory items", "drink")->Set(items);
+              GetValue<list<Item*> >("inventory items", "food")->Set(items);
+
+              GetValue<uint8>("aoe heal", "low")->Set(0);
+              GetValue<uint8>("aoe heal", "medium")->Set(0);
+              GetValue<uint8>("aoe heal", "critical")->Set(0);
+
+              GetValue<uint8>("threat")->Set(0);
+              GetValue<uint8>("bag space")->Set(0);
+              GetValue<uint8>("speed", "current target")->Set(80);
+          }
+
+    public:
+        virtual UntypedValue* GetUntypedValue(string  name)
+        {
+            UntypedValue* value = mockValueContext.create(name, ai);
+            UntypedValue* real = realContext->GetUntypedValue(name);
+            if (!real)
+            {
+                std::cout << "\n===\n";
+                cout << "Value " << name << " not found in context";
+                std::cout << "\n===\n";
+
+                CPPUNIT_ASSERT(false);
+            }
+            return value ? value : real;
+        }
+        virtual Strategy* GetStrategy(string  name) { return realContext->GetStrategy(name); }
+        virtual set<string> GetSiblingStrategy(string name) { return realContext->GetSiblingStrategy(name); }
+        virtual Trigger* GetTrigger(string  name) { return realContext->GetTrigger(name); }
+        virtual Action* GetAction(string  name) { return realContext->GetAction(name); }
+        virtual void Update()
+        {
+            mockValueContext.Update();
+            realContext->Update();
+        }
+
+    private:
+        AiObjectContext *realContext;
+        MockValueContext mockValueContext;
+    };
+
+}
diff --git a/src/test/ArcaneMageTestCase.cpp b/src/test/ArcaneMageTestCase.cpp
new file mode 100644
index 0000000..456dd54
--- /dev/null
+++ b/src/test/ArcaneMageTestCase.cpp
@@ -0,0 +1,55 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+
+using namespace ai;
+
+
+class ArcaneMageTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( ArcaneMageTestCase );
+      CPPUNIT_TEST( combatVsMelee );
+      CPPUNIT_TEST( avoid_melee );
+      CPPUNIT_TEST( stress );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new MageAiObjectContext(ai), "arcane", NULL);
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+        tick();
+		addAura("arcane blast");
+
+        tick();
+
+        addAura("missile barrage");
+        tick();
+        tickWithSpellAvailable("arcane missiles");
+        tick();
+
+        assertActions(">T:arcane blast>T:arcane barrage>T:arcane missiles>T:arcane missiles>T:shoot");
+	}
+
+ 	void avoid_melee()
+ 	{
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		assertActions(">T:frost nova>S:flee");
+	}
+
+    void stress()
+    {
+        runStressTest();
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ArcaneMageTestCase );
diff --git a/src/test/BearTankDruidTestCase.cpp b/src/test/BearTankDruidTestCase.cpp
new file mode 100644
index 0000000..2da7966
--- /dev/null
+++ b/src/test/BearTankDruidTestCase.cpp
@@ -0,0 +1,223 @@
+#include "pch.h"
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+class BearTankDruidTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( BearTankDruidTestCase );
+        CPPUNIT_TEST( startMeleeCombat );
+        CPPUNIT_TEST( meleeCombat );
+        CPPUNIT_TEST( druidMustHoldAggro );
+        CPPUNIT_TEST( bearFormIfDireNotAvailable );
+        CPPUNIT_TEST( healHimself );
+        CPPUNIT_TEST( intensiveHealing );
+        CPPUNIT_TEST( healOthers );
+        CPPUNIT_TEST( curePoison );
+        CPPUNIT_TEST( interruptSpells );
+        CPPUNIT_TEST( buff );
+        CPPUNIT_TEST( aoe );
+        CPPUNIT_TEST( incompatibles );
+        CPPUNIT_TEST( interrupt_enemy_healer );
+        CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "bear", NULL);
+
+		addAura("thorns");
+        addTargetAura("faerie fire (feral)");
+        set<uint8>("rage", "self target", 100);
+    }
+
+protected:
+    void bearFormIfDireNotAvailable()
+    {
+		tickWithSpellUnavailable("dire bear form");
+
+		assertActions(">S:bear form");
+    }
+
+    void druidMustHoldAggro()
+    {
+        addAura("dire bear form");
+
+		tickWithNoAggro();
+
+		assertActions(">T:growl");
+    }
+
+    void startMeleeCombat()
+    {
+        removeTargetAura("faerie fire (feral)");
+
+        tick();
+        addAura("dire bear form");
+
+        tick();
+        tickInMeleeRange();
+
+        tickOutOfMeleeRange();
+        tickInMeleeRange();
+
+        assertActions(">S:dire bear form>T:feral charge - bear>T:faerie fire (feral)>T:reach melee>T:lacerate");
+    }
+
+    void meleeCombat()
+    {
+        addAura("dire bear form");
+
+        tickInMeleeRange();
+		tick();
+		tick();
+		tick();
+
+		tickWithSpellAvailable("lacerate");
+		tick();
+		tickWithSpellAvailable("lacerate");
+        tick();
+
+        spellAvailable("lacerate");
+        spellAvailable("mangle (bear)");
+        spellAvailable("maul");
+        spellAvailable("faerie fire (feral)");
+
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+
+        assertActions(">T:lacerate>T:mangle (bear)>T:maul>T:feral charge - bear>T:faerie fire (feral)>T:melee>T:lacerate>T:melee>T:faerie fire (feral)>T:lacerate>T:mangle (bear)>T:maul>T:melee>T:lacerate");
+    }
+
+    void healHimself()
+    {
+        addAura("dire bear form");
+
+		tickWithLowHealth(59);
+		tickWithLowHealth(59);
+
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+        addAura("dire bear form");
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">T:reach melee>T:lacerate>S:caster form>S:regrowth>S:survival instincts>S:barskin>S:caster form>S:regrowth>S:healing touch");
+    }
+
+    void intensiveHealing()
+    {
+        addAura("dire bear form");
+		tickWithLowHealth(1);
+
+		assertActions(">S:survival instincts");
+    }
+
+    void healOthers()
+    {
+        tick();
+        addAura("dire bear form");
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("dire bear form");
+        tickWithPartyLowHealth(39);
+        tickWithPartyLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("dire bear form");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+		assertActions(">S:dire bear form>S:caster form>P:regrowth on party>S:caster form>P:regrowth on party>P:healing touch on party");
+    }
+    void curePoison()
+    {
+        tick();
+        addAura("dire bear form");
+
+		tickWithAuraToDispel(DISPEL_POISON);
+		tickWithAuraToDispel(DISPEL_POISON);
+
+		spellAvailable("abolish poison");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+
+		tickWithAuraToDispel(DISPEL_POISON);
+
+		spellAvailable("cure poison");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+
+		assertActions(">S:dire bear form>S:caster form>S:abolish poison>P:abolish poison on party>S:cure poison>P:cure poison on party");
+    }
+    void interruptSpells()
+    {
+        addAura("dire bear form");
+        tickInMeleeRange();
+		tickWithTargetIsCastingNonMeleeSpell();
+
+        assertActions(">T:lacerate>T:bash");
+    }
+	void buff()
+	{
+        removeAura("thorns");
+        tick();
+
+        removeTargetAura("faerie fire (feral)");
+        tickInMeleeRange();
+		addAura("dire bear form");
+
+        assertActions(">S:thorns>S:dire bear form");
+	}
+
+    void aoe()
+    {
+        addAura("dire bear form");
+		tickInMeleeRange();
+		tickWithAttackerCount(2);
+		tickWithAttackerCount(3);
+        spellAvailable("swipe (bear)");
+		tickWithAttackerCount(3);
+
+		assertActions(">T:lacerate>T:swipe (bear)>T:demoralizing roar>T:swipe (bear)");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("bear", "cat", "caster", "dps", "tank", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: bear");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("bash");
+        assertActions(">H:bash on enemy healer");
+    }
+
+    void stress()
+    {
+        addAura("dire bear form");
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( BearTankDruidTestCase );
diff --git a/src/test/CMakeLists.txt b/src/test/CMakeLists.txt
new file mode 100644
index 0000000..4e7ee10
--- /dev/null
+++ b/src/test/CMakeLists.txt
@@ -0,0 +1,177 @@
+# Copyright (C) 2008-2014 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+file(GLOB_RECURSE sources_cppunit cppunit/*.cpp cppunit/*.h)
+file(GLOB_RECURSE sources_efficiency efficiency/*.cpp efficiency/*.h)
+file(GLOB_RECURSE sources_main *.cpp *.h)
+
+# Create game-libary
+
+if (USE_COREPCH)
+  set(tests_STAT_PCH_HDR pch.h)
+  set(tests_STAT_PCH_SRC pch.cpp)
+endif ()
+
+set(tests_STAT_SRCS
+  ${tests_STAT_SRCS}
+  ${sources_cppunit}
+  ${sources_efficiency}
+  ${sources_main}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour/Include
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast/Include
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/dep/cppformat
+  ${CMAKE_SOURCE_DIR}/src/common
+  ${CMAKE_SOURCE_DIR}/src/common/Collision
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Management
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Models
+  ${CMAKE_SOURCE_DIR}/src/common/Configuration
+  ${CMAKE_SOURCE_DIR}/src/common/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/common/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/common/Debugging
+  ${CMAKE_SOURCE_DIR}/src/common/Logging
+  ${CMAKE_SOURCE_DIR}/src/common/Threading
+  ${CMAKE_SOURCE_DIR}/src/common/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/server/database
+  ${CMAKE_SOURCE_DIR}/src/server/database/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Networking
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_SOURCE_DIR}/src/test
+  ${CMAKE_SOURCE_DIR}/src/test/cppunit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/DungeonFinding
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Corpse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/DynamicObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Totem
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Transport
+  ${CMAKE_SOURCE_DIR}/src/server/game/Events
+  ${CMAKE_SOURCE_DIR}/src/server/game/Globals
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
+  ${CMAKE_SOURCE_DIR}/src/server/game/Guilds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Instances
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Mails
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/MovementGenerators
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/game/Pools
+  ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/game/Quests
+  ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
+  ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Skills
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden/Modules
+  ${CMAKE_SOURCE_DIR}/src/server/game/Weather
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/game/Playerbot
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${MYSQL_INCLUDE_DIR}
+  ${OPENSSL_INCLUDE_DIR}
+  ${CMAKE_SOURCE_DIR}/src/test/cppunit
+)
+
+add_executable(tests
+  ${tests_STAT_SRCS}
+  ${tests_STAT_PCH_SRC}
+)
+
+target_link_libraries(tests
+  game
+  plugins
+  common
+  shared
+  database
+  scripts
+  g3dlib
+  gsoap
+  Detour
+  format
+  ${JEMALLOC_LIBRARY}
+  ${READLINE_LIBRARY}
+  ${TERMCAP_LIBRARY}
+  ${MYSQL_LIBRARY}
+  ${OPENSSL_LIBRARIES}
+  ${ZLIB_LIBRARIES}
+  ${CMAKE_THREAD_LIBS_INIT}
+  ${Boost_LIBRARIES}
+)
+
+# Generate precompiled header
+if (USE_COREPCH)
+  add_cxx_pch(tests ${tests_STAT_PCH_HDR} ${tests_STAT_PCH_SRC})
+endif ()
diff --git a/src/test/CasterDruidTestCase.cpp b/src/test/CasterDruidTestCase.cpp
new file mode 100644
index 0000000..e529a04
--- /dev/null
+++ b/src/test/CasterDruidTestCase.cpp
@@ -0,0 +1,166 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+
+class CasterDruidTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( CasterDruidTestCase );
+    CPPUNIT_TEST( combat);
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( healOthers );
+	CPPUNIT_TEST( curePoison );
+	CPPUNIT_TEST( resurrect );
+    CPPUNIT_TEST( cc );
+	CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "caster", "caster debuff", NULL);
+
+		addAura("moonkin form");
+    }
+
+protected:
+    void combat()
+    {
+		removeAura("moonkin form");
+		tick();
+		addAura("moonkin form");
+
+		tickOutOfSpellRange();
+
+		tickInSpellRange();
+		addTargetAura("faerie fire");
+
+		tick();
+		addTargetAura("insect swarm");
+
+		tick();
+		addTargetAura("moonfire");
+
+        tick();
+		tick();
+
+		spellAvailable("starfire");
+		tickInSpellRange();
+
+        tickWithBalancePercent(49);
+
+        spellAvailable("starfire");
+        spellAvailable("wrath");
+        addAura("eclipse (lunar)");
+        tick();
+
+        addAura("eclipse (solar)");
+        tick();
+
+		assertActions(">S:moonkin form>T:reach spell>T:faerie fire>T:insect swarm>T:moonfire>T:starfire>T:wrath>T:starfire>S:nature's grasp>T:starfire>T:wrath");
+    }
+
+	void healHimself()
+    {
+		tickWithLowHealth(79);
+		tickWithLowHealth(79);
+        addAura("moonkin form");
+        spellAvailable("rejuvenation");
+
+		tickWithLowHealth(59);
+		tickWithLowHealth(59);
+		tickWithLowHealth(59);
+
+		addAura("moonkin form");
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">S:caster form>S:rejuvenation>S:caster form>S:regrowth>S:healing touch>S:caster form>S:regrowth>S:regrowth>S:healing touch");
+    }
+
+	void healOthers()
+    {
+        addAura("moonkin form");
+
+        tickWithPartyLowHealth(79);
+        tickWithPartyLowHealth(79);
+        addAura("moonkin form");
+        spellAvailable("rejuvenation");
+
+        tickWithPartyLowHealth(59);
+        tickWithPartyLowHealth(59);
+        tickWithPartyLowHealth(59);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("dire bear form");
+        tickWithPartyLowHealth(39);
+        tickWithPartyLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("moonkin form");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+        assertActions(">S:caster form>P:rejuvenation on party>S:caster form>P:regrowth on party>P:healing touch on party>S:caster form>P:regrowth on party>S:caster form>P:regrowth on party>P:healing touch on party");
+    }
+
+	void curePoison()
+	{
+		tickWithAuraToDispel(DISPEL_POISON);
+
+		spellAvailable("abolish poison");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+
+		tickWithAuraToDispel(DISPEL_POISON);
+
+		spellAvailable("cure poison");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+
+		assertActions(">S:abolish poison>P:abolish poison on party>S:cure poison>P:cure poison on party");
+	}
+
+	void resurrect()
+	{
+		tickWithDeadPartyMember();
+		tickWithDeadPartyMember();
+
+		assertActions(">S:caster form>P:rebirth");
+	}
+
+    void cc()
+    {
+        tickWithCcTarget("entangling roots");
+
+        assertActions(">Cc:entangling roots on cc");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("caster aoe");
+        tickWithAttackerCount(4);
+        tickWithAttackerCount(4);
+
+		assertActions(">T:starfall>T:hurricane");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( CasterDruidTestCase );
diff --git a/src/test/CasterShamanTestCase.cpp b/src/test/CasterShamanTestCase.cpp
new file mode 100644
index 0000000..12912aa
--- /dev/null
+++ b/src/test/CasterShamanTestCase.cpp
@@ -0,0 +1,86 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+
+using namespace ai;
+
+
+class CasterShamanTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( CasterShamanTestCase );
+    CPPUNIT_TEST( combat );
+	CPPUNIT_TEST( buff );
+	CPPUNIT_TEST( incompatibles );
+    CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST( snare );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new ShamanAiObjectContext(ai), "caster", NULL);
+
+        addAura("water shield");
+        addTargetAura("earth shock");
+    }
+
+protected:
+    void combat()
+    {
+        removeTargetAura("earth shock");
+
+		tick();
+        tick();
+        addTargetAura("flame shock");
+
+		tick();
+		tick();
+
+        assertActions(">T:earth shock>T:flame shock>S:searing totem>T:lightning bolt");
+    }
+
+    void buff()
+    {
+        engine->addStrategy("bmana");
+        removeAura("water shield");
+
+        tickWithItemForSpell("flametongue weapon");
+
+        tick();
+        addAura("water shield");
+
+        assertActions(">S:flametongue weapon>S:water shield");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("melee", "dps", "heal", "caster", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: caster");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("caster aoe");
+
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+
+        assertActions(">S:flametongue totem>T:reach melee>S:magma totem>T:thunderstorm>T:fire nova>T:chain lightning");
+    }
+
+    void snare()
+    {
+        tickWithTargetIsMoving();
+
+        assertActions(">T:frost shock");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( CasterShamanTestCase );
diff --git a/src/test/CatDpsDruidTestCase.cpp b/src/test/CatDpsDruidTestCase.cpp
new file mode 100644
index 0000000..7dc78b7
--- /dev/null
+++ b/src/test/CatDpsDruidTestCase.cpp
@@ -0,0 +1,140 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+
+class CatDpsDruidTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( CatDpsDruidTestCase );
+    CPPUNIT_TEST( combatVsMelee );
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( intensiveHealing );
+    CPPUNIT_TEST( healOthers );
+    CPPUNIT_TEST( boost );
+    CPPUNIT_TEST( cower );
+    CPPUNIT_TEST( buff );
+	CPPUNIT_TEST( aoe );
+	CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "cat", NULL);
+
+		addAura("cat form");
+        addAura("thorns");
+		addTargetAura("faerie fire (feral)");
+    }
+
+protected:
+
+    void combatVsMelee()
+    {
+		tickInMeleeRange();
+
+		tick();
+
+        tickWithComboPoints(5);
+        tickWithComboPoints(5);
+
+		assertActions(">T:rake>T:mangle (cat)>T:ferocious bite>T:rip");
+    }
+
+	void healHimself()
+	{
+		addAura("cat form");
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">S:caster form>S:regrowth>S:survival instincts>S:barskin>S:regrowth>S:healing touch");
+	}
+
+    void intensiveHealing()
+    {
+		tickWithLowHealth(1);
+
+		assertActions(">S:survival instincts");
+    }
+
+    void healOthers()
+    {
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("dire bear form");
+        tickWithPartyLowHealth(39);
+        tickWithPartyLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("cat form");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+        assertActions(">S:caster form>P:regrowth on party>S:caster form>P:regrowth on party>P:healing touch on party");
+    }
+
+    void boost()
+    {
+		tickWithBalancePercent(49);
+
+		assertActions(">S:tiger's fury");
+    }
+
+    void cower()
+    {
+		tickWithMyAttackerCount(2);
+
+		assertActions(">S:cower");
+    }
+
+    void buff()
+    {
+        removeAura("cat form");
+        removeAura("thorns");
+        tick();
+        addAura("cat form");
+
+        removeTargetAura("faerie fire (feral)");
+        tickInMeleeRange();
+
+        assertActions(">S:cat form>T:faerie fire (feral)");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("cat aoe");
+
+		tickInMeleeRange();
+		tickWithAttackerCount(3);
+
+		assertActions(">T:rake>T:swipe (cat)");
+    }
+
+    void stress()
+    {
+        addAura("cat form");
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( CatDpsDruidTestCase );
diff --git a/src/test/ChatCommandTestCase.cpp b/src/test/ChatCommandTestCase.cpp
new file mode 100644
index 0000000..45e25c4
--- /dev/null
+++ b/src/test/ChatCommandTestCase.cpp
@@ -0,0 +1,454 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class ChatCommandTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( ChatCommandTestCase );
+      CPPUNIT_TEST( stats );
+      CPPUNIT_TEST( leave );
+      CPPUNIT_TEST( quests );
+      CPPUNIT_TEST( reputation );
+      CPPUNIT_TEST( log );
+      CPPUNIT_TEST( los );
+      CPPUNIT_TEST( drop );
+      CPPUNIT_TEST( query );
+      CPPUNIT_TEST( ll );
+      CPPUNIT_TEST( loot_all );
+      CPPUNIT_TEST( release );
+      CPPUNIT_TEST( teleport );
+      CPPUNIT_TEST( taxi );
+      CPPUNIT_TEST( repair );
+      CPPUNIT_TEST( use );
+      CPPUNIT_TEST( item_count );
+      CPPUNIT_TEST( reward );
+      CPPUNIT_TEST( trade );
+      CPPUNIT_TEST( equip );
+      CPPUNIT_TEST( unequip );
+      CPPUNIT_TEST( sell );
+      CPPUNIT_TEST( buy );
+      CPPUNIT_TEST( talents );
+      CPPUNIT_TEST( spells );
+      CPPUNIT_TEST( strategy );
+      CPPUNIT_TEST( trainer );
+      CPPUNIT_TEST( attack );
+      CPPUNIT_TEST( chat );
+      CPPUNIT_TEST( accept );
+      CPPUNIT_TEST( home );
+      CPPUNIT_TEST( destroy );
+      CPPUNIT_TEST( reset_ai );
+      CPPUNIT_TEST( emote );
+      CPPUNIT_TEST( buff );
+      CPPUNIT_TEST( help );
+      CPPUNIT_TEST( gb );
+      CPPUNIT_TEST( bank );
+      CPPUNIT_TEST( follow );
+      CPPUNIT_TEST( flee );
+      CPPUNIT_TEST( stay );
+      CPPUNIT_TEST( grind );
+      CPPUNIT_TEST( tank_attack );
+      CPPUNIT_TEST( talk );
+      CPPUNIT_TEST( cast );
+      CPPUNIT_TEST( invite );
+      CPPUNIT_TEST( spell );
+      CPPUNIT_TEST( rti );
+      CPPUNIT_TEST( revive );
+      CPPUNIT_TEST( runaway );
+      CPPUNIT_TEST( warning );
+      CPPUNIT_TEST( position );
+      CPPUNIT_TEST( summon );
+      CPPUNIT_TEST( who );
+      CPPUNIT_TEST( save_mana );
+      CPPUNIT_TEST( max_dps );
+      CPPUNIT_TEST( tell_attackers );
+      CPPUNIT_TEST( formation );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "chat", NULL);
+    }
+
+protected:
+ 	void stats()
+	{
+        assertCommand("stats");
+	}
+
+    void leave()
+    {
+        assertCommand("leave");
+    }
+
+    void reputation()
+    {
+        assertCommand("rep", "reputation");
+        assertCommand("reputation");
+    }
+
+    void quests()
+    {
+        assertCommand("quests");
+        assertParametrizedCommand("quests", "summary");
+        assertParametrizedCommand("quests", "completed");
+        assertParametrizedCommand("quests", "incompleted");
+    }
+
+    void log()
+    {
+        assertCommand("log");
+        assertParametrizedCommand("log", "debug");
+    }
+
+    void los()
+    {
+        assertCommand("los");
+        assertParametrizedCommand("los", "targets");
+        assertParametrizedCommand("los", "npcs");
+        assertParametrizedCommand("los", "gos");
+        assertParametrizedCommand("los", "game objects");
+        assertParametrizedCommand("los", "corpses");
+    }
+
+    void drop()
+    {
+        assertCommand("drop");
+    }
+
+    void query()
+    {
+        trigger("q");
+        tick();
+        tick();
+
+        assertActions(">S:query quest>S:query item usage");
+    }
+
+    void ll()
+    {
+        assertCommand("ll");
+        assertParametrizedCommand("ll", "?");
+        assertParametrizedCommand("ll", "[item]");
+        assertParametrizedCommand("ll", "-[item]");
+        assertParametrizedCommand("ll", "all");
+    }
+
+    void loot_all()
+    {
+        trigger("add all loot");
+        tick();
+        tick();
+
+        assertActions(">S:add all loot>S:loot");
+    }
+
+    void release()
+    {
+        assertCommand("release");
+    }
+
+    void teleport()
+    {
+        assertCommand("teleport");
+    }
+
+    void taxi()
+    {
+        assertCommand("taxi");
+    }
+
+    void repair()
+    {
+        assertCommand("repair");
+    }
+
+    void use()
+    {
+        trigger("u");
+        tick();
+
+        assertActions(">S:use");
+    }
+
+    void item_count()
+    {
+        trigger("c");
+        tick();
+
+        assertActions(">S:item count");
+    }
+
+    void reward()
+    {
+        trigger("r");
+        tick();
+
+        assertActions(">S:reward");
+    }
+    void trade()
+    {
+        trigger("t");
+        tick();
+        trigger("nt");
+        tick();
+
+        assertActions(">S:trade>S:trade");
+    }
+    void sell()
+    {
+        trigger("s");
+        tick();
+
+        assertActions(">S:sell");
+    }
+    void buy()
+    {
+        trigger("b");
+        tick();
+
+        assertActions(">S:buy");
+    }
+    void equip()
+    {
+        trigger("e");
+        tick();
+
+        assertActions(">S:equip");
+    }
+    void unequip()
+    {
+        trigger("ue");
+        tick();
+
+        assertActions(">S:unequip");
+    }
+
+    void talents()
+    {
+        assertParametrizedCommand("talents", "1");
+        assertParametrizedCommand("talents", "2");
+    }
+
+    void spells()
+    {
+        assertCommand("spells");
+    }
+
+    void strategy()
+    {
+        assertParametrizedCommand("co", "?");
+        assertParametrizedCommand("nc", "?");
+        assertParametrizedCommand("dead", "?");
+    }
+
+    void trainer()
+    {
+        assertParametrizedCommand("trainer", "?");
+        assertParametrizedCommand("trainer", "learn");
+    }
+
+    void attack()
+    {
+        trigger("attack");
+        tick();
+        assertActions(">S:attack my target");
+    }
+
+    void chat()
+    {
+        assertParametrizedCommand("chat", "?");
+        assertParametrizedCommand("chat", "raid");
+    }
+
+    void accept()
+    {
+        trigger("accept");
+        tick();
+        assertActions(">S:accept quest");
+    }
+
+    void home()
+    {
+        assertCommand("home");
+    }
+
+    void reset_ai()
+    {
+        assertCommand("reset ai");
+    }
+
+    void destroy()
+    {
+        assertCommand("destroy");
+    }
+
+    void emote()
+    {
+        assertCommand("emote");
+    }
+
+    void buff()
+    {
+        assertCommand("buff");
+        assertParametrizedCommand("buff", "?");
+    }
+
+    void help()
+    {
+        assertCommand("help");
+    }
+
+    void follow()
+    {
+        trigger("follow");
+        tick();
+        assertActions(">S:follow chat shortcut");
+    }
+
+    void stay()
+    {
+        trigger("stay");
+        tick();
+        assertActions(">S:stay chat shortcut");
+    }
+
+    void flee()
+    {
+        trigger("flee");
+        tick();
+        assertActions(">S:flee chat shortcut");
+    }
+
+    void grind()
+    {
+        trigger("grind");
+        tick();
+        assertActions(">S:grind chat shortcut");
+    }
+
+    void tank_attack()
+    {
+        trigger("tank attack");
+        tick();
+        tick();
+        assertActions(">S:tank attack chat shortcut>S:attack my target");
+    }
+
+    void gb()
+    {
+        assertParametrizedCommand("gb", "link");
+    }
+
+    void bank()
+    {
+        assertParametrizedCommand("bank", "link");
+    }
+
+    void talk()
+    {
+        trigger("talk");
+        tick();
+        assertActions(">S:gossip hello");
+    }
+
+    void cast()
+    {
+        trigger("cast");
+        tick();
+        assertActions(">S:cast custom spell");
+    }
+
+    void invite()
+    {
+        trigger("invite");
+        tick();
+        assertActions(">S:invite");
+    }
+
+    void spell()
+    {
+        trigger("spell");
+        tick();
+        assertActions(">S:spell");
+    }
+
+    void rti()
+    {
+        trigger("rti");
+        tick();
+        assertActions(">S:rti");
+    }
+
+    void revive()
+    {
+        trigger("revive");
+        tick();
+        assertActions(">S:spirit healer");
+    }
+
+    void runaway()
+    {
+        trigger("runaway");
+        tick();
+        assertActions(">S:runaway chat shortcut");
+    }
+
+    void warning()
+    {
+        trigger("warning");
+        tick();
+        assertActions(">S:runaway chat shortcut");
+    }
+
+    void position()
+    {
+        assertParametrizedCommand("position", "guard");
+    }
+
+    void summon()
+    {
+        assertParametrizedCommand("summon", "summon");
+    }
+
+    void who()
+    {
+        assertCommand("who", "who");
+    }
+
+    void save_mana()
+    {
+        assertParametrizedCommand("save mana", "save mana");
+    }
+
+    void max_dps()
+    {
+        trigger("max dps");
+        tick();
+        assertActions(">S:max dps chat shortcut");
+    }
+
+    void tell_attackers()
+    {
+        trigger("attackers");
+        tick();
+        assertActions(">S:tell attackers");
+    }
+
+    void formation()
+    {
+        trigger("formation");
+        tick();
+        assertActions(">S:formation");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ChatCommandTestCase );
diff --git a/src/test/ChatFilterTestCase.cpp b/src/test/ChatFilterTestCase.cpp
new file mode 100644
index 0000000..83e9604
--- /dev/null
+++ b/src/test/ChatFilterTestCase.cpp
@@ -0,0 +1,32 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/ChatFilter.h"
+
+using namespace ai;
+
+class ChatFilterTestCase : public CPPUNIT_NS::TestFixture
+{
+public:
+	ChatFilterTestCase() : filter(NULL) {}
+
+  CPPUNIT_TEST_SUITE( ChatFilterTestCase );
+      CPPUNIT_TEST( filter1 );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	ChatFilter filter;
+
+	void filter1()
+	{
+	    string message = filter.Filter("@some message for some");
+	    CPPUNIT_ASSERT(message == "message for some");
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ChatFilterTestCase );
diff --git a/src/test/DpsHunterEngineTestCase.cpp b/src/test/DpsHunterEngineTestCase.cpp
new file mode 100644
index 0000000..7ab4a70
--- /dev/null
+++ b/src/test/DpsHunterEngineTestCase.cpp
@@ -0,0 +1,166 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/hunter/HunterAiObjectContext.h"
+
+using namespace ai;
+
+class DpsHunterEngineTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( DpsHunterEngineTestCase );
+  CPPUNIT_TEST( combatVsMelee );
+  CPPUNIT_TEST( summonPet );
+  CPPUNIT_TEST( lowMana );
+  CPPUNIT_TEST( boost );
+  CPPUNIT_TEST( cc );
+  CPPUNIT_TEST( aoe );
+  CPPUNIT_TEST( buff );
+  CPPUNIT_TEST( incompatibles );
+  CPPUNIT_TEST( feign_death );
+  CPPUNIT_TEST( stress );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new HunterAiObjectContext(ai), "dps", "dps debuff", NULL);
+		engine->addStrategy("bdps");
+
+        addAura("aspect of the hawk");
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+        removeAura("aspect of the hawk");
+
+		tick();
+        addAura("aspect of the hawk");
+
+		tick();
+        tick();
+		tick();
+		addTargetAura("serpent sting");
+
+		tick();
+		tick();
+
+		tickInMeleeRange();
+		spellAvailable("wing clip");
+		addTargetAura("wing clip");
+		tickInMeleeRange();
+		tickInSpellRange();
+
+		// resetSpells
+		tickWithSpellUnavailable("aimed shot");
+
+        tick();
+        tick();
+		tickWithSpellAvailable("auto shot");
+
+		assertActions(">S:aspect of the hawk>T:hunter's mark>T:black arrow>T:serpent sting>T:explosive shot>T:auto shot>T:wing clip>S:flee>T:concussive shot>T:wyvern sting>T:chimera shot>T:auto shot>T:arcane shot");
+
+	}
+
+    void lowMana()
+    {
+        spellUnavailable("serpent sting");
+        spellUnavailable("concussive shot");
+        removeAura("aspect of the hawk");
+
+		tickWithLowMana(30);
+
+		tick();
+
+		assertActions(">T:viper sting>S:aspect of the hawk");
+
+    }
+
+    void summonPet()
+    {
+        tickWithNoPet();
+		tickWithPetLowHealth(30);
+
+		assertActions(">S:call pet>Pet:mend pet");
+	}
+
+
+    void boost()
+    {
+		tick();
+        spellUnavailable("serpent sting");
+
+		tickWithBalancePercent(1);
+		tickWithBalancePercent(1);
+
+		assertActions(">T:hunter's mark>S:rapid fire>S:readiness");
+    }
+
+
+    void cc()
+    {
+        tickWithCcTarget("freezing trap");
+
+        assertActions(">Cc:freezing trap");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("aoe");
+
+		addTargetAura("hunter's mark");
+		addTargetAura("black arrow");
+		addTargetAura("serpent sting");
+        tickWithAttackerCount(3);
+		tickWithAttackerCount(4);
+
+        set<Unit*>("attacker without aura", "serpent sting", MockedTargets::GetAttackerWithoutAura());
+        tick();
+
+        set<Unit*>("attacker without aura", "serpent sting", NULL);
+        tick();
+
+		assertActions(">T:multi-shot>T:volley>A:serpent sting on attacker>T:explosive shot");
+    }
+
+	void buff()
+	{
+		engine->removeStrategy("bdps");
+		engine->addStrategy("rnature");
+		removeAura("aspect of the hawk");
+
+		tick();
+		addAura("aspect of the wild");
+
+		assertActions(">S:aspect of the wild");
+
+	}
+
+    void incompatibles()
+    {
+        engine->removeStrategy("dps");
+        engine->removeStrategy("dps debuff");
+        engine->addStrategies("bdps", "bspeed", "rnature", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: rnature");
+    }
+
+    void feign_death()
+    {
+        tick();
+
+        tickWithMyAttackerCount(3);
+        set<float>("distance", "current target", 5);
+        tickWithMyAttackerCount(3);
+
+        assertActions(">T:hunter's mark>S:feign death>S:flee");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsHunterEngineTestCase );
diff --git a/src/test/DpsPaladinTestCase.cpp b/src/test/DpsPaladinTestCase.cpp
new file mode 100644
index 0000000..7621946
--- /dev/null
+++ b/src/test/DpsPaladinTestCase.cpp
@@ -0,0 +1,79 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsPaladinTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DpsPaladinTestCase );
+    CPPUNIT_TEST( buff );
+	CPPUNIT_TEST( combatVsMelee );
+	CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+	virtual void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new PaladinAiObjectContext(ai), "dps", NULL);
+		engine->addStrategy("bdps");
+
+        addAura("retribution aura");
+        addAura("seal of vengeance");
+        addAura("blessing of might");
+
+        set<float>("distance", "current target", 0.0f);
+    }
+
+protected:
+    void buff()
+    {
+        removeAura("retribution aura");
+        removeAura("blessing of might");
+        removeAura("seal of vengeance");
+        removeAura("holy shield");
+
+        tick();
+        addAura("devotion aura");
+
+        tick();
+        tick();
+        tick();
+        tick();
+        addAura("seal of wisdom");
+
+        tick();
+        tick();
+        addAura("blessing of kings");
+
+        assertActions(">S:retribution aura>S:seal of vengeance>S:seal of command>S:seal of wisdom>S:seal of justice>S:blessing of might>S:blessing of kings");
+    }
+
+    void combatVsMelee()
+    {
+		tickOutOfMeleeRange();
+
+        tick();
+		tick();
+		addTargetAura("judgement of wisdom");
+
+		tick();
+
+		tickWithAttackerCount(3);
+		tickWithAttackerCount(3);
+
+		tickWithTargetLowHealth(19);
+
+		assertActions(">T:reach melee>T:judgement of wisdom>T:judgement of light>T:crusader strike>S:divine storm>T:consecration>T:hammer of wrath");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsPaladinTestCase );
diff --git a/src/test/DpsPriestTestCase.cpp b/src/test/DpsPriestTestCase.cpp
new file mode 100644
index 0000000..4f9c1a0
--- /dev/null
+++ b/src/test/DpsPriestTestCase.cpp
@@ -0,0 +1,95 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsPriestTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DpsPriestTestCase );
+    CPPUNIT_TEST( combat );
+    CPPUNIT_TEST( low_mana );
+    CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PriestAiObjectContext(ai), "dps", "dps debuff", NULL);
+
+        addAura("power word: fortitude");
+        addAura("divine spirit");
+        addAura("inner fire");
+        addPartyAura("power word: fortitude");
+        addPartyAura("divine spirit");
+    }
+
+protected:
+    void combat()
+    {
+        tick();
+        addAura("vampiric embrace");
+
+        tick();
+        addAura("shadowform");
+
+        tick();
+        tick();
+        tick();
+        tick();
+        tick();
+        tick();
+
+        tickWithLowHealth(39);
+        tickWithLowHealth(39);
+        tickWithLowHealth(39);
+
+        spellAvailable("power word: shield");
+        spellAvailable("greater heal");
+        addAura("shadowform");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">S:vampiric embrace>S:shadowform>T:devouring plague>T:shadow word: pain>T:vampiric touch>T:mind blast>T:mind flay>T:shoot>S:remove shadowform>S:power word: shield>S:greater heal>S:remove shadowform>S:power word: shield>S:flash heal");
+    }
+
+    void low_mana()
+    {
+        tickWithLowMana(1);
+
+        assertActions(">S:dispersion");
+    }
+
+    void aoe()
+    {
+        addAura("vampiric embrace");
+        addAura("shadowform");
+        addTargetAura("devouring plague");
+        addTargetAura("shadow word: pain");
+        addTargetAura("vampiric touch");
+
+        engine->addStrategy("aoe");
+
+        set<Unit*>("attacker without aura", "shadow word: pain", MockedTargets::GetAttackerWithoutAura());
+        tick();
+
+        set<Unit*>("attacker without aura", "shadow word: pain", NULL);
+        tick();
+
+        assertActions(">A:shadow word: pain on attacker>T:mind blast");
+    }
+
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsPriestTestCase );
diff --git a/src/test/DpsRogueTestCase.cpp b/src/test/DpsRogueTestCase.cpp
new file mode 100644
index 0000000..9e311f7
--- /dev/null
+++ b/src/test/DpsRogueTestCase.cpp
@@ -0,0 +1,80 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/rogue/RogueAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsRogueTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DpsRogueTestCase );
+		CPPUNIT_TEST( combatVsMelee );
+		CPPUNIT_TEST( healHimself );
+		CPPUNIT_TEST( interruptSpells );
+		CPPUNIT_TEST( interrupt_enemy_healer );
+		CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new RogueAiObjectContext(ai), "dps", NULL);
+        addAura("slice and dice");
+        addTargetAura("rupture");
+    }
+
+protected:
+    void combatVsMelee()
+    {
+        removeTargetAura("rupture");
+
+		tickOutOfMeleeRange();
+		tickInMeleeRange();
+		tick();
+
+		tickWithEnergy(70);
+        tickWithEnergy(70);
+
+        tickWithComboPoints(5);
+        tickWithComboPoints(5);
+
+        tickBehindTarget();
+
+        assertActions(">T:reach melee>T:riposte>T:mutilate>T:sinister strike>T:melee>T:rupture>T:eviscerate>T:backstab");
+    }
+
+	void healHimself()
+	{
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithMyAttackerCount(3);
+
+		assertActions(">S:evasion>S:feint>S:vanish");
+	}
+
+	void interruptSpells()
+	{
+        tickInMeleeRange();
+
+		tickWithTargetIsCastingNonMeleeSpell();
+		tickWithTargetIsCastingNonMeleeSpell();
+
+		assertActions(">T:riposte>T:kick>T:kidney shot");
+	}
+
+	void interrupt_enemy_healer()
+	{
+	    tickWithEnemyHealerIsCastingInterruptableSpell("kick");
+
+		assertActions(">H:kick on enemy healer");
+	}
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsRogueTestCase );
diff --git a/src/test/DpsWarlockTestCase.cpp b/src/test/DpsWarlockTestCase.cpp
new file mode 100644
index 0000000..1e18907
--- /dev/null
+++ b/src/test/DpsWarlockTestCase.cpp
@@ -0,0 +1,99 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsWarlockTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( DpsWarlockTestCase );
+      CPPUNIT_TEST( combatVsMelee );
+      CPPUNIT_TEST( aoe );
+      CPPUNIT_TEST( low_mana );
+      CPPUNIT_TEST( cc );
+      CPPUNIT_TEST( stress );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarlockAiObjectContext(ai), "dps", "dps debuff", NULL);
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+ 	    tick();
+ 	    addTargetAura("immolate");
+
+ 	    tick();
+
+        tick();
+        addTargetAura("corruption");
+        tick();
+        addTargetAura("curse of agony");
+
+        tick();
+
+        tickWithLowHealth(49);
+
+        tick();
+
+		tickWithTargetLowHealth(19);
+
+        set<uint8>("item count", "soul shard", 2);
+		spellAvailable("drain soul");
+		tick();
+
+		spellAvailable("shadow bolt");
+		addAura("shadow trance");
+		tick();
+
+        spellAvailable("shadow bolt");
+		addAura("backlash");
+		tick();
+
+		assertActions(">T:immolate>T:conflagrate>T:corruption>T:curse of agony>T:incinirate>T:drain life>T:shadow bolt>T:drain soul>T:shoot>T:shadow bolt>T:shadow bolt");
+	}
+
+    void low_mana()
+    {
+        tickWithLowMana(1);
+
+		assertActions(">S:life tap");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("aoe");
+
+        tickWithAttackerCount(2);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(4);
+
+        set<Unit*>("attacker without aura", "corruption", MockedTargets::GetAttackerWithoutAura());
+        tick();
+
+        set<Unit*>("attacker without aura", "corruption", NULL);
+        tick();
+
+		assertActions(">T:shadowfury>T:seed of corruption>T:rain of fire>A:corruption on attacker>T:immolate");
+    }
+
+    void cc()
+    {
+        tickWithCcTarget("fear");
+
+        assertActions(">Cc:fear on cc");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsWarlockTestCase );
diff --git a/src/test/DpsWarriorTestCase.cpp b/src/test/DpsWarriorTestCase.cpp
new file mode 100644
index 0000000..f89fc70
--- /dev/null
+++ b/src/test/DpsWarriorTestCase.cpp
@@ -0,0 +1,133 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsWarriorTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DpsWarriorTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( combatVsMelee );
+    CPPUNIT_TEST( boost );
+    CPPUNIT_TEST( execute );
+    CPPUNIT_TEST( hamstring );
+	CPPUNIT_TEST( victoryRush );
+	CPPUNIT_TEST( aoe );
+	CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarriorAiObjectContext(ai), "dps", NULL);
+
+		spellUnavailable("revenge");
+        addAura("battle shout");
+        set<uint8>("rage", "self target", 20);
+    }
+
+protected:
+    void buff()
+    {
+        removeAura("battle shout");
+
+        tickInSpellRange(); // reach melee
+		tickInMeleeRange();
+        tick();
+
+		assertActions(">S:battle shout>S:battle stance>T:charge");
+
+    }
+
+    void combatVsMelee()
+    {
+		tickInSpellRange();
+		tickInSpellRange();
+
+		tickInMeleeRange();
+
+		tickInSpellRange();
+
+		tickInMeleeRange();
+
+        tick();
+        addTargetAura("rend");
+
+        tick();
+
+        set<uint8>("rage", "self target", 0);
+        tick();
+
+		assertActions(">S:battle stance>T:charge>T:bloodthirst>T:reach melee>T:rend>T:heroic strike>T:melee>S:bloodrage");
+    }
+
+    void boost()
+    {
+        tickInMeleeRange(); // battle stance
+
+		tickWithBalancePercent(1);
+		tickWithBalancePercent(1);
+
+		assertActions(">S:battle stance>S:death wish>S:berserker rage");
+    }
+
+    void execute()
+    {
+        tickInMeleeRange(); // battle stance
+
+		tickWithTargetLowHealth(19);
+
+		assertActions(">S:battle stance>T:execute");
+    }
+
+
+    void hamstring ()
+    {
+		tickInMeleeRange(); // reach melee
+
+		tickWithTargetIsMoving();
+
+		assertActions(">S:battle stance>T:hamstring");
+    }
+
+
+	void victoryRush()
+	{
+		tickInMeleeRange();
+		addAura("victory rush");
+
+		tick();
+
+		assertActions(">S:battle stance>T:victory rush");
+	}
+
+    void aoe()
+    {
+        engine->addStrategy("aoe");
+
+        tickInMeleeRange();
+
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+
+        set<Unit*>("attacker without aura", "rend", MockedTargets::GetAttackerWithoutAura());
+        tickInMeleeRange();
+
+        set<Unit*>("attacker without aura", "rend", NULL);
+        tickInMeleeRange();
+
+        assertActions(">S:battle stance>T:cleave>T:thunder clap>T:demoralizing shout>A:rend on attacker>T:bloodthirst");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsWarriorTestCase );
diff --git a/src/test/DruidNonCombatTestCase.cpp b/src/test/DruidNonCombatTestCase.cpp
new file mode 100644
index 0000000..29fd12c
--- /dev/null
+++ b/src/test/DruidNonCombatTestCase.cpp
@@ -0,0 +1,70 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+
+class DruidNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DruidNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( low_mana );
+	CPPUNIT_TEST( resurrect );
+	CPPUNIT_TEST( dispel );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "nc", NULL);
+    }
+
+protected:
+    void buff()
+    {
+		tick();
+		addAura("mark of the wild");
+                
+		tickWithSpellAvailable("mark of the wild");
+        
+		assertActions(">S:mark of the wild>P:mark of the wild on party");
+    }
+
+	void resurrect()
+	{
+		tickWithDeadPartyMember();
+
+		assertActions(">P:revive");
+	}
+
+	void low_mana()
+	{
+	    engine->addStrategy("flee");
+        set<uint8>("item count", "drink", 1);
+        tickWithLowMana(5);
+        tickWithLowMana(5);
+
+        set<uint8>("item count", "drink", 0);
+        tickWithLowMana(5);
+
+        assertActions(">S:innervate>S:drink>S:flee");
+    }
+
+    void dispel()
+    {
+        tickWithAuraToDispel(DISPEL_POISON);
+        tickWithAuraToDispel(DISPEL_POISON);
+
+        spellAvailable("abolish poison");
+        spellAvailable("cure poison");
+        tickWithPartyAuraToDispel(DISPEL_POISON);
+        tickWithPartyAuraToDispel(DISPEL_POISON);
+
+        assertActions(">S:abolish poison>S:cure poison>P:abolish poison on party>P:cure poison on party");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DruidNonCombatTestCase );
diff --git a/src/test/DuelTestCase.cpp b/src/test/DuelTestCase.cpp
new file mode 100644
index 0000000..f4aede4
--- /dev/null
+++ b/src/test/DuelTestCase.cpp
@@ -0,0 +1,44 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class DuelTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( DuelTestCase );
+      CPPUNIT_TEST( accept );
+      CPPUNIT_TEST( attack );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "default", "duel", NULL);
+    }
+
+protected:
+    void accept()
+    {
+        trigger("duel requested");
+        tick();
+
+        assertActions(">S:accept duel");
+    }
+    void attack()
+    {
+        trigger("no attackers");
+        context->GetValue<Unit*>("duel target")->Set(MockedTargets::GetDuelTarget());
+        tick();
+        context->GetValue<Unit*>("duel target")->Set(NULL);
+
+        assertActions(">S:attack duel opponent");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DuelTestCase );
diff --git a/src/test/EngineTestBase.cpp b/src/test/EngineTestBase.cpp
new file mode 100644
index 0000000..f2b05be
--- /dev/null
+++ b/src/test/EngineTestBase.cpp
@@ -0,0 +1,557 @@
+#include "pch.h"
+#include "aitest.h"
+#include "EngineTestBase.h"
+#include "MockedTargets.h"
+#include "AiObjectContextWrapper.h"
+
+class TestActionExecutionListener : public ActionExecutionListener
+{
+public:
+    TestActionExecutionListener(MockPlayerbotAIBase *ai) : ai(ai) {}
+
+    virtual bool Before(Action* action, Event event) { return true; }
+    virtual bool AllowExecution(Action* action, Event event) { return false; }
+    virtual bool OverrideResult(Action* action, bool executed, Event event) { return executed; }
+    virtual void After(Action* action, bool executed, Event event)
+    {
+        string name = action->getName();
+
+        ai->buffer.append(">");
+        MockedTargets::Append(ai->buffer, action->GetTarget());
+        ai->buffer.append(":");
+        ai->buffer.append(name);
+
+        if (!event.getParam().empty())
+        {
+            ai->buffer.append("(");
+            ai->buffer.append(event.getParam());
+            ai->buffer.append(")");
+        }
+
+        if (name == "caster form")
+        {
+            ai->auras[MockedTargets::GetSelf()].remove("dire bear form");
+            ai->auras[MockedTargets::GetSelf()].remove("bear form");
+            ai->auras[MockedTargets::GetSelf()].remove("cat form");
+            ai->auras[MockedTargets::GetSelf()].remove("moonkin form");
+            ai->auras[MockedTargets::GetSelf()].remove("travel form");
+            ai->auras[MockedTargets::GetSelf()].remove("aquatic form");
+        }
+        if (name == "remove shadowform")
+        {
+            ai->auras[MockedTargets::GetSelf()].remove("shadowform");
+        }
+        if (name == "reach melee" ||
+                name == "feral charge - bear" || name == "feral charge - cat" ||
+                name == "charge")
+        {
+            ai->GetAiObjectContext()->GetValue<float>("distance", "current target")->Set(ATTACK_DISTANCE - 1);
+        }
+
+        remove(name, " on party");
+        remove(name, " on cc");
+        remove(name, " on enemy healer");
+        if (name.find("cleanse") != string ::npos)
+            name = "cleanse";
+        if (name.find("purify") != string ::npos)
+            name = "purify";
+
+        if (name != "shoot" && name != "auto shot")
+            ai->spellCooldowns.push_back(name);
+    }
+
+    void remove(string & name, string pattern)
+    {
+        size_t pos = name.find(pattern);
+        if (pos != string ::npos)
+            name = name.substr(0, pos);
+    }
+
+private:
+    MockPlayerbotAIBase *ai;
+};
+
+
+void EngineTestBase::setUp()
+{
+	ai = new MockPlayerbotAIBase();
+}
+
+void EngineTestBase::tearDown()
+{
+    if (engine)
+        delete engine;
+    if (ai)
+        delete ai;
+}
+
+void EngineTestBase::va_generic(void (EngineTestBase::*callback)(const char*), va_list vl)
+{
+	const char* cur;
+	do
+	{
+		cur = va_arg(vl, const char*);
+		if (cur)
+			(this->*callback)(cur);
+	}
+	while (cur);
+
+	va_end(vl);
+}
+
+
+void EngineTestBase::setupEngine(AiObjectContext* aiObjectContext, ...)
+{
+    context = new AiObjectContextWrapper(ai, aiObjectContext);
+    ai->SetContext(context);
+    engine = new Engine(ai, context);
+	engine->testMode = true;
+    engine->AddActionExecutionListener(new TestActionExecutionListener(ai));
+
+	va_list vl;
+	va_start(vl, aiObjectContext);
+
+	va_generic(&EngineTestBase::setupEngineCallback, vl);
+
+	engine->Init();
+}
+
+void EngineTestBase::setupEngineCallback(const char* name)
+{
+	engine->addStrategy(name);
+}
+
+void EngineTestBase::tick()
+{
+	engine->DoNextAction(NULL);
+}
+
+void EngineTestBase::ticks(int count)
+{
+    for (int i = 0; i < count; ++i)
+    {
+        tick();
+        ai->buffer.append(",");
+    }
+}
+
+void EngineTestBase::assertActions(string  expected)
+{
+	bool pass = ai->buffer == expected;
+	if (!pass)
+	{
+		std::cout << "\n===\n";
+		std::cout << "Exp: " << expected << "\n";
+		std::cout << "Act: " << ai->buffer << "\n";
+		std::cout << "===\n";
+	}
+    CPPUNIT_ASSERT(pass);
+}
+
+void EngineTestBase::tickWithNoTarget()
+{
+    context->GetValue<Unit*>("current target")->Set(NULL);
+    set<uint8>("my attacker count", 0);
+
+	tick();
+
+    set<uint8>("my attacker count", 1);
+    context->GetValue<Unit*>("current target")->Set(MockedTargets::GetCurrentTarget());
+}
+
+void EngineTestBase::spellUnavailable(string  spell)
+{
+	ai->spellCooldowns.push_back(spell);
+}
+
+void EngineTestBase::tickWithSpellUnavailable(string  spell)
+{
+	spellUnavailable(spell);
+	tick();
+}
+
+void EngineTestBase::tickWithSpellAvailable(string  spell)
+{
+	spellAvailable(spell);
+	tick();
+}
+
+void EngineTestBase::spellAvailable(string  spell)
+{
+    list<string > remove;
+    for (list<string >::iterator i = ai->spellCooldowns.begin(); i != ai->spellCooldowns.end(); i++)
+    {
+        if (i->find(spell) != string ::npos) remove.push_back(*i);
+    }
+    for (list<string >::iterator i = remove.begin(); i != remove.end(); i++)
+    {
+        ai->spellCooldowns.remove(*i);
+    }
+}
+
+void EngineTestBase::addAura(string  spell)
+{
+	ai->auras[MockedTargets::GetSelf()].push_back(spell);
+}
+
+void EngineTestBase::removeAura(string  spell)
+{
+	ai->auras[MockedTargets::GetSelf()].remove(spell);
+}
+
+void EngineTestBase::tickOutOfSpellRange()
+{
+    set<float>("distance", "current target", 49.0f);
+    tick();
+    set<float>("distance", "current target", 15.0f);
+}
+
+void EngineTestBase::tickOutOfMeleeRange()
+{
+    set<float>("distance", "current target", 15.0f);
+    tick();
+    set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+}
+
+void EngineTestBase::setInMeleeRange()
+{
+    set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+}
+
+void EngineTestBase::tickInMeleeRange()
+{
+    set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+	tick();
+}
+
+void EngineTestBase::tickWithNoAggro()
+{
+    set<bool>("has aggro", "current target", false);
+    tick();
+    set<bool>("has aggro", "current target", true);
+}
+
+void EngineTestBase::tickWithRage(int amount)
+{
+    set<uint8>("rage", "self target", amount);
+    tick();
+    set<uint8>("rage", "self target", 0);
+}
+
+void EngineTestBase::tickWithEnergy(int amount)
+{
+    set<uint8>("energy", "self target", amount);
+	tick();
+    set<uint8>("energy", "self target", 0);
+}
+
+void EngineTestBase::tickWithAttackerCount(int count)
+{
+    set<uint8>("attacker count", count);
+	tick();
+    set<uint8>("attacker count", 1);
+}
+
+void EngineTestBase::tickWithMyAttackerCount(int count)
+{
+    set<uint8>("my attacker count", count);
+	tickWithAttackerCount(count + 1);
+    set<uint8>("my attacker count", 1);
+}
+
+void EngineTestBase::tickWithLowHealth(int amount)
+{
+	lowHealth(amount);
+	tick();
+	healthRestored();
+}
+
+void EngineTestBase::tickWithPartyLowHealth(int amount)
+{
+    set<uint8>("health", "party member to heal", amount);
+	tick();
+    set<uint8>("health", "party member to heal", 100);
+}
+
+void EngineTestBase::tickWithAoeHeal(string type, int amount)
+{
+    set<uint8>("health", "party member to heal", 45);
+	set<uint8>("aoe heal", "medium", amount);
+	tick();
+	set<uint8>("aoe heal", "medium", 0);
+    set<uint8>("health", "party member to heal", 100);
+}
+
+void EngineTestBase::tickWithAuraToDispel(uint32 type)
+{
+	ai->dispels[MockedTargets::GetSelf()] = type;
+	tick();
+	ai->dispels[MockedTargets::GetSelf()] = 0;
+}
+
+void EngineTestBase::tickWithPartyAuraToDispel(uint32 type)
+{
+	ai->dispels[MockedTargets::GetPartyMember()] = type;
+	tick();
+	ai->dispels[MockedTargets::GetPartyMember()] = 0;
+}
+
+void EngineTestBase::tickWithTargetAuraToDispel(uint32 type)
+{
+	ai->dispels[MockedTargets::GetCurrentTarget()] = type;
+	tick();
+	ai->dispels[MockedTargets::GetCurrentTarget()] = 0;
+}
+
+void EngineTestBase::lowHealth(int amount)
+{
+    set<uint8>("health", "self target", amount);
+}
+
+void EngineTestBase::lowMana(int amount)
+{
+    set<uint8>("mana", "self target", amount);
+}
+
+void EngineTestBase::healthRestored()
+{
+    set<uint8>("health", "self target", 100);
+}
+
+void EngineTestBase::tickWithComboPoints(int amount)
+{
+    set<uint8>("combo", "current target", amount);
+	tick();
+    set<uint8>("combo", "current target", 0);
+}
+
+void EngineTestBase::tickWithTargetIsCastingNonMeleeSpell()
+{
+    ai->targetIsCastingNonMeleeSpell = true;
+    tick();
+    ai->targetIsCastingNonMeleeSpell = false;
+}
+
+void EngineTestBase::tickWithBalancePercent(int percent)
+{
+    set<uint8>("balance", percent);
+	tick();
+    set<uint8>("balance", 100);
+}
+
+void EngineTestBase::tickWithNoPet()
+{
+    context->GetValue<Unit*>("pet target")->Set(NULL);
+	tick();
+    context->GetValue<Unit*>("pet target")->Set(MockedTargets::GetPet());
+}
+
+void EngineTestBase::tickWithPetLowHealth(int amount)
+{
+    set<uint8>("health", "pet target", amount);
+	tick();
+    set<uint8>("health", "pet target", 100);
+}
+
+void EngineTestBase::tickWithPetDead()
+{
+    set<bool>("dead", "pet target", true);
+    tick();
+    set<bool>("dead", "pet target", false);
+}
+
+void EngineTestBase::tickWithLowMana(int amount)
+{
+    Value<float>* distance = context->GetValue<float>("distance", "current target");
+    float oldDistance = distance->Get();
+    distance->Set(5.0f);
+    set<uint8>("mana", "self target", amount);
+    tick();
+    set<uint8>("mana", "self target", 100);
+    distance->Set(oldDistance);
+}
+
+void EngineTestBase::tickWithTargetLowHealth(int amount)
+{
+    set<uint8>("health", "current target", amount);
+    tick();
+    set<uint8>("health", "current target", 100);
+}
+void EngineTestBase::tickWithTargetIsMoving()
+{
+    set<bool>("moving", "current target", true);
+    tick();
+    set<bool>("moving", "current target", false);
+}
+
+void EngineTestBase::tickInSpellRange()
+{
+    set<float>("distance", "current target", 15.0f);
+    tick();
+}
+
+void EngineTestBase::addTargetAura(string  spell)
+{
+	ai->auras[MockedTargets::GetCurrentTarget()].push_back(spell);
+}
+
+void EngineTestBase::removeTargetAura(string  spell)
+{
+    ai->auras[MockedTargets::GetCurrentTarget()].remove(spell);
+}
+
+void EngineTestBase::addPartyAura(string  spell)
+{
+    ai->auras[MockedTargets::GetPartyMember()].push_back(spell);
+}
+
+void EngineTestBase::removePartyAura(string  spell)
+{
+    ai->auras[MockedTargets::GetPartyMember()].remove(spell);
+}
+
+void EngineTestBase::tickWithLootAvailable()
+{
+    set<bool>("has available loot", true);
+	tick();
+    set<bool>("has available loot", false);
+}
+
+void EngineTestBase::tickWithNoDrink()
+{
+    list<Item*> items;
+    set<list<Item*> >("inventory items", "drink", items);
+
+	tick();
+
+	items.push_back((Item*)(void*)0x01);
+    set<list<Item*> >("inventory items", "drink", items);
+}
+
+void EngineTestBase::tickWithNoFood()
+{
+    list<Item*> items;
+    set<list<Item*> >("inventory items", "food", items);
+
+	tick();
+
+	items.push_back((Item*)(void*)0x01);
+    set<list<Item*> >("inventory items", "food", items);
+}
+
+void EngineTestBase::itemAvailable(string  item, int amount)
+{
+    set<uint8>("item count", item, 2);
+}
+
+void EngineTestBase::tickWithDeadPartyMember()
+{
+    context->GetValue<Unit*>("party member to resurrect")->Set(MockedTargets::GetPartyMember());
+	tick();
+    context->GetValue<Unit*>("party member to resurrect")->Set(NULL);
+}
+
+void EngineTestBase::tickBehindTarget()
+{
+    set<bool>("behind", "current target", true);
+    tick();
+    set<bool>("behind", "current target", false);
+}
+
+void EngineTestBase::tickWithCcTarget(string  spell)
+{
+    set<uint8>("attacker count", 3);
+    context->GetValue<Unit*>("cc target", spell)->Set(MockedTargets::GetCc());
+    tick();
+    set<uint8>("attacker count", 1);
+    context->GetValue<Unit*>("cc target", spell)->Set(NULL);
+}
+
+void EngineTestBase::tickWhileSwimming()
+{
+    set<bool>("swimming", "self target", true);
+    tick();
+    set<bool>("swimming", "self target", false);
+}
+
+void EngineTestBase::tickWithItemForSpell(string spell)
+{
+    set<Item*>("item for spell", "1", (Item*)(void*)0x01);
+    tick();
+    set<Item*>("item for spell", "1", NULL);
+}
+
+void EngineTestBase::tickWithEnemyHealerIsCastingInterruptableSpell(string interrupt)
+{
+    set<Unit*>("enemy healer target", interrupt, MockedTargets::GetEnemyHealer());
+    tick();
+    set<Unit*>("enemy healer target", interrupt, NULL);
+}
+
+void EngineTestBase::runStressTest()
+{
+    int count = 20;
+    std::cout << "\n";
+
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "Normal:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+
+    ai->targetIsCastingNonMeleeSpell = true;
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "Spell Cast:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+
+    set<uint8>("attacker count", 5);
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "AOE:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+
+    set<uint8>("health", "current target", 10);
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "Target Low Health:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+
+    ai->dispels[MockedTargets::GetCurrentTarget()] = DISPEL_DISEASE;
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "Dispel:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+
+    context->GetValue<Unit*>("cc target", "entangling roots")->Set(MockedTargets::GetCc());
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "CC:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+
+    set<bool>("moving", "current target", true);
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "Snare:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+
+    lowHealth(10);
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "Low Health:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+
+    lowMana(20);
+    ai->buffer = "";
+    ai->spellCooldowns.clear();
+    ticks(count);
+    std::cout << "Low Mana:\n" << ai->buffer << "\n\n";
+    CPPUNIT_ASSERT(ai->buffer.find(",,,,,,,") == string::npos);
+}
diff --git a/src/test/EngineTestBase.h b/src/test/EngineTestBase.h
new file mode 100644
index 0000000..78c7ed9
--- /dev/null
+++ b/src/test/EngineTestBase.h
@@ -0,0 +1,90 @@
+#pragma once
+
+#include "../../plugins/playerbot/strategy/Action.h"
+#include "../../plugins/playerbot/strategy/ActionBasket.h"
+#include "../../plugins/playerbot/strategy/Queue.h"
+#include "../../plugins/playerbot/strategy/Trigger.h"
+#include "../../plugins/playerbot/strategy/Engine.h"
+
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class EngineTestBase : public CPPUNIT_NS::TestFixture
+{
+public:
+    virtual void setUp();
+    virtual void tearDown();
+
+private:
+	void va_generic(void (EngineTestBase::*callback)(const char*), va_list vl);
+
+protected:
+    template <class T>
+    void set(string  name, T value) { context->GetValue<T>(name)->Set(value); }
+    template <class T>
+    void set(string  name, string  param, T value) { context->GetValue<T>(name, param)->Set(value); }
+
+protected:
+	virtual void setupEngine(AiObjectContext* AiObjectContext, ...);
+	void setupEngineCallback(const char*  name);
+	void tick();
+	void ticks(int count);
+	void assertActions(string  expected);
+
+	void tickWithNoTarget();
+	void spellUnavailable(string  spell);
+	void tickWithSpellUnavailable(string  spell);
+	void tickWithSpellAvailable(string  spell);
+	void spellAvailable(string  spell);
+	void addAura(string  spell);
+	void addTargetAura(string  spell);
+	void removeTargetAura(string  spell);
+	void addPartyAura(string  spell);
+	void removePartyAura(string  spell);
+	void removeAura(string  spell);
+	void tickOutOfSpellRange();
+	void tickOutOfMeleeRange();
+	void tickInMeleeRange();
+	void tickInSpellRange();
+	void tickWithNoAggro();
+	void tickWithRage(int amount);
+	void tickWithEnergy(int amount);
+	void tickWithAttackerCount(int count);
+	void tickWithMyAttackerCount(int count);
+	void tickWithLowHealth(int amount);
+	void tickWithPartyLowHealth(int amount);
+	void tickWithAuraToDispel(uint32 type);
+	void tickWithPartyAuraToDispel(uint32 type);
+	void tickWithTargetAuraToDispel(uint32 type);
+    void tickBehindTarget();
+	void lowHealth(int amount);
+	void lowMana(int amount);
+	void healthRestored();
+	void tickWithComboPoints(int amount);
+	void tickWithTargetIsCastingNonMeleeSpell();
+	void tickWithBalancePercent(int percent);
+	void tickWithNoPet();
+	void tickWithPetLowHealth(int amount);
+    void tickWithPetDead();
+	void tickWithLowMana(int amount);
+	void tickWithTargetLowHealth(int amount);
+	void tickWithTargetIsMoving();
+	void tickWithLootAvailable();
+	void tickWithNoFood();
+	void tickWithNoDrink();
+	void itemAvailable(string  item, int amount);
+	void tickWithDeadPartyMember();
+    void tickWithCcTarget(string   spell);
+    void tickWhileSwimming();
+    void setInMeleeRange();
+    void tickWithAoeHeal(string type, int amount = 2);
+    void tickWithItemForSpell(string spell);
+    void tickWithEnemyHealerIsCastingInterruptableSpell(string interrupt);
+    void runStressTest();
+
+protected:
+    MockPlayerbotAIBase *ai;
+    Engine *engine;
+    AiObjectContext *context;
+};
diff --git a/src/test/EngineTestCase.cpp b/src/test/EngineTestCase.cpp
new file mode 100644
index 0000000..2a5935f
--- /dev/null
+++ b/src/test/EngineTestCase.cpp
@@ -0,0 +1,321 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class PrerequisiteAction : public Action
+{
+public:
+    PrerequisiteAction(PlayerbotAI* const ai) : Action(ai) {}
+    virtual ~PrerequisiteAction() { destroyed = TRUE; }
+
+    bool Execute(Event event) { executed++; return TRUE; }
+    virtual string getName() {return "PrerequisiteAction"; }
+
+    static int executed;
+    static int destroyed;
+};
+
+int PrerequisiteAction::executed = 0;
+int PrerequisiteAction::destroyed = 0;
+
+class AlternativeAction : public Action
+{
+public:
+    AlternativeAction(PlayerbotAI* const ai) : Action(ai) {}
+    virtual ~AlternativeAction() {destroyed = TRUE;}
+
+    bool Execute(Event event) { executed++; return TRUE; }
+    string  getName() {return "AlternativeAction"; }
+
+    static int executed;
+    static int destroyed;
+};
+
+int AlternativeAction::executed = 0;
+int AlternativeAction::destroyed = 0;
+
+class RepeatingAction : public Action
+{
+public:
+	RepeatingAction(PlayerbotAI* const ai) : Action(ai) {}
+
+	virtual ~RepeatingAction()
+	{
+		destroyed++;
+	}
+
+    bool Execute(Event event) { executed++; return TRUE; }
+    string  getName() {return "RepeatingAction"; }
+    bool isPossible() { return available; }
+
+	static int destroyed;
+    static int executed;
+    static int available;
+};
+
+int RepeatingAction::available = TRUE;
+int RepeatingAction::destroyed = 0;
+int RepeatingAction::executed = 0;
+
+class TriggeredAction : public Action
+{
+public:
+	TriggeredAction(PlayerbotAI* const ai) : Action(ai) { fired = false; }
+	virtual ~TriggeredAction() {}
+
+    bool Execute(Event event) { param = event.getParam(); fired = TRUE; return true; }
+    string  getName() {return "TriggeredAction"; }
+
+	static int fired;
+    static string param;
+};
+
+int TriggeredAction::fired = 0;
+string TriggeredAction::param;
+
+class TestTrigger : public Trigger
+{
+public:
+	TestTrigger(PlayerbotAI* const ai) : Trigger(ai) {count = 0;}
+    virtual Event Check()
+    {
+        return IsActive() ? Event(getName(), "test") : Event();
+    }
+	virtual bool IsActive()
+	{
+		return ++count==3;
+	}
+
+private:
+	int count;
+};
+
+class TestMultiplier : public Multiplier
+{
+public:
+    TestMultiplier(PlayerbotAI* const ai) : Multiplier(ai, "test") { asked = 0; }
+    float GetValue(Action* action) { return asked = 1.0f; }
+
+    static int asked;
+};
+
+int TestMultiplier::asked;
+
+class TestStrategy : public Strategy
+{
+public:
+    TestStrategy(PlayerbotAI* const ai) : Strategy(ai) {}
+
+    virtual string  getName() { return "TestStrategy"; }
+
+    virtual NextAction** getDefaultActions() { return NextAction::array(0, new NextAction("RepeatingAction", 1.0f), NULL); }
+
+    virtual void InitMultipliers(std::list<Multiplier*> &multipliers)
+    {
+        multipliers.push_back(new TestMultiplier(ai));
+    }
+
+    virtual void InitTriggers(std::list<TriggerNode*> &triggers)
+    {
+        triggers.push_back(new TriggerNode(
+            "TestTrigger",
+            NextAction::array(0, new NextAction("TriggeredAction", 10.0f), NULL)));
+    }
+
+    virtual ActionNode* GetAction(string  name)
+    {
+        if (name == "TriggeredAction")
+        {
+            return new ActionNode ("TriggeredAction",
+                /*P*/ NULL,
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        else if (name == "RepeatingAction")
+        {
+            return new ActionNode ("RepeatingAction",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("AlternativeAction", 1.0f), NULL),
+                /*C*/ NextAction::array(0, new NextAction("RepeatingAction", 1.0f), NULL));
+        }
+        else if (name == "AlternativeAction")
+        {
+            return new ActionNode ("AlternativeAction",
+                /*P*/ NextAction::array(0, new NextAction("PrerequisiteAction", 1.0f), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        else if (name == "PrerequisiteAction")
+        {
+            return new ActionNode ("PrerequisiteAction",
+                /*P*/ NULL,
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        else return NULL;
+    }
+};
+
+class AnotherTestStrategy : public Strategy
+{
+public:
+    AnotherTestStrategy(PlayerbotAI* const ai) : Strategy(ai) {}
+
+    virtual string  getName() { return "AnotherTestStrategy"; }
+};
+
+class TestStrategyContext : public NamedObjectContext<Strategy>
+{
+public:
+    TestStrategyContext() : NamedObjectContext(false, true)
+    {
+        creators["TestStrategy"] = &TestStrategyContext::Test;
+        creators["AnotherTestStrategy"] = &TestStrategyContext::AnotherTest;
+    }
+
+private:
+    static Strategy* Test(PlayerbotAI* ai) { return new TestStrategy(ai); }
+    static Strategy* AnotherTest(PlayerbotAI* ai) { return new AnotherTestStrategy(ai); }
+};
+
+class TestTriggerContext : public NamedObjectContext<Trigger>
+{
+public:
+    TestTriggerContext()
+    {
+        creators["TestTrigger"] = &TestTriggerContext::Test;
+    }
+
+private:
+    static Trigger* Test(PlayerbotAI* ai) { return new TestTrigger(ai); }
+};
+
+
+class TestActionContext : public NamedObjectContext<Action>
+{
+public:
+    TestActionContext()
+    {
+        creators["TriggeredAction"] = &TestActionContext::Triggered;
+        creators["RepeatingAction"] = &TestActionContext::Repeating;
+        creators["AlternativeAction"] = &TestActionContext::Alternative;
+        creators["PrerequisiteAction"] = &TestActionContext::Prerequisite;
+    }
+
+private:
+    static Action* Triggered(PlayerbotAI* ai) { return new TriggeredAction(ai); }
+    static Action* Repeating(PlayerbotAI* ai) { return new RepeatingAction(ai); }
+    static Action* Alternative(PlayerbotAI* ai) { return new AlternativeAction(ai); }
+    static Action* Prerequisite(PlayerbotAI* ai) { return new PrerequisiteAction(ai); }
+};
+
+class TestAiObjectContext : public AiObjectContext
+{
+public:
+    TestAiObjectContext(PlayerbotAI* const ai) : AiObjectContext(ai)
+    {
+        strategyContexts.Add(new TestStrategyContext());
+        triggerContexts.Add(new TestTriggerContext());
+        actionContexts.Add(new TestActionContext());
+    }
+};
+
+class EngineTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( EngineTestCase );
+      CPPUNIT_TEST( engineMustRepeatActions );
+      CPPUNIT_TEST( addRemoveStrategies );
+      CPPUNIT_TEST( listStrategies );
+      CPPUNIT_TEST( eventMustPassToAction );
+      CPPUNIT_TEST( siblings );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void engineMustRepeatActions()
+	{
+		MockPlayerbotAIBase mock;
+		Engine engine(&mock, new TestAiObjectContext(&mock));
+		engine.testMode = true;
+        engine.addStrategy("TestStrategy");
+        engine.Init();
+
+		for (int i=0; i<6; i++)
+			engine.DoNextAction(NULL);
+
+		CPPUNIT_ASSERT(TriggeredAction::fired);
+        CPPUNIT_ASSERT(TestMultiplier::asked);
+        CPPUNIT_ASSERT_EQUAL(5, RepeatingAction::executed);
+
+        RepeatingAction::available = FALSE;
+        engine.DoNextAction(NULL);
+        engine.DoNextAction(NULL);
+        CPPUNIT_ASSERT(AlternativeAction::executed);
+        CPPUNIT_ASSERT(PrerequisiteAction::executed);
+	}
+
+    void addRemoveStrategies()
+    {
+		MockPlayerbotAIBase mock;
+        Engine engine(&mock, new TestAiObjectContext(&mock));
+        engine.testMode = true;
+        engine.addStrategy("AnotherTestStrategy");
+        engine.removeStrategy("AnotherTestStrategy");
+        engine.Init();
+
+        engine.addStrategy("TestStrategy");
+        engine.Init();
+
+        engine.DoNextAction(NULL);
+        CPPUNIT_ASSERT(TriggeredAction::fired);
+    }
+
+    void listStrategies()
+    {
+		MockPlayerbotAIBase mock;
+        Engine engine(&mock, new TestAiObjectContext(&mock));
+        engine.testMode = true;
+        engine.addStrategy("AnotherTestStrategy");
+        engine.addStrategy("TestStrategy");
+        engine.Init();
+
+        std::string s = engine.ListStrategies();
+        CPPUNIT_ASSERT(s == "Strategies: TestStrategy");
+    }
+
+    void eventMustPassToAction()
+    {
+        MockPlayerbotAIBase mock;
+        Engine engine(&mock, new TestAiObjectContext(&mock));
+        engine.testMode = true;
+        engine.addStrategy("TestStrategy");
+        engine.Init();
+
+        for (int i=0; i<6; i++)
+            engine.DoNextAction(NULL);
+
+        CPPUNIT_ASSERT(TriggeredAction::param == "test");
+    }
+
+    void siblings()
+    {
+        MockPlayerbotAIBase mock;
+        TestAiObjectContext * context = new TestAiObjectContext(&mock);
+
+        set<string> siblings = context->GetSiblingStrategy("TestStrategy");
+
+        CPPUNIT_ASSERT(siblings.size() == 1);
+        CPPUNIT_ASSERT(*siblings.begin() == "AnotherTestStrategy");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( EngineTestCase );
diff --git a/src/test/EventTestCase.cpp b/src/test/EventTestCase.cpp
new file mode 100644
index 0000000..a293b90
--- /dev/null
+++ b/src/test/EventTestCase.cpp
@@ -0,0 +1,59 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+char *strstri(const char *haystack, const char *needle);
+
+class EventTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( EventTestCase );
+      CPPUNIT_TEST( emptyEvent );
+      CPPUNIT_TEST( eventHandling );
+      CPPUNIT_TEST( strstriTest1 );
+      CPPUNIT_TEST( strstriTest2 );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void emptyEvent()
+	{
+        Event event;
+        CPPUNIT_ASSERT(!event);
+	}
+
+    void eventHandling()
+    {
+        Event event("source", "param");
+
+        Event event2 = event;
+
+        CPPUNIT_ASSERT(!!event2);
+        CPPUNIT_ASSERT(event2.getParam() == "param");
+        CPPUNIT_ASSERT(event2.getSource() == "source");
+    }
+
+    void strstriTest1()
+    {
+        string a = "Mana Spring Totem V";
+        string b = "strength of earth totem";
+        CPPUNIT_ASSERT(!strstri(a.c_str(), b.c_str()));
+    }
+
+    void strstriTest2()
+    {
+        string a = "mana spring Totem V";
+        string b = "mana Spring totem";
+        CPPUNIT_ASSERT(strstri(a.c_str(), b.c_str()));
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( EventTestCase );
diff --git a/src/test/EverythingUnavailableAiManagerRegistry.h b/src/test/EverythingUnavailableAiManagerRegistry.h
new file mode 100644
index 0000000..7bc4f90
--- /dev/null
+++ b/src/test/EverythingUnavailableAiManagerRegistry.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class EverythingUnavailablePlayerbotAI : public MockPlayerbotAIBase
+    {
+    public:
+        EverythingUnavailablePlayerbotAI() : MockPlayerbotAIBase()
+		{
+			managers[AiSpellManagerType] = new EverythingUnavailableAiSpellManager(ai, this, &buffer);
+		}
+        virtual bool CanCastSpell(string  name, Unit* target) { return false; }
+    };
+
+}
\ No newline at end of file
diff --git a/src/test/ExternalEventHelperTestCase.cpp b/src/test/ExternalEventHelperTestCase.cpp
new file mode 100644
index 0000000..7895b62
--- /dev/null
+++ b/src/test/ExternalEventHelperTestCase.cpp
@@ -0,0 +1,81 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+#include "../../plugins/playerbot/strategy/triggers/ChatCommandTrigger.h"
+#include "../../plugins/playerbot/strategy/ExternalEventHelper.h"
+
+using namespace ai;
+
+class ExternalEventTestTriggerContext : public NamedObjectContext<Trigger>
+{
+public:
+    ExternalEventTestTriggerContext()
+    {
+        creators["message"] = &ExternalEventTestTriggerContext::message;
+        creators["message from"] = &ExternalEventTestTriggerContext::message_from;
+    }
+
+private:
+    static Trigger* message(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "message"); }
+    static Trigger* message_from(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "message from"); }
+};
+
+
+
+class ExternalEventTestAiObjectContext : public AiObjectContext
+{
+public:
+    ExternalEventTestAiObjectContext(PlayerbotAI* const ai) : AiObjectContext(ai)
+    {
+        triggerContexts.Add(new ExternalEventTestTriggerContext());
+    }
+};
+
+
+class ExternalEventHelperTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( ExternalEventHelperTestCase );
+      CPPUNIT_TEST( externalEvent );
+      CPPUNIT_TEST( emptyExternalEvent );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void externalEvent()
+	{
+        MockPlayerbotAIBase ai;
+        ExternalEventTestAiObjectContext aiObjectContext(&ai);
+        ExternalEventHelper helper(&aiObjectContext);
+        
+        helper.ParseChatCommand("message from chat");
+        
+        Event event = aiObjectContext.GetTrigger("message from")->Check();
+        CPPUNIT_ASSERT(event);
+        CPPUNIT_ASSERT(event.getParam() == "chat");
+	
+        event = aiObjectContext.GetTrigger("message")->Check();
+        CPPUNIT_ASSERT(!event);
+    }
+
+    void emptyExternalEvent()
+    {
+        MockPlayerbotAIBase ai;
+        ExternalEventTestAiObjectContext aiObjectContext(&ai);
+        ExternalEventHelper helper(&aiObjectContext);
+
+        helper.ParseChatCommand("message from");
+
+        Event event = aiObjectContext.GetTrigger("message from")->Check();
+        CPPUNIT_ASSERT(event);
+        CPPUNIT_ASSERT(event.getParam() == "");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ExternalEventHelperTestCase );
diff --git a/src/test/FireMageTestCase.cpp b/src/test/FireMageTestCase.cpp
new file mode 100644
index 0000000..2cd5cb3
--- /dev/null
+++ b/src/test/FireMageTestCase.cpp
@@ -0,0 +1,109 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+
+using namespace ai;
+
+
+class FireMageTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( FireMageTestCase );
+  CPPUNIT_TEST( combatVsMelee );
+  CPPUNIT_TEST( avoid_melee );
+  CPPUNIT_TEST( avoid_melee_low_level );
+  CPPUNIT_TEST( panic );
+  CPPUNIT_TEST( boost );
+  CPPUNIT_TEST( aoe );
+  CPPUNIT_TEST( invisibility );
+  CPPUNIT_TEST( stress );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new MageAiObjectContext(ai), "fire", NULL);
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+        tick();
+		addTargetAura("pyroblast");
+
+        tick();
+		tick();
+		tick();
+
+        addAura("hot streak");
+        spellAvailable("pyroblast");
+        tick();
+        tick();
+
+        assertActions(">T:pyroblast>T:scorch>T:fireball>T:fire blast>T:pyroblast>T:shoot");
+	}
+
+ 	void avoid_melee()
+ 	{
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		spellAvailable("flamestrike");
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		assertActions(">T:dragon's breath>T:flamestrike>T:blast wave>T:flamestrike>T:frost nova>S:flee");
+	}
+
+ 	void avoid_melee_low_level()
+ 	{
+ 	    spellUnavailable("dragon's breath");
+ 	    spellUnavailable("blast wave");
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		assertActions(">T:frost nova>S:flee");
+	}
+
+ 	void panic()
+ 	{
+        tickWithLowHealth(19);
+
+        assertActions(">S:ice block");
+ 	}
+
+    void boost()
+    {
+		tickWithBalancePercent(1);
+
+		assertActions(">S:combustion");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("fire aoe");
+
+		tickWithAttackerCount(3);
+		tickWithAttackerCount(3);
+
+		assertActions(">T:living bomb>T:flamestrike");
+    }
+
+    void invisibility()
+    {
+		tickWithMyAttackerCount(3);
+
+		assertActions(">S:invisibility");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( FireMageTestCase );
diff --git a/src/test/FrostMageTestCase.cpp b/src/test/FrostMageTestCase.cpp
new file mode 100644
index 0000000..8099bf9
--- /dev/null
+++ b/src/test/FrostMageTestCase.cpp
@@ -0,0 +1,150 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+
+using namespace ai;
+
+
+class FrostMageTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( FrostMageTestCase );
+  CPPUNIT_TEST( combatVsMelee );
+  CPPUNIT_TEST( dispel );
+  CPPUNIT_TEST( boost );
+  CPPUNIT_TEST( interruptSpells );
+  CPPUNIT_TEST( cc );
+  CPPUNIT_TEST( aoe );
+  CPPUNIT_TEST( incompatibles );
+  CPPUNIT_TEST( low_mana );
+  CPPUNIT_TEST( interrupt_enemy_healer );
+  CPPUNIT_TEST( stress );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new MageAiObjectContext(ai), "frost", NULL);
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+        tick();
+        spellAvailable("frostbolt");
+
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		spellAvailable("frostbolt");
+		tickInSpellRange();
+        tick();
+
+		tickWithLowHealth(19);
+
+		context->GetValue<uint8>("speed", "current target")->Set(100);
+        spellAvailable("frost nova");
+        spellAvailable("frostbolt");
+        tickInMeleeRange();
+        tickInMeleeRange();
+        context->GetValue<uint8>("speed", "current target")->Set(80);
+
+		assertActions(">T:frostbolt>T:frost nova>S:flee>T:frostbolt>T:shoot>S:ice block>T:frost nova>T:frostbolt");
+	}
+
+    void dispel()
+    {
+        tick();
+
+		tickWithAuraToDispel(DISPEL_CURSE);
+
+		spellAvailable("remove curse");
+		tickWithPartyAuraToDispel(DISPEL_CURSE);
+
+        tick();
+
+		tickWithTargetAuraToDispel(DISPEL_MAGIC);
+
+		assertActions(">T:frostbolt>S:remove curse>P:remove curse on party>T:shoot>T:spellsteal");
+    }
+
+    void boost()
+    {
+        tick(); // frostbolt
+
+		tickWithBalancePercent(1);
+
+        spellAvailable("frostbolt");
+        tick(); // frostbolt
+
+        tick(); // shoot
+
+		assertActions(">T:frostbolt>S:icy veins>T:frostbolt>T:shoot");
+    }
+
+    void interruptSpells()
+    {
+		tickWithTargetIsCastingNonMeleeSpell();
+
+        tick(); // frostbolt
+
+        assertActions(">T:counterspell>T:frostbolt");
+    }
+
+    void cc()
+    {
+        tickWithCcTarget("polymorph");
+
+        assertActions(">Cc:polymorph");
+    }
+
+   	void aoe()
+	{
+        engine->addStrategy("frost aoe");
+
+		tick();
+		tickWithAttackerCount(4);
+		tick();
+
+		assertActions(">T:frostbolt>T:blizzard>T:shoot");
+	}
+
+   	void incompatibles()
+   	{
+        engine->addStrategies("frost", "fire", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: fire");
+   	}
+
+    void low_mana()
+    {
+        engine->addStrategy("flee");
+        addAura("arcane intellect");
+        addPartyAura("arcane intellect");
+        addAura("mage armor");
+
+        tickWithLowMana(5);
+
+        set<uint8>("item count", "drink", 0);
+        set<float>("distance", "current target", 5);
+        tickWithLowMana(5);
+        tickWithLowMana(5);
+
+        assertActions(">S:evocation>T:frost nova>S:flee");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("counterspell");
+
+        assertActions(">H:counterspell on enemy healer");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( FrostMageTestCase );
diff --git a/src/test/GenericTestCase.cpp b/src/test/GenericTestCase.cpp
new file mode 100644
index 0000000..fc65367
--- /dev/null
+++ b/src/test/GenericTestCase.cpp
@@ -0,0 +1,139 @@
+#include "pch.h"
+#include "aitest.h"
+
+#include "EngineTestBase.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+class GenericTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( GenericTestCase );
+	CPPUNIT_TEST( flee );
+	CPPUNIT_TEST( adds );
+	CPPUNIT_TEST( potions );
+	CPPUNIT_TEST( guard );
+	CPPUNIT_TEST( threat );
+	CPPUNIT_TEST( facing );
+	CPPUNIT_TEST( drop_target );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "bear", "flee", NULL);
+    }
+
+protected:
+	void flee()
+	{
+	    list<Item*> items;
+        set<list<Item*> >("inventory items", "drink", items);
+	    set<list<Item*> >("inventory items", "food", items);
+
+        set<float>("distance", "current target", 5);
+		lowHealth(1);
+		lowMana(1);
+		tick();
+
+		assertActions(">S:flee");
+	}
+
+	void adds()
+	{
+	    engine->addStrategy("flee from adds");
+
+	    list<ObjectGuid> adds;
+	    adds.push_front(ObjectGuid(uint64(1)));
+	    set<list<ObjectGuid> >("nearest adds", adds);
+
+	    tick();
+
+		assertActions(">S:runaway");
+	}
+
+	void potions()
+	{
+        engine->addStrategy("flee");
+	    engine->addStrategy("potions");
+
+        set<uint8>("item count", "mana potion", 1);
+        set<uint8>("item count", "drink", 1);
+        set<uint8>("item count", "healing potion", 1);
+        set<uint8>("item count", "food", 1);
+
+        spellUnavailable("innervate");
+        spellUnavailable("barskin");
+        spellUnavailable("survival instincts");
+
+        spellUnavailable("regrowth");
+        spellUnavailable("healing touch");
+        spellUnavailable("rejuvenation");
+
+	    tickWithLowMana(1);
+
+	    set<bool>("combat", "self target", true);
+	    tickWithLowMana(1);
+        set<uint8>("item count", "mana potion", 0);
+	    tickWithLowMana(1);
+        set<uint8>("item count", "drink", 0);
+        set<float>("distance", "current target", 5);
+	    tickWithLowMana(1);
+
+	    tickWithLowHealth(1);
+        set<uint8>("item count", "healing potion", 0);
+	    tickWithLowHealth(1);
+        set<uint8>("item count", "food", 0);
+        set<float>("distance", "current target", 5);
+	    tickWithLowHealth(1);
+
+		assertActions(">S:flee>S:mana potion>S:drink>S:flee>S:healing potion>S:food>S:flee");
+	}
+
+	void guard()
+	{
+	    engine->removeStrategy("bear");
+	    engine->addStrategy("guard");
+
+	    tick();
+
+		assertActions(">S:move to position");
+	}
+
+	void threat()
+	{
+	    engine->addStrategy("threat");
+
+        set<uint8>("threat", "current target", 100);
+	    tick();
+
+		assertActions(">T:reach melee");
+	}
+
+	void facing()
+	{
+        addAura("dire bear form");
+        addAura("thorns");
+        addTargetAura("faerie fire (feral)");
+
+        set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+        set<bool>("facing", "current target", false);
+	    tick();
+        set<bool>("facing", "current target", true);
+
+		assertActions(">S:set facing");
+	}
+
+    void drop_target()
+    {
+        set<bool>("invalid target", "current target", true);
+        tick();
+        set<bool>("invalid target", "current target", false);
+
+        assertActions(">S:drop target");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( GenericTestCase );
diff --git a/src/test/HealDruidTestCase.cpp b/src/test/HealDruidTestCase.cpp
new file mode 100644
index 0000000..d58d290
--- /dev/null
+++ b/src/test/HealDruidTestCase.cpp
@@ -0,0 +1,91 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+
+class HealDruidTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HealDruidTestCase );
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( healOthers );
+	CPPUNIT_TEST( aoe );
+	CPPUNIT_TEST( range );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "heal", NULL);
+
+		addAura("moonkin form");
+    }
+
+protected:
+
+	void healHimself()
+    {
+	    tick();
+        addAura("tree of life");
+
+		tickWithLowHealth(79);
+        spellAvailable("rejuvenation");
+
+		tickWithLowHealth(59);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+		tickWithLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">S:tree of life>S:rejuvenation>S:regrowth>S:regrowth>S:regrowth>S:healing touch");
+    }
+
+	void healOthers()
+    {
+        addAura("tree of life");
+
+        tickWithPartyLowHealth(79);
+        spellAvailable("rejuvenation");
+
+        tickWithPartyLowHealth(59);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithPartyLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+        assertActions(">P:rejuvenation on party>P:regrowth on party>P:regrowth on party>P:regrowth on party>P:healing touch on party");
+    }
+
+    void aoe()
+    {
+        tickWithAoeHeal("medium");
+
+		assertActions(">P:tranquility");
+    }
+
+    void range()
+    {
+        tickOutOfSpellRange();
+
+        assertActions(">T:reach spell");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HealDruidTestCase );
diff --git a/src/test/HealPriestTestCase.cpp b/src/test/HealPriestTestCase.cpp
new file mode 100644
index 0000000..8a44fa3
--- /dev/null
+++ b/src/test/HealPriestTestCase.cpp
@@ -0,0 +1,201 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+
+using namespace ai;
+
+
+class HealPriestTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HealPriestTestCase );
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( healOthers );
+    CPPUNIT_TEST( aoe_heal );
+    CPPUNIT_TEST( dispel );
+    CPPUNIT_TEST( flee );
+    CPPUNIT_TEST( cc );
+    CPPUNIT_TEST( enemyTooClose );
+	CPPUNIT_TEST( racials );
+	CPPUNIT_TEST( incompatibles );
+	CPPUNIT_TEST( range );
+	CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PriestAiObjectContext(ai), "heal", NULL);
+
+        addAura("power word: fortitude");
+        addAura("divine spirit");
+        addAura("inner fire");
+        addPartyAura("power word: fortitude");
+        addPartyAura("divine spirit");
+    }
+
+protected:
+    void healHimself()
+    {
+        addPartyAura("power word: fortitude");
+
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+		tick();
+
+		tickWithLowHealth(59);
+
+        spellAvailable("renew");
+        tickWithLowHealth(79);
+
+		tickWithSpellAvailable("shoot");
+
+		assertActions(">S:power word: shield>S:greater heal>S:renew>S:heal>S:lesser heal>T:shoot>S:flash heal>S:renew>T:shoot");
+    }
+
+	void racials()
+	{
+		engine->addStrategy("racials");
+		addPartyAura("power word: fortitude");
+
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+		tick();
+
+		tickWithLowHealth(59);
+
+		tickWithSpellAvailable("shoot");
+
+		assertActions(">S:lifeblood>S:gift of the naaru>S:power word: shield>S:greater heal>S:renew>S:heal>S:lesser heal>T:shoot>S:flash heal>T:shoot");
+	}
+
+    void healOthers()
+    {
+        tick(); // shoot
+
+		tickWithPartyLowHealth(39);
+		tickWithPartyLowHealth(39);
+		tickWithPartyLowHealth(39);
+		tickWithPartyLowHealth(39);
+		tickWithPartyLowHealth(39);
+
+        spellAvailable("greater heal");
+        spellAvailable("renew");
+        spellAvailable("flash heal");
+        spellAvailable("lesser heal");
+        spellAvailable("power word: shield");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+		tickWithSpellAvailable("shoot");
+
+        spellAvailable("flash heal");
+		tickWithPartyLowHealth(59);
+
+        spellAvailable("renew");
+        tickWithPartyLowHealth(79);
+
+        tickWithSpellAvailable("shoot"); // shoot
+
+
+		assertActions(">T:shoot>P:power word: shield on party>P:greater heal on party>P:renew on party>P:heal on party>P:lesser heal on party>P:power word: shield on party>P:flash heal on party>P:renew on party>P:greater heal on party>T:shoot>P:flash heal on party>P:renew on party>T:shoot");
+    }
+
+    void aoe_heal()
+    {
+        tickWithAoeHeal("medium");
+        tickWithAoeHeal("medium");
+
+        assertActions(">P:circle of healing>P:flash heal on party");
+    }
+
+    void flee()
+    {
+        tickInMeleeRange();
+        tickInMeleeRange();
+
+		assertActions(">S:fade>S:flee");
+    }
+
+    void cc()
+    {
+		tickWithMyAttackerCount(3);
+		tickWithMyAttackerCount(3);
+        set<float>("distance", "current target", 5);
+		tickWithMyAttackerCount(3);
+
+		assertActions(">T:psychic scream>S:fade>S:flee");
+    }
+
+    void enemyTooClose()
+    {
+        tick();
+
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		spellAvailable("shoot");
+		tickInSpellRange();
+
+		assertActions(">T:shoot>S:fade>S:flee>T:shoot");
+    }
+
+    void dispel()
+    {
+        tick(); // shoot
+
+		tickWithAuraToDispel(DISPEL_MAGIC);
+
+		spellAvailable("dispel magic");
+		tickWithPartyAuraToDispel(DISPEL_MAGIC);
+
+		tickWithAuraToDispel(DISPEL_DISEASE);
+
+		spellAvailable("abolish disease");
+		tickWithPartyAuraToDispel(DISPEL_DISEASE);
+
+		tickWithAuraToDispel(DISPEL_DISEASE);
+
+		spellAvailable("cure disease");
+		tickWithPartyAuraToDispel(DISPEL_DISEASE);
+
+        tickWithSpellAvailable("shoot");
+
+		assertActions(">T:shoot>S:dispel magic>P:dispel magic on party>S:abolish disease>P:abolish disease on party>S:cure disease>P:cure disease on party>T:shoot");
+    }
+
+
+    void incompatibles()
+    {
+        engine->addStrategies("heal", "shadow", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: shadow");
+    }
+
+    void range()
+    {
+        tickOutOfSpellRange();
+
+        assertActions(">T:reach spell");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HealPriestTestCase );
diff --git a/src/test/HealShamanTestCase.cpp b/src/test/HealShamanTestCase.cpp
new file mode 100644
index 0000000..9091f82
--- /dev/null
+++ b/src/test/HealShamanTestCase.cpp
@@ -0,0 +1,137 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+
+using namespace ai;
+
+
+class HealShamanTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HealShamanTestCase );
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( healOthers );
+    CPPUNIT_TEST( aoe_heal );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( interruptSpell );
+	CPPUNIT_TEST( dispel );
+	CPPUNIT_TEST( cure );
+	CPPUNIT_TEST( lowMana );
+	CPPUNIT_TEST( range );
+	CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new ShamanAiObjectContext(ai), "heal", NULL);
+
+        addAura("water shield");
+    }
+
+protected:
+    void healHimself()
+    {
+        tickWithLowHealth(45);
+		tickWithLowHealth(35);
+        tickWithLowHealth(35);
+
+        assertActions(">S:lesser healing wave>S:riptide>S:healing wave");
+    }
+
+    void healOthers()
+    {
+        tickWithPartyLowHealth(45);
+        tickWithPartyLowHealth(35);
+		tickWithPartyLowHealth(35);
+
+        assertActions(">P:lesser healing wave on party>P:riptide on party>P:healing wave on party");
+    }
+
+    void aoe_heal()
+    {
+        tickWithAoeHeal("medium");
+        tickWithAoeHeal("medium");
+
+        assertActions(">P:chain heal>P:lesser healing wave on party");
+    }
+
+    void buff()
+    {
+        engine->addStrategy("bmana");
+        removeAura("water shield");
+
+        tick();
+        addAura("water shield");
+
+        tickWithItemForSpell("earthliving weapon");
+        tickWithItemForSpell("earthliving weapon");
+        tickWithItemForSpell("earthliving weapon");
+        tickWithItemForSpell("earthliving weapon");
+
+        engine->addStrategy("totems");
+        tick();
+        tick();
+        tick();
+        tick();
+
+        assertActions(">S:water shield>S:earthliving weapon>S:flametongue weapon>S:frostbrand weapon>S:rockbiter weapon>S:mana spring totem>S:strength of earth totem>S:flametongue totem>S:windfury totem");
+    }
+
+    void interruptSpell()
+    {
+        tickWithTargetIsCastingNonMeleeSpell();
+
+		assertActions(">T:wind shear");
+    }
+
+	void dispel()
+	{
+		tickWithTargetAuraToDispel(DISPEL_MAGIC);
+
+		assertActions(">T:purge");
+	}
+
+	void cure()
+	{
+		tickWithAuraToDispel(DISPEL_CURSE);
+		spellAvailable("cleanse spirit");
+		tickWithAuraToDispel(DISPEL_DISEASE);
+        spellAvailable("cleanse spirit");
+		tickWithAuraToDispel(DISPEL_POISON);
+        spellAvailable("cleanse spirit");
+
+        tickWithPartyAuraToDispel(DISPEL_CURSE);
+		spellAvailable("cleanse spirit");
+		tickWithPartyAuraToDispel(DISPEL_DISEASE);
+        spellAvailable("cleanse spirit");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+        spellAvailable("cleanse spirit");
+
+		assertActions(">S:cleanse spirit>S:cleanse spirit>S:cleanse spirit>P:cleanse spirit curse on party>P:cleanse spirit disease on party>P:cleanse spirit poison on party");
+	}
+
+	void lowMana()
+	{
+	    tickWithLowMana(1);
+		assertActions(">S:mana tide totem");
+	}
+
+    void range()
+    {
+        tickOutOfSpellRange();
+
+        assertActions(">T:reach spell");
+    }
+
+    void aoe()
+    {
+        tickWithAttackerCount(3);
+
+        assertActions(">S:healing stream totem");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HealShamanTestCase );
diff --git a/src/test/HolyPriestTestCase.cpp b/src/test/HolyPriestTestCase.cpp
new file mode 100644
index 0000000..2c50e66
--- /dev/null
+++ b/src/test/HolyPriestTestCase.cpp
@@ -0,0 +1,62 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+
+using namespace ai;
+
+
+class HolyPriestTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HolyPriestTestCase );
+    CPPUNIT_TEST( combat );
+	CPPUNIT_TEST( incompatibles );
+	CPPUNIT_TEST( flee );
+	CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PriestAiObjectContext(ai), "holy", NULL);
+
+        addAura("power word: fortitude");
+        addAura("divine spirit");
+        addAura("inner fire");
+        addPartyAura("power word: fortitude");
+        addPartyAura("divine spirit");
+    }
+
+protected:
+    void combat()
+    {
+		tick();
+		tick();
+		tick();
+
+		assertActions(">T:holy fire>T:smite>T:shoot");
+    }
+
+    void flee()
+    {
+        tickInMeleeRange();
+        tickInMeleeRange();
+
+        assertActions(">S:fade>S:flee");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("shadow", "holy", NULL);
+
+        CPPUNIT_ASSERT_EQUAL(engine->ListStrategies(), string("Strategies: holy"));
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HolyPriestTestCase );
diff --git a/src/test/HunterNonCombatTestCase.cpp b/src/test/HunterNonCombatTestCase.cpp
new file mode 100644
index 0000000..8133e9c
--- /dev/null
+++ b/src/test/HunterNonCombatTestCase.cpp
@@ -0,0 +1,74 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/hunter/HunterAiObjectContext.h"
+
+using namespace ai;
+
+
+class HunterNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HunterNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( lowMana );
+    CPPUNIT_TEST( summonPet );
+	CPPUNIT_TEST( buffIfPackUnavailable );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new HunterAiObjectContext(ai), "nc", NULL);
+
+        set<uint8>("attacker count", 0);
+    }
+
+protected:
+    void buff()
+    {
+		engine->addStrategy("bspeed");
+
+		tick();
+        addAura("aspect of the pack");
+        tick();
+
+        engine->addStrategy("bdps");
+		tickWithAttackerCount(1);
+
+        assertActions(">S:aspect of the pack>S:trueshot aura>S:aspect of the hawk");
+    }
+
+    void lowMana()
+    {
+        addAura("trueshot aura");
+
+        engine->addStrategy("bmana");
+
+		tick();
+        addAura("aspect of the viper");
+
+        assertActions(">S:aspect of the viper");
+    }
+
+    void summonPet()
+    {
+        tickWithNoPet();
+
+		tickWithPetDead();
+		tickWithPetLowHealth(30);
+
+		assertActions(">S:call pet>S:revive pet>Pet:mend pet");
+	}
+
+    void buffIfPackUnavailable()
+    {
+		engine->addStrategy("bspeed");
+
+        tickWithSpellUnavailable("aspect of the pack");
+
+		assertActions(">S:aspect of the cheetah");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HunterNonCombatTestCase );
diff --git a/src/test/KiteTestCase.cpp b/src/test/KiteTestCase.cpp
new file mode 100644
index 0000000..f835f31
--- /dev/null
+++ b/src/test/KiteTestCase.cpp
@@ -0,0 +1,39 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "EngineTestBase.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class KiteTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( KiteTestCase );
+    CPPUNIT_TEST( kite );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+	virtual void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new WarriorAiObjectContext(ai), "tank", NULL);
+
+		engine->addStrategy("kite");
+        set<float>("distance", "current target", 0.0f);
+		
+		addAura("battle shout");
+		addAura("defensive stance");
+    }
+ 
+protected:
+    void kite()
+    {
+        set<bool>("has aggro", "current target", true);
+		tick();
+
+        assertActions(">S:runaway");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( KiteTestCase );
diff --git a/src/test/LootObjectStackTestCase.cpp b/src/test/LootObjectStackTestCase.cpp
new file mode 100644
index 0000000..1cf2426
--- /dev/null
+++ b/src/test/LootObjectStackTestCase.cpp
@@ -0,0 +1,52 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+#include "../../plugins/playerbot/LootObjectStack.h"
+
+using namespace ai;
+using namespace std;
+
+class LootObjectStackTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( LootObjectStackTestCase );
+      CPPUNIT_TEST( duplicates );
+      CPPUNIT_TEST( shrink );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void duplicates()
+	{
+	    LootTargetList data;
+	    data.insert(LootTarget(ObjectGuid(uint64(2))));
+	    data.insert(LootTarget(ObjectGuid(uint64(2))));
+
+	    CPPUNIT_ASSERT(data.size() == 1);
+	}
+
+	void shrink()
+	{
+	    LootTargetList data;
+	    LootTarget t1 = LootTarget(ObjectGuid(uint64(2)));
+	    t1.asOfTime = 10;
+	    LootTarget t2 = LootTarget(ObjectGuid(uint64(3)));
+	    t2.asOfTime = 5;
+
+	    data.insert(t1);
+	    data.insert(t2);
+	    CPPUNIT_ASSERT(data.size() == 2);
+
+	    data.shrink(7);
+        CPPUNIT_ASSERT(data.size() == 1);
+	    CPPUNIT_ASSERT(data.begin()->asOfTime == 10);
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( LootObjectStackTestCase );
diff --git a/src/test/MageNonCombatTestCase.cpp b/src/test/MageNonCombatTestCase.cpp
new file mode 100644
index 0000000..14d0dea
--- /dev/null
+++ b/src/test/MageNonCombatTestCase.cpp
@@ -0,0 +1,87 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+
+using namespace ai;
+
+
+class MageNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( MageNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( bdps );
+    CPPUNIT_TEST( bmana );
+    CPPUNIT_TEST( dispel );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new MageAiObjectContext(ai), "nc", NULL);
+		set<uint8>("item count", "food", 1);
+		set<uint8>("item count", "drink", 1);
+    }
+
+protected:
+    void buff()
+    {
+		tick();
+        addAura("arcane intellect");
+
+		tickWithSpellAvailable("arcane intellect");
+        addPartyAura("arcane intellect");
+
+		tickWithNoDrink();
+		tickWithNoFood();
+
+        assertActions(">S:arcane intellect>P:arcane intellect on party>S:conjure water>S:conjure food");
+    }
+
+    void bmana()
+    {
+        engine->addStrategy("bmana");
+
+        addAura("arcane intellect");
+        addPartyAura("arcane intellect");
+
+        tick();
+        tick();
+        tick();
+
+        assertActions(">S:mage armor>S:ice armor>S:frost armor");
+    }
+
+    void bdps()
+    {
+        engine->addStrategy("bdps");
+
+        addAura("arcane intellect");
+        addPartyAura("arcane intellect");
+
+        tick();
+        tick();
+        tick();
+        tick();
+
+        assertActions(">S:molten armor>S:mage armor>S:ice armor>S:frost armor");
+    }
+
+    void dispel()
+    {
+        addAura("arcane intellect");
+        addPartyAura("arcane intellect");
+        addAura("mage armor");
+
+        tickWithAuraToDispel(DISPEL_CURSE);
+
+        spellAvailable("remove curse");
+        tickWithPartyAuraToDispel(DISPEL_CURSE);
+
+        assertActions(">S:remove curse>P:remove curse on party");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( MageNonCombatTestCase );
diff --git a/src/test/MeleeShamanTestCase.cpp b/src/test/MeleeShamanTestCase.cpp
new file mode 100644
index 0000000..e05bbcd
--- /dev/null
+++ b/src/test/MeleeShamanTestCase.cpp
@@ -0,0 +1,109 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+
+using namespace ai;
+
+
+class MeleeShamanTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( MeleeShamanTestCase );
+    CPPUNIT_TEST( combat );
+	CPPUNIT_TEST( buff );
+	CPPUNIT_TEST( incompatibles );
+    CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST( boost );
+    CPPUNIT_TEST( interruptSpell );
+    CPPUNIT_TEST( interrupt_enemy_healer );
+    CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new ShamanAiObjectContext(ai), "melee", NULL);
+
+        addAura("lightning shield");
+    }
+
+protected:
+    void combat()
+    {
+		tickInMeleeRange();
+
+        tick();
+        tick();
+        addTargetAura("earth shock");
+
+        tick();
+		tick();
+		tick();
+
+        assertActions(">S:searing totem>T:earth shock>T:flame shock>T:stormstrike>T:lava lash>T:melee");
+    }
+
+    void buff()
+    {
+        engine->addStrategy("bdps");
+        removeAura("lightning shield");
+        tickInMeleeRange();
+
+        tick();
+        addAura("lightning shield");
+
+        tickWithItemForSpell("windfury weapon");
+        tickWithItemForSpell("windfury weapon");
+
+        assertActions(">S:lightning shield>S:searing totem>S:windfury weapon>S:rockbiter weapon");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("melee", "dps", "heal", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: heal");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("melee aoe");
+
+        tickInMeleeRange();
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+
+        assertActions(">S:searing totem>S:strength of earth totem>S:magma totem>T:fire nova");
+    }
+
+    void boost()
+    {
+        tickWithBalancePercent(1);
+        tickWithBalancePercent(1);
+
+        assertActions(">S:heroism>S:bloodlust");
+    }
+
+    void interruptSpell()
+    {
+        tickWithTargetIsCastingNonMeleeSpell();
+
+        assertActions(">T:wind shear");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("wind shear");
+
+        assertActions(">H:wind shear on enemy healer");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( MeleeShamanTestCase );
diff --git a/src/test/MockAiObjectContext.cpp b/src/test/MockAiObjectContext.cpp
new file mode 100644
index 0000000..10918ee
--- /dev/null
+++ b/src/test/MockAiObjectContext.cpp
@@ -0,0 +1,114 @@
+#include "pch.h"
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+
+using namespace std;
+using namespace ai;
+
+class MockTrigger : public Trigger
+{
+public:
+    MockTrigger(PlayerbotAI* const ai) : Trigger(ai)
+    {
+    }
+
+public:
+    virtual Event Check()
+    {
+        Event copy = event;
+        event = Event();
+        return copy;
+    }
+
+    virtual void ExternalEvent(string param, Player* owner = NULL)
+    {
+        this->event = Event("mock", param);
+    }
+
+private:
+    Event event;
+};
+
+class MockAction : public Action
+{
+public:
+    MockAction(PlayerbotAI* const ai, string* buffer, string  name) : Action(ai, name), buffer(buffer)
+    {
+
+    }
+
+    virtual bool Execute(Event event)
+    {
+        buffer->append(">");
+        buffer->append(getName());
+        if (event.getParam().empty())
+            return true;
+
+        buffer->append("(");
+        buffer->append(event.getParam());
+        buffer->append(")");
+        return true;
+    }
+
+    virtual bool ExecuteResult()
+    {
+        buffer->append(getName());
+        return true;
+    }
+
+private:
+    string* buffer;
+};
+
+MockAiObjectContext::MockAiObjectContext(PlayerbotAI* const ai, AiObjectContext *realContext, string* buffer) :
+    AiObjectContext(ai), buffer(buffer), realContext(realContext)
+{
+}
+
+void MockAiObjectContext::reportNotFound(string  what, string  name)
+{
+    std::cout << "\n===\n";
+    cout << what << " " << name << " not found in context";
+    std::cout << "\n===\n";
+}
+
+Strategy* MockAiObjectContext::GetStrategy(string  name)
+{
+    if (!realContext->GetStrategy(name))
+    {
+        reportNotFound("Strategy", name);
+        CPPUNIT_ASSERT(false);
+    }
+
+    return realContext->GetStrategy(name);
+}
+
+Trigger* MockAiObjectContext::GetTrigger(string  name)
+{
+    if (!realContext->GetTrigger(name))
+    {
+        reportNotFound("Trigger", name);
+        CPPUNIT_ASSERT(false);
+    }
+
+    Trigger* trigger = triggers[name];
+    if (trigger)
+        return trigger;
+
+    return triggers[name] = new MockTrigger(ai);
+}
+
+Action* MockAiObjectContext::GetAction(string  name)
+{
+    if (!realContext->GetAction(name))
+    {
+        reportNotFound("Action", name);
+        CPPUNIT_ASSERT(false);
+    }
+
+    Action* action = actions[name];
+    if (action)
+        return action;
+
+    return actions[name] = new MockAction(ai, buffer, name);
+}
diff --git a/src/test/MockAiObjectContext.h b/src/test/MockAiObjectContext.h
new file mode 100644
index 0000000..e63b4f0
--- /dev/null
+++ b/src/test/MockAiObjectContext.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "string "
+
+using namespace std;
+
+#include "MockedTargets.h"
+
+namespace ai
+{
+    class MockAiObjectContext : public AiObjectContext
+    {
+    public:
+        MockAiObjectContext(PlayerbotAI* const ai, AiObjectContext *realContext, string* buffer);
+    
+    public:
+        virtual Strategy* GetStrategy(string  name);
+        virtual Trigger* GetTrigger(string  name);
+        virtual Action* GetAction(string  name);
+
+    private:
+        void reportNotFound(string  what, string  name);
+
+	private:
+		string* buffer;
+        AiObjectContext *realContext;
+        map<string , Trigger*> triggers;
+        map<string , Action*> actions;
+    };
+
+}
\ No newline at end of file
diff --git a/src/test/MockPlayerbotAIBase.cpp b/src/test/MockPlayerbotAIBase.cpp
new file mode 100644
index 0000000..faaae89
--- /dev/null
+++ b/src/test/MockPlayerbotAIBase.cpp
@@ -0,0 +1,79 @@
+#include "pch.h"
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+#include "MockedTargets.h"
+
+using namespace std;
+using namespace ai;
+
+void MockPlayerbotAIBase::InterruptSpell()
+{
+}
+
+void MockPlayerbotAIBase::RemoveAura(string name)
+{
+    Unit* target = MockedTargets::GetSelf();
+    if (HasAura(name, target)) {
+        auras[target].remove(name);
+        buffer.append(">-");
+        buffer.append(name);
+    }
+}
+
+bool MockPlayerbotAIBase::CanCastSpell(string name, Unit* target)
+{
+    for (list<string >::iterator i = spellCooldowns.begin(); i != spellCooldowns.end(); i++)
+    {
+        string s = *i;
+        if (s == name)
+            return false;
+    }
+    return true;
+}
+
+bool MockPlayerbotAIBase::IsSpellCastUseful(string name, Unit* target)
+{
+    return true;
+}
+
+bool MockPlayerbotAIBase::CastSpell(string name, Unit* target)
+{
+    buffer.append(">");
+    if (target == MockedTargets::GetPartyMember())
+        buffer.append("P:");
+    if (target == MockedTargets::GetCurrentTarget())
+        buffer.append("T:");
+    if (target == MockedTargets::GetSelf())
+        buffer.append("S:");
+    if (target == MockedTargets::GetPet())
+        buffer.append("Pet:");
+    if (target == MockedTargets::GetCc())
+        buffer.append("Cc:");
+    buffer.append(name);
+
+    spellCooldowns.push_back(name);
+    auras[target].push_back(name);
+
+    return true;
+}
+
+bool MockPlayerbotAIBase::HasAura(string spellName, Unit* player)
+{
+    for (list<string >::iterator i = auras[player].begin(); i != auras[player].end(); i++)
+    {
+        string s = *i;
+        if (s == spellName)
+            return TRUE;
+    }
+    return false;
+
+}
+bool MockPlayerbotAIBase::IsInterruptableSpellCasting(Unit* player, string spell)
+{
+    return targetIsCastingNonMeleeSpell;
+}
+
+bool MockPlayerbotAIBase::HasAuraToDispel(Unit* player, uint32 dispelType)
+{
+    return dispels[player] == dispelType;
+}
diff --git a/src/test/MockPlayerbotAIBase.h b/src/test/MockPlayerbotAIBase.h
new file mode 100644
index 0000000..f3bc5bd
--- /dev/null
+++ b/src/test/MockPlayerbotAIBase.h
@@ -0,0 +1,41 @@
+#pragma once
+
+#include "MockedTargets.h"
+
+namespace ai
+{
+	class MockPlayerbotAIBase : public PlayerbotAI
+	{
+	public:
+		MockPlayerbotAIBase() : PlayerbotAI() 
+        {
+            targetIsCastingNonMeleeSpell = false;
+        }
+        void SetContext(AiObjectContext* context) { this->aiObjectContext = context; }
+	
+        virtual uint32 GetSpellId(string args) { return 1; }
+        virtual void InterruptSpell();
+        virtual void RemoveAura(string name);
+        virtual bool CanCastSpell(string name, Unit* target);
+        virtual bool CastSpell(string name, Unit* target);
+        virtual bool HasAura(string spellName, Unit* player);
+        virtual bool IsInterruptableSpellCasting(Unit* player, string spell);
+        virtual bool HasAuraToDispel(Unit* player, uint32 dispelType);
+        virtual bool IsSpellCastUseful(string name, Unit* target);
+
+    public:
+        void resetSpells() {spellCooldowns.clear(); }
+
+    public:
+        string buffer;
+
+    public:
+        list<string > spellCooldowns;
+
+        map<Unit*, list<string >> auras;
+        map<Unit*, uint32> dispels;
+
+        bool targetIsCastingNonMeleeSpell;
+    };
+
+}
diff --git a/src/test/MockedAiObjectContextTestCase.h b/src/test/MockedAiObjectContextTestCase.h
new file mode 100644
index 0000000..1a68a33
--- /dev/null
+++ b/src/test/MockedAiObjectContextTestCase.h
@@ -0,0 +1,54 @@
+#include "MockAiObjectContext.h"
+
+using namespace ai;
+
+
+class MockedAiObjectContextTestCase : public EngineTestBase
+{
+  
+protected:
+    MockAiObjectContext* context;
+
+
+protected:
+    void assertCommand(string  trigger)
+    {
+        assertCommand(trigger, trigger);
+    }
+
+    void assertCommand(string  trigger, string  expectedAction)
+    {
+        ai->buffer.clear();
+
+        context->GetTrigger(trigger)->ExternalEvent("");
+        tick();
+
+        assertActions(string(">S:") + expectedAction);
+    }
+
+    void assertParametrizedCommand(string  trigger, string  param)
+    {
+        ai->buffer.clear();
+
+        context->GetTrigger(trigger)->ExternalEvent(param);
+        tick();
+
+        assertActions(string (">S:") + trigger + "(" + param + ")");
+    }
+
+    void trigger(string  name)
+    {
+        context->GetTrigger(name)->ExternalEvent("");
+    }
+
+    void trigger(string  name, string  param)
+    {
+        context->GetTrigger(name)->ExternalEvent(param);
+    }
+
+    void tickWithTrigger(string  name)
+    {
+        trigger(name);
+        tick();
+    }
+};
diff --git a/src/test/MockedTargets.h b/src/test/MockedTargets.h
new file mode 100644
index 0000000..812b670
--- /dev/null
+++ b/src/test/MockedTargets.h
@@ -0,0 +1,65 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    class MockedTargets
+    {
+	public:
+		static Unit* GetPartyMember() { return (Unit*)1; }
+		static Unit* GetCurrentTarget()  { return (Unit*)7; }
+		static Player* GetSelf() { return (Player*)9; }
+		static Unit* GetPet() { return (Unit*)10; }
+		static Player* GetMaster() { return (Player*)2; }
+        static Player* GetTargetForDps() { return (Player*)3; }
+        static Player* GetTargetForTank() { return (Player*)4; }
+        static Player* GetCc() { return (Player*)12; }
+		static Player* GetLineTarget() { return (Player*)14; }
+		static Unit* GetLeastHpTarget() { return (Unit*)15; }
+		static Unit* GetLeastHpPartyMember() { return (Unit*)16; }
+		static Unit* GetRtiTarget() { return (Unit*)17; }
+		static Unit* GetDuelTarget() { return (Unit*)18; }
+		static Unit* GetGridTarget() { return (Unit*)19; }
+		static Unit* GetEnemyPlayer() { return (Unit*)20; }
+		static Unit* GetAttackerWithoutAura() { return (Unit*)21; }
+		static Unit* GetEnemyHealer() { return (Unit*)22; }
+
+        static void Append(string &buffer, Unit* unit)
+        {
+            if (unit == GetPartyMember())
+                buffer.append("P");
+            if (unit == GetCurrentTarget())
+                buffer.append("T");
+            if (unit == GetSelf())
+                buffer.append("S");
+            if (unit == GetPet())
+                buffer.append("Pet");
+            if (unit == GetMaster())
+                buffer.append("M");
+            if (unit == GetTargetForDps())
+                buffer.append("Dps");
+            if (unit == GetTargetForTank())
+                buffer.append("Tank");
+            if (unit == GetCc())
+                buffer.append("Cc");
+            if (unit == GetLineTarget())
+                buffer.append("Line");
+            if (unit == GetLeastHpTarget())
+                buffer.append("LeastHp");
+            if (unit == GetRtiTarget())
+                buffer.append("Rti");
+            if (unit == GetDuelTarget())
+                buffer.append("Duel");
+            if (unit == GetGridTarget())
+                buffer.append("Grind");
+            if (unit == GetEnemyPlayer())
+                buffer.append("Enemy");
+            if (unit == GetAttackerWithoutAura())
+                buffer.append("A");
+            if (unit == GetEnemyHealer())
+                buffer.append("H");
+        }
+   };
+
+}
diff --git a/src/test/NextActionTestCase.cpp b/src/test/NextActionTestCase.cpp
new file mode 100644
index 0000000..be94d98
--- /dev/null
+++ b/src/test/NextActionTestCase.cpp
@@ -0,0 +1,82 @@
+#include "pch.h"
+
+#include "aitest.h"
+
+using namespace ai;
+
+class NextActionTestCase : public CPPUNIT_NS::TestFixture
+{
+	CPPUNIT_TEST_SUITE( NextActionTestCase );
+	CPPUNIT_TEST( array );
+    CPPUNIT_TEST( clone );
+    CPPUNIT_TEST( merge );
+    CPPUNIT_TEST( cloneNull );
+    CPPUNIT_TEST( mergeWithNull );
+	CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+    void array()
+    {
+        NextAction** actions = NextAction::array(0, new NextAction("1", 1), NULL);
+        CPPUNIT_ASSERT(actions[0]->getName() == "1");
+        CPPUNIT_ASSERT(!actions[1]);
+        NextAction::destroy(actions);
+    }
+
+	void clone()
+	{
+		NextAction** actions = new NextAction*[3];
+        actions[0] = new NextAction("1", 1);
+        actions[1] = new NextAction("2", 2);
+        actions[2] = NULL;
+
+        NextAction** cloned = NextAction::clone(actions);
+
+		CPPUNIT_ASSERT(!cloned[2]);
+		CPPUNIT_ASSERT(cloned[0]->getName() == "1");
+        CPPUNIT_ASSERT(cloned[1]->getName() == "2");
+
+        // check memory
+        NextAction::destroy(cloned);
+	}
+
+    void merge()
+    {
+        NextAction** left = NextAction::array(0, new NextAction("1", 1),  new NextAction("2", 2), NULL);
+        NextAction** right = NextAction::array(0, new NextAction("3", 3), NULL);
+
+        NextAction** merged = NextAction::merge(left, right);
+
+        CPPUNIT_ASSERT(!merged[3]);
+        CPPUNIT_ASSERT(merged[0]->getName() == "1");
+        CPPUNIT_ASSERT(merged[1]->getName() == "2");
+        CPPUNIT_ASSERT(merged[2]->getName() == "3");
+
+        // check memory
+        NextAction::destroy(merged);
+    }
+
+    void cloneNull()
+    {
+        NextAction** cloned = NextAction::clone(NULL);
+        CPPUNIT_ASSERT(!cloned);
+    }
+
+    void mergeWithNull()
+    {
+        NextAction** left = NextAction::array(0, new NextAction("1", 1), NULL);
+        NextAction** merged = NextAction::merge(left, NULL);
+
+        CPPUNIT_ASSERT(!merged[1]);
+        CPPUNIT_ASSERT(merged[0]->getName() == "1");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( NextActionTestCase );
diff --git a/src/test/NonCombatEngineTestCase.cpp b/src/test/NonCombatEngineTestCase.cpp
new file mode 100644
index 0000000..a065e1f
--- /dev/null
+++ b/src/test/NonCombatEngineTestCase.cpp
@@ -0,0 +1,290 @@
+#include "pch.h"
+#include "aitest.h"
+
+#include "EngineTestBase.h"
+
+using namespace ai;
+
+
+class NonCombatEngineTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( NonCombatEngineTestCase );
+      CPPUNIT_TEST( stay );
+      CPPUNIT_TEST( eatDrink );
+      CPPUNIT_TEST( dpsAssist );
+      CPPUNIT_TEST( tankAssist );
+      CPPUNIT_TEST( attackWeak );
+      CPPUNIT_TEST( doNotGrindIfLowMpHp );
+      CPPUNIT_TEST( grindIfNoMana );
+      CPPUNIT_TEST( attackRti );
+      CPPUNIT_TEST( loot );
+      CPPUNIT_TEST( loot_failed );
+      CPPUNIT_TEST( gather );
+      CPPUNIT_TEST( runaway );
+      CPPUNIT_TEST( passive );
+      CPPUNIT_TEST( movementStrategies );
+      CPPUNIT_TEST( assistStrategies );
+      CPPUNIT_TEST( out_of_react );
+      CPPUNIT_TEST( tell_target );
+      CPPUNIT_TEST( pvp );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+	void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new AiObjectContext(ai), NULL);
+	}
+
+protected:
+    void runaway()
+    {
+        engine->addStrategy("runaway");
+		tickWithAttackerCount(0);
+		tickInMeleeRange();
+        assertActions(">S:runaway>S:runaway");
+    }
+
+    void stay()
+    {
+		engine->addStrategy("stay");
+
+		tickWithAttackerCount(0);
+		assertActions(">S:stay");
+    }
+
+    void dpsAssist()
+    {
+        engine->addStrategy("stay");
+        engine->addStrategy("dps assist");
+
+		tick();
+		tickWithNoTarget();
+
+		assertActions(">S:stay>Dps:dps assist");
+    }
+
+
+	void tankAssist()
+	{
+		engine->addStrategy("stay");
+		engine->addStrategy("tank assist");
+
+		tick();
+		tickWithNoTarget();
+
+		assertActions(">S:stay>Tank:tank assist");
+	}
+
+	void attackRti()
+	{
+		engine->addStrategy("stay");
+		engine->addStrategy("attack rti");
+
+		tick();
+		tickWithNoTarget();
+
+		assertActions(">S:stay>Rti:attack rti target");
+	}
+
+	void attackWeak()
+	{
+		engine->addStrategy("stay");
+		engine->addStrategy("attack weak");
+
+		set<Unit*>("current target", MockedTargets::GetLeastHpTarget());
+		tick();
+
+		tickWithNoTarget();
+
+		set<Unit*>("current target", MockedTargets::GetCurrentTarget()); // means any other
+		tick();
+
+		assertActions(">S:stay>LeastHp:attack least hp target>LeastHp:attack least hp target");
+	}
+
+	void pvp()
+	{
+		engine->addStrategy("stay");
+		engine->addStrategy("pvp");
+
+        set<Unit*>("current target", MockedTargets::GetEnemyPlayer());
+		tick();
+
+		tickWithNoTarget();
+
+		set<Unit*>("current target", MockedTargets::GetCurrentTarget()); // means any other
+		tick();
+
+		assertActions(">S:stay>Enemy:attack enemy player>Enemy:attack enemy player");
+	}
+
+    void loot()
+    {
+		engine->addStrategy("stay");
+		engine->addStrategy("loot");
+
+		tickWithLootAvailable();
+
+        set<float>("distance", "loot target", 15.0f);
+        tick();
+
+        set<float>("distance", "loot target", 0.0f);
+        set<bool>("can loot", true);
+        tick();
+
+        set<bool>("can loot", false);
+        tick();
+
+        set<uint8>("bag space", 99);
+        tickWithLootAvailable();
+        set<uint8>("bag space", 0);
+
+        assertActions(">S:loot>S:move to loot>S:open loot>S:stay>S:check mount state");
+    }
+
+    void loot_failed()
+    {
+		engine->addStrategy("follow");
+		engine->addStrategy("loot");
+
+		tickWithLootAvailable();
+
+        set<float>("distance", "loot target", 15.0f);
+        tick();
+        set<float>("distance", "loot target", 0.0f);
+
+        set<bool>("can loot", true);
+        tick();
+
+        spellAvailable("open loot");
+        tick();
+
+        assertActions(">S:loot>S:move to loot>S:open loot>S:open loot");
+    }
+
+    void gather()
+    {
+		engine->addStrategy("stay");
+		engine->addStrategy("gather");
+		engine->addStrategy("loot");
+
+		set<list<ObjectGuid>>("possible targets", list<ObjectGuid>());
+		tick();
+
+        tickWithLootAvailable();
+
+        set<bool>("can loot", true);
+        tick();
+
+        assertActions(">S:add gathering loot>S:loot>S:open loot");
+    }
+
+    void eatDrink()
+    {
+        engine->addStrategy("food");
+        set<uint8>("item count", "food", 1);
+        set<uint8>("item count", "drink", 1);
+
+        tickWithLowHealth(1);
+        tickWithLowMana(1);
+
+        assertActions(">S:food>S:drink");
+    }
+
+    void passive()
+    {
+        engine->addStrategy("stay");
+        engine->addStrategy("passive");
+
+        tick();
+		tickWithNoTarget();
+
+        assertActions(">S:stay>S:check mount state");
+    }
+
+    void movementStrategies()
+    {
+        engine->addStrategy("follow");
+        engine->addStrategy("follow line");
+        engine->addStrategy("be near");
+        engine->addStrategy("runaway");
+        engine->addStrategy("stay");
+
+        cout << engine->ListStrategies();
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: stay");
+    }
+
+    void assistStrategies()
+    {
+        engine->addStrategy("dps assist");
+        engine->addStrategy("tank asssist");
+        engine->addStrategy("dps aoe");
+        engine->addStrategy("tank asssist");
+        engine->addStrategy("grind");
+
+        cout << engine->ListStrategies();
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: grind");
+    }
+
+    void out_of_react()
+    {
+        engine->addStrategy("follow");
+        set<float>("distance", "master target", 100.0f / 2 + 10);
+        tick();
+        assertActions(">S:tell out of react range");
+    }
+
+    void tell_target()
+    {
+        engine->addStrategy("tell target");
+        set<Unit*>("old target", MockedTargets::GetPet());
+        tick();
+        set<Unit*>("current target", NULL);
+        tick();
+        assertActions(">S:tell target");
+    }
+
+    void doNotGrindIfLowMpHp()
+    {
+        engine->addStrategy("stay");
+        engine->addStrategy("grind");
+        context->GetValue<Unit*>("grind target")->Set(MockedTargets::GetGridTarget());
+
+        tick();
+        set<uint8>("health", "self target", 1);
+        tickWithNoTarget();
+        set<uint8>("health", "self target", 100);
+        set<uint8>("mana", "self target", 1);
+        tickWithNoTarget();
+
+        set<uint8>("health", "self target", 100);
+        set<uint8>("mana", "self target", 100);
+        tickWithNoTarget();
+
+        set<uint8>("health", "self target", 1);
+        set<bool>("combat", "self target", true);
+        tickWithNoTarget();
+
+        set<bool>("combat", "self target", false);
+        tickWithNoTarget();
+
+        assertActions(">S:stay>S:check mount state>S:check mount state>Grind:attack anything>Grind:attack anything>S:check mount state");
+    }
+
+    void grindIfNoMana()
+    {
+        engine->addStrategy("stay");
+        engine->addStrategy("grind");
+        context->GetValue<Unit*>("grind target")->Set(MockedTargets::GetGridTarget());
+
+        tick();
+        set<uint8>("health", "self target", 100);
+        set<uint8>("mana", "self target", 0);
+        tickWithNoTarget();
+
+        assertActions(">S:stay>Grind:attack anything");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( NonCombatEngineTestCase );
diff --git a/src/test/NonCombatEngineTestCase2.cpp b/src/test/NonCombatEngineTestCase2.cpp
new file mode 100644
index 0000000..e053286
--- /dev/null
+++ b/src/test/NonCombatEngineTestCase2.cpp
@@ -0,0 +1,42 @@
+#include "pch.h"
+#include "aitest.h"
+
+#include "EngineTestBase.h"
+#include "MockedAiObjectContextTestCase.h"
+
+using namespace ai;
+
+
+class NonCombatEngineTestCase2 : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( NonCombatEngineTestCase2 );
+      CPPUNIT_TEST( emote );
+      CPPUNIT_TEST( ready_check );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+	void setUp()
+	{
+		EngineTestBase::setUp();
+        setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "emote", NULL);
+	}
+
+protected:
+    void emote()
+    {
+        tickWithTrigger("random");
+        tickWithTrigger("seldom");
+
+        assertActions(">S:emote>S:suggest what to do");
+    }
+
+    void ready_check()
+    {
+        engine->addStrategy("ready check");
+        tickWithTrigger("timer");
+
+        assertActions(">S:ready check");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( NonCombatEngineTestCase2 );
diff --git a/src/test/PaladinNonCombatTestCase.cpp b/src/test/PaladinNonCombatTestCase.cpp
new file mode 100644
index 0000000..31c5bcb
--- /dev/null
+++ b/src/test/PaladinNonCombatTestCase.cpp
@@ -0,0 +1,97 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h"
+
+using namespace ai;
+
+
+class PaladinNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( PaladinNonCombatTestCase );
+        CPPUNIT_TEST( buff );
+		CPPUNIT_TEST( resurrect );
+		CPPUNIT_TEST( healing );
+        CPPUNIT_TEST( curePoison );
+        CPPUNIT_TEST( cureMagic );
+        CPPUNIT_TEST( cureDisease );
+    CPPUNIT_TEST_SUITE_END();
+
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PaladinAiObjectContext(ai), "nc", NULL);
+
+        set<uint8>("attacker count", 0);
+    }
+
+protected:
+    void buff()
+    {
+        tick();
+
+        engine->addStrategy("bspeed");
+        set<bool>("mounted", "self target", true);
+		tick();
+        set<bool>("mounted", "self target", false);
+
+		assertActions(">P:blessing of kings on party>S:crusader aura");
+    }
+
+	void resurrect()
+	{
+		tickWithDeadPartyMember();
+		assertActions(">P:redemption");
+	}
+
+    void healing()
+    {
+        tickWithLowHealth(50);
+        tickWithLowHealth(30);
+
+        spellAvailable("flash of light");
+        spellAvailable("holy light");
+        tickWithPartyLowHealth(50);
+        tickWithPartyLowHealth(30);
+
+        assertActions(">S:flash of light>S:holy light>P:flash of light on party>P:holy light on party");
+    }
+
+
+    void cureDisease()
+    {
+        cureKind(DISPEL_DISEASE);
+        assertActions(">S:cleanse>P:cleanse disease on party>S:purify>P:purify disease on party");
+    }
+
+    void curePoison()
+    {
+        cureKind(DISPEL_POISON);
+        assertActions(">S:cleanse>P:cleanse poison on party>S:purify>P:purify poison on party");
+    }
+
+    void cureMagic()
+    {
+        cureKind(DISPEL_MAGIC);
+        assertActions(">S:cleanse>P:cleanse magic on party>P:blessing of kings on party>S:check mount state");
+    }
+
+    void cureKind(DispelType type)
+    {
+        spellAvailable("cleanse");
+        tickWithAuraToDispel(type);
+
+        spellAvailable("cleanse");
+        tickWithPartyAuraToDispel(type);
+
+        spellAvailable("purify");
+        tickWithAuraToDispel(type);
+
+        spellAvailable("purify");
+        tickWithPartyAuraToDispel(type);
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( PaladinNonCombatTestCase );
diff --git a/src/test/PerformanceTestCase.cpp b/src/test/PerformanceTestCase.cpp
new file mode 100644
index 0000000..0113db1
--- /dev/null
+++ b/src/test/PerformanceTestCase.cpp
@@ -0,0 +1,177 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "EngineTestBase.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/hunter/HunterAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
+
+using namespace ai;
+
+#define MAX_TICKS 20
+
+class EverythingFailedActionExecutionListener : public ActionExecutionListener
+{
+public:
+    EverythingFailedActionExecutionListener(MockPlayerbotAIBase *ai) : ai(ai) {}
+
+    virtual bool Before(Action* action, Event event)
+    {
+        string name = action->getName();
+        if (name == "melee" ||
+                name == "shoot" ||
+                name == "auto shot" ||
+                name == "reach melee" ||
+                name == "reach spell")
+            return true;
+
+        return false;
+    }
+
+    virtual bool AllowExecution(Action* action, Event event) { return false; }
+    virtual bool OverrideResult(Action* action, bool executed, Event event) { return executed; }
+    virtual void After(Action* action, bool executed, Event event) {}
+
+private:
+    MockPlayerbotAIBase *ai;
+};
+
+
+
+class PerformanceTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( PerformanceTestCase );
+        CPPUNIT_TEST( druidBear );
+        CPPUNIT_TEST( druidCat );
+        CPPUNIT_TEST( paladin );
+        CPPUNIT_TEST( warrior );
+        CPPUNIT_TEST( warlock );
+        CPPUNIT_TEST( priest );
+        CPPUNIT_TEST( mage );
+        CPPUNIT_TEST( hunter );
+        CPPUNIT_TEST( shaman );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new AiObjectContext(ai), "melee", NULL);
+    }
+
+protected:
+    void run()
+    {
+        time_t timestamp = time(0);
+        int i = 0;
+        for (; i<sPlayerbotAIConfig.iterationsPerTick; ++i)
+        {
+            tick();
+
+            if (!ai->buffer.empty())
+                break;
+        }
+
+        CPPUNIT_ASSERT(!ai->buffer.empty());
+
+        cout << ai->buffer << " - " << i << "ticks, time: " << (time(0) - timestamp);
+    }
+
+    void druidBear()
+    {
+        setupEngine(new DruidAiObjectContext(ai), "tank", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void paladin()
+    {
+        setupEngine(new PaladinAiObjectContext(ai), "tank", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void priest()
+    {
+        setupEngine(new PriestAiObjectContext(ai), "heal", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void mage()
+    {
+        setupEngine(new MageAiObjectContext(ai), "frost", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void hunter()
+    {
+        setupEngine(new HunterAiObjectContext(ai), "dps", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void warrior()
+    {
+        setupEngine(new WarriorAiObjectContext(ai), "tank", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void druidCat()
+    {
+        setupEngine(new DruidAiObjectContext(ai), "cat", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void warlock()
+    {
+        setupEngine(new WarlockAiObjectContext(ai), "dps", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void shaman()
+    {
+        setupEngine(new ShamanAiObjectContext(ai), "melee", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( PerformanceTestCase );
diff --git a/src/test/PriestNonCombatTestCase.cpp b/src/test/PriestNonCombatTestCase.cpp
new file mode 100644
index 0000000..584c403
--- /dev/null
+++ b/src/test/PriestNonCombatTestCase.cpp
@@ -0,0 +1,112 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+
+using namespace ai;
+
+
+class PriestNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( PriestNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( healing );
+    CPPUNIT_TEST( aoe_heal );
+    CPPUNIT_TEST( nonCombat );
+    CPPUNIT_TEST( dispel );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PriestAiObjectContext(ai), "nc", NULL);
+
+        addAura("power word: fortitude");
+        addPartyAura("power word: fortitude");
+        addAura("divine spirit");
+        addAura("inner fire");
+        addPartyAura("power word: fortitude");
+        addPartyAura("divine spirit");
+    }
+
+protected:
+    void nonCombat()
+    {
+		tickWithDeadPartyMember();
+
+		assertActions(">P:resurrection");
+    }
+
+    void aoe_heal()
+    {
+        tickWithAoeHeal("medium");
+
+		assertActions(">P:circle of healing");
+    }
+
+    void healing()
+    {
+		tickWithLowHealth(30);
+
+		spellAvailable("flash heal");
+		tickWithPartyLowHealth(30);
+
+		tickWithLowHealth(10);
+		addAura("power word: shield");
+		tickWithLowHealth(10);
+
+		spellAvailable("power word: shield");
+		spellAvailable("greater heal");
+		tickWithPartyLowHealth(10);
+        addPartyAura("power word: shield");
+		tickWithPartyLowHealth(10);
+
+		assertActions(">S:flash heal>P:flash heal on party>S:power word: shield>S:greater heal>P:power word: shield on party>P:greater heal on party");
+    }
+
+    void buff()
+    {
+		removeAura("power word: fortitude");
+        removeAura("divine spirit");
+        removeAura("inner fire");
+        removePartyAura("power word: fortitude");
+        removePartyAura("divine spirit");
+
+        tick();
+        addAura("divine spirit");
+
+        tickWithSpellAvailable("divine spirit");
+        addPartyAura("divine spirit");
+
+        tick();
+        addAura("power word: fortitude");
+
+        tickWithSpellAvailable("power word: fortitude");
+        addPartyAura("power word: fortitude");
+
+        tick();
+
+		assertActions(">S:divine spirit>P:divine spirit on party>S:power word: fortitude>P:power word: fortitude on party>S:inner fire");
+    }
+
+    void dispel()
+    {
+        tickWithAuraToDispel(DISPEL_DISEASE);
+        tickWithAuraToDispel(DISPEL_DISEASE);
+
+        spellAvailable("abolish disease");
+        spellAvailable("cure disease");
+        tickWithPartyAuraToDispel(DISPEL_DISEASE);
+        tickWithPartyAuraToDispel(DISPEL_DISEASE);
+
+        tickWithAuraToDispel(DISPEL_MAGIC);
+
+        spellAvailable("dispel magic");
+        tickWithPartyAuraToDispel(DISPEL_MAGIC);
+
+		assertActions(">S:abolish disease>S:cure disease>P:abolish disease on party>P:cure disease on party>S:dispel magic>P:dispel magic on party");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( PriestNonCombatTestCase );
diff --git a/src/test/QualifiedValueTestCase.cpp b/src/test/QualifiedValueTestCase.cpp
new file mode 100644
index 0000000..6406e68
--- /dev/null
+++ b/src/test/QualifiedValueTestCase.cpp
@@ -0,0 +1,84 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class TestQualifiedValue : public ManualSetValue<string >, public Qualified
+{
+public:
+    TestQualifiedValue(PlayerbotAI* ai) : ManualSetValue<string >(ai, "", "name"), Qualified() {}
+    virtual string Get() { return qualifier; }
+};
+
+class TestQualifiedValueContext : public NamedObjectContext<UntypedValue>
+{
+public:
+    TestQualifiedValueContext()
+    {
+        creators["value"] = &TestQualifiedValueContext::value;
+    }
+
+private:
+    static UntypedValue* value(PlayerbotAI* ai) { return new TestQualifiedValue(ai); }
+};
+
+class TestQualifiedValueAiObjectContext : public AiObjectContext
+{
+public:
+    TestQualifiedValueAiObjectContext(PlayerbotAI* const ai) : AiObjectContext(ai)
+    {
+        valueContexts.Add(new TestQualifiedValueContext());
+    }
+};
+
+
+class QualifiedValueTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( QualifiedValueTestCase );
+      CPPUNIT_TEST( empty );
+      CPPUNIT_TEST( qualifier );
+      CPPUNIT_TEST( number );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+    void qualifier()
+	{
+        MockPlayerbotAIBase ai;
+        TestQualifiedValueAiObjectContext context(&ai);
+        
+        Value<string > *value = context.GetValue<string >("value", "data");
+        CPPUNIT_ASSERT(value->Get() == "data");
+	}
+
+    void empty()
+    {
+        MockPlayerbotAIBase ai;
+        TestQualifiedValueAiObjectContext context(&ai);
+
+        Value<string > *value = context.GetValue<string >("value");
+        CPPUNIT_ASSERT(value->Get().empty());
+    }
+
+    void number()
+    {
+        MockPlayerbotAIBase ai;
+        TestQualifiedValueAiObjectContext context(&ai);
+
+        Value<string > *value = context.GetValue<string >("value", 5);
+        CPPUNIT_ASSERT(value->Get() == "5");
+    
+        value = context.GetValue<string >("value", "5");
+        CPPUNIT_ASSERT(value->Get() == "5");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( QualifiedValueTestCase );
diff --git a/src/test/QuestStrategyTestCase.cpp b/src/test/QuestStrategyTestCase.cpp
new file mode 100644
index 0000000..2faf831
--- /dev/null
+++ b/src/test/QuestStrategyTestCase.cpp
@@ -0,0 +1,73 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class QuestStrategyTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( QuestStrategyTestCase );
+      CPPUNIT_TEST( turn_in_quest );
+      CPPUNIT_TEST( accept_quest );
+      CPPUNIT_TEST( quest_share );
+      CPPUNIT_TEST( useGameObject );
+      CPPUNIT_TEST( incompatibles );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "quest", NULL);
+    }
+
+protected:
+    void useGameObject()
+    {
+        trigger("use game object");
+        tick();
+
+        assertActions(">S:talk to quest giver");
+    }
+
+    void turn_in_quest()
+    {
+        trigger("complete quest");
+        tick();
+
+        trigger("gossip hello");
+        tick();
+
+        assertActions(">S:talk to quest giver>S:talk to quest giver");
+    }
+
+    void accept_quest()
+    {
+        trigger("accept quest");
+        tick();
+
+        assertActions(">S:accept quest");
+    }
+
+    void quest_share()
+    {
+        trigger("quest share");
+        tick();
+
+        assertActions(">S:accept quest share");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("quest", "accept all quests", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: accept all quests");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( QuestStrategyTestCase );
diff --git a/src/test/QueueTestCase.cpp b/src/test/QueueTestCase.cpp
new file mode 100644
index 0000000..d607bac
--- /dev/null
+++ b/src/test/QueueTestCase.cpp
@@ -0,0 +1,40 @@
+#include "pch.h"
+#include "aitest.h"
+#include "../plugins/playerbot/strategy/actions/GenericSpellActions.h"
+
+using namespace ai;
+
+class QueueTestCase : public CPPUNIT_NS::TestFixture
+{
+	CPPUNIT_TEST_SUITE( QueueTestCase );
+	CPPUNIT_TEST( queueMustHaveOrder );
+	CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void queueMustHaveOrder()
+	{
+		MockPlayerbotAIBase mock;
+		CastSpellAction action1(&mock, "1");
+        CastSpellAction action2(&mock, "2");
+        CastSpellAction action3(&mock, "3");
+
+		Queue q;
+		q.Push(new ActionBasket(new ActionNode("action1", NULL, NULL, NULL), 0.5f, false, Event()));
+		q.Push(new ActionBasket(new ActionNode("action2", NULL, NULL, NULL), 0.7f, false, Event()));
+		q.Push(new ActionBasket(new ActionNode("action3", NULL, NULL, NULL), 0.3f, false, Event()));
+
+		CPPUNIT_ASSERT(string (q.Pop()->getName()) == "action2");
+		CPPUNIT_ASSERT(string (q.Pop()->getName()) == "action1");
+		CPPUNIT_ASSERT(string (q.Pop()->getName()) == "action3");
+		CPPUNIT_ASSERT(q.Pop() == NULL);
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( QueueTestCase );
diff --git a/src/test/RacialsTestCase.cpp b/src/test/RacialsTestCase.cpp
new file mode 100644
index 0000000..240622b
--- /dev/null
+++ b/src/test/RacialsTestCase.cpp
@@ -0,0 +1,41 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "EngineTestBase.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class RacialsTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( RacialsTestCase );
+    CPPUNIT_TEST( healing );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+	virtual void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new WarriorAiObjectContext(ai), "tank", NULL);
+
+		engine->addStrategy("racials");
+        set<float>("distance", "current target", 0.0f);
+		
+		addAura("battle shout");
+		addAura("defensive stance");
+    }
+ 
+protected:
+    void healing()
+    {
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+        tickWithLowMana(39);
+
+        assertActions(">S:lifeblood>S:gift of the naaru>S:arcane torrent");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( RacialsTestCase );
diff --git a/src/test/RandomItemMgrTestCase.cpp b/src/test/RandomItemMgrTestCase.cpp
new file mode 100644
index 0000000..55afe53
--- /dev/null
+++ b/src/test/RandomItemMgrTestCase.cpp
@@ -0,0 +1,84 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../plugins/playerbot/RandomItemMgr.h"
+#include "cppunit/extensions/HelperMacros.h"
+#include "cppunit/TestFixture.h"
+
+using namespace ai;
+
+
+class RandomItemMgrTestCase : public CPPUNIT_NS::TestFixture
+{
+
+    void Show(uint32 id)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(id);
+        cout << proto->ItemId << " = " << proto->Name1 << endl;
+    }
+
+  CPPUNIT_TEST_SUITE( RandomItemMgrTestCase );
+      CPPUNIT_TEST( guildTaskItems );
+      CPPUNIT_TEST( guildTaskRewardItems );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        TC_LOG_INFO("server.loading", "Loading SpellInfo store...");
+        sSpellMgr->LoadSpellInfoStore();
+
+        TC_LOG_INFO("server.loading", "Loading SpellInfo corrections...");
+        sSpellMgr->LoadSpellInfoCorrections();
+
+        TC_LOG_INFO("server.loading", "Loading SkillLineAbilityMultiMap Data...");
+        sSpellMgr->LoadSkillLineAbilityMap();
+
+        TC_LOG_INFO("server.loading", "Loading SpellInfo custom attributes...");
+        sSpellMgr->LoadSpellInfoCustomAttributes();
+
+        TC_LOG_INFO("server.loading", "Loading Item Random Enchantments Table...");
+        LoadRandomEnchantmentsTable();
+
+        TC_LOG_INFO("server.loading", "Loading Items...");                         // must be after LoadRandomEnchantmentsTable and LoadPageTexts
+        sObjectMgr->LoadItemTemplates();
+    }
+    virtual void tearDown()
+    {
+    }
+
+protected:
+ 	void checkRandomItems(RandomItemType type)
+	{
+        RandomItemList const& list = sRandomItemMgr.Query(type, NULL);
+        CPPUNIT_ASSERT(!list.empty());
+
+        for (RandomItemList::const_iterator i = list.begin(); i != list.end(); ++i)
+        {
+            uint32 id = *i;
+            Show(id);
+        }
+
+        cout << "Picking randoms" << endl;
+
+        for (int i = 0; i < 10; i++)
+        {
+            uint32 id = sRandomItemMgr.GetRandomItem(type, NULL);
+            CPPUNIT_ASSERT(id);
+            Show(id);
+        }
+	}
+
+ 	void guildTaskItems()
+ 	{
+ 	   checkRandomItems(RANDOM_ITEM_GUILD_TASK);
+	}
+
+ 	void guildTaskRewardItems()
+ 	{
+ 	   checkRandomItems(RANDOM_ITEM_GUILD_TASK_REWARD);
+	}
+
+};
+
+//CPPUNIT_TEST_SUITE_REGISTRATION( RandomItemMgrTestCase );
diff --git a/src/test/SayStrategyTestCase.cpp b/src/test/SayStrategyTestCase.cpp
new file mode 100644
index 0000000..78b3e8e
--- /dev/null
+++ b/src/test/SayStrategyTestCase.cpp
@@ -0,0 +1,85 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/hunter/HunterAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/CustomStrategy.h"
+
+using namespace ai;
+
+
+class SayStrategyTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( SayStrategyTestCase );
+      CPPUNIT_TEST( critical_health );
+      CPPUNIT_TEST( aoe );
+      CPPUNIT_TEST( low_mana );
+      CPPUNIT_TEST( low_health );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+
+		CustomStrategy::actionLinesCache["say"] = R"(
+(NULL, 'say', 'critical health>say::critical health|99'),
+(NULL, 'say', 'low health>say::low health|99'),
+(NULL, 'say', 'low mana>say::low mana|99'),
+(NULL, 'say', 'tank aoe>say::taunt|99'),
+(NULL, 'say', 'medium aoe>say::aoe|99');
+        )";
+    }
+
+protected:
+    void critical_health()
+    {
+        setupEngine(new DruidAiObjectContext(ai), "bear", "custom::say", NULL);
+
+        addAura("dire bear form");
+        set<Unit*>("tank target", MockedTargets::GetCurrentTarget());
+
+        tickWithLowHealth(9);
+
+        assertActions(">S:say::critical health");
+    }
+
+
+    void aoe()
+    {
+        setupEngine(new HunterAiObjectContext(ai), "dps", "dps debuff", "custom::say", NULL);
+
+        addAura("aspect of the hawk");
+        set<Unit*>("tank target", MockedTargets::GetCurrentTarget());
+        tickWithAttackerCount(7);
+
+        assertActions(">S:say::aoe");
+    }
+
+
+    void low_mana()
+    {
+        setupEngine(new PriestAiObjectContext(ai), "heal", "custom::say", NULL);
+
+        set<Unit*>("tank target", MockedTargets::GetCurrentTarget());
+        tickWithLowMana(1);
+
+        assertActions(">S:say::low mana");
+    }
+
+    void low_health()
+    {
+        setupEngine(new MageAiObjectContext(ai), "frost", "custom::say", NULL);
+
+        set<Unit*>("tank target", MockedTargets::GetCurrentTarget());
+        tickWithLowHealth(39);
+
+        assertActions(">S:say::low health");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( SayStrategyTestCase );
diff --git a/src/test/ShamanNonCombatTestCase.cpp b/src/test/ShamanNonCombatTestCase.cpp
new file mode 100644
index 0000000..d0c8dc1
--- /dev/null
+++ b/src/test/ShamanNonCombatTestCase.cpp
@@ -0,0 +1,69 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+
+using namespace ai;
+
+
+class ShamanNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( ShamanNonCombatTestCase );
+        CPPUNIT_TEST( ressurect );
+        CPPUNIT_TEST( swimming );
+        CPPUNIT_TEST( healing );
+        CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new ShamanAiObjectContext(ai), "nc", NULL);
+    }
+
+protected:
+	void ressurect()
+	{
+		tickWithDeadPartyMember();
+
+		assertActions(">P:ancestral spirit");
+	}
+
+	void healing()
+	{
+	    tickWithLowHealth(10);
+	    spellAvailable("healing wave");
+	    tickWithPartyLowHealth(10);
+
+		assertActions(">S:healing wave>P:healing wave on party");
+	}
+
+	void aoe()
+	{
+	    tickWithAoeHeal("medium");
+
+		assertActions(">P:chain heal");
+	}
+
+	void swimming()
+	{
+	    tickWhileSwimming();
+	    addAura("water breathing");
+
+	    tickWhileSwimming();
+        addAura("water walking");
+
+        spellAvailable("water breathing");
+        tickWhileSwimming();
+        addPartyAura("water breathing");
+
+        spellAvailable("water walking");
+        tickWhileSwimming();
+        addPartyAura("water walking");
+
+		assertActions(">S:water breathing>S:water walking>P:water breathing on party>P:water walking on party");
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ShamanNonCombatTestCase );
diff --git a/src/test/TankPaladinTestCase.cpp b/src/test/TankPaladinTestCase.cpp
new file mode 100644
index 0000000..fc69a5d
--- /dev/null
+++ b/src/test/TankPaladinTestCase.cpp
@@ -0,0 +1,230 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h"
+
+using namespace ai;
+
+
+class TankPaladinTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( TankPaladinTestCase );
+		CPPUNIT_TEST( combatVsMelee );
+		CPPUNIT_TEST( paladinMustHoldAggro );
+		CPPUNIT_TEST( healing );
+		CPPUNIT_TEST( buff );
+		CPPUNIT_TEST( bmana );
+		CPPUNIT_TEST( curePoison );
+		CPPUNIT_TEST( cureMagic );
+		CPPUNIT_TEST( cureDisease );
+		CPPUNIT_TEST( interruptSpells );
+		CPPUNIT_TEST( resistances );
+		CPPUNIT_TEST( combatIncompatibles );
+		CPPUNIT_TEST( buffIncompatibles );
+		CPPUNIT_TEST( resistanceIncompatibles );
+		CPPUNIT_TEST( lowMana );
+		CPPUNIT_TEST( interrupt_enemy_healer );
+		CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+	virtual void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new PaladinAiObjectContext(ai), "tank", NULL);
+		engine->addStrategy("barmor");
+
+        addAura("devotion aura");
+        addAura("seal of justice");
+        addAura("blessing of sanctuary");
+        addAura("righteous fury");
+
+		addAura("holy shield");
+
+        set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+    }
+
+protected:
+    void bmana()
+    {
+		engine->removeStrategy("bhealth");
+		engine->addStrategy("bmana");
+
+        removeAura("seal of justice");
+        tick();
+
+		assertActions(">S:seal of wisdom");
+	}
+
+    void buff()
+    {
+        removeAura("devotion aura");
+        removeAura("righteous fury");
+        removeAura("blessing of sanctuary");
+        removeAura("seal of justice");
+        removeAura("holy shield");
+
+        tick();
+        addAura("devotion aura");
+
+        tick();
+        tick();
+        addAura("seal of light");
+
+        tick();
+        tick();
+        addAura("blessing of kings");
+
+        tick();
+        addAura("righteous fury");
+
+        tick();
+        addAura("holy shield");
+
+        assertActions(">S:devotion aura>S:seal of light>S:seal of justice>S:blessing of sanctuary>S:blessing of kings>S:righteous fury>S:holy shield");
+    }
+
+    void healing()
+    {
+		tickWithLowHealth(50);
+
+		tickWithLowHealth(30);
+        tickWithLowHealth(30);
+
+		tickWithLowHealth(19);
+
+		spellAvailable("lay on hands");
+		tickWithPartyLowHealth(20);
+        tickWithLowHealth(19);
+        spellAvailable("flash of light");
+        tickWithLowHealth(19);
+
+        assertActions(">S:flash of light>S:divine protection>S:holy light>S:lay on hands>P:lay on hands on party>S:divine shield>S:flash of light");
+    }
+
+    void paladinMustHoldAggro()
+    {
+		tickWithAttackerCount(2);
+		tickWithAttackerCount(2);
+
+		tickWithAttackerCount(3);
+
+		tickWithNoAggro();
+		tickWithNoAggro();
+
+		assertActions(">T:hammer of the righteous>T:avenger's shield>T:consecration>T:hand of reckoning>T:judgement of justice");
+    }
+
+    void combatVsMelee()
+    {
+		tickOutOfMeleeRange();
+
+        tick();
+
+		tickWithTargetLowHealth(19);
+
+        assertActions(">T:reach melee>T:judgement of light>T:hammer of wrath");
+    }
+
+    void lowMana()
+    {
+        tickWithLowMana(10);
+
+        assertActions(">T:judgement of wisdom");
+    }
+
+	void interruptSpells()
+	{
+		tickWithTargetIsCastingNonMeleeSpell();
+
+		assertActions(">T:hammer of justice");
+	}
+
+    void cureDisease()
+    {
+        cureKind(DISPEL_DISEASE);
+		assertActions(">S:cleanse>P:cleanse disease on party>S:purify>P:purify disease on party");
+    }
+
+	void curePoison()
+	{
+		cureKind(DISPEL_POISON);
+		assertActions(">S:cleanse>P:cleanse poison on party>S:purify>P:purify poison on party");
+	}
+
+	void cureMagic()
+	{
+        cureKind(DISPEL_MAGIC);
+        assertActions(">S:cleanse>P:cleanse magic on party>T:judgement of light>T:melee");
+	}
+
+    void cureKind(DispelType type)
+    {
+        spellAvailable("cleanse");
+        tickWithAuraToDispel(type);
+
+        spellAvailable("cleanse");
+        tickWithPartyAuraToDispel(type);
+
+        spellAvailable("purify");
+        tickWithAuraToDispel(type);
+
+        spellAvailable("purify");
+        tickWithPartyAuraToDispel(type);
+    }
+
+	void resistances()
+	{
+		engine->addStrategy("rshadow");
+		tick();
+
+		engine->addStrategy("rfrost");
+		tick();
+
+		engine->addStrategy("rfire");
+		tick();
+
+		assertActions(">S:shadow resistance aura>S:frost resistance aura>S:fire resistance aura");
+	}
+
+    void combatIncompatibles()
+    {
+        engine->removeStrategy("barmor");
+        engine->removeStrategy("tank");
+        engine->addStrategies("dps", "tank", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: tank");
+    }
+
+    void buffIncompatibles()
+    {
+        engine->removeStrategy("barmor");
+        engine->removeStrategy("tank");
+        engine->addStrategies("bhealth", "bmana", "bdps", "barmor", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: barmor");
+    }
+
+    void resistanceIncompatibles()
+    {
+        engine->removeStrategy("barmor");
+        engine->removeStrategy("tank");
+        engine->addStrategies("rshadow", "rfrost", "rfire", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: rfire");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("hammer of justice");
+
+        assertActions(">H:hammer of justice on enemy healer");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( TankPaladinTestCase );
diff --git a/src/test/TankWarlockTestCase.cpp b/src/test/TankWarlockTestCase.cpp
new file mode 100644
index 0000000..d7c9415
--- /dev/null
+++ b/src/test/TankWarlockTestCase.cpp
@@ -0,0 +1,57 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h"
+
+using namespace ai;
+
+
+class TankWarlockTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( TankWarlockTestCase );
+      CPPUNIT_TEST( summonPet );
+      CPPUNIT_TEST( cc );
+      CPPUNIT_TEST( incompatibles );
+      CPPUNIT_TEST( stress );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarlockAiObjectContext(ai), "tank", NULL);
+    }
+
+protected:
+
+    void summonPet()
+    {
+        itemAvailable("soul shard", 2);
+        tickWithNoPet();
+        tickWithNoPet();
+
+		assertActions(">S:summon felguard>S:summon voidwalker");
+    }
+
+    void cc()
+    {
+        tickWithCcTarget("banish");
+        tickWithCcTarget("fear");
+
+        assertActions(">Cc:banish on cc>Cc:fear on cc");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("tank", "dps", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: dps");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( TankWarlockTestCase );
diff --git a/src/test/TankWarriorTestCase.cpp b/src/test/TankWarriorTestCase.cpp
new file mode 100644
index 0000000..c4ad236
--- /dev/null
+++ b/src/test/TankWarriorTestCase.cpp
@@ -0,0 +1,174 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class TankWarriorTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( TankWarriorTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( startMeleeCombat );
+    CPPUNIT_TEST( melee );
+    CPPUNIT_TEST( warriorMustHoldAggro );
+    CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST( healing );
+	CPPUNIT_TEST( snare );
+    CPPUNIT_TEST( interruptSpells );
+    CPPUNIT_TEST( incompatibles );
+    CPPUNIT_TEST( interrupt_enemy_healer );
+    CPPUNIT_TEST( stress );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarriorAiObjectContext(ai), "tank", NULL);
+
+        // this buff is combat-only, so skip for most test cases
+        addAura("battle shout");
+        set<uint8>("rage", "self target", 20);
+        set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+    }
+
+protected:
+    void interruptSpells()
+    {
+		tickWithTargetIsCastingNonMeleeSpell();
+
+        tick(); // rend
+
+        assertActions(">T:shield bash>S:defensive stance");
+    }
+
+    void healing()
+    {
+        tickWithLowHealth(50); // defensive stance
+        tickWithLowHealth(50); // shield wall
+        tickWithLowHealth(50); // shield block
+
+		tickWithLowHealth(4);
+		tickWithLowHealth(4);
+
+		assertActions(">S:defensive stance>T:shield wall>S:shield block>S:last stand>T:intimidating shout");
+    }
+
+    void buff()
+    {
+        set<uint8>("rage", "self target", 0);
+        removeAura("battle shout");
+
+        tickInSpellRange();
+        addAura("battle shout");
+
+        tickInSpellRange();
+
+		assertActions(">S:battle shout>S:bloodrage");
+
+    }
+
+    void aoe()
+    {
+        addAura("defensive stance");
+
+		tickWithAttackerCount(3);
+		tickWithAttackerCount(3);
+
+		spellAvailable("cleave");
+		tickWithAttackerCount(2);
+		tickWithAttackerCount(2);
+		tickWithAttackerCount(2);
+
+        assertActions(">T:shockwave>T:thunder clap>T:demoralizing shout>T:cleave>T:devastate");
+    }
+
+    void warriorMustHoldAggro()
+    {
+        addAura("defensive stance");
+
+		tickWithNoAggro();
+		tickWithNoAggro();
+
+		assertActions(">T:taunt>T:mocking blow");
+    }
+
+    void startMeleeCombat()
+    {
+        tickOutOfMeleeRange();
+        tickWithRage(0);
+        tickInMeleeRange();
+        tick();
+        tick();
+        tick();
+
+        assertActions(">T:reach melee>S:bloodrage>S:defensive stance>T:devastate>T:revenge>T:rend");
+    }
+
+    void melee()
+    {
+        addAura("defensive stance");
+        tickInMeleeRange();
+        tick();
+        tick();
+        tick();
+        tick();
+        spellAvailable("rend");
+        addTargetAura("rend");
+
+        tickWithRage(31);
+
+        set<uint8>("rage", "self target", 41);
+        tick();
+
+        tickWithSpellAvailable("heroic strike");
+
+        addAura("sword and board");
+		tickWithSpellAvailable("devastate");
+        tickWithSpellAvailable("shield slam");
+
+		assertActions(">T:devastate>T:revenge>T:rend>T:disarm>T:sunder armor>T:melee>T:shield slam>T:heroic strike>T:melee>T:shield slam");
+    }
+
+    void revengeIfDodge()
+    {
+        tick(); // melee
+        spellAvailable("revenge");
+        tick(); // defensive stance
+        tick(); // revenge
+
+		assertActions(">T:melee>S:defensive stance>T:revenge");
+    }
+
+	void snare()
+	{
+		tick();
+		tickWithTargetIsMoving();
+
+		assertActions(">S:defensive stance>T:concussion blow");
+	}
+
+
+    void incompatibles()
+    {
+        engine->addStrategies("tank", "dps", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: dps");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("shield bash");
+
+        assertActions(">H:shield bash on enemy healer");
+    }
+
+    void stress()
+    {
+        runStressTest();
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( TankWarriorTestCase );
diff --git a/src/test/ValueTestCase.cpp b/src/test/ValueTestCase.cpp
new file mode 100644
index 0000000..aab4755
--- /dev/null
+++ b/src/test/ValueTestCase.cpp
@@ -0,0 +1,121 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class TestValue : public CalculatedValue<int>
+{
+public:
+    TestValue(PlayerbotAI* ai) : CalculatedValue<int>(ai, "name", 2), increment(0) {}
+    virtual int Calculate() { return ++increment; }
+
+private:
+    int increment;
+};
+
+class TestManualValue : public ManualSetValue<int>
+{
+public:
+    TestManualValue(PlayerbotAI* ai) : ManualSetValue<int>(ai, 0, "name") {}
+};
+
+class TestValueContext : public NamedObjectContext<UntypedValue>
+{
+public:
+    TestValueContext()
+    {
+        creators["value"] = &TestValueContext::value;
+        creators["manual value"] = &TestValueContext::manual_value;
+    }
+
+private:
+    static UntypedValue* value(PlayerbotAI* ai) { return new TestValue(ai); }
+    static UntypedValue* manual_value(PlayerbotAI* ai) { return new TestManualValue(ai); }
+};
+
+class TestValueAiObjectContext : public AiObjectContext
+{
+public:
+    TestValueAiObjectContext(PlayerbotAI* const ai) : AiObjectContext(ai)
+    {
+        valueContexts.Add(new TestValueContext());
+    }
+};
+
+
+class ValueTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( ValueTestCase );
+      CPPUNIT_TEST( empty );
+      CPPUNIT_TEST( calculate );
+      CPPUNIT_TEST( manual );
+      CPPUNIT_TEST( fromContext );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+    void empty()
+	{
+        MockPlayerbotAIBase ai;
+        TestValue value(&ai);
+        CPPUNIT_ASSERT(value == 1);
+	}
+    
+    void calculate()
+    {
+        MockPlayerbotAIBase ai;
+        TestValue value(&ai);
+
+        value.Update();
+        CPPUNIT_ASSERT(value == 1);
+        
+        value.Update();
+        CPPUNIT_ASSERT(value == 1);
+    
+        value.Update();
+        CPPUNIT_ASSERT(value == 2);
+    
+        value.Update();
+        CPPUNIT_ASSERT(value == 2);
+    }
+
+    void manual()
+    {
+        MockPlayerbotAIBase ai;
+        TestManualValue value(&ai);
+        CPPUNIT_ASSERT(value == 0);
+
+        value.Set(3);
+        CPPUNIT_ASSERT(value == 3);
+
+        value.Update();
+        CPPUNIT_ASSERT(value == 3);
+    }
+
+    void fromContext()
+    {
+        MockPlayerbotAIBase ai;
+        TestValueAiObjectContext context(&ai);
+        Value<int> *value = context.GetValue<int>("manual value");
+        CPPUNIT_ASSERT(value);
+
+        value->Set(3);
+        CPPUNIT_ASSERT(3 == value->Get());
+
+        value = context.GetValue<int>("value");
+        context.Update();
+        context.Update();
+        CPPUNIT_ASSERT(1 == value->Get());
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ValueTestCase );
diff --git a/src/test/WarlockNonCombatTestCase.cpp b/src/test/WarlockNonCombatTestCase.cpp
new file mode 100644
index 0000000..eb37021
--- /dev/null
+++ b/src/test/WarlockNonCombatTestCase.cpp
@@ -0,0 +1,50 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h"
+
+using namespace ai;
+
+
+class WarlockNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( WarlockNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarlockAiObjectContext(ai), "nc", NULL);
+    }
+
+protected:
+    void buff()
+    {
+        tick();
+        tick();
+        tick();
+        addAura("fel armor");
+
+		itemAvailable("soul shard", 2);
+		tick();
+		itemAvailable("healthstone", 1);
+
+		tick();
+		itemAvailable("firestone", 1);
+
+		tick();
+		itemAvailable("spellstone", 1);
+
+        tick();
+        addAura("spellstone");
+
+        tickWithNoPet();
+
+        assertActions(">S:fel armor>S:demon armor>S:demon skin>S:create healthstone>S:create firestone>S:create spellstone>S:spellstone>S:summon imp");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( WarlockNonCombatTestCase );
diff --git a/src/test/WarrirorNonCombatTestCase.cpp b/src/test/WarrirorNonCombatTestCase.cpp
new file mode 100644
index 0000000..b73ad56
--- /dev/null
+++ b/src/test/WarrirorNonCombatTestCase.cpp
@@ -0,0 +1,40 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class WarriorNonCombatTestCase : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( WarriorNonCombatTestCase );
+    //CPPUNIT_TEST( buff );
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    MockPlayerbotAIBase *ai;
+
+public:
+    void setUp()
+    {
+    }
+
+protected:
+    void buff()
+    {
+        ai = new MockPlayerbotAIBase();
+
+        Engine engine(ai, new WarriorAiObjectContext(ai));
+        engine.addStrategy("nc");
+        engine.Init();
+
+        engine.DoNextAction(NULL);
+        engine.DoNextAction(NULL);
+
+        std::cout << ai->buffer;
+		CPPUNIT_ASSERT(ai->buffer == ">S:defensive stance");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( WarriorNonCombatTestCase );
diff --git a/src/test/WorldPacketHandlerTestCase.cpp b/src/test/WorldPacketHandlerTestCase.cpp
new file mode 100644
index 0000000..715cace
--- /dev/null
+++ b/src/test/WorldPacketHandlerTestCase.cpp
@@ -0,0 +1,278 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class WorldPacketHandlerTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( WorldPacketHandlerTestCase );
+      CPPUNIT_TEST( groupInvite );
+      CPPUNIT_TEST( groupSetLeader );
+      CPPUNIT_TEST( notEnoughMoney );
+      CPPUNIT_TEST( notEnoughReputation );
+      CPPUNIT_TEST( gossip_hello );
+      CPPUNIT_TEST( useGameObject );
+      CPPUNIT_TEST( roll );
+      CPPUNIT_TEST( revive );
+      CPPUNIT_TEST( resurrect_request );
+      CPPUNIT_TEST( area_trigger );
+      CPPUNIT_TEST( mount );
+      CPPUNIT_TEST( taxi );
+      CPPUNIT_TEST( cannot_equip );
+      CPPUNIT_TEST( trade_status );
+      CPPUNIT_TEST( loot );
+      CPPUNIT_TEST( item_push_result );
+      CPPUNIT_TEST( quest_objective_completed );
+      CPPUNIT_TEST( party_command );
+      CPPUNIT_TEST( taxi_done );
+      CPPUNIT_TEST( ready_check );
+      CPPUNIT_TEST( uninvite );
+      CPPUNIT_TEST( lfg );
+      CPPUNIT_TEST( lfg_leave );
+      CPPUNIT_TEST( security_check );
+      CPPUNIT_TEST( guild_accept );
+      CPPUNIT_TEST( lfg_teleport );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "default", NULL);
+    }
+
+protected:
+    void groupInvite()
+    {
+        trigger("group invite");
+        tick();
+
+        assertActions(">S:accept invitation");
+    }
+    void groupSetLeader()
+    {
+        trigger("group set leader");
+        tick();
+
+        assertActions(">S:leader");
+    }
+    void notEnoughMoney()
+    {
+        trigger("not enough money");
+        tick();
+        assertActions(">S:tell not enough money");
+    }
+    void notEnoughReputation()
+    {
+        trigger("not enough reputation");
+        tick();
+        assertActions(">S:tell not enough reputation");
+    }
+
+    void useGameObject()
+    {
+        trigger("use game object");
+        tick();
+        tick();
+
+        assertActions(">S:add loot>S:use meeting stone");
+    }
+
+    void gossip_hello()
+    {
+        trigger("gossip hello");
+        tick();
+
+        assertActions(">S:trainer");
+    }
+
+    void roll()
+    {
+        trigger("loot roll");
+        tick();
+
+        assertActions(">S:loot roll");
+    }
+
+    void revive()
+    {
+        engine->addStrategy("dead");
+
+        trigger("dead");
+        tick();
+
+        assertActions(">S:revive from corpse");
+    }
+
+    void resurrect_request()
+    {
+        engine->addStrategy("dead");
+
+        trigger("resurrect request");
+        tick();
+
+        assertActions(">S:accept resurrect");
+    }
+
+    void area_trigger()
+    {
+        trigger("area trigger");
+        tick();
+        trigger("within area trigger");
+        tick();
+
+        assertActions(">S:reach area trigger>S:area trigger");
+    }
+
+    void mount()
+    {
+        trigger("check mount state");
+        tick();
+
+        assertActions(">S:check mount state");
+    }
+
+    void taxi()
+    {
+        trigger("activate taxi");
+        tick();
+        tick();
+
+        assertActions(">S:remember taxi>S:taxi");
+    }
+    void cannot_equip()
+    {
+        trigger("cannot equip");
+        tick();
+        assertActions(">S:tell cannot equip");
+    }
+
+    void trade_status()
+    {
+        trigger("trade status");
+        tick();
+        assertActions(">S:accept trade");
+    }
+
+    void loot()
+    {
+        trigger("loot response");
+        tick();
+        assertActions(">S:store loot");
+    }
+
+    void quest_objective_completed()
+    {
+        trigger("quest objective completed");
+        tick();
+
+        assertActions(">S:quest objective completed");
+    }
+
+    void item_push_result()
+    {
+        trigger("item push result");
+        tick();
+
+        assertActions(">S:query item usage");
+    }
+
+    void party_command()
+    {
+        trigger("party command");
+        tick();
+
+        assertActions(">S:party command");
+    }
+
+    void taxi_done()
+    {
+        trigger("taxi done");
+        tick();
+
+        assertActions(">S:taxi");
+    }
+
+    void ready_check()
+    {
+        trigger("ready check");
+        tick();
+
+        assertActions(">S:ready check");
+    }
+
+    void ready_check_finished()
+    {
+        trigger("ready check finished");
+        tick();
+
+        assertActions(">S:finish ready check");
+    }
+
+    void uninvite()
+    {
+        trigger("uninvite");
+        tick();
+
+        assertActions(">S:uninvite");
+    }
+
+    void lfg()
+    {
+        engine->addStrategy("lfg");
+        trigger("no possible targets");
+        tick();
+
+        trigger("lfg role check");
+        tick();
+
+        trigger("lfg proposal");
+        tick();
+
+        trigger("lfg proposal active");
+        tick();
+
+        assertActions(">S:lfg join>S:lfg role check>S:lfg accept>S:lfg accept");
+    }
+
+    void lfg_leave()
+    {
+        trigger("seldom");
+        tick();
+
+        assertActions(">S:lfg leave");
+    }
+
+    void security_check()
+    {
+        trigger("often");
+        tick();
+        tick();
+
+        assertActions(">S:security check>S:check mail");
+    }
+
+    void guild_accept()
+    {
+        trigger("guild invite");
+        tick();
+
+        assertActions(">S:guild accept");
+    }
+
+    void lfg_teleport()
+    {
+        trigger("lfg teleport");
+        tick();
+
+        assertActions(">S:lfg teleport");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( WorldPacketHandlerTestCase );
diff --git a/src/test/aitest.h b/src/test/aitest.h
new file mode 100644
index 0000000..ee45191
--- /dev/null
+++ b/src/test/aitest.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../../plugins/playerbot/PlayerbotAIAware.h"
+#include "../../plugins/playerbot/PlayerbotMgr.h"
+#include "../../plugins/playerbot/ChatHelper.h"
+#include "../../plugins/playerbot/PlayerbotAI.h"
+
+#include "../../plugins/playerbot/strategy/Action.h"
+#include "../../plugins/playerbot/strategy/ActionBasket.h"
+#include "../../plugins/playerbot/strategy/Queue.h"
+#include "../../plugins/playerbot/strategy/Trigger.h"
+#include "../../plugins/playerbot/strategy/Engine.h"
+
+#include "EngineTestBase.h"
diff --git a/src/test/cppunit/AdditionalMessage.cpp b/src/test/cppunit/AdditionalMessage.cpp
new file mode 100644
index 0000000..9f3da13
--- /dev/null
+++ b/src/test/cppunit/AdditionalMessage.cpp
@@ -0,0 +1,41 @@
+#include <cppunit/AdditionalMessage.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+AdditionalMessage::AdditionalMessage()
+{
+}
+
+
+AdditionalMessage::AdditionalMessage( const std::string &detail1 )
+{
+  if ( !detail1.empty() )
+    addDetail( detail1 );
+}
+
+
+AdditionalMessage::AdditionalMessage( const char *detail1 )
+{
+  if ( detail1  &&  !std::string( detail1 ).empty() )
+    addDetail( std::string(detail1) );
+}
+
+
+AdditionalMessage::AdditionalMessage( const Message &other )
+    : SuperClass( other )
+{
+}
+
+
+AdditionalMessage &
+AdditionalMessage::operator =( const Message &other )
+{
+  SuperClass::operator =( other );
+
+  return *this;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/AdditionalMessage.h b/src/test/cppunit/AdditionalMessage.h
new file mode 100644
index 0000000..917d754
--- /dev/null
+++ b/src/test/cppunit/AdditionalMessage.h
@@ -0,0 +1,76 @@
+#ifndef CPPUNIT_ADDITIONALMESSAGE_H
+#define CPPUNIT_ADDITIONALMESSAGE_H
+
+#include <cppunit/Message.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief An additional Message for assertions.
+ * \ingroup CreatingNewAssertions
+ *
+ * Provides a implicit constructor that takes a single string. This allow this
+ * class to be used as the message arguments in macros.
+ *
+ * The constructed object is either a Message with a single detail string if
+ * a string was passed to the macro, or a copy of the Message passed to the macro.
+ *
+ * Here is an example of usage:
+ * \code
+ * 
+ *   void checkStringEquals( const std::string &expected,
+ *                          const std::string &actual,
+ *                           const CppUnit::SourceLine &sourceLine,
+ *                           const CppUnit::AdditionalMessage &message );
+ *  
+ *   #define XTLUT_ASSERT_STRING_EQUAL_MESSAGE( expected, actual, message )  \
+ *     ::XtlUt::Impl::checkStringEquals( ::Xtl::toString(expected),        \
+ *                                       ::Xtl::toString(actual),          \
+ *                                       CPPUNIT_SOURCELINE(),             \
+ *                                       message )
+ * \endcode
+ *
+ * In the previous example, the user can specify a simple string for \a message,
+ * or a complex Message object.
+ *
+ * \see Message
+ */
+class CPPUNIT_API AdditionalMessage : public Message
+{
+public:
+  typedef Message SuperClass;
+
+  /// Constructs an empty Message.
+  AdditionalMessage();
+
+  /*! \brief Constructs a Message with the specified detail string.
+   * \param detail1 Detail string of the message. If empty, then it is not added.
+   */
+  AdditionalMessage( const std::string &detail1 );
+
+  /*! \brief Constructs a Message with the specified detail string.
+   * \param detail1 Detail string of the message. If empty, then it is not added.
+   */
+  AdditionalMessage( const char *detail1 );
+
+  /*! \brief Constructs a copy of the specified message.
+   * \param other Message to copy.
+   */
+  AdditionalMessage( const Message &other );
+
+  /*! \brief Assignment operator.
+   * \param other Message to copy.
+   * \return Reference on this object.
+   */
+  AdditionalMessage &operator =( const Message &other );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+
+
+#endif  // CPPUNIT_ADDITIONALMESSAGE_H
diff --git a/src/test/cppunit/Asserter.cpp b/src/test/cppunit/Asserter.cpp
new file mode 100644
index 0000000..a9cf95c
--- /dev/null
+++ b/src/test/cppunit/Asserter.cpp
@@ -0,0 +1,101 @@
+#include <cppunit/Asserter.h>
+#include <cppunit/Exception.h>
+#include <cppunit/Message.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+void 
+Asserter::fail( std::string message, 
+                const SourceLine &sourceLine )
+{
+  fail( Message( "assertion failed", message ), sourceLine );
+}
+
+
+void 
+Asserter::fail( const Message &message, 
+                const SourceLine &sourceLine )
+{
+  throw Exception( message, sourceLine );
+}
+
+
+void 
+Asserter::failIf( bool shouldFail, 
+                  const Message &message, 
+                  const SourceLine &sourceLine )
+{
+  if ( shouldFail )
+    fail( message, sourceLine );
+}
+
+
+void 
+Asserter::failIf( bool shouldFail, 
+                  std::string message, 
+                  const SourceLine &sourceLine )
+{
+  failIf( shouldFail, Message( "assertion failed", message ), sourceLine );
+}
+
+
+std::string 
+Asserter::makeExpected( const std::string &expectedValue )
+{
+  return "Expected: " + expectedValue;
+}
+
+
+std::string 
+Asserter::makeActual( const std::string &actualValue )
+{
+  return "Actual  : " + actualValue;
+}
+
+
+Message 
+Asserter::makeNotEqualMessage( const std::string &expectedValue,
+                               const std::string &actualValue,
+                               const AdditionalMessage &additionalMessage,
+                               const std::string &shortDescription )
+{
+  Message message( shortDescription,
+                   makeExpected( expectedValue ),
+                   makeActual( actualValue ) );
+  message.addDetail( additionalMessage );
+
+  return message;
+}
+
+
+void 
+Asserter::failNotEqual( std::string expected, 
+                        std::string actual, 
+                        const SourceLine &sourceLine,
+                        const AdditionalMessage &additionalMessage,
+                        std::string shortDescription )
+{
+  fail( makeNotEqualMessage( expected,
+                             actual,
+                             additionalMessage,
+                             shortDescription ), 
+        sourceLine );
+}
+
+
+void 
+Asserter::failNotEqualIf( bool shouldFail,
+                          std::string expected, 
+                          std::string actual, 
+                          const SourceLine &sourceLine,
+                          const AdditionalMessage &additionalMessage,
+                          std::string shortDescription )
+{
+  if ( shouldFail )
+    failNotEqual( expected, actual, sourceLine, additionalMessage, shortDescription );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/Asserter.h b/src/test/cppunit/Asserter.h
new file mode 100644
index 0000000..94dadaa
--- /dev/null
+++ b/src/test/cppunit/Asserter.h
@@ -0,0 +1,143 @@
+#ifndef CPPUNIT_ASSERTER_H
+#define CPPUNIT_ASSERTER_H
+
+#include <cppunit/AdditionalMessage.h>
+#include <cppunit/SourceLine.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Message;
+
+
+/*! \brief A set of functions to help writing assertion macros.
+ * \ingroup CreatingNewAssertions
+ *
+ * Here is an example of assertion, a simplified version of the
+ * actual assertion implemented in examples/cppunittest/XmlUniformiser.h:
+ * \code
+ * #include <cppunit/SourceLine.h>
+ * #include <cppunit/TestAssert.h>
+ * 
+ * void 
+ * checkXmlEqual( std::string expectedXml,
+ *                std::string actualXml,
+ *                CppUnit::SourceLine sourceLine )
+ * {
+ *   std::string expected = XmlUniformiser( expectedXml ).stripped();
+ *   std::string actual = XmlUniformiser( actualXml ).stripped();
+ * 
+ *   if ( expected == actual )
+ *     return;
+ * 
+ *   ::CppUnit::Asserter::failNotEqual( expected,
+ *                                      actual,
+ *                                      sourceLine );
+ * }
+ * 
+ * /// Asserts that two XML strings are equivalent.
+ * #define CPPUNITTEST_ASSERT_XML_EQUAL( expected, actual ) \
+ *     checkXmlEqual( expected, actual,                     \
+ *                    CPPUNIT_SOURCELINE() )
+ * \endcode
+ */
+struct Asserter
+{
+  /*! \brief Throws a Exception with the specified message and location.
+   */
+  static void CPPUNIT_API fail( const Message &message, 
+                                const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \deprecated Use fail( Message, SourceLine ) instead.
+   */
+  static void CPPUNIT_API fail( std::string message, 
+                                const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param message Message explaining the assertion failiure.
+   * \param sourceLine Location of the assertion.
+   */
+  static void CPPUNIT_API failIf( bool shouldFail, 
+                                  const Message &message, 
+                                  const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \deprecated Use failIf( bool, Message, SourceLine ) instead.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param message Message explaining the assertion failiure.
+   * \param sourceLine Location of the assertion.
+   */
+  static void CPPUNIT_API failIf( bool shouldFail, 
+                                  std::string message, 
+                                  const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Returns a expected value string for a message.
+   * Typically used to create 'not equal' message, or to check that a message
+   * contains the expected content when writing unit tests for your custom 
+   * assertions.
+   *
+   * \param expectedValue String that represents the expected value.
+   * \return \a expectedValue prefixed with "Expected: ".
+   * \see makeActual().
+   */
+  static std::string CPPUNIT_API makeExpected( const std::string &expectedValue );
+
+  /*! \brief Returns an actual value string for a message.
+   * Typically used to create 'not equal' message, or to check that a message
+   * contains the expected content when writing unit tests for your custom 
+   * assertions.
+   *
+   * \param actualValue String that represents the actual value.
+   * \return \a actualValue prefixed with "Actual  : ".
+   * \see makeExpected().
+   */
+  static std::string CPPUNIT_API makeActual( const std::string &actualValue );
+
+  static Message CPPUNIT_API makeNotEqualMessage( const std::string &expectedValue,
+                                                  const std::string &actualValue,
+                                                  const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                                  const std::string &shortDescription = "equality assertion failed");
+
+  /*! \brief Throws an Exception with the specified message and location.
+   * \param expected Text describing the expected value.
+   * \param actual Text describing the actual value.
+   * \param sourceLine Location of the assertion.
+   * \param additionalMessage Additional message. Usually used to report
+   *                          what are the differences between the expected and actual value.
+   * \param shortDescription Short description for the failure message.
+   */
+  static void CPPUNIT_API failNotEqual( std::string expected, 
+                                        std::string actual, 
+                                        const SourceLine &sourceLine,
+                                        const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                        std::string shortDescription = "equality assertion failed" );
+
+  /*! \brief Throws an Exception with the specified message and location.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param expected Text describing the expected value.
+   * \param actual Text describing the actual value.
+   * \param sourceLine Location of the assertion.
+   * \param additionalMessage Additional message. Usually used to report
+   *                          where the "difference" is located.
+   * \param shortDescription Short description for the failure message.
+   */
+  static void CPPUNIT_API failNotEqualIf( bool shouldFail,
+                                          std::string expected, 
+                                          std::string actual, 
+                                          const SourceLine &sourceLine,
+                                          const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                          std::string shortDescription = "equality assertion failed" );
+
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_ASSERTER_H
diff --git a/src/test/cppunit/BeOsDynamicLibraryManager.cpp b/src/test/cppunit/BeOsDynamicLibraryManager.cpp
new file mode 100644
index 0000000..b8568be
--- /dev/null
+++ b/src/test/cppunit/BeOsDynamicLibraryManager.cpp
@@ -0,0 +1,49 @@
+#include <cppunit/Portability.h>
+
+#if defined(CPPUNIT_HAVE_BEOS_DLL_LOADER)
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#include <kernel/image.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::LibraryHandle 
+DynamicLibraryManager::doLoadLibrary( const std::string &libraryName )
+{
+  return (LibraryHandle)::load_add_on( libraryName.c_str() );
+}
+
+
+void 
+DynamicLibraryManager::doReleaseLibrary()
+{
+  ::unload_add_on( (image_id)m_libraryHandle );
+}
+
+
+DynamicLibraryManager::Symbol 
+DynamicLibraryManager::doFindSymbol( const std::string &symbol )
+{
+  void *symbolPointer;
+  if ( ::get_image_symbol( (image_id)m_libraryHandle, 
+                           symbol.c_str(), 
+                           B_SYMBOL_TYPE_TEXT, 
+                           &symbolPointer ) == B_OK )
+    return symnolPointer;
+  return NULL;
+}
+
+
+std::string 
+DynamicLibraryManager::getLastErrorDetail() const
+{
+  return "";
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // defined(CPPUNIT_HAVE_BEOS_DLL_LOADER)
diff --git a/src/test/cppunit/BriefTestProgressListener.cpp b/src/test/cppunit/BriefTestProgressListener.cpp
new file mode 100644
index 0000000..c38cea0
--- /dev/null
+++ b/src/test/cppunit/BriefTestProgressListener.cpp
@@ -0,0 +1,49 @@
+#include <cppunit/BriefTestProgressListener.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/portability/Stream.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+BriefTestProgressListener::BriefTestProgressListener()
+    : m_lastTestFailed( false )
+{
+}
+
+
+BriefTestProgressListener::~BriefTestProgressListener()
+{
+}
+
+
+void 
+BriefTestProgressListener::startTest( Test *test )
+{
+  stdCOut() << test->getName();
+  stdCOut().flush();
+
+  m_lastTestFailed = false;
+}
+
+
+void 
+BriefTestProgressListener::addFailure( const TestFailure &failure )
+{
+  stdCOut() << " : " << (failure.isError() ? "error" : "assertion");
+  m_lastTestFailed  = true;
+}
+
+
+void 
+BriefTestProgressListener::endTest( Test *test )
+{
+  if ( !m_lastTestFailed )
+    stdCOut()  <<  " : OK";
+  stdCOut() << "\n";
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/BriefTestProgressListener.h b/src/test/cppunit/BriefTestProgressListener.h
new file mode 100644
index 0000000..137ca44
--- /dev/null
+++ b/src/test/cppunit/BriefTestProgressListener.h
@@ -0,0 +1,43 @@
+#ifndef CPPUNIT_BRIEFTESTPROGRESSLISTENER_H
+#define CPPUNIT_BRIEFTESTPROGRESSLISTENER_H
+
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief TestListener that prints the name of each test before running it.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API BriefTestProgressListener : public TestListener
+{
+public:
+  /*! Constructs a BriefTestProgressListener object.
+   */
+  BriefTestProgressListener();
+
+  /// Destructor.
+  virtual ~BriefTestProgressListener();
+
+  void startTest( Test *test );
+
+  void addFailure( const TestFailure &failure );
+
+  void endTest( Test *test );
+
+private:
+  /// Prevents the use of the copy constructor.
+  BriefTestProgressListener( const BriefTestProgressListener &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const BriefTestProgressListener &copy );
+
+private:
+  bool m_lastTestFailed;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_BRIEFTESTPROGRESSLISTENER_H
diff --git a/src/test/cppunit/CompilerOutputter.cpp b/src/test/cppunit/CompilerOutputter.cpp
new file mode 100644
index 0000000..8196a5f
--- /dev/null
+++ b/src/test/cppunit/CompilerOutputter.cpp
@@ -0,0 +1,216 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/Exception.h>
+#include <cppunit/SourceLine.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/CompilerOutputter.h>
+#include <algorithm>
+#include <cppunit/tools/StringTools.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+CompilerOutputter::CompilerOutputter( TestResultCollector *result,
+                                      OStream &stream,
+                                      const std::string &locationFormat )
+    : m_result( result )
+    , m_stream( stream )
+    , m_locationFormat( locationFormat )
+    , m_wrapColumn( CPPUNIT_WRAP_COLUMN )
+{
+}
+
+
+CompilerOutputter::~CompilerOutputter()
+{
+}
+
+
+void 
+CompilerOutputter::setLocationFormat( const std::string &locationFormat )
+{
+  m_locationFormat = locationFormat;
+}
+
+
+CompilerOutputter *
+CompilerOutputter::defaultOutputter( TestResultCollector *result,
+                                     OStream &stream )
+{
+  return new CompilerOutputter( result, stream );
+}
+
+
+void 
+CompilerOutputter::write()
+{
+  if ( m_result->wasSuccessful() )
+    printSuccess();
+  else
+    printFailureReport();
+}
+
+
+void 
+CompilerOutputter::printSuccess()
+{
+  m_stream  << "OK (" << m_result->runTests()  << ")\n";
+}
+
+
+void 
+CompilerOutputter::printFailureReport()
+{
+  printFailuresList();
+  printStatistics();
+}
+
+
+void 
+CompilerOutputter::printFailuresList()
+{
+  for ( int index =0; index < m_result->testFailuresTotal(); ++index)
+  {
+    printFailureDetail( m_result->failures()[ index ] );
+  }
+}
+
+
+void 
+CompilerOutputter::printFailureDetail( TestFailure *failure )
+{
+  printFailureLocation( failure->sourceLine() );
+  printFailureType( failure );
+  printFailedTestName( failure );
+  printFailureMessage( failure );
+}
+
+ 
+void 
+CompilerOutputter::printFailureLocation( SourceLine sourceLine )
+{
+  if ( !sourceLine.isValid() )
+  {
+    m_stream  <<  "##Failure Location unknown## : ";
+    return;
+  }
+
+  std::string location;
+  for ( unsigned int index = 0; index < m_locationFormat.length(); ++index )
+  {
+    char c = m_locationFormat[ index ];
+    if ( c == '%'  &&  ( index+1 < m_locationFormat.length() ) )
+    {
+      char command = m_locationFormat[index+1];
+      if ( processLocationFormatCommand( command, sourceLine ) )
+      {
+        ++index;
+        continue;
+      }
+    }
+
+    m_stream  << c;
+  }
+}
+
+
+bool 
+CompilerOutputter::processLocationFormatCommand( char command, 
+                                                 const SourceLine &sourceLine )
+{
+  switch ( command )
+  {
+  case 'p':
+    m_stream  <<  sourceLine.fileName();
+    return true;
+  case 'l':
+    m_stream  <<  sourceLine.lineNumber();
+    return true;
+  case 'f':
+    m_stream  <<  extractBaseName( sourceLine.fileName() );
+    return true;
+  }
+  
+  return false;
+}
+
+
+std::string 
+CompilerOutputter::extractBaseName( const std::string &fileName ) const
+{
+  int indexLastDirectorySeparator = fileName.find_last_of( '/' );
+  
+  if ( indexLastDirectorySeparator < 0 )
+    indexLastDirectorySeparator = fileName.find_last_of( '\\' );
+  
+  if ( indexLastDirectorySeparator < 0 )
+    return fileName;
+
+  return fileName.substr( indexLastDirectorySeparator +1 );
+}
+
+
+void 
+CompilerOutputter::printFailureType( TestFailure *failure )
+{
+  m_stream  <<  (failure->isError() ? "Error" : "Assertion");
+}
+
+
+void 
+CompilerOutputter::printFailedTestName( TestFailure *failure )
+{
+  m_stream  <<  "\nTest name: "  <<  failure->failedTestName();
+}
+
+
+void 
+CompilerOutputter::printFailureMessage( TestFailure *failure )
+{
+  m_stream  <<  "\n";
+  Exception *thrownException = failure->thrownException();
+  m_stream  << thrownException->message().shortDescription()  <<  "\n";
+
+  std::string message = thrownException->message().details();
+  if ( m_wrapColumn > 0 )
+    message = StringTools::wrap( message, m_wrapColumn );
+
+  m_stream  <<  message  <<  "\n";
+}
+
+
+void 
+CompilerOutputter::printStatistics()
+{
+  m_stream  <<  "Failures !!!\n";
+  m_stream  <<  "Run: "  <<  m_result->runTests()  << "   "
+            <<  "Failure total: "  <<  m_result->testFailuresTotal()  << "   "
+            <<  "Failures: "  <<  m_result->testFailures()  << "   "
+            <<  "Errors: "  <<  m_result->testErrors()
+            <<  "\n";
+}
+
+
+void 
+CompilerOutputter::setWrapColumn( int wrapColumn )
+{
+  m_wrapColumn = wrapColumn;
+}
+
+
+void 
+CompilerOutputter::setNoWrap()
+{
+  m_wrapColumn = 0;
+}
+
+
+int 
+CompilerOutputter::wrapColumn() const
+{
+  return m_wrapColumn;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/CompilerOutputter.h b/src/test/cppunit/CompilerOutputter.h
new file mode 100644
index 0000000..885fe65
--- /dev/null
+++ b/src/test/cppunit/CompilerOutputter.h
@@ -0,0 +1,146 @@
+#ifndef CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H
+#define CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Outputter.h>
+#include <cppunit/portability/Stream.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class Test;
+class TestFailure;
+class TestResultCollector;
+
+/*! 
+ * \brief Outputs a TestResultCollector in a compiler compatible format.
+ * \ingroup WritingTestResult
+ *
+ * Printing the test results in a compiler compatible format (assertion
+ * location has the same format as compiler error), allow you to use your
+ * IDE to jump to the assertion failure. Location format can be customized (see
+ * setLocationFormat() ).
+ *
+ * For example, when running the test in a post-build with VC++, if an assertion
+ * fails, you can jump to the assertion by pressing F4 (jump to next error).
+ *
+ * Heres is an example of usage (from examples/cppunittest/CppUnitTestMain.cpp):
+ * \code
+ * int main( int argc, char* argv[] ) {
+ *   // if command line contains "-selftest" then this is the post build check
+ *   // => the output must be in the compiler error format.
+ *   bool selfTest = (argc > 1)  &&  
+ *                   (std::string("-selftest") == argv[1]);
+ *
+ *   CppUnit::TextUi::TestRunner runner;
+ *   runner.addTest( CppUnitTest::suite() );   // Add the top suite to the test runner
+ * 
+ *  if ( selfTest )
+ *   { // Change the default outputter to a compiler error format outputter
+ *     // The test runner owns the new outputter.
+ *     runner.setOutputter( new CppUnit::CompilerOutputter( &runner.result(),
+ *                                                          std::cerr ) );
+ *   }
+ * 
+ *  // Run the test and don't wait a key if post build check.
+ *   bool wasSuccessful = runner.run( "", !selfTest );
+ * 
+ *   // Return error code 1 if the one of test failed.
+ *   return wasSuccessful ? 0 : 1;
+ * }
+ * \endcode
+ */
+class CPPUNIT_API CompilerOutputter : public Outputter
+{
+public:
+  /*! \brief Constructs a CompilerOutputter object.
+   * \param result Result of the test run.
+   * \param stream Stream used to output test result.
+   * \param locationFormat Error location format used by your compiler. Default
+   *                       to \c CPPUNIT_COMPILER_LOCATION_FORMAT which is defined
+   *                       in the configuration file. See setLocationFormat() for detail.
+   * \see setLocationFormat().
+   */
+  CompilerOutputter( TestResultCollector *result,
+                     OStream &stream,
+                     const std::string &locationFormat = CPPUNIT_COMPILER_LOCATION_FORMAT );
+
+  /// Destructor.
+  virtual ~CompilerOutputter();
+
+  /*! \brief Sets the error location format.
+   * 
+   * Indicates the format used to report location of failed assertion. This format should
+   * match the one used by your compiler.
+   *
+   * The location format is a string in which the occurence of the following character
+   * sequence are replaced:
+   *
+   * - "%l" => replaced by the line number
+   * - "%p" => replaced by the full path name of the file ("G:\prg\vc\cppunit\MyTest.cpp")
+   * - "%f" => replaced by the base name of the file ("MyTest.cpp")
+   *
+   * Some examples:
+   *
+   * - VC++ error location format: "%p(%l):" => produce "G:\prg\MyTest.cpp(43):"
+   * - GCC error location format: "%f:%l:" => produce "MyTest.cpp:43:"
+   * 
+   * Thoses are the two compilers currently <em>supported</em> (gcc format is used if
+   * VC++ is not detected). If you want your compiler to be automatically supported by
+   * CppUnit, send a mail to the mailing list (preferred), or submit a feature request
+   * that indicates how to detect your compiler with the preprocessor (\#ifdef...) and
+   * your compiler location format.
+   */
+  void setLocationFormat( const std::string &locationFormat );
+
+  /*! \brief Creates an instance of an outputter that matches your current compiler.
+   * \deprecated This class is specialized through parameterization instead of subclassing...
+   *             Use CompilerOutputter::CompilerOutputter instead.
+   */
+  static CompilerOutputter *defaultOutputter( TestResultCollector *result,
+                                              OStream &stream );
+
+  void write();
+
+  void setNoWrap();
+
+  void setWrapColumn( int wrapColumn );
+
+  int wrapColumn() const;
+
+  virtual void printSuccess();
+  virtual void printFailureReport();
+  virtual void printFailuresList();
+  virtual void printStatistics();
+  virtual void printFailureDetail( TestFailure *failure );
+  virtual void printFailureLocation( SourceLine sourceLine );
+  virtual void printFailureType( TestFailure *failure );
+  virtual void printFailedTestName( TestFailure *failure );
+  virtual void printFailureMessage( TestFailure *failure );
+
+private:
+  /// Prevents the use of the copy constructor.
+  CompilerOutputter( const CompilerOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const CompilerOutputter &copy );
+
+  virtual bool processLocationFormatCommand( char command, 
+                                             const SourceLine &sourceLine );
+
+  virtual std::string extractBaseName( const std::string &fileName ) const;
+
+private:
+  TestResultCollector *m_result;
+  OStream &m_stream;
+  std::string m_locationFormat;
+  int m_wrapColumn;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H
diff --git a/src/test/cppunit/DefaultProtector.cpp b/src/test/cppunit/DefaultProtector.cpp
new file mode 100644
index 0000000..6fb306b
--- /dev/null
+++ b/src/test/cppunit/DefaultProtector.cpp
@@ -0,0 +1,42 @@
+#include <cppunit/Exception.h>
+#include <cppunit/extensions/TypeInfoHelper.h>
+#include "DefaultProtector.h"
+
+
+CPPUNIT_NS_BEGIN
+
+
+bool 
+DefaultProtector::protect( const Functor &functor,
+                           const ProtectorContext &context )
+{
+  try
+  {
+    return functor();
+  }
+  catch ( Exception &failure )
+  {
+    reportFailure( context, failure );
+  }
+  catch ( std::exception &e )
+  {
+    std::string shortDescription( "uncaught exception of type " );
+#if CPPUNIT_USE_TYPEINFO_NAME
+    shortDescription += TypeInfoHelper::getClassName( typeid(e) );
+#else
+    shortDescription += "std::exception (or derived).";
+#endif
+    Message message( shortDescription, e.what() );
+    reportError( context, message );
+  }
+  catch ( ... )
+  {
+    reportError( context,
+                 Message( "uncaught exception of unknown type") );
+  }
+  
+  return false;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/DefaultProtector.h b/src/test/cppunit/DefaultProtector.h
new file mode 100644
index 0000000..4a76ea0
--- /dev/null
+++ b/src/test/cppunit/DefaultProtector.h
@@ -0,0 +1,27 @@
+#ifndef CPPUNIT_DEFAULTPROTECTOR_H
+#define CPPUNIT_DEFAULTPROTECTOR_H
+
+#include <cppunit/Protector.h>
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Default protector that catch all exceptions (Implementation).
+ *
+ * Implementation detail.
+ * \internal This protector catch and generate a failure for the following
+ * exception types:
+ * - Exception
+ * - std::exception
+ * - ...
+ */
+class DefaultProtector : public Protector
+{
+public:
+  bool protect( const Functor &functor,
+                const ProtectorContext &context );
+};
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_DEFAULTPROTECTOR_H
+
diff --git a/src/test/cppunit/DllMain.cpp b/src/test/cppunit/DllMain.cpp
new file mode 100644
index 0000000..51fe31e
--- /dev/null
+++ b/src/test/cppunit/DllMain.cpp
@@ -0,0 +1,16 @@
+#define WIN32_LEAN_AND_MEAN 
+#define NOGDI
+#define NOUSER
+#define NOKERNEL
+#define NOSOUND
+#define BLENDFUNCTION void    // for mingw & gcc
+
+#include <windows.h>
+
+BOOL APIENTRY 
+DllMain( HANDLE hModule, 
+         DWORD  ul_reason_for_call, 
+         LPVOID lpReserved )
+{
+  return TRUE;
+}
diff --git a/src/test/cppunit/DynamicLibraryManager.cpp b/src/test/cppunit/DynamicLibraryManager.cpp
new file mode 100644
index 0000000..e6f6294
--- /dev/null
+++ b/src/test/cppunit/DynamicLibraryManager.cpp
@@ -0,0 +1,77 @@
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+#include <cppunit/plugin/DynamicLibraryManagerException.h>
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::DynamicLibraryManager( const std::string &libraryFileName )
+    : m_libraryHandle( NULL )
+    , m_libraryName( libraryFileName )
+{
+  loadLibrary( libraryFileName );
+}
+
+
+DynamicLibraryManager::~DynamicLibraryManager()
+{
+  releaseLibrary();
+}
+
+
+DynamicLibraryManager::Symbol 
+DynamicLibraryManager::findSymbol( const std::string &symbol )
+{
+  try
+  {
+    Symbol symbolPointer = doFindSymbol( symbol );
+    if ( symbolPointer != NULL )
+      return symbolPointer;
+  }
+  catch ( ... )
+  {
+  }
+
+  throw DynamicLibraryManagerException( m_libraryName, 
+                                        symbol,
+                                        DynamicLibraryManagerException::symbolNotFound );
+  return NULL;    // keep compiler happy
+}
+
+
+void
+DynamicLibraryManager::loadLibrary( const std::string &libraryName )
+{
+  try
+  {
+    releaseLibrary();
+    m_libraryHandle = doLoadLibrary( libraryName );
+    if ( m_libraryHandle != NULL )
+      return;
+  }
+  catch (...)
+  {
+  }
+
+  throw DynamicLibraryManagerException( m_libraryName,
+                                        getLastErrorDetail(),
+                                        DynamicLibraryManagerException::loadingFailed );
+}
+
+
+void 
+DynamicLibraryManager::releaseLibrary()
+{
+  if ( m_libraryHandle != NULL )
+  {
+    doReleaseLibrary();
+    m_libraryHandle = NULL;
+  }
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/DynamicLibraryManagerException.cpp b/src/test/cppunit/DynamicLibraryManagerException.cpp
new file mode 100644
index 0000000..8498652
--- /dev/null
+++ b/src/test/cppunit/DynamicLibraryManagerException.cpp
@@ -0,0 +1,41 @@
+#include <cppunit/plugin/DynamicLibraryManagerException.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManagerException::DynamicLibraryManagerException( 
+                                         const std::string &libraryName,
+                                         const std::string &errorDetail,
+                                         Cause cause )
+    : std::runtime_error( "" ),
+      m_cause( cause )
+{
+  if ( cause == loadingFailed )
+    m_message = "Failed to load dynamic library: " + libraryName + "\n" + 
+                errorDetail;
+  else
+    m_message = "Symbol [" + errorDetail + "] not found in dynamic libary:" + 
+                libraryName;
+}
+
+
+DynamicLibraryManagerException::Cause 
+DynamicLibraryManagerException::getCause() const
+{
+  return m_cause;
+}
+
+
+const char *
+DynamicLibraryManagerException::what() const throw()
+{
+  return m_message.c_str();
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/Exception.cpp b/src/test/cppunit/Exception.cpp
new file mode 100644
index 0000000..3bbe24b
--- /dev/null
+++ b/src/test/cppunit/Exception.cpp
@@ -0,0 +1,126 @@
+#include <cppunit/Exception.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+/*!
+ * \deprecated Use SourceLine::isValid() instead.
+ */
+const std::string Exception::UNKNOWNFILENAME = "<unknown>";
+
+/*!
+ * \deprecated Use SourceLine::isValid() instead.
+ */
+const long Exception::UNKNOWNLINENUMBER = -1;
+#endif
+
+
+Exception::Exception( const Exception &other )
+   : std::exception( other )
+{ 
+  m_message = other.m_message; 
+  m_sourceLine = other.m_sourceLine;
+} 
+
+
+Exception::Exception( const Message &message, 
+                      const SourceLine &sourceLine )
+    : m_message( message )
+    , m_sourceLine( sourceLine )
+{
+}
+
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+Exception::Exception( std::string message, 
+                      long lineNumber, 
+                      std::string fileName )
+    : m_message( message )
+    , m_sourceLine( fileName, lineNumber )
+{
+}
+#endif
+
+
+Exception::~Exception() throw()
+{
+}
+
+
+Exception & 
+Exception::operator =( const Exception& other )
+{ 
+// Don't call superclass operator =(). VC++ STL implementation
+// has a bug. It calls the destructor and copy constructor of 
+// std::exception() which reset the virtual table to std::exception.
+//  SuperClass::operator =(other);
+
+  if ( &other != this )
+  {
+    m_message = other.m_message; 
+    m_sourceLine = other.m_sourceLine;
+  }
+
+  return *this; 
+}
+
+
+const char*
+Exception::what() const throw()
+{
+  Exception *mutableThis = CPPUNIT_CONST_CAST( Exception *, this );
+  mutableThis->m_whatMessage = m_message.shortDescription() + "\n" + 
+                               m_message.details();
+  return m_whatMessage.c_str();
+}
+
+
+SourceLine 
+Exception::sourceLine() const
+{
+  return m_sourceLine;
+}
+
+
+Message 
+Exception::message() const
+{
+  return m_message;
+}
+
+
+void 
+Exception::setMessage( const Message &message )
+{
+  m_message = message;
+}
+
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+long 
+Exception::lineNumber() const
+{ 
+  return m_sourceLine.isValid() ? m_sourceLine.lineNumber() : 
+                                  UNKNOWNLINENUMBER; 
+}
+
+
+std::string 
+Exception::fileName() const
+{ 
+  return m_sourceLine.isValid() ? m_sourceLine.fileName() : 
+                                  UNKNOWNFILENAME;
+}
+#endif
+
+
+Exception *
+Exception::clone() const
+{
+  return new Exception( *this );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/Exception.h b/src/test/cppunit/Exception.h
new file mode 100644
index 0000000..bf5fcac
--- /dev/null
+++ b/src/test/cppunit/Exception.h
@@ -0,0 +1,90 @@
+#ifndef CPPUNIT_EXCEPTION_H
+#define CPPUNIT_EXCEPTION_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Message.h>
+#include <cppunit/SourceLine.h>
+#include <exception>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Exceptions thrown by failed assertions.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * Exception is an exception that serves
+ * descriptive strings through its what() method
+ */
+class CPPUNIT_API Exception : public std::exception
+{
+public:
+  /*! \brief Constructs the exception with the specified message and source location.
+   * \param message Message associated to the exception.
+   * \param sourceLine Source location related to the exception.
+   */
+  Exception( const Message &message = Message(), 
+             const SourceLine &sourceLine = SourceLine() );
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+  /*!
+   * \deprecated Use other constructor instead.
+   */
+  Exception( std::string  message, 
+	     long lineNumber, 
+	     std::string fileName );
+#endif
+
+  /*! \brief Constructs a copy of an exception.
+   * \param other Exception to copy.
+   */
+  Exception( const Exception &other );
+
+  /// Destructs the exception
+  virtual ~Exception() throw();
+
+  /// Performs an assignment
+  Exception &operator =( const Exception &other );
+
+  /// Returns descriptive message
+  const char *what() const throw();
+
+  /// Location where the error occured
+  SourceLine sourceLine() const;
+
+  /// Message related to the exception.
+  Message message() const;
+
+  /// Set the message.
+  void setMessage( const Message &message );
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+  /// The line on which the error occurred
+  long lineNumber() const;
+
+  /// The file in which the error occurred
+  std::string fileName() const;
+
+  static const std::string UNKNOWNFILENAME;
+  static const long UNKNOWNLINENUMBER;
+#endif
+
+  /// Clones the exception.
+  virtual Exception *clone() const;
+
+protected:
+  // VC++ does not recognize call to parent class when prefixed
+  // with a namespace. This is a workaround.
+  typedef std::exception SuperClass;
+
+  Message m_message;
+  SourceLine m_sourceLine;
+  std::string m_whatMessage;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXCEPTION_H
+
diff --git a/src/test/cppunit/Makefile.am b/src/test/cppunit/Makefile.am
new file mode 100644
index 0000000..d5a60bf
--- /dev/null
+++ b/src/test/cppunit/Makefile.am
@@ -0,0 +1,67 @@
+#
+# $Id: Makefile.am,v 1.44 2005/06/14 21:28:46 blep Exp $
+#
+
+EXTRA_DIST = cppunit.dsp cppunit_dll.dsp DllMain.cpp
+INCLUDES = -I$(top_builddir)/include -I$(top_srcdir)/include
+
+lib_LTLIBRARIES = libcppunit.la
+
+libcppunit_la_SOURCES = \
+  AdditionalMessage.cpp \
+  Asserter.cpp \
+  BeOsDynamicLibraryManager.cpp \
+  BriefTestProgressListener.cpp \
+  CompilerOutputter.cpp \
+  DefaultProtector.h \
+  DefaultProtector.cpp \
+  DynamicLibraryManager.cpp \
+  DynamicLibraryManagerException.cpp \
+  Exception.cpp \
+  Message.cpp \
+  RepeatedTest.cpp \
+  PlugInManager.cpp \
+  PlugInParameters.cpp \
+  Protector.cpp \
+  ProtectorChain.h \
+  ProtectorContext.h \
+  ProtectorChain.cpp \
+  SourceLine.cpp \
+  StringTools.cpp \
+  SynchronizedObject.cpp \
+  Test.cpp \
+  TestAssert.cpp \
+  TestCase.cpp \
+  TestCaseDecorator.cpp \
+  TestComposite.cpp \
+  TestDecorator.cpp \
+  TestFactoryRegistry.cpp \
+  TestFailure.cpp \
+  TestLeaf.cpp \
+  TestNamer.cpp \
+  TestPath.cpp \
+  TestPlugInDefaultImpl.cpp \
+  TestResult.cpp \
+  TestResultCollector.cpp \
+  TestRunner.cpp \
+  TestSetUp.cpp \
+  TestSuccessListener.cpp \
+  TestSuite.cpp \
+  TestSuiteBuilderContext.cpp \
+  TextOutputter.cpp \
+  TextTestProgressListener.cpp \
+  TextTestResult.cpp \
+  TextTestRunner.cpp \
+  TypeInfoHelper.cpp \
+  UnixDynamicLibraryManager.cpp \
+  ShlDynamicLibraryManager.cpp \
+  XmlDocument.cpp \
+  XmlElement.cpp \
+  XmlOutputter.cpp \
+  XmlOutputterHook.cpp \
+  Win32DynamicLibraryManager.cpp
+
+libcppunit_la_LDFLAGS= \
+ -no-undefined -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
+ -release $(LT_RELEASE)
+
diff --git a/src/test/cppunit/Makefile.in b/src/test/cppunit/Makefile.in
new file mode 100644
index 0000000..aa68cb0
--- /dev/null
+++ b/src/test/cppunit/Makefile.in
@@ -0,0 +1,632 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+# $Id: Makefile.am,v 1.44 2005/06/14 21:28:46 blep Exp $
+#
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/cppunit
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libdir)"
+libLTLIBRARIES_INSTALL = $(INSTALL)
+LTLIBRARIES = $(lib_LTLIBRARIES)
+libcppunit_la_LIBADD =
+am_libcppunit_la_OBJECTS = AdditionalMessage.lo Asserter.lo \
+	BeOsDynamicLibraryManager.lo BriefTestProgressListener.lo \
+	CompilerOutputter.lo DefaultProtector.lo \
+	DynamicLibraryManager.lo DynamicLibraryManagerException.lo \
+	Exception.lo Message.lo RepeatedTest.lo PlugInManager.lo \
+	PlugInParameters.lo Protector.lo ProtectorChain.lo \
+	SourceLine.lo StringTools.lo SynchronizedObject.lo Test.lo \
+	TestAssert.lo TestCase.lo TestCaseDecorator.lo \
+	TestComposite.lo TestDecorator.lo TestFactoryRegistry.lo \
+	TestFailure.lo TestLeaf.lo TestNamer.lo TestPath.lo \
+	TestPlugInDefaultImpl.lo TestResult.lo TestResultCollector.lo \
+	TestRunner.lo TestSetUp.lo TestSuccessListener.lo TestSuite.lo \
+	TestSuiteBuilderContext.lo TextOutputter.lo \
+	TextTestProgressListener.lo TextTestResult.lo \
+	TextTestRunner.lo TypeInfoHelper.lo \
+	UnixDynamicLibraryManager.lo ShlDynamicLibraryManager.lo \
+	XmlDocument.lo XmlElement.lo XmlOutputter.lo \
+	XmlOutputterHook.lo Win32DynamicLibraryManager.lo
+libcppunit_la_OBJECTS = $(am_libcppunit_la_OBJECTS)
+libcppunit_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
+	$(CXXFLAGS) $(libcppunit_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/config
+depcomp = $(SHELL) $(top_srcdir)/config/depcomp
+am__depfiles_maybe = depfiles
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libcppunit_la_SOURCES)
+DIST_SOURCES = $(libcppunit_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+EXTRA_DIST = cppunit.dsp cppunit_dll.dsp DllMain.cpp
+INCLUDES = -I$(top_builddir)/include -I$(top_srcdir)/include
+lib_LTLIBRARIES = libcppunit.la
+libcppunit_la_SOURCES = \
+  AdditionalMessage.cpp \
+  Asserter.cpp \
+  BeOsDynamicLibraryManager.cpp \
+  BriefTestProgressListener.cpp \
+  CompilerOutputter.cpp \
+  DefaultProtector.h \
+  DefaultProtector.cpp \
+  DynamicLibraryManager.cpp \
+  DynamicLibraryManagerException.cpp \
+  Exception.cpp \
+  Message.cpp \
+  RepeatedTest.cpp \
+  PlugInManager.cpp \
+  PlugInParameters.cpp \
+  Protector.cpp \
+  ProtectorChain.h \
+  ProtectorContext.h \
+  ProtectorChain.cpp \
+  SourceLine.cpp \
+  StringTools.cpp \
+  SynchronizedObject.cpp \
+  Test.cpp \
+  TestAssert.cpp \
+  TestCase.cpp \
+  TestCaseDecorator.cpp \
+  TestComposite.cpp \
+  TestDecorator.cpp \
+  TestFactoryRegistry.cpp \
+  TestFailure.cpp \
+  TestLeaf.cpp \
+  TestNamer.cpp \
+  TestPath.cpp \
+  TestPlugInDefaultImpl.cpp \
+  TestResult.cpp \
+  TestResultCollector.cpp \
+  TestRunner.cpp \
+  TestSetUp.cpp \
+  TestSuccessListener.cpp \
+  TestSuite.cpp \
+  TestSuiteBuilderContext.cpp \
+  TextOutputter.cpp \
+  TextTestProgressListener.cpp \
+  TextTestResult.cpp \
+  TextTestRunner.cpp \
+  TypeInfoHelper.cpp \
+  UnixDynamicLibraryManager.cpp \
+  ShlDynamicLibraryManager.cpp \
+  XmlDocument.cpp \
+  XmlElement.cpp \
+  XmlOutputter.cpp \
+  XmlOutputterHook.cpp \
+  Win32DynamicLibraryManager.cpp
+
+libcppunit_la_LDFLAGS = \
+ -no-undefined -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
+ -release $(LT_RELEASE)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/cppunit/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/cppunit/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(libdir)/$$f'"; \
+	    $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(libdir)/$$f"; \
+	  else :; fi; \
+	done
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$p'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libdir)/$$p"; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libcppunit.la: $(libcppunit_la_OBJECTS) $(libcppunit_la_DEPENDENCIES) 
+	$(libcppunit_la_LINK) -rpath $(libdir) $(libcppunit_la_OBJECTS) $(libcppunit_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/AdditionalMessage.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Asserter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/BeOsDynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/BriefTestProgressListener.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/CompilerOutputter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DefaultProtector.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DynamicLibraryManagerException.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Exception.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Message.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/PlugInManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/PlugInParameters.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Protector.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ProtectorChain.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/RepeatedTest.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ShlDynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SourceLine.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StringTools.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SynchronizedObject.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Test.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestAssert.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestCase.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestCaseDecorator.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestComposite.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestDecorator.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestFactoryRegistry.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestFailure.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestLeaf.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestNamer.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestPath.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestPlugInDefaultImpl.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestResult.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestResultCollector.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestRunner.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestSetUp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestSuccessListener.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestSuite.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestSuiteBuilderContext.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextOutputter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextTestProgressListener.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextTestResult.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextTestRunner.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TypeInfoHelper.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/UnixDynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Win32DynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/XmlDocument.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/XmlElement.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/XmlOutputter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/XmlOutputterHook.Plo@am__quote@
+
+.cpp.o:
+@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cpp.lo:
+@am__fastdepCXX_TRUE@	$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(libdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am: install-libLTLIBRARIES
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libLTLIBRARIES clean-libtool ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libLTLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/Message.cpp b/src/test/cppunit/Message.cpp
new file mode 100644
index 0000000..9d6a0e9
--- /dev/null
+++ b/src/test/cppunit/Message.cpp
@@ -0,0 +1,170 @@
+#include <cppunit/Message.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+Message::Message()
+{
+}
+
+Message::Message( const Message &other )
+{
+   *this = other;
+}
+
+
+Message::Message( const std::string &shortDescription )
+    : m_shortDescription( shortDescription )
+{
+}
+
+
+Message::Message( const std::string &shortDescription,
+                  const std::string &detail1 )
+    : m_shortDescription( shortDescription )
+{
+  addDetail( detail1 );
+}
+
+
+Message::Message( const std::string &shortDescription,
+                  const std::string &detail1,
+                  const std::string &detail2 )
+    : m_shortDescription( shortDescription )
+{
+  addDetail( detail1, detail2 );
+}
+
+
+Message::Message( const std::string &shortDescription,
+                  const std::string &detail1,
+                  const std::string &detail2,
+                  const std::string &detail3 )
+    : m_shortDescription( shortDescription )
+{
+  addDetail( detail1, detail2, detail3 );
+}
+
+Message &
+Message::operator =( const Message &other )
+{
+   if ( this != &other )
+   {
+      m_shortDescription = other.m_shortDescription.c_str();
+      m_details.clear();
+      Details::const_iterator it = other.m_details.begin();
+      Details::const_iterator itEnd = other.m_details.end();
+      while ( it != itEnd )
+         m_details.push_back( (*it++).c_str() );
+   }
+
+   return *this;
+}
+
+
+const std::string &
+Message::shortDescription() const
+{
+  return m_shortDescription;
+}
+
+
+int 
+Message::detailCount() const
+{
+  return m_details.size();
+}
+
+
+std::string 
+Message::detailAt( int index ) const
+{
+  if ( index < 0  ||  index >= detailCount() )
+    throw std::invalid_argument( "Message::detailAt() : invalid index" );
+
+  return m_details[ index ];
+}
+
+
+std::string 
+Message::details() const
+{
+  std::string details;
+  for ( Details::const_iterator it = m_details.begin(); it != m_details.end(); ++it )
+  {
+    details += "- ";
+    details += *it;
+    details += '\n';
+  }
+  return details;
+}
+
+
+void 
+Message::clearDetails()
+{
+  m_details.clear();
+}
+
+
+void 
+Message::addDetail( const std::string &detail )
+{
+  m_details.push_back( detail );
+}
+
+
+void 
+Message::addDetail( const std::string &detail1,
+                    const std::string &detail2 )
+{
+  addDetail( detail1 );
+  addDetail( detail2 );
+}
+
+
+void 
+Message::addDetail( const std::string &detail1,
+                    const std::string &detail2,
+                    const std::string &detail3 )
+{
+  addDetail( detail1, detail2 );
+  addDetail( detail3 );
+}
+
+
+void 
+Message::addDetail( const Message &message )
+{
+  m_details.insert( m_details.end(), 
+                    message.m_details.begin(), 
+                    message.m_details.end() );
+}
+
+
+void 
+Message::setShortDescription( const std::string &shortDescription )
+{
+  m_shortDescription = shortDescription;
+}
+
+
+bool 
+Message::operator ==( const Message &other ) const
+{
+  return m_shortDescription == other.m_shortDescription  &&
+         m_details == other.m_details;
+}
+
+
+bool 
+Message::operator !=( const Message &other ) const
+{
+  return !( *this == other );
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/Message.h b/src/test/cppunit/Message.h
new file mode 100644
index 0000000..1ae51cc
--- /dev/null
+++ b/src/test/cppunit/Message.h
@@ -0,0 +1,156 @@
+#ifndef CPPUNIT_MESSAGE_H
+#define CPPUNIT_MESSAGE_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<std::string>;
+#endif
+
+/*! \brief Message associated to an Exception.
+ * \ingroup CreatingNewAssertions
+ *  A message is composed of two items:
+ *  - a short description (~20/30 characters)
+ *  - a list of detail strings
+ *
+ *  The short description is used to indicate how the detail strings should be
+ *  interpreted. It usually indicates the failure types, such as
+ *  "assertion failed", "forced failure", "unexpected exception caught",
+ *  "equality assertion failed"... It should not contains new line character (\n).
+ *
+ *  Detail strings are used to provide more information about the failure. It
+ *  can contains the asserted expression, the expected and actual values in an
+ *  equality assertion, some addional messages... Detail strings can contains
+ *  new line characters (\n).
+ */
+class CPPUNIT_API Message
+{
+public:
+  Message();
+
+  // Ensure thread-safe copy by detaching the string.
+  Message( const Message &other );
+
+  explicit Message( const std::string &shortDescription );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1 );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1,
+           const std::string &detail2 );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1,
+           const std::string &detail2,
+           const std::string &detail3 );
+
+  Message &operator =( const Message &other );
+
+  /*! \brief Returns the short description.
+   * \return Short description.
+   */
+  const std::string &shortDescription() const;
+
+  /*! \brief Returns the number of detail string.
+   * \return Number of detail string.
+   */
+  int detailCount() const;
+
+  /*! \brief Returns the detail at the specified index.
+   * \param index Zero based index of the detail string to return.
+   * \returns Detail string at the specified index.
+   * \exception std::invalid_argument if \a index < 0 or index >= detailCount().
+   */
+  std::string detailAt( int index ) const;
+
+  /*! \brief Returns a string that represents a list of the detail strings.
+   *
+   * Example:
+   * \code
+   * Message message( "not equal", "Expected: 3", "Actual: 7" );
+   * std::string details = message.details();
+   * // details contains:
+   * // "- Expected: 3\n- Actual: 7\n"  \endcode
+   *
+   * \return A string that is a concatenation of all the detail strings. Each detail
+   *         string is prefixed with '- ' and suffixed with '\n' before being
+   *         concatenated to the other.
+   */
+  std::string details() const;
+
+  /*! \brief Removes all detail strings.
+   */
+  void clearDetails();
+
+  /*! \brief Adds a single detail string.
+   * \param detail Detail string to add.
+   */
+  void addDetail( const std::string &detail );
+
+  /*! \brief Adds two detail strings.
+   * \param detail1 Detail string to add.
+   * \param detail2 Detail string to add.
+   */
+  void addDetail( const std::string &detail1,
+                  const std::string &detail2 );
+
+  /*! \brief Adds three detail strings.
+   * \param detail1 Detail string to add.
+   * \param detail2 Detail string to add.
+   * \param detail3 Detail string to add.
+   */
+  void addDetail( const std::string &detail1,
+                  const std::string &detail2,
+                  const std::string &detail3 );
+
+  /*! \brief Adds the detail strings of the specified message.
+   * \param message All the detail strings of this message are added to this one.
+   */
+  void addDetail( const Message &message );
+
+  /*! \brief Sets the short description.
+   * \param shortDescription New short description.
+   */
+  void setShortDescription( const std::string &shortDescription );
+
+  /*! \brief Tests if a message is identical to another one.
+   * \param other Message this message is compared to.
+   * \return \c true if the two message are identical, \c false otherwise.
+   */
+  bool operator ==( const Message &other ) const;
+
+  /*! \brief Tests if a message is different from another one.
+   * \param other Message this message is compared to.
+   * \return \c true if the two message are not identical, \c false otherwise.
+   */
+  bool operator !=( const Message &other ) const;
+
+private:
+  std::string m_shortDescription;
+
+  typedef CppUnitDeque<std::string> Details;
+  Details m_details;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_MESSAGE_H
diff --git a/src/test/cppunit/Outputter.h b/src/test/cppunit/Outputter.h
new file mode 100644
index 0000000..f31d681
--- /dev/null
+++ b/src/test/cppunit/Outputter.h
@@ -0,0 +1,26 @@
+#ifndef CPPUNIT_OUTPUTTER_H
+#define CPPUNIT_OUTPUTTER_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Abstract outputter to print test result summary.
+ * \ingroup WritingTestResult
+ */
+class CPPUNIT_API Outputter
+{
+public:
+  /// Destructor.
+  virtual ~Outputter() {}
+
+  virtual void write() =0;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_OUTPUTTER_H
diff --git a/src/test/cppunit/PlugInManager.cpp b/src/test/cppunit/PlugInManager.cpp
new file mode 100644
index 0000000..b595dee
--- /dev/null
+++ b/src/test/cppunit/PlugInManager.cpp
@@ -0,0 +1,110 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/XmlOutputterHook.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/plugin/PlugInManager.h>
+#include <cppunit/plugin/TestPlugIn.h>
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+PlugInManager::PlugInManager()
+{
+}
+
+
+PlugInManager::~PlugInManager()
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    unload( *it );
+}
+
+
+void
+PlugInManager::load( const std::string &libraryFileName,
+                     const PlugInParameters &parameters )
+{
+  PlugInInfo info;
+  info.m_fileName = libraryFileName;
+  info.m_manager = new DynamicLibraryManager( libraryFileName );
+
+  TestPlugInSignature plug = (TestPlugInSignature)info.m_manager->findSymbol( 
+        CPPUNIT_STRINGIZE( CPPUNIT_PLUGIN_EXPORTED_NAME ) );
+  info.m_interface = (*plug)();
+
+  m_plugIns.push_back( info );
+  
+  info.m_interface->initialize( &TestFactoryRegistry::getRegistry(), parameters );
+}
+
+
+void 
+PlugInManager::unload( const std::string &libraryFileName )
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+  {
+    if ( (*it).m_fileName == libraryFileName )
+    {
+      unload( *it );
+      m_plugIns.erase( it );
+      break;
+    }
+  }
+}
+
+
+void 
+PlugInManager::addListener( TestResult *eventManager )
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    (*it).m_interface->addListener( eventManager );
+}
+
+
+void 
+PlugInManager::removeListener( TestResult *eventManager )
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    (*it).m_interface->removeListener( eventManager );
+}
+
+
+void 
+PlugInManager::unload( PlugInInfo &plugIn )
+{
+  try
+  {
+    plugIn.m_interface->uninitialize( &TestFactoryRegistry::getRegistry() );
+    delete plugIn.m_manager;
+  }
+  catch (...)
+  {
+    delete plugIn.m_manager;
+    plugIn.m_manager = NULL;
+    throw;
+  }
+}
+
+
+void 
+PlugInManager::addXmlOutputterHooks( XmlOutputter *outputter )
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    (*it).m_interface->addXmlOutputterHooks( outputter );
+}
+
+
+void 
+PlugInManager::removeXmlOutputterHooks()
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    (*it).m_interface->removeXmlOutputterHooks();
+}
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/PlugInParameters.cpp b/src/test/cppunit/PlugInParameters.cpp
new file mode 100644
index 0000000..1b532f9
--- /dev/null
+++ b/src/test/cppunit/PlugInParameters.cpp
@@ -0,0 +1,28 @@
+#include <cppunit/plugin/PlugInParameters.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+CPPUNIT_NS_BEGIN
+
+
+PlugInParameters::PlugInParameters( const std::string &commandLine )
+    : m_commandLine( commandLine )
+{
+}
+
+
+PlugInParameters::~PlugInParameters()
+{
+}
+
+
+std::string 
+PlugInParameters::getCommandLine() const
+{
+  return m_commandLine;
+}
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/Portability.h b/src/test/cppunit/Portability.h
new file mode 100644
index 0000000..ddf0316
--- /dev/null
+++ b/src/test/cppunit/Portability.h
@@ -0,0 +1,177 @@
+#ifndef CPPUNIT_PORTABILITY_H
+#define CPPUNIT_PORTABILITY_H
+
+#if defined(_WIN32) && !defined(WIN32)
+# define WIN32 1
+#endif
+
+/* include platform specific config */
+#if defined(__BORLANDC__)
+#  include <cppunit/config/config-bcb5.h>
+#elif defined (_MSC_VER)
+#  if _MSC_VER == 1200 && defined(_WIN32_WCE) //evc4
+#    include <cppunit/config/config-evc4.h>
+#  else
+#    include <cppunit/config/config-msvc6.h>
+#  endif
+#else
+#    include <cppunit/config-auto.h>
+#endif
+
+// Version number of package
+#ifndef CPPUNIT_VERSION 
+#define CPPUNIT_VERSION  "1.12.0"
+#endif
+ 
+#include <cppunit/config/CppUnitApi.h>    // define CPPUNIT_API & CPPUNIT_NEED_DLL_DECL
+#include <cppunit/config/SelectDllLoader.h>
+
+
+/* Options that the library user may switch on or off.
+ * If the user has not done so, we chose default values.
+ */
+
+
+/* Define to 1 if you wish to have the old-style macros
+   assert(), assertEqual(), assertDoublesEqual(), and assertLongsEqual() */
+#if !defined(CPPUNIT_ENABLE_NAKED_ASSERT)
+# define CPPUNIT_ENABLE_NAKED_ASSERT          0
+#endif
+
+/* Define to 1 if you wish to have the old-style CU_TEST family
+   of macros. */
+#if !defined(CPPUNIT_ENABLE_CU_TEST_MACROS)
+# define CPPUNIT_ENABLE_CU_TEST_MACROS        0
+#endif
+
+/* Define to 1 if the preprocessor expands (#foo) to "foo" (quotes incl.) 
+   I don't think there is any C preprocess that does NOT support this! */
+#if !defined(CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION)
+# define CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION   1
+#endif
+
+/* Assumes that STL and CppUnit are in global space if the compiler does not
+   support namespace. */
+#if !defined(CPPUNIT_HAVE_NAMESPACES)
+# if !defined(CPPUNIT_NO_NAMESPACE)
+#  define CPPUNIT_NO_NAMESPACE 1
+# endif // !defined(CPPUNIT_NO_NAMESPACE)
+# if !defined(CPPUNIT_NO_STD_NAMESPACE)
+#  define CPPUNIT_NO_STD_NAMESPACE 1
+# endif // !defined(CPPUNIT_NO_STD_NAMESPACE)
+#endif // !defined(CPPUNIT_HAVE_NAMESPACES)
+
+/* Define CPPUNIT_STD_NEED_ALLOCATOR to 1 if you need to specify
+ * the allocator you used when instantiating STL container. Typically
+ * used for compilers that do not support template default parameter.
+ * CPPUNIT_STD_ALLOCATOR will be used as the allocator. Default is
+ * std::allocator. On some compilers, you may need to change this to
+ * std::allocator<T>.
+ */
+#if CPPUNIT_STD_NEED_ALLOCATOR
+# if !defined(CPPUNIT_STD_ALLOCATOR)
+#  define CPPUNIT_STD_ALLOCATOR std::allocator
+# endif // !defined(CPPUNIT_STD_ALLOCATOR)
+#endif // defined(CPPUNIT_STD_NEED_ALLOCATOR)
+
+
+// Compiler error location format for CompilerOutputter
+// If not define, assumes that it's gcc
+// See class CompilerOutputter for format.
+#if !defined(CPPUNIT_COMPILER_LOCATION_FORMAT)
+#if defined(__GNUC__) && ( defined(__APPLE_CPP__) || defined(__APPLE_CC__) )
+// gcc/Xcode integration on Mac OS X
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p:%l: " 
+#else
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%f:%l:"
+#endif
+#endif
+
+// If CPPUNIT_HAVE_CPP_CAST is defined, then c++ style cast will be used,
+// otherwise, C style cast are used.
+#if defined( CPPUNIT_HAVE_CPP_CAST )
+# define CPPUNIT_CONST_CAST( TargetType, pointer ) \
+    const_cast<TargetType>( pointer )
+
+# define CPPUNIT_STATIC_CAST( TargetType, pointer ) \
+    static_cast<TargetType>( pointer )
+#else // defined( CPPUNIT_HAVE_CPP_CAST )
+# define CPPUNIT_CONST_CAST( TargetType, pointer ) \
+    ((TargetType)( pointer ))
+# define CPPUNIT_STATIC_CAST( TargetType, pointer ) \
+    ((TargetType)( pointer ))
+#endif // defined( CPPUNIT_HAVE_CPP_CAST )
+
+// If CPPUNIT_NO_STD_NAMESPACE is defined then STL are in the global space.
+// => Define macro 'std' to nothing
+#if defined(CPPUNIT_NO_STD_NAMESPACE)
+# undef std
+# define std
+#endif  // defined(CPPUNIT_NO_STD_NAMESPACE)
+
+// If CPPUNIT_NO_NAMESPACE is defined, then put CppUnit classes in the
+// global namespace: the compiler does not support namespace.
+#if defined(CPPUNIT_NO_NAMESPACE)
+# define CPPUNIT_NS_BEGIN
+# define CPPUNIT_NS_END
+# define CPPUNIT_NS
+#else   // defined(CPPUNIT_NO_NAMESPACE)
+# define CPPUNIT_NS_BEGIN namespace CppUnit {
+# define CPPUNIT_NS_END }
+# define CPPUNIT_NS CppUnit
+#endif  // defined(CPPUNIT_NO_NAMESPACE)
+
+/*! Stringize a symbol.
+ * 
+ * Use this macro to convert a preprocessor symbol to a string.
+ *
+ * Example of usage:
+ * \code
+ * #define CPPUNIT_PLUGIN_EXPORTED_NAME cppunitTestPlugIn
+ * const char *name = CPPUNIT_STRINGIZE( CPPUNIT_PLUGIN_EXPORTED_NAME );
+ * \endcode
+ */
+#define CPPUNIT_STRINGIZE( symbol ) _CPPUNIT_DO_STRINGIZE( symbol )
+
+/// \internal
+#define _CPPUNIT_DO_STRINGIZE( symbol ) #symbol
+
+/*! Joins to symbol after expanding them into string.
+ *
+ * Use this macro to join two symbols. Example of usage:
+ *
+ * \code
+ * #define MAKE_UNIQUE_NAME(prefix) CPPUNIT_JOIN( prefix, __LINE__ )
+ * \endcode
+ *
+ * The macro defined in the example concatenate a given prefix with the line number
+ * to obtain a 'unique' identifier.
+ *
+ * \internal From boost documentation:
+ * The following piece of macro magic joins the two 
+ * arguments together, even when one of the arguments is
+ * itself a macro (see 16.3.1 in C++ standard).  The key
+ * is that macro expansion of macro arguments does not
+ * occur in CPPUNIT_JOIN2 but does in CPPUNIT_JOIN.
+ */
+#define CPPUNIT_JOIN( symbol1, symbol2 ) _CPPUNIT_DO_JOIN( symbol1, symbol2 )
+
+/// \internal
+#define _CPPUNIT_DO_JOIN( symbol1, symbol2 ) _CPPUNIT_DO_JOIN2( symbol1, symbol2 )
+
+/// \internal
+#define _CPPUNIT_DO_JOIN2( symbol1, symbol2 ) symbol1##symbol2
+
+/*! Adds the line number to the specified string to create a unique identifier.
+ * \param prefix Prefix added to the line number to create a unique identifier.
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION for an example of usage.
+ */
+#define CPPUNIT_MAKE_UNIQUE_NAME( prefix ) CPPUNIT_JOIN( prefix, __LINE__ )
+
+/*! Defines wrap colunm for %CppUnit. Used by CompilerOuputter.
+ */
+#if !defined(CPPUNIT_WRAP_COLUMN)
+# define CPPUNIT_WRAP_COLUMN 79
+#endif
+
+#endif // CPPUNIT_PORTABILITY_H
diff --git a/src/test/cppunit/Protector.cpp b/src/test/cppunit/Protector.cpp
new file mode 100644
index 0000000..5c171ec
--- /dev/null
+++ b/src/test/cppunit/Protector.cpp
@@ -0,0 +1,86 @@
+#include <cppunit/Exception.h>
+#include <cppunit/Message.h>
+#include <cppunit/Protector.h>
+#include <cppunit/TestResult.h>
+#include "ProtectorContext.h"
+#include <memory>
+
+CPPUNIT_NS_BEGIN
+
+Functor::~Functor()
+{
+}
+
+
+Protector::~Protector()
+{
+}
+
+
+void 
+Protector::reportError( const ProtectorContext &context,
+                        const Exception &error ) const
+{
+  std::auto_ptr<Exception> actualError( error.clone() );
+  actualError->setMessage( actualMessage( actualError->message(), context ) );
+  context.m_result->addError( context.m_test, 
+                              actualError.release() );
+}
+
+
+
+void 
+Protector::reportError( const ProtectorContext &context,
+                        const Message &message,
+                        const SourceLine &sourceLine ) const
+{
+  reportError( context, Exception( message, sourceLine ) );
+}
+
+
+void 
+Protector::reportFailure( const ProtectorContext &context,
+                          const Exception &failure ) const
+{
+  std::auto_ptr<Exception> actualFailure( failure.clone() );
+  actualFailure->setMessage( actualMessage( actualFailure->message(), context ) );
+  context.m_result->addFailure( context.m_test, 
+                                actualFailure.release() );
+}
+
+
+Message 
+Protector::actualMessage( const Message &message,
+                          const ProtectorContext &context ) const
+{
+  Message theActualMessage;
+  if ( context.m_shortDescription.empty() )
+    theActualMessage = message;
+  else
+  {
+    theActualMessage = Message( context.m_shortDescription, 
+                                message.shortDescription() );
+    theActualMessage.addDetail( message );
+  }
+
+  return theActualMessage;
+}
+
+
+
+
+ProtectorGuard::ProtectorGuard( TestResult *result,
+                                              Protector *protector )
+    : m_result( result )
+{
+  m_result->pushProtector( protector );
+}
+
+
+ProtectorGuard::~ProtectorGuard()
+{
+  m_result->popProtector();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/Protector.h b/src/test/cppunit/Protector.h
new file mode 100644
index 0000000..d14e75f
--- /dev/null
+++ b/src/test/cppunit/Protector.h
@@ -0,0 +1,94 @@
+#ifndef CPPUNIT_PROTECTOR_H
+#define CPPUNIT_PROTECTOR_H
+
+#include <cppunit/SourceLine.h>
+
+CPPUNIT_NS_BEGIN
+
+class Exception;
+class Message;
+class ProtectorContext;
+class TestResult;
+
+
+class CPPUNIT_API Functor
+{
+public:
+  virtual ~Functor();
+
+  virtual bool operator()() const =0;
+};
+
+
+/*! \brief Protects one or more test case run.
+ *
+ * Protector are used to globably 'decorate' a test case. The most common
+ * usage of Protector is to catch exception that do not subclass std::exception,
+ * such as MFC CException class or Rogue Wave RWXMsg class, and capture the
+ * message associated to the exception. In fact, CppUnit capture message from
+ * Exception and std::exception using a Protector.
+ *
+ * Protector are chained. When you add a Protector using 
+ * TestResult::pushProtector(), your protector is in fact passed as a Functor
+ * to the first protector of the chain.
+ *
+ * TestCase protects call to setUp(), runTest() and tearDown() by calling
+ * TestResult::protect().
+ *
+ * Because the protector chain is handled by TestResult, a protector can be
+ * active for a single test, or a complete test run.
+ *
+ * Here are some possible usages:
+ * - run all test case in a separate thread and assumes the test failed if it
+ *   did not finish in a given time (infinite loop work around)
+ * - performance tracing : time only the runTest() time.
+ * \sa TestResult, TestCase, TestListener.
+ */
+class CPPUNIT_API Protector
+{
+public:
+  virtual ~Protector();
+  
+  virtual bool protect( const Functor &functor,
+                        const ProtectorContext &context ) =0;
+
+protected:
+  void reportError( const ProtectorContext &context,
+                    const Exception &error ) const;
+
+  void reportError( const ProtectorContext &context,
+                    const Message &message,
+                    const SourceLine &sourceLine = SourceLine() ) const;
+
+  void reportFailure( const ProtectorContext &context,
+                      const Exception &failure ) const;
+
+  Message actualMessage( const Message &message,
+                         const ProtectorContext &context ) const;
+};
+
+
+/*! \brief Scoped protector push to TestResult.
+ *
+ * Adds the specified Protector to the specified TestResult for the object
+ * life-time.
+ */
+class CPPUNIT_API ProtectorGuard
+{
+public:
+  /// Pushes the specified protector.
+  ProtectorGuard( TestResult *result,
+                  Protector *protector );
+
+  /// Pops the protector.
+  ~ProtectorGuard();
+
+private:
+  TestResult *m_result;
+};
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_PROTECTOR_H
+
diff --git a/src/test/cppunit/ProtectorChain.cpp b/src/test/cppunit/ProtectorChain.cpp
new file mode 100644
index 0000000..f528341
--- /dev/null
+++ b/src/test/cppunit/ProtectorChain.cpp
@@ -0,0 +1,86 @@
+#include "ProtectorChain.h"
+
+CPPUNIT_NS_BEGIN
+
+
+class ProtectorChain::ProtectFunctor : public Functor
+{
+public:
+  ProtectFunctor( Protector *protector,
+                  const Functor &functor,
+                  const ProtectorContext &context )
+      : m_protector( protector )
+      , m_functor( functor )
+      , m_context( context )
+  {
+  }
+
+  bool operator()() const
+  {
+    return m_protector->protect( m_functor, m_context );
+  }
+
+private:
+  Protector *m_protector;
+  const Functor &m_functor;
+  const ProtectorContext &m_context;
+};
+
+
+ProtectorChain::~ProtectorChain()
+{
+  while ( count() > 0 )
+    pop();
+}
+
+
+void 
+ProtectorChain::push( Protector *protector )
+{
+  m_protectors.push_back( protector );
+}
+
+
+void 
+ProtectorChain::pop()
+{
+  delete m_protectors.back();
+  m_protectors.pop_back();
+}
+
+int 
+ProtectorChain::count() const
+{
+  return m_protectors.size();
+}
+
+
+bool 
+ProtectorChain::protect( const Functor &functor,
+                         const ProtectorContext &context )
+{
+  if ( m_protectors.empty() )
+    return functor();
+
+  Functors functors;
+  for ( int index = m_protectors.size()-1; index >= 0; --index )
+  {
+    const Functor &protectedFunctor = 
+              functors.empty() ? functor : *functors.back();
+
+    functors.push_back( new ProtectFunctor( m_protectors[index],
+                                            protectedFunctor, 
+                                            context ) );
+  }
+
+  const Functor &outermostFunctor = *functors.back();
+  bool succeed = outermostFunctor();
+
+  for ( unsigned int deletingIndex = 0; deletingIndex < m_protectors.size(); ++deletingIndex )
+    delete functors[deletingIndex];
+
+  return succeed;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/ProtectorChain.h b/src/test/cppunit/ProtectorChain.h
new file mode 100644
index 0000000..711b56f
--- /dev/null
+++ b/src/test/cppunit/ProtectorChain.h
@@ -0,0 +1,51 @@
+#ifndef CPPUNIT_PROTECTORCHAIN_H
+#define CPPUNIT_PROTECTORCHAIN_H
+
+#include <cppunit/Protector.h>
+#include <cppunit/portability/CppUnitDeque.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Protector chain (Implementation).
+ * Implementation detail.
+ * \internal Protector that protect a Functor using a chain of nested Protector.
+ */
+class CPPUNIT_API ProtectorChain : public Protector
+{
+public:
+  ~ProtectorChain();
+
+  void push( Protector *protector );
+
+  void pop();
+
+  int count() const;
+
+  bool protect( const Functor &functor,
+                const ProtectorContext &context );
+
+private:
+  class ProtectFunctor;
+
+private:
+  typedef CppUnitDeque<Protector *> Protectors;
+  Protectors m_protectors;
+
+  typedef CppUnitDeque<Functor *> Functors;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_PROTECTORCHAIN_H
+
diff --git a/src/test/cppunit/ProtectorContext.h b/src/test/cppunit/ProtectorContext.h
new file mode 100644
index 0000000..c3d496c
--- /dev/null
+++ b/src/test/cppunit/ProtectorContext.h
@@ -0,0 +1,38 @@
+#ifndef CPPUNIT_PROTECTORCONTEXT_H
+#define CPPUNIT_PROTECTORCONTEXT_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+class Test;
+class TestResult;
+
+
+/*! \brief Protector context (Implementation).
+ * Implementation detail.
+ * \internal Context use to report failure in Protector.
+ */
+class CPPUNIT_API ProtectorContext
+{
+public:
+  ProtectorContext( Test *test,
+                    TestResult *result,
+                    const std::string &shortDescription )
+      : m_test( test )
+      , m_result( result )
+      , m_shortDescription( shortDescription )
+  {
+  }
+
+  Test *m_test;
+  TestResult *m_result;
+  std::string m_shortDescription;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_PROTECTORCONTEXT_H
+
diff --git a/src/test/cppunit/RepeatedTest.cpp b/src/test/cppunit/RepeatedTest.cpp
new file mode 100644
index 0000000..2533ca1
--- /dev/null
+++ b/src/test/cppunit/RepeatedTest.cpp
@@ -0,0 +1,29 @@
+#include <cppunit/extensions/RepeatedTest.h>
+#include <cppunit/TestResult.h>
+
+CPPUNIT_NS_BEGIN
+
+
+// Counts the number of test cases that will be run by this test.
+int
+RepeatedTest::countTestCases() const
+{ 
+  return TestDecorator::countTestCases() * m_timesRepeat; 
+}
+
+
+// Runs a repeated test
+void 
+RepeatedTest::run( TestResult *result )
+{
+  for ( int n = 0; n < m_timesRepeat; n++ ) 
+  {
+    if ( result->shouldStop() )
+        break;
+
+    TestDecorator::run( result );
+  }
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/ShlDynamicLibraryManager.cpp b/src/test/cppunit/ShlDynamicLibraryManager.cpp
new file mode 100644
index 0000000..9f4be22
--- /dev/null
+++ b/src/test/cppunit/ShlDynamicLibraryManager.cpp
@@ -0,0 +1,53 @@
+#include <cppunit/Portability.h>
+
+#if defined(CPPUNIT_HAVE_UNIX_SHL_LOADER)
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#include <dl.h>
+#include <unistd.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::LibraryHandle 
+DynamicLibraryManager::doLoadLibrary( const std::string &libraryName )
+{
+   return ::shl_load(libraryName.c_str(), BIND_IMMEDIATE, 0L);
+}
+
+
+void 
+DynamicLibraryManager::doReleaseLibrary()
+{
+  ::shl_unload( (shl_t)m_libraryHandle);
+}
+
+
+DynamicLibraryManager::Symbol 
+DynamicLibraryManager::doFindSymbol( const std::string &symbol )
+{
+   DynamicLibraryManager::Symbol L_symaddr = 0;
+   if ( ::shl_findsym( (shl_t*)(&m_libraryHandle), 
+                       symbol.c_str(), 
+                       TYPE_UNDEFINED, 
+                       &L_symaddr ) == 0 )
+   {
+      return L_symaddr;
+   } 
+
+   return 0;
+}
+
+
+std::string 
+DynamicLibraryManager::getLastErrorDetail() const
+{
+  return "";
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // defined(CPPUNIT_HAVE_UNIX_SHL_LOADER)
diff --git a/src/test/cppunit/SourceLine.cpp b/src/test/cppunit/SourceLine.cpp
new file mode 100644
index 0000000..dfadae3
--- /dev/null
+++ b/src/test/cppunit/SourceLine.cpp
@@ -0,0 +1,81 @@
+#include <cppunit/SourceLine.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+SourceLine::SourceLine() :
+    m_lineNumber( -1 )
+{
+}
+
+
+SourceLine::SourceLine( const SourceLine &other )
+   : m_fileName( other.m_fileName.c_str() )
+   , m_lineNumber( other.m_lineNumber )
+{
+}
+
+
+SourceLine::SourceLine( const std::string &fileName,
+                        int lineNumber )
+   : m_fileName( fileName.c_str() )
+   , m_lineNumber( lineNumber )
+{
+}
+
+
+SourceLine &
+SourceLine::operator =( const SourceLine &other )
+{
+   if ( this != &other )
+   {
+      m_fileName = other.m_fileName.c_str();
+      m_lineNumber = other.m_lineNumber;
+   }
+   return *this;
+}
+
+
+SourceLine::~SourceLine()
+{
+}
+
+
+bool 
+SourceLine::isValid() const
+{
+  return !m_fileName.empty();
+}
+
+
+int 
+SourceLine::lineNumber() const
+{
+  return m_lineNumber;
+}
+
+
+std::string 
+SourceLine::fileName() const
+{
+  return m_fileName;
+}
+
+
+bool 
+SourceLine::operator ==( const SourceLine &other ) const
+{
+  return m_fileName == other.m_fileName  &&
+         m_lineNumber == other.m_lineNumber;
+}
+
+
+bool 
+SourceLine::operator !=( const SourceLine &other ) const
+{
+  return !( *this == other );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/SourceLine.h b/src/test/cppunit/SourceLine.h
new file mode 100644
index 0000000..f7a85df
--- /dev/null
+++ b/src/test/cppunit/SourceLine.h
@@ -0,0 +1,63 @@
+#ifndef CPPUNIT_SOURCELINE_H
+#define CPPUNIT_SOURCELINE_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+/*! \brief Constructs a SourceLine object initialized with the location where the macro is expanded.
+ * \ingroup CreatingNewAssertions
+ * \relates CppUnit::SourceLine
+ * Used to write your own assertion macros.
+ * \see Asserter for example of usage.
+ */
+#define CPPUNIT_SOURCELINE() CPPUNIT_NS::SourceLine( __FILE__, __LINE__ )
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Represents a source line location.
+ * \ingroup CreatingNewAssertions
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * Used to capture the failure location in assertion.
+ * 
+ * Use the CPPUNIT_SOURCELINE() macro to construct that object. Typically used when
+ * writing an assertion macro in association with Asserter.
+ *
+ * \see Asserter.
+ */
+class CPPUNIT_API SourceLine
+{
+public:
+  SourceLine();
+
+  // Ensure thread-safe copy by detaching the string buffer.
+  SourceLine( const SourceLine &other );
+
+  SourceLine( const std::string &fileName,
+              int lineNumber );
+
+  SourceLine &operator =( const SourceLine &other );
+
+  /// Destructor.
+  virtual ~SourceLine();
+
+  bool isValid() const;
+
+  int lineNumber() const;
+
+  std::string fileName() const;
+
+  bool operator ==( const SourceLine &other ) const;
+  bool operator !=( const SourceLine &other ) const;
+
+private:
+  std::string m_fileName;
+  int m_lineNumber;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_SOURCELINE_H
diff --git a/src/test/cppunit/StringTools.cpp b/src/test/cppunit/StringTools.cpp
new file mode 100644
index 0000000..dc995d8
--- /dev/null
+++ b/src/test/cppunit/StringTools.cpp
@@ -0,0 +1,80 @@
+#include <cppunit/tools/StringTools.h>
+#include <cppunit/portability/Stream.h>
+#include <algorithm>
+
+
+CPPUNIT_NS_BEGIN
+
+
+std::string 
+StringTools::toString( int value )
+{
+  OStringStream stream;
+  stream << value;
+  return stream.str();
+}
+
+
+std::string 
+StringTools::toString( double value )
+{
+  OStringStream stream;
+  stream << value;
+  return stream.str();
+}
+
+
+StringTools::Strings
+StringTools::split( const std::string &text, 
+                    char separator )
+{
+  Strings splittedText;
+
+  std::string::const_iterator itStart = text.begin();
+  while ( !text.empty() )
+  {
+    std::string::const_iterator itSeparator = std::find( itStart, 
+                                                         text.end(), 
+                                                         separator );
+    splittedText.push_back( text.substr( itStart - text.begin(),
+                                         itSeparator - itStart ) );
+    if ( itSeparator == text.end() )
+      break;
+    itStart = itSeparator +1;
+  }
+
+  return splittedText;
+}
+
+
+std::string 
+StringTools::wrap( const std::string &text,
+                   int wrapColumn )
+{
+  const char lineBreak = '\n';
+  Strings lines = split( text, lineBreak );
+
+  std::string wrapped;
+  for ( Strings::const_iterator it = lines.begin(); it != lines.end(); ++it )
+  {
+    if ( it != lines.begin() )
+      wrapped += lineBreak;
+
+    const std::string &line = *it;
+    unsigned int index =0;
+    while ( index < line.length() )
+    {
+      std::string lineSlice( line.substr( index, wrapColumn ) );
+      wrapped += lineSlice;
+      index += wrapColumn;
+      if ( index < line.length() )
+        wrapped += lineBreak;
+    }
+  }
+
+  return wrapped;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/SynchronizedObject.cpp b/src/test/cppunit/SynchronizedObject.cpp
new file mode 100644
index 0000000..1764538
--- /dev/null
+++ b/src/test/cppunit/SynchronizedObject.cpp
@@ -0,0 +1,32 @@
+#include <cppunit/SynchronizedObject.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+SynchronizedObject::SynchronizedObject( SynchronizationObject *syncObject )
+    : m_syncObject( syncObject == 0 ? new SynchronizationObject() : 
+                                      syncObject )
+{
+}
+
+
+SynchronizedObject::~SynchronizedObject()
+{
+  delete m_syncObject;
+}
+
+
+/** Accept a new synchronization object for protection of this instance
+ * TestResult assumes ownership of the object
+ */
+void 
+SynchronizedObject::setSynchronizationObject( SynchronizationObject *syncObject )
+{ 
+  delete m_syncObject; 
+  m_syncObject = syncObject; 
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/SynchronizedObject.h b/src/test/cppunit/SynchronizedObject.h
new file mode 100644
index 0000000..0f7d094
--- /dev/null
+++ b/src/test/cppunit/SynchronizedObject.h
@@ -0,0 +1,80 @@
+#ifndef CPPUNIT_SYNCHRONIZEDOBJECT_H
+#define CPPUNIT_SYNCHRONIZEDOBJECT_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Base class for synchronized object.
+ *
+ * Synchronized object are object which members are used concurrently by mutiple
+ * threads.
+ *
+ * This class define the class SynchronizationObject which must be subclassed
+ * to implement an actual lock.
+ *
+ * Each instance of this class holds a pointer on a lock object.
+ *
+ * See src/msvc6/MfcSynchronizedObject.h for an example.
+ */
+class CPPUNIT_API SynchronizedObject
+{
+public:
+  /*! \brief Abstract synchronization object (mutex)
+   */
+  class SynchronizationObject
+  {
+    public:
+      SynchronizationObject() {}
+      virtual ~SynchronizationObject() {}
+
+      virtual void lock() {}
+      virtual void unlock() {}
+  };
+
+  /*! Constructs a SynchronizedObject object.
+   */
+  SynchronizedObject( SynchronizationObject *syncObject =0 );
+
+  /// Destructor.
+  virtual ~SynchronizedObject();
+
+protected:
+  /*! \brief Locks a synchronization object in the current scope.
+   */
+  class ExclusiveZone
+  {
+    SynchronizationObject *m_syncObject;
+
+  public:
+    ExclusiveZone( SynchronizationObject *syncObject ) 
+        : m_syncObject( syncObject ) 
+    { 
+      m_syncObject->lock(); 
+    }
+
+    ~ExclusiveZone() 
+    { 
+      m_syncObject->unlock (); 
+    }
+  };
+
+  virtual void setSynchronizationObject( SynchronizationObject *syncObject );
+
+protected:
+  SynchronizationObject *m_syncObject;
+
+private:
+  /// Prevents the use of the copy constructor.
+  SynchronizedObject( const SynchronizedObject &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const SynchronizedObject &copy );
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_SYNCHRONIZEDOBJECT_H
diff --git a/src/test/cppunit/Test.cpp b/src/test/cppunit/Test.cpp
new file mode 100644
index 0000000..fef8be7
--- /dev/null
+++ b/src/test/cppunit/Test.cpp
@@ -0,0 +1,97 @@
+#include <cppunit/Portability.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestPath.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+Test *
+Test::getChildTestAt( int index ) const
+{
+  checkIsValidIndex( index );
+  return doGetChildTestAt( index );
+}
+
+
+Test *
+Test::findTest( const std::string &testName ) const
+{
+  TestPath path;
+  Test *mutableThis = CPPUNIT_CONST_CAST( Test *, this );
+  mutableThis->findTestPath( testName, path );
+  if ( !path.isValid() )
+    throw std::invalid_argument( "No test named <" + testName + "> found in test <"
+                                 + getName() + ">." );
+  return path.getChildTest();
+}
+
+
+bool 
+Test::findTestPath( const std::string &testName,
+                    TestPath &testPath ) const
+{
+  Test *mutableThis = CPPUNIT_CONST_CAST( Test *, this );
+  if ( getName() == testName )
+  {
+    testPath.add( mutableThis );
+    return true;
+  }
+
+  int childCount = getChildTestCount();
+  for ( int childIndex =0; childIndex < childCount; ++childIndex )
+  {
+    if ( getChildTestAt( childIndex )->findTestPath( testName, testPath ) )
+    {
+      testPath.insert( mutableThis, 0 );
+      return true;
+    }
+  }
+
+  return false;
+}
+
+
+bool 
+Test::findTestPath( const Test *test,
+                    TestPath &testPath ) const
+{
+  Test *mutableThis = CPPUNIT_CONST_CAST( Test *, this );
+  if ( this == test )
+  {
+    testPath.add( mutableThis );
+    return true;
+  }
+
+  int childCount = getChildTestCount();
+  for ( int childIndex =0; childIndex < childCount; ++childIndex )
+  {
+    if ( getChildTestAt( childIndex )->findTestPath( test, testPath ) )
+    {
+      testPath.insert( mutableThis, 0 );
+      return true;
+    }
+  }
+
+  return false;
+}
+
+
+TestPath 
+Test::resolveTestPath( const std::string &testPath ) const
+{
+  Test *mutableThis = CPPUNIT_CONST_CAST( Test *, this );
+  return TestPath( mutableThis, testPath );
+}
+
+
+void 
+Test::checkIsValidIndex( int index ) const
+{
+  if ( index < 0  ||  index >= getChildTestCount() )
+    throw std::out_of_range( "Test::checkValidIndex(): invalid index" );
+}
+  
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/Test.h b/src/test/cppunit/Test.h
new file mode 100644
index 0000000..a56be0f
--- /dev/null
+++ b/src/test/cppunit/Test.h
@@ -0,0 +1,117 @@
+#ifndef CPPUNIT_TEST_H
+#define CPPUNIT_TEST_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+class TestPath;
+
+/*! \brief Base class for all test objects.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * All test objects should be a subclass of Test.  Some test objects,
+ * TestCase for example, represent one individual test.  Other test
+ * objects, such as TestSuite, are comprised of several tests.  
+ *
+ * When a Test is run, the result is collected by a TestResult object.
+ *
+ * \see TestCase
+ * \see TestSuite
+ */
+class CPPUNIT_API Test
+{
+public:
+  virtual ~Test() {};
+
+  /*! \brief Run the test, collecting results.
+   */
+  virtual void run( TestResult *result ) =0;
+
+  /*! \brief Return the number of test cases invoked by run().
+   *
+   * The base unit of testing is the class TestCase.  This
+   * method returns the number of TestCase objects invoked by
+   * the run() method.
+   */
+  virtual int countTestCases () const =0;
+
+  /*! \brief Returns the number of direct child of the test.
+   */
+  virtual int getChildTestCount() const =0;
+
+  /*! \brief Returns the child test of the specified index.
+   *
+   * This method test if the index is valid, then call doGetChildTestAt() if 
+   * the index is valid. Otherwise std::out_of_range exception is thrown.
+   *
+   * You should override doGetChildTestAt() method.
+   * 
+   * \param index Zero based index of the child test to return.
+   * \return Pointer on the test. Never \c NULL.
+   * \exception std::out_of_range is \a index is < 0 or >= getChildTestCount().
+   */
+  virtual Test *getChildTestAt( int index ) const;
+
+  /*! \brief Returns the test name.
+   * 
+   * Each test has a name.  This name may be used to find the
+   * test in a suite or registry of tests.
+   */
+  virtual std::string getName () const =0;
+
+  /*! \brief Finds the test with the specified name and its parents test.
+   * \param testName Name of the test to find.
+   * \param testPath If the test is found, then all the tests traversed to access
+   *                 \a test are added to \a testPath, including \c this and \a test.
+   * \return \c true if a test with the specified name is found, \c false otherwise.
+   */
+  virtual bool findTestPath( const std::string &testName,
+                             TestPath &testPath ) const;
+
+  /*! \brief Finds the specified test and its parents test.
+   * \param test Test to find.
+   * \param testPath If the test is found, then all the tests traversed to access
+   *                 \a test are added to \a testPath, including \c this and \a test.
+   * \return \c true if the specified test is found, \c false otherwise.
+   */
+  virtual bool findTestPath( const Test *test,
+                             TestPath &testPath ) const;
+
+  /*! \brief Finds the test with the specified name in the hierarchy.
+   * \param testName Name of the test to find.
+   * \return Pointer on the first test found that is named \a testName. Never \c NULL.
+   * \exception std::invalid_argument if no test named \a testName is found.
+   */
+  virtual Test *findTest( const std::string &testName ) const;
+
+  /*! \brief Resolved the specified test path with this test acting as 'root'.
+   * \param testPath Test path string to resolve.
+   * \return Resolved TestPath. 
+   * \exception std::invalid_argument if \a testPath could not be resolved.
+   * \see TestPath.
+   */
+  virtual TestPath resolveTestPath( const std::string &testPath ) const;
+
+protected:
+  /*! Throws an exception if the specified index is invalid.
+   * \param index Zero base index of a child test.
+   * \exception std::out_of_range is \a index is < 0 or >= getChildTestCount().
+   */
+  virtual void checkIsValidIndex( int index ) const;
+
+  /*! \brief Returns the child test of the specified valid index.
+   * \param index Zero based valid index of the child test to return.
+   * \return Pointer on the test. Never \c NULL.
+   */
+  virtual Test *doGetChildTestAt( int index ) const =0;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TEST_H
+
diff --git a/src/test/cppunit/TestAssert.cpp b/src/test/cppunit/TestAssert.cpp
new file mode 100644
index 0000000..6e4e794
--- /dev/null
+++ b/src/test/cppunit/TestAssert.cpp
@@ -0,0 +1,46 @@
+#include <cppunit/TestAssert.h>
+#include <cppunit/portability/FloatingPoint.h>
+
+CPPUNIT_NS_BEGIN
+
+
+void 
+assertDoubleEquals( double expected,
+                    double actual,
+                    double delta,
+                    SourceLine sourceLine,
+                    const std::string &message )
+{
+  AdditionalMessage msg( "Delta   : " + 
+                         assertion_traits<double>::toString(delta) );
+  msg.addDetail( AdditionalMessage(message) );
+
+  bool equal;
+  if ( floatingPointIsFinite(expected)  &&  floatingPointIsFinite(actual) )
+      equal = fabs( expected - actual ) <= delta;
+  else
+  {
+    // If expected or actual is not finite, it may be +inf, -inf or NaN (Not a Number).
+    // Value of +inf or -inf leads to a true equality regardless of delta if both
+    // expected and actual have the same value (infinity sign).
+    // NaN Value should always lead to a failed equality.
+    if ( floatingPointIsUnordered(expected)  ||  floatingPointIsUnordered(actual) )
+    { 
+       equal = false;  // expected or actual is a NaN
+    }
+    else // ordered values, +inf or -inf comparison
+    {
+       equal = expected == actual;
+    }
+  }
+
+  Asserter::failNotEqualIf( !equal,
+                            assertion_traits<double>::toString(expected),
+                            assertion_traits<double>::toString(actual),
+                            sourceLine, 
+                            msg, 
+                            "double equality assertion failed" );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestAssert.h b/src/test/cppunit/TestAssert.h
new file mode 100644
index 0000000..f74797b
--- /dev/null
+++ b/src/test/cppunit/TestAssert.h
@@ -0,0 +1,428 @@
+#ifndef CPPUNIT_TESTASSERT_H
+#define CPPUNIT_TESTASSERT_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Exception.h>
+#include <cppunit/Asserter.h>
+#include <cppunit/portability/Stream.h>
+#include <stdio.h>
+#include <float.h> // For struct assertion_traits<double>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Traits used by CPPUNIT_ASSERT_EQUAL().
+ *
+ * Here is an example of specialising these traits: 
+ *
+ * \code
+ * template<>
+ * struct assertion_traits<std::string>   // specialization for the std::string type
+ * {
+ *   static bool equal( const std::string& x, const std::string& y )
+ *   {
+ *     return x == y;
+ *   }
+ * 
+ *   static std::string toString( const std::string& x )
+ *   {
+ *     std::string text = '"' + x + '"';    // adds quote around the string to see whitespace
+ *     OStringStream ost;
+ *     ost << text;
+ *     return ost.str();
+ *   }
+ * };
+ * \endcode
+ */
+template <class T>
+struct assertion_traits 
+{  
+    static bool equal( const T& x, const T& y )
+    {
+        return x == y;
+    }
+
+    static std::string toString( const T& x )
+    {
+        OStringStream ost;
+        ost << x;
+        return ost.str();
+    }
+};
+
+
+/*! \brief Traits used by CPPUNIT_ASSERT_DOUBLES_EQUAL(). 
+ * 
+ * This specialisation from @c struct @c assertion_traits<> ensures that 
+ * doubles are converted in full, instead of being rounded to the default 
+ * 6 digits of precision. Use the system defined ISO C99 macro DBL_DIG 
+ * within float.h is available to define the maximum precision, otherwise
+ * use the hard-coded maximum precision of 15.
+ */
+template <>
+struct assertion_traits<double>
+{  
+    static bool equal( double x, double y )
+    {
+        return x == y;
+    }
+
+    static std::string toString( double x )
+    {
+#ifdef DBL_DIG
+       const int precision = DBL_DIG;
+#else
+       const int precision = 15;
+#endif  // #ifdef DBL_DIG
+       char buffer[128];
+#ifdef __STDC_SECURE_LIB__ // Use secure version with visual studio 2005 to avoid warning.
+       sprintf_s(buffer, sizeof(buffer), "%.*g", precision, x); 
+#else	
+       sprintf(buffer, "%.*g", precision, x); 
+#endif
+       return buffer;
+    }
+};
+
+
+/*! \brief (Implementation) Asserts that two objects of the same type are equals.
+ * Use CPPUNIT_ASSERT_EQUAL instead of this function.
+ * \sa assertion_traits, Asserter::failNotEqual().
+ */
+template <class T>
+void assertEquals( const T& expected,
+                   const T& actual,
+                   SourceLine sourceLine,
+                   const std::string &message )
+{
+  if ( !assertion_traits<T>::equal(expected,actual) ) // lazy toString conversion...
+  {
+    Asserter::failNotEqual( assertion_traits<T>::toString(expected),
+                            assertion_traits<T>::toString(actual),
+                            sourceLine,
+                            message );
+  }
+}
+
+
+/*! \brief (Implementation) Asserts that two double are equals given a tolerance.
+ * Use CPPUNIT_ASSERT_DOUBLES_EQUAL instead of this function.
+ * \sa Asserter::failNotEqual().
+ * \sa CPPUNIT_ASSERT_DOUBLES_EQUAL for detailed semantic of the assertion.
+ */
+void CPPUNIT_API assertDoubleEquals( double expected,
+                                     double actual,
+                                     double delta,
+                                     SourceLine sourceLine, 
+                                     const std::string &message );
+
+
+/* A set of macros which allow us to get the line number
+ * and file name at the point of an error.
+ * Just goes to show that preprocessors do have some
+ * redeeming qualities.
+ */
+#if CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION
+/** Assertions that a condition is \c true.
+ * \ingroup Assertions
+ */
+#define CPPUNIT_ASSERT(condition)                                                 \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \
+                                 CPPUNIT_NS::Message( "assertion failed",         \
+                                                      "Expression: " #condition), \
+                                 CPPUNIT_SOURCELINE() ) )
+#else
+#define CPPUNIT_ASSERT(condition)                                            \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),                              \
+                                  CPPUNIT_NS::Message( "assertion failed" ), \
+                                  CPPUNIT_SOURCELINE() ) )
+#endif
+
+/** Assertion with a user specified message.
+ * \ingroup Assertions
+ * \param message Message reported in diagnostic if \a condition evaluates
+ *                to \c false.
+ * \param condition If this condition evaluates to \c false then the
+ *                  test failed.
+ */
+#define CPPUNIT_ASSERT_MESSAGE(message,condition)                          \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),                            \
+                                  CPPUNIT_NS::Message( "assertion failed", \
+                                                       "Expression: "      \
+                                                       #condition,         \
+                                                       message ),          \
+                                  CPPUNIT_SOURCELINE() ) )
+
+/** Fails with the specified message.
+ * \ingroup Assertions
+ * \param message Message reported in diagnostic.
+ */
+#define CPPUNIT_FAIL( message )                                         \
+  ( CPPUNIT_NS::Asserter::fail( CPPUNIT_NS::Message( "forced failure",  \
+                                                     message ),         \
+                                CPPUNIT_SOURCELINE() ) )
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+/// Generalized macro for primitive value comparisons
+#define CPPUNIT_ASSERT_EQUAL(expected,actual)                     \
+  ( CPPUNIT_NS::assertEquals( (expected),             \
+                              (actual),               \
+                              __LINE__, __FILE__ ) )
+#else
+/** Asserts that two values are equals.
+ * \ingroup Assertions
+ *
+ * Equality and string representation can be defined with
+ * an appropriate CppUnit::assertion_traits class.
+ *
+ * A diagnostic is printed if actual and expected values disagree.
+ *
+ * Requirement for \a expected and \a actual parameters:
+ * - They are exactly of the same type
+ * - They are serializable into a std::strstream using operator <<.
+ * - They can be compared using operator ==. 
+ *
+ * The last two requirements (serialization and comparison) can be
+ * removed by specializing the CppUnit::assertion_traits.
+ */
+#define CPPUNIT_ASSERT_EQUAL(expected,actual)          \
+  ( CPPUNIT_NS::assertEquals( (expected),              \
+                              (actual),                \
+                              CPPUNIT_SOURCELINE(),    \
+                              "" ) )
+
+/** Asserts that two values are equals, provides additional message on failure.
+ * \ingroup Assertions
+ *
+ * Equality and string representation can be defined with
+ * an appropriate assertion_traits class.
+ *
+ * A diagnostic is printed if actual and expected values disagree.
+ * The message is printed in addition to the expected and actual value
+ * to provide additional information.
+ *
+ * Requirement for \a expected and \a actual parameters:
+ * - They are exactly of the same type
+ * - They are serializable into a std::strstream using operator <<.
+ * - They can be compared using operator ==. 
+ *
+ * The last two requirements (serialization and comparison) can be
+ * removed by specializing the CppUnit::assertion_traits.
+ */
+#define CPPUNIT_ASSERT_EQUAL_MESSAGE(message,expected,actual)      \
+  ( CPPUNIT_NS::assertEquals( (expected),              \
+                              (actual),                \
+                              CPPUNIT_SOURCELINE(),    \
+                              (message) ) )
+#endif
+
+/*! \brief Macro for primitive double value comparisons. 
+ * \ingroup Assertions
+ *
+ * The assertion pass if both expected and actual are finite and
+ * \c fabs( \c expected - \c actual ) <= \c delta.
+ * If either \c expected or actual are infinite (+/- inf), the 
+ * assertion pass if \c expected == \c actual.
+ * If either \c expected or \c actual is a NaN (not a number), then
+ * the assertion fails.
+ */
+#define CPPUNIT_ASSERT_DOUBLES_EQUAL(expected,actual,delta)        \
+  ( CPPUNIT_NS::assertDoubleEquals( (expected),            \
+                                    (actual),              \
+                                    (delta),               \
+                                    CPPUNIT_SOURCELINE(),  \
+                                    "" ) )
+
+
+/*! \brief Macro for primitive double value comparisons, setting a 
+ * user-supplied message in case of failure. 
+ * \ingroup Assertions
+ * \sa CPPUNIT_ASSERT_DOUBLES_EQUAL for detailed semantic of the assertion.
+ */
+#define CPPUNIT_ASSERT_DOUBLES_EQUAL_MESSAGE(message,expected,actual,delta)  \
+  ( CPPUNIT_NS::assertDoubleEquals( (expected),            \
+                                    (actual),              \
+                                    (delta),               \
+                                    CPPUNIT_SOURCELINE(),  \
+                                    (message) ) )
+
+
+/** Asserts that the given expression throws an exception of the specified type. 
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *  CPPUNIT_ASSERT_THROW( v.at( 50 ), std::out_of_range );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_THROW( expression, ExceptionType )              \
+   CPPUNIT_ASSERT_THROW_MESSAGE( CPPUNIT_NS::AdditionalMessage(),       \
+                                 expression,                            \
+                                 ExceptionType )
+
+
+// implementation detail
+#if CPPUNIT_USE_TYPEINFO_NAME
+#define CPPUNIT_EXTRACT_EXCEPTION_TYPE_( exception, no_rtti_message ) \
+   CPPUNIT_NS::TypeInfoHelper::getClassName( typeid(exception) )
+#else
+#define CPPUNIT_EXTRACT_EXCEPTION_TYPE_( exception, no_rtti_message ) \
+   std::string( no_rtti_message )
+#endif // CPPUNIT_USE_TYPEINFO_NAME
+
+// implementation detail
+#define CPPUNIT_GET_PARAMETER_STRING( parameter ) #parameter
+
+/** Asserts that the given expression throws an exception of the specified type, 
+ * setting a user supplied message in case of failure. 
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *  CPPUNIT_ASSERT_THROW_MESSAGE( "- std::vector<int> v;", v.at( 50 ), std::out_of_range );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_THROW_MESSAGE( message, expression, ExceptionType )   \
+   do {                                                                       \
+      bool cpputCorrectExceptionThrown_ = false;                              \
+      CPPUNIT_NS::Message cpputMsg_( "expected exception not thrown" );       \
+      cpputMsg_.addDetail( message );                                         \
+      cpputMsg_.addDetail( "Expected: "                                       \
+                           CPPUNIT_GET_PARAMETER_STRING( ExceptionType ) );   \
+                                                                              \
+      try {                                                                   \
+         expression;                                                          \
+      } catch ( const ExceptionType & ) {                                     \
+         cpputCorrectExceptionThrown_ = true;                                 \
+      } catch ( const std::exception &e) {                                    \
+         cpputMsg_.addDetail( "Actual  : " +                                  \
+                              CPPUNIT_EXTRACT_EXCEPTION_TYPE_( e,             \
+                                          "std::exception or derived") );     \
+         cpputMsg_.addDetail( std::string("What()  : ") + e.what() );         \
+      } catch ( ... ) {                                                       \
+         cpputMsg_.addDetail( "Actual  : unknown.");                          \
+      }                                                                       \
+                                                                              \
+      if ( cpputCorrectExceptionThrown_ )                                     \
+         break;                                                               \
+                                                                              \
+      CPPUNIT_NS::Asserter::fail( cpputMsg_,                                  \
+                                  CPPUNIT_SOURCELINE() );                     \
+   } while ( false )
+
+
+/** Asserts that the given expression does not throw any exceptions.
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *   v.push_back( 10 );
+ *  CPPUNIT_ASSERT_NO_THROW( v.at( 0 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_NO_THROW( expression )                             \
+   CPPUNIT_ASSERT_NO_THROW_MESSAGE( CPPUNIT_NS::AdditionalMessage(),       \
+                                    expression )
+
+
+/** Asserts that the given expression does not throw any exceptions, 
+ * setting a user supplied message in case of failure. 
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *   v.push_back( 10 );
+ *  CPPUNIT_ASSERT_NO_THROW( "std::vector<int> v;", v.at( 0 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_NO_THROW_MESSAGE( message, expression )               \
+   do {                                                                       \
+      CPPUNIT_NS::Message cpputMsg_( "unexpected exception caught" );         \
+      cpputMsg_.addDetail( message );                                         \
+                                                                              \
+      try {                                                                   \
+         expression;                                                          \
+      } catch ( const std::exception &e ) {                                   \
+         cpputMsg_.addDetail( "Caught: " +                                    \
+                              CPPUNIT_EXTRACT_EXCEPTION_TYPE_( e,             \
+                                          "std::exception or derived" ) );    \
+         cpputMsg_.addDetail( std::string("What(): ") + e.what() );           \
+         CPPUNIT_NS::Asserter::fail( cpputMsg_,                               \
+                                     CPPUNIT_SOURCELINE() );                  \
+      } catch ( ... ) {                                                       \
+         cpputMsg_.addDetail( "Caught: unknown." );                           \
+         CPPUNIT_NS::Asserter::fail( cpputMsg_,                               \
+                                     CPPUNIT_SOURCELINE() );                  \
+      }                                                                       \
+   } while ( false )
+
+
+/** Asserts that an assertion fail.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_FAIL( CPPUNIT_ASSERT( 1 == 2 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_FAIL( assertion )                 \
+   CPPUNIT_ASSERT_THROW( assertion, CPPUNIT_NS::Exception )
+
+
+/** Asserts that an assertion fail, with a user-supplied message in 
+ * case of error.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_FAIL_MESSAGE( "1 == 2", CPPUNIT_ASSERT( 1 == 2 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_FAIL_MESSAGE( message, assertion )    \
+   CPPUNIT_ASSERT_THROW_MESSAGE( message, assertion, CPPUNIT_NS::Exception )
+
+
+/** Asserts that an assertion pass.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_PASS( CPPUNIT_ASSERT( 1 == 1 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_PASS( assertion )                 \
+   CPPUNIT_ASSERT_NO_THROW( assertion )
+
+
+/** Asserts that an assertion pass, with a user-supplied message in 
+ * case of failure. 
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_PASS_MESSAGE( "1 != 1", CPPUNIT_ASSERT( 1 == 1 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_PASS_MESSAGE( message, assertion )    \
+   CPPUNIT_ASSERT_NO_THROW_MESSAGE( message, assertion )
+
+
+
+
+// Backwards compatibility
+
+#if CPPUNIT_ENABLE_NAKED_ASSERT
+
+#undef assert
+#define assert(c)                 CPPUNIT_ASSERT(c)
+#define assertEqual(e,a)          CPPUNIT_ASSERT_EQUAL(e,a)
+#define assertDoublesEqual(e,a,d) CPPUNIT_ASSERT_DOUBLES_EQUAL(e,a,d)
+#define assertLongsEqual(e,a)     CPPUNIT_ASSERT_EQUAL(e,a)
+
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTASSERT_H
diff --git a/src/test/cppunit/TestCaller.h b/src/test/cppunit/TestCaller.h
new file mode 100644
index 0000000..dc4d82e
--- /dev/null
+++ b/src/test/cppunit/TestCaller.h
@@ -0,0 +1,204 @@
+#ifndef CPPUNIT_TESTCALLER_H    // -*- C++ -*-
+#define CPPUNIT_TESTCALLER_H
+
+#include <cppunit/Exception.h>
+#include <cppunit/TestCase.h>
+
+
+#if CPPUNIT_USE_TYPEINFO_NAME
+#  include <cppunit/extensions/TypeInfoHelper.h>
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+#if 0
+/*! \brief Marker class indicating that no exception is expected by TestCaller.
+ * This class is an implementation detail. You should never use this class directly.
+ */
+class CPPUNIT_API NoExceptionExpected
+{
+private:
+  //! Prevent class instantiation.
+  NoExceptionExpected();
+};
+
+
+/*! \brief (Implementation) Traits used by TestCaller to expect an exception.
+ *
+ * This class is an implementation detail. You should never use this class directly.
+ */
+template<class ExceptionType>
+struct ExpectedExceptionTraits
+{
+  static void expectedException()
+  {
+#if CPPUNIT_USE_TYPEINFO_NAME
+    throw Exception( Message(
+                         "expected exception not thrown",
+                         "Expected exception type: " + 
+                           TypeInfoHelper::getClassName( typeid( ExceptionType ) ) ) );
+#else
+    throw Exception( "expected exception not thrown" );
+#endif
+  }
+};
+
+
+/*! \brief (Implementation) Traits specialization used by TestCaller to 
+ * expect no exception.
+ *
+ * This class is an implementation detail. You should never use this class directly.
+ */
+template<>
+struct ExpectedExceptionTraits<NoExceptionExpected>
+{
+  static void expectedException()
+  {
+  }
+};
+
+
+#endif
+
+//*** FIXME: rework this when class Fixture is implemented. ***//
+
+
+/*! \brief Generate a test case from a fixture method.
+ * \ingroup WritingTestFixture
+ *
+ * A test caller provides access to a test case method 
+ * on a test fixture class.  Test callers are useful when 
+ * you want to run an individual test or add it to a 
+ * suite.
+ * Test Callers invoke only one Test (i.e. test method) on one 
+ * Fixture of a TestFixture.
+ * 
+ * Here is an example:
+ * \code
+ * class MathTest : public CppUnit::TestFixture {
+ *         ...
+ *     public:
+ *         void         setUp();
+ *         void         tearDown();
+ *
+ *         void         testAdd();
+ *         void         testSubtract();
+ * };
+ *
+ * CppUnit::Test *MathTest::suite() {
+ *     CppUnit::TestSuite *suite = new CppUnit::TestSuite;
+ *
+ *     suite->addTest( new CppUnit::TestCaller<MathTest>( "testAdd", testAdd ) );
+ *     return suite;
+ * }
+ * \endcode
+ *
+ * You can use a TestCaller to bind any test method on a TestFixture
+ * class, as long as it accepts void and returns void.
+ * 
+ * \see TestCase
+ */
+
+template <class Fixture>
+class TestCaller : public TestCase
+{ 
+  typedef void (Fixture::*TestMethod)();
+    
+public:
+  /*!
+   * Constructor for TestCaller. This constructor builds a new Fixture
+   * instance owned by the TestCaller.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   */
+  TestCaller( std::string name, TestMethod test ) :
+	    TestCase( name ), 
+	    m_ownFixture( true ),
+	    m_fixture( new Fixture() ),
+	    m_test( test )
+  {
+  }
+
+  /*!
+   * Constructor for TestCaller. 
+   * This constructor does not create a new Fixture instance but accepts
+   * an existing one as parameter. The TestCaller will not own the
+   * Fixture object.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   * \param fixture the Fixture to invoke the test method on.
+   */
+  TestCaller(std::string name, TestMethod test, Fixture& fixture) :
+	    TestCase( name ), 
+	    m_ownFixture( false ),
+	    m_fixture( &fixture ),
+	    m_test( test )
+  {
+  }
+    
+  /*!
+   * Constructor for TestCaller. 
+   * This constructor does not create a new Fixture instance but accepts
+   * an existing one as parameter. The TestCaller will own the
+   * Fixture object and delete it in its destructor.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   * \param fixture the Fixture to invoke the test method on.
+   */
+  TestCaller(std::string name, TestMethod test, Fixture* fixture) :
+	    TestCase( name ), 
+	    m_ownFixture( true ),
+	    m_fixture( fixture ),
+	    m_test( test )
+  {
+  }
+    
+  ~TestCaller() 
+  {
+    if (m_ownFixture)
+      delete m_fixture;
+  }
+
+  void runTest()
+  { 
+//	  try {
+	    (m_fixture->*m_test)();
+//	  }
+//	  catch ( ExpectedException & ) {
+//	    return;
+//	  }
+
+//  	ExpectedExceptionTraits<ExpectedException>::expectedException();
+  }  
+
+  void setUp()
+  { 
+  	m_fixture->setUp (); 
+  }
+
+  void tearDown()
+  { 
+	  m_fixture->tearDown (); 
+  }
+
+  std::string toString() const
+  { 
+  	return "TestCaller " + getName(); 
+  }
+
+private: 
+  TestCaller( const TestCaller &other ); 
+  TestCaller &operator =( const TestCaller &other );
+
+private:
+  bool m_ownFixture;
+  Fixture *m_fixture;
+  TestMethod m_test;
+};
+
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCALLER_H
diff --git a/src/test/cppunit/TestCase.cpp b/src/test/cppunit/TestCase.cpp
new file mode 100644
index 0000000..13c0525
--- /dev/null
+++ b/src/test/cppunit/TestCase.cpp
@@ -0,0 +1,137 @@
+#include <cppunit/Portability.h>
+#include <cppunit/Exception.h>
+#include <cppunit/Protector.h>
+#include <cppunit/TestCase.h>
+#include <cppunit/TestResult.h>
+#include <stdexcept>
+
+#if CPPUNIT_USE_TYPEINFO_NAME
+#  include <typeinfo>
+#endif
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Functor to call test case method (Implementation).
+ *
+ * Implementation detail.
+ */
+class TestCaseMethodFunctor : public Functor
+{
+public:
+  typedef void (TestCase::*Method)();
+
+  TestCaseMethodFunctor( TestCase *target,
+                         Method method )
+     : m_target( target )
+     , m_method( method )
+  {
+  }
+
+  bool operator()() const
+  {
+    (m_target->*m_method)();
+    return true;
+  }
+
+private:
+  TestCase *m_target;
+  Method m_method;
+};
+
+
+/** Constructs a test case.
+ *  \param name the name of the TestCase.
+ **/
+TestCase::TestCase( const std::string &name )
+    : m_name(name)
+{
+}
+
+
+/// Run the test and catch any exceptions that are triggered by it 
+void 
+TestCase::run( TestResult *result )
+{
+  result->startTest(this);
+/*
+  try {
+    setUp();
+
+    try {
+      runTest();
+    }
+    catch ( Exception &e ) {
+      Exception *copy = e.clone();
+      result->addFailure( this, copy );
+    }
+    catch ( std::exception &e ) {
+      result->addError( this, new Exception( Message( "uncaught std::exception", 
+                                                      e.what() ) ) );
+    }
+    catch (...) {
+      Exception *e = new Exception( Message( "uncaught unknown exception" ) );
+      result->addError( this, e );
+    }
+
+    try {
+      tearDown();
+    }
+    catch (...) {
+      result->addError( this, new Exception( Message( "tearDown() failed" ) ) );
+    }
+  }
+  catch (...) {
+    result->addError( this, new Exception( Message( "setUp() failed" ) ) );
+  }
+*/
+  if ( result->protect( TestCaseMethodFunctor( this, &TestCase::setUp ),
+                        this,
+                       "setUp() failed" ) )
+  {
+    result->protect( TestCaseMethodFunctor( this, &TestCase::runTest ),
+                     this );
+  }
+
+  result->protect( TestCaseMethodFunctor( this, &TestCase::tearDown ),
+                   this,
+                   "tearDown() failed" );
+
+  result->endTest( this );
+}
+
+
+/// All the work for runTest is deferred to subclasses 
+void 
+TestCase::runTest()
+{
+}
+
+
+/** Constructs a test case for a suite.
+ * \deprecated This constructor was used by fixture when TestFixture did not exist.
+ *             Have your fixture inherits TestFixture instead of TestCase.
+ * \internal
+ *  This TestCase was intended for use by the TestCaller and should not
+ *  be used by a test case for which run() is called.
+ **/
+TestCase::TestCase()
+    : m_name( "" )
+{
+}
+
+
+/// Destructs a test case
+TestCase::~TestCase()
+{
+}
+
+
+/// Returns the name of the test case
+std::string 
+TestCase::getName() const
+{ 
+  return m_name; 
+}
+  
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestCase.h b/src/test/cppunit/TestCase.h
new file mode 100644
index 0000000..d4b7a46
--- /dev/null
+++ b/src/test/cppunit/TestCase.h
@@ -0,0 +1,55 @@
+#ifndef CPPUNIT_TESTCASE_H
+#define CPPUNIT_TESTCASE_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/TestLeaf.h>
+#include <cppunit/TestAssert.h>
+#include <cppunit/TestFixture.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+
+
+/*! \brief A single test object.
+ *
+ * This class is used to implement a simple test case: define a subclass
+ * that overrides the runTest method.
+ *
+ * You don't usually need to use that class, but TestFixture and TestCaller instead.
+ *
+ * You are expected to subclass TestCase is you need to write a class similiar
+ * to TestCaller.
+ */
+class CPPUNIT_API TestCase : public TestLeaf,
+                             public TestFixture
+{
+public:
+
+    TestCase( const std::string &name );
+
+    TestCase();
+
+    ~TestCase();
+    
+    virtual void run(TestResult *result);
+
+    std::string getName() const;
+
+    //! FIXME: this should probably be pure virtual.
+    virtual void runTest();
+    
+private:
+    TestCase( const TestCase &other ); 
+    TestCase &operator=( const TestCase &other ); 
+    
+private:
+    const std::string m_name;
+};
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCASE_H 
diff --git a/src/test/cppunit/TestCaseDecorator.cpp b/src/test/cppunit/TestCaseDecorator.cpp
new file mode 100644
index 0000000..a7229f4
--- /dev/null
+++ b/src/test/cppunit/TestCaseDecorator.cpp
@@ -0,0 +1,47 @@
+#include <cppunit/extensions/TestCaseDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+TestCaseDecorator::TestCaseDecorator( TestCase *test )
+    : TestCase( test->getName() ),
+      m_test( test )
+{ 
+}
+
+
+TestCaseDecorator::~TestCaseDecorator()
+{
+  delete m_test;
+}
+
+
+std::string 
+TestCaseDecorator::getName() const
+{ 
+  return m_test->getName(); 
+}
+
+
+void 
+TestCaseDecorator::setUp()
+{
+  m_test->setUp();
+}
+
+
+void 
+TestCaseDecorator::tearDown()
+{
+  m_test->tearDown();
+}
+
+
+void 
+TestCaseDecorator::runTest()
+{
+  m_test->runTest();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestComposite.cpp b/src/test/cppunit/TestComposite.cpp
new file mode 100644
index 0000000..4768791
--- /dev/null
+++ b/src/test/cppunit/TestComposite.cpp
@@ -0,0 +1,77 @@
+#include <cppunit/TestComposite.h>
+#include <cppunit/TestResult.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestComposite::TestComposite( const std::string &name )
+    : m_name( name )
+{
+}
+
+
+TestComposite::~TestComposite()
+{
+}
+
+
+void 
+TestComposite::run( TestResult *result )
+{
+  doStartSuite( result );
+  doRunChildTests( result );
+  doEndSuite( result );
+}
+
+
+int 
+TestComposite::countTestCases() const
+{
+  int count = 0;
+  
+  int childCount = getChildTestCount();
+  for ( int index =0; index < childCount; ++index )
+    count += getChildTestAt( index )->countTestCases();
+  
+  return count;
+}
+
+
+std::string 
+TestComposite::getName() const
+{
+  return m_name;
+}
+
+
+void 
+TestComposite::doStartSuite( TestResult *controller )
+{
+  controller->startSuite( this );
+}
+
+
+void 
+TestComposite::doRunChildTests( TestResult *controller )
+{
+  int childCount = getChildTestCount();
+  for ( int index =0; index < childCount; ++index )
+  {
+    if ( controller->shouldStop() )
+      break;
+
+    getChildTestAt( index )->run( controller );
+  }
+}
+
+
+void 
+TestComposite::doEndSuite( TestResult *controller )
+{
+  controller->endSuite( this );
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestComposite.h b/src/test/cppunit/TestComposite.h
new file mode 100644
index 0000000..0ded95f
--- /dev/null
+++ b/src/test/cppunit/TestComposite.h
@@ -0,0 +1,45 @@
+#ifndef CPPUNIT_TESTCOMPSITE_H    // -*- C++ -*-
+#define CPPUNIT_TESTCOMPSITE_H
+
+#include <cppunit/Test.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief A Composite of Tests.
+ *
+ * Base class for all test composites. Subclass this class if you need to implement
+ * a custom TestSuite.
+ * 
+ * \see Test, TestSuite.
+ */
+class CPPUNIT_API TestComposite : public Test
+{
+public:
+  TestComposite( const std::string &name = "" );
+
+  ~TestComposite();
+
+  void run( TestResult *result );
+
+  int countTestCases() const;
+  
+  std::string getName() const;
+
+private:
+  TestComposite( const TestComposite &other );
+  TestComposite &operator =( const TestComposite &other ); 
+
+  virtual void doStartSuite( TestResult *controller );
+  virtual void doRunChildTests( TestResult *controller );
+  virtual void doEndSuite( TestResult *controller );
+
+private:
+  const std::string m_name;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCOMPSITE_H
diff --git a/src/test/cppunit/TestDecorator.cpp b/src/test/cppunit/TestDecorator.cpp
new file mode 100644
index 0000000..4e25a6a
--- /dev/null
+++ b/src/test/cppunit/TestDecorator.cpp
@@ -0,0 +1,53 @@
+#include <cppunit/extensions/TestDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+TestDecorator::TestDecorator( Test *test )
+    : m_test( test)
+{ 
+}
+
+
+TestDecorator::~TestDecorator()
+{
+  delete m_test;
+}
+
+
+int 
+TestDecorator::countTestCases() const
+{ 
+  return m_test->countTestCases(); 
+}
+
+
+void 
+TestDecorator::run( TestResult *result )
+{ 
+  m_test->run(result); 
+}
+
+
+std::string 
+TestDecorator::getName() const
+{ 
+  return m_test->getName(); 
+}
+
+
+int 
+TestDecorator::getChildTestCount() const
+{
+  return m_test->getChildTestCount();
+}
+
+
+Test *
+TestDecorator::doGetChildTestAt( int index ) const
+{
+  return m_test->getChildTestAt( index );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestFactoryRegistry.cpp b/src/test/cppunit/TestFactoryRegistry.cpp
new file mode 100644
index 0000000..afe10bb
--- /dev/null
+++ b/src/test/cppunit/TestFactoryRegistry.cpp
@@ -0,0 +1,161 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/portability/CppUnitMap.h>
+#include <cppunit/TestSuite.h>
+#include <assert.h>
+
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief (INTERNAL) List of all TestFactoryRegistry.
+ */
+class TestFactoryRegistryList
+{
+private:
+  typedef CppUnitMap<std::string, TestFactoryRegistry *, std::less<std::string> > Registries;
+  Registries m_registries;
+
+  enum State {
+    doNotChange =0,
+    notCreated,
+    exist,
+    destroyed
+  };
+
+  static State stateFlag( State newState = doNotChange )
+  {
+    static State state = notCreated;
+    if ( newState != doNotChange )
+      state = newState;
+    return state;
+  }
+
+  static TestFactoryRegistryList *getInstance()
+  {
+    static TestFactoryRegistryList list;
+    return &list;
+  }
+
+  TestFactoryRegistry *getInternalRegistry( const std::string &name )
+  {
+    Registries::const_iterator foundIt = m_registries.find( name );
+    if ( foundIt == m_registries.end() )
+    {
+      TestFactoryRegistry *factory = new TestFactoryRegistry( name );
+      m_registries.insert( std::pair<const std::string, TestFactoryRegistry*>( name, factory ) );
+      return factory;
+    }
+    return (*foundIt).second;
+  }
+
+public:
+  TestFactoryRegistryList()
+  {
+    stateFlag( exist );
+  }
+
+  ~TestFactoryRegistryList()
+  {
+    for ( Registries::iterator it = m_registries.begin(); it != m_registries.end(); ++it )
+      delete (*it).second;
+
+    stateFlag( destroyed );
+  }
+
+  static TestFactoryRegistry *getRegistry( const std::string &name )
+  {
+    // If the following assertion failed, then TestFactoryRegistry::getRegistry() 
+    // was called during static variable destruction without checking the registry 
+    // validity beforehand using TestFactoryRegistry::isValid() beforehand.
+    assert( isValid() );
+    if ( !isValid() )         // release mode
+      return NULL;            // => force CRASH
+
+    return getInstance()->getInternalRegistry( name );
+  }
+
+  static bool isValid()
+  {
+    return stateFlag() != destroyed;
+  }
+};
+
+
+
+TestFactoryRegistry::TestFactoryRegistry( std::string name ) :
+    m_name( name )
+{
+}
+
+
+TestFactoryRegistry::~TestFactoryRegistry()
+{
+}
+
+
+TestFactoryRegistry &
+TestFactoryRegistry::getRegistry( const std::string &name )
+{
+  return *TestFactoryRegistryList::getRegistry( name );
+}
+
+
+void 
+TestFactoryRegistry::registerFactory( const std::string &name,
+                                      TestFactory *factory )
+{
+  registerFactory( factory );
+}
+
+
+void 
+TestFactoryRegistry::registerFactory( TestFactory *factory )
+{
+  m_factories.insert( factory );
+}
+
+
+void 
+TestFactoryRegistry::unregisterFactory( TestFactory *factory )
+{
+  m_factories.erase( factory );
+}
+
+
+void 
+TestFactoryRegistry::addRegistry( const std::string &name )
+{
+  registerFactory( &getRegistry( name ) );
+}
+
+
+Test *
+TestFactoryRegistry::makeTest()
+{
+  TestSuite *suite = new TestSuite( m_name );
+  addTestToSuite( suite );
+  return suite;
+}
+
+
+void 
+TestFactoryRegistry::addTestToSuite( TestSuite *suite )
+{
+  for ( Factories::iterator it = m_factories.begin(); 
+        it != m_factories.end(); 
+        ++it )
+  {
+    TestFactory *factory = *it;
+    suite->addTest( factory->makeTest() );
+  }
+}
+
+
+bool 
+TestFactoryRegistry::isValid()
+{
+  return TestFactoryRegistryList::isValid();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestFailure.cpp b/src/test/cppunit/TestFailure.cpp
new file mode 100644
index 0000000..e31e138
--- /dev/null
+++ b/src/test/cppunit/TestFailure.cpp
@@ -0,0 +1,71 @@
+#include <cppunit/Exception.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/// Constructs a TestFailure with the given test and exception.
+TestFailure::TestFailure( Test *failedTest, 
+                          Exception *thrownException,
+                          bool isError ) :
+    m_failedTest( failedTest ), 
+    m_thrownException( thrownException ),
+    m_isError( isError )
+{
+}
+
+/// Deletes the owned exception.
+TestFailure::~TestFailure()
+{ 
+  delete m_thrownException; 
+}
+
+/// Gets the failed test.
+Test *
+TestFailure::failedTest() const
+{ 
+  return m_failedTest; 
+}
+
+
+/// Gets the thrown exception. Never \c NULL.
+Exception *
+TestFailure::thrownException() const
+{ 
+  return m_thrownException; 
+}
+
+
+/// Gets the failure location.
+SourceLine 
+TestFailure::sourceLine() const
+{
+  return m_thrownException->sourceLine();
+}
+
+
+/// Indicates if the failure is a failed assertion or an error.
+bool 
+TestFailure::isError() const
+{
+  return m_isError;
+}
+
+
+/// Gets the name of the failed test.
+std::string 
+TestFailure::failedTestName() const
+{
+  return m_failedTest->getName();
+}
+
+
+TestFailure *
+TestFailure::clone() const
+{
+  return new TestFailure( m_failedTest, m_thrownException->clone(), m_isError );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestFailure.h b/src/test/cppunit/TestFailure.h
new file mode 100644
index 0000000..6419979
--- /dev/null
+++ b/src/test/cppunit/TestFailure.h
@@ -0,0 +1,58 @@
+#ifndef CPPUNIT_TESTFAILURE_H    // -*- C++ -*-
+#define CPPUNIT_TESTFAILURE_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class Test;
+
+
+/*! \brief Record of a failed Test execution.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * A TestFailure collects a failed test together with
+ * the caught exception.
+ *
+ * TestFailure assumes lifetime control for any exception
+ * passed to it.
+ */
+class CPPUNIT_API TestFailure 
+{
+public:
+  TestFailure( Test *failedTest,
+               Exception *thrownException,
+               bool isError );
+
+  virtual ~TestFailure ();
+
+  virtual Test *failedTest() const;
+
+  virtual Exception *thrownException() const;
+
+  virtual SourceLine sourceLine() const;
+
+  virtual bool isError() const;
+
+  virtual std::string failedTestName() const;
+
+  virtual TestFailure *clone() const;
+
+protected:
+  Test *m_failedTest;
+  Exception *m_thrownException;
+  bool m_isError;
+
+private: 
+  TestFailure( const TestFailure &other ); 
+  TestFailure &operator =( const TestFailure& other ); 
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTFAILURE_H
diff --git a/src/test/cppunit/TestFixture.h b/src/test/cppunit/TestFixture.h
new file mode 100644
index 0000000..1223adb
--- /dev/null
+++ b/src/test/cppunit/TestFixture.h
@@ -0,0 +1,99 @@
+#ifndef CPPUNIT_TESTFIXTURE_H    // -*- C++ -*-
+#define CPPUNIT_TESTFIXTURE_H
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Wraps a test case with setUp and tearDown methods.
+ * \ingroup WritingTestFixture
+ *
+ * A TestFixture is used to provide a common environment for a set
+ * of test cases.
+ *
+ * To define a test fixture, do the following:
+ * - implement a subclass of TestCase 
+ * - the fixture is defined by instance variables 
+ * - initialize the fixture state by overriding setUp
+ *   (i.e. construct the instance variables of the fixture)
+ * - clean-up after a test by overriding tearDown.
+ *
+ * Each test runs in its own fixture so there
+ * can be no side effects among test runs.
+ * Here is an example:
+ * 
+ * \code
+ * class MathTest : public CppUnit::TestFixture {
+ * protected:
+ *   int m_value1, m_value2;
+ *
+ * public:
+ *   MathTest() {}
+ *
+ *   void setUp () {
+ *     m_value1 = 2;
+ *     m_value2 = 3;
+ *   }
+ * }
+ * \endcode
+ *
+ * For each test implement a method which interacts
+ * with the fixture. Verify the expected results with assertions specified
+ * by calling CPPUNIT_ASSERT on the expression you want to test:
+ * 
+ * \code
+ * public: 
+ *   void testAdd () {
+ *     int result = m_value1 + m_value2;
+ *     CPPUNIT_ASSERT( result == 5 );
+ *   }
+ * \endcode
+ * 
+ * Once the methods are defined you can run them. To do this, use
+ * a TestCaller.
+ *
+ * \code
+ * CppUnit::Test *test = new CppUnit::TestCaller<MathTest>( "testAdd", 
+ *                                                          &MathTest::testAdd );
+ * test->run();
+ * \endcode
+ *
+ *
+ * The tests to be run can be collected into a TestSuite. 
+ * 
+ * \code
+ * public: 
+ *   static CppUnit::TestSuite *MathTest::suite () {
+ *      CppUnit::TestSuite *suiteOfTests = new CppUnit::TestSuite;
+ *      suiteOfTests->addTest(new CppUnit::TestCaller<MathTest>(
+ *                              "testAdd", &MathTest::testAdd));
+ *      suiteOfTests->addTest(new CppUnit::TestCaller<MathTest>(
+ *                              "testDivideByZero", &MathTest::testDivideByZero));
+ *      return suiteOfTests;
+ *  }
+ * \endcode
+ * 
+ * A set of macros have been created for convenience. They are located in HelperMacros.h.
+ *
+ * \see TestResult, TestSuite, TestCaller,
+ * \see CPPUNIT_TEST_SUB_SUITE, CPPUNIT_TEST, CPPUNIT_TEST_SUITE_END, 
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_EXCEPTION, CPPUNIT_TEST_FAIL.
+ */
+class CPPUNIT_API TestFixture
+{
+public:
+  virtual ~TestFixture() {};
+
+  //! \brief Set up context before running a test.
+  virtual void setUp() {};
+
+  //! Clean up after the test run.
+  virtual void tearDown() {};
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif
diff --git a/src/test/cppunit/TestLeaf.cpp b/src/test/cppunit/TestLeaf.cpp
new file mode 100644
index 0000000..3d8767c
--- /dev/null
+++ b/src/test/cppunit/TestLeaf.cpp
@@ -0,0 +1,28 @@
+#include <cppunit/TestLeaf.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+int 
+TestLeaf::countTestCases() const
+{
+  return 1;
+}
+
+
+int 
+TestLeaf::getChildTestCount() const
+{
+  return 0;
+}
+
+
+Test *
+TestLeaf::doGetChildTestAt( int index ) const
+{
+  checkIsValidIndex( index );
+  return NULL;    // never called, checkIsValidIndex() always throw.
+}
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestLeaf.h b/src/test/cppunit/TestLeaf.h
new file mode 100644
index 0000000..c83b075
--- /dev/null
+++ b/src/test/cppunit/TestLeaf.h
@@ -0,0 +1,44 @@
+#ifndef CPPUNIT_TESTLEAF_H
+#define CPPUNIT_TESTLEAF_H
+
+#include <cppunit/Test.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief A single test object.
+ *
+ * Base class for single test case: a test that doesn't have any children.
+ *
+ */
+class CPPUNIT_API TestLeaf: public Test
+{
+public:
+  /*! Returns 1 as the default number of test cases invoked by run().
+   * 
+   * You may override this method when many test cases are invoked (RepeatedTest
+   * for example).
+   * 
+   * \return 1.
+   * \see Test::countTestCases().
+   */
+  int countTestCases() const;
+
+  /*! Returns the number of child of this test case: 0.
+   *
+   * You should never override this method: a TestLeaf as no children by definition.
+   *
+   * \return 0.
+   */
+  int getChildTestCount() const;
+
+  /*! Always throws std::out_of_range.
+   * \see Test::doGetChildTestAt().
+   */
+  Test *doGetChildTestAt( int index ) const;
+};
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTLEAF_H
diff --git a/src/test/cppunit/TestListener.h b/src/test/cppunit/TestListener.h
new file mode 100644
index 0000000..330262d
--- /dev/null
+++ b/src/test/cppunit/TestListener.h
@@ -0,0 +1,148 @@
+#ifndef CPPUNIT_TESTLISTENER_H    // -*- C++ -*-
+#define CPPUNIT_TESTLISTENER_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class Test;
+class TestFailure;
+class TestResult;
+
+
+/*! \brief Listener for test progress and result.
+ * \ingroup TrackingTestExecution
+ *
+ * Implementing the Observer pattern a TestListener may be registered
+ * to a TestResult to obtain information on the testing progress. Use
+ * specialized sub classes of TestListener for text output
+ * (TextTestProgressListener). Do not use the Listener for the test
+ * result output, use a subclass of Outputter instead.
+ *
+ * The test framework distinguishes between failures and errors.
+ * A failure is anticipated and checked for with assertions. Errors are
+ * unanticipated problems signified by exceptions that are not generated
+ * by the framework.
+ *
+ * Here is an example to track test time:
+ *
+ *
+ * \code
+ * #include <cppunit/TestListener.h>
+ * #include <cppunit/Test.h>
+ * #include <time.h>    // for clock()
+ *
+ * class TimingListener : public CppUnit::TestListener
+ * {
+ * public:
+ *   void startTest( CppUnit::Test *test )
+ *   {
+ *     _chronometer.start();
+ *   }
+ *  
+ *   void endTest( CppUnit::Test *test )
+ *   {
+ *     _chronometer.end();
+ *     addTest( test, _chronometer.elapsedTime() );
+ *   }
+ *
+ *   // ... (interface to add/read test timing result)
+ *
+ * private:
+ *   Clock _chronometer;
+ * };
+ * \endcode
+ *   
+ * And another example that track failure/success at test suite level and captures
+ * the TestPath of each suite:
+ * \code
+ * class SuiteTracker : public CppUnit::TestListener
+ * {
+ * public:
+ *   void startSuite( CppUnit::Test *suite )
+ *   {
+ *     m_currentPath.add( suite );
+ *   }
+ *   
+ *   void addFailure( const TestFailure &failure )
+ *   {
+ *     m_suiteFailure.top() = false;
+ *   }
+ * 
+ *   void endSuite( CppUnit::Test *suite )
+ *   {
+ *     m_suiteStatus.insert( std::make_pair( suite, m_suiteFailure.top() ) );
+ *     m_suitePaths.insert( std::make_pair( suite, m_currentPath ) );
+ *
+ *     m_currentPath.up();
+ *     m_suiteFailure.pop();
+ *   }
+ *
+ * private:
+ *   std::stack<bool> m_suiteFailure;
+ *   CppUnit::TestPath m_currentPath;
+ *   std::map<CppUnit::Test *, bool> m_suiteStatus;
+ *   std::map<CppUnit::Test *, CppUnit::TestPath> m_suitePaths;
+ * };
+ * \endcode
+ *
+ * \see TestResult
+ */
+class CPPUNIT_API TestListener
+{
+public:
+  virtual ~TestListener() {}
+  
+  /// Called when just before a TestCase is run.
+  virtual void startTest( Test * /*test*/ ) {}
+
+  /*! \brief Called when a failure occurs while running a test.
+   * \see TestFailure.
+   * \warning \a failure is a temporary object that is destroyed after the 
+   *          method call. Use TestFailure::clone() to create a duplicate.
+   */
+  virtual void addFailure( const TestFailure & /*failure*/ ) {}
+
+  /// Called just after a TestCase was run (even if a failure occured).
+  virtual void endTest( Test * /*test*/ ) {}
+
+  /*! \brief Called by a TestComposite just before running its child tests.
+   */
+  virtual void startSuite( Test * /*suite*/ ) {}
+
+  /*! \brief Called by a TestComposite after running its child tests.
+   */
+  virtual void endSuite( Test * /*suite*/ ) {}
+
+  /*! \brief Called by a TestRunner before running the test.
+   * 
+   * You can use this to do some global initialisation. A listener
+   * could also use to output a 'prolog' to the test run.
+   *
+   * \param test Test that is going to be run.
+   * \param eventManager Event manager used for the test run.
+   */
+  virtual void startTestRun( Test * /*test*/, 
+                             TestResult * /*eventManager*/ ) {}
+
+  /*! \brief Called by a TestRunner after running the test.
+   *
+   * TextTestProgressListener use this to emit a line break. You can also use this
+   * to do some global uninitialisation.
+   *
+   * \param test Test that was run.
+   * \param eventManager Event manager used for the test run.
+   */
+  virtual void endTestRun( Test * /*test*/, 
+                           TestResult * /*eventManager*/ ) {}
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTLISTENER_H
+
+
diff --git a/src/test/cppunit/TestNamer.cpp b/src/test/cppunit/TestNamer.cpp
new file mode 100644
index 0000000..eec9be9
--- /dev/null
+++ b/src/test/cppunit/TestNamer.cpp
@@ -0,0 +1,44 @@
+#include <cppunit/extensions/TestNamer.h>
+#include <cppunit/extensions/TypeInfoHelper.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+#if CPPUNIT_HAVE_RTTI
+TestNamer::TestNamer( const std::type_info &typeInfo )
+{
+  m_fixtureName = TypeInfoHelper::getClassName( typeInfo );
+}
+#endif
+
+
+TestNamer::TestNamer( const std::string &fixtureName )
+  : m_fixtureName( fixtureName )
+{
+}
+
+
+TestNamer::~TestNamer()
+{
+}
+
+
+std::string 
+TestNamer::getFixtureName() const
+{
+  return m_fixtureName;
+}
+
+
+std::string 
+TestNamer::getTestNameFor( const std::string &testMethodName ) const
+{
+  return getFixtureName() + "::" + testMethodName;
+}
+
+
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestPath.cpp b/src/test/cppunit/TestPath.cpp
new file mode 100644
index 0000000..a2783a2
--- /dev/null
+++ b/src/test/cppunit/TestPath.cpp
@@ -0,0 +1,254 @@
+#include <cppunit/Portability.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestPath.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestPath::TestPath()
+{
+}
+
+
+TestPath::TestPath( Test *root )
+{
+  add( root );
+}
+
+
+TestPath::TestPath( const TestPath &other, 
+                    int indexFirst, 
+                    int count )
+{
+  int countAdjustment = 0;
+  if ( indexFirst < 0 )
+  {
+    countAdjustment = indexFirst;
+    indexFirst = 0;
+  }
+
+  if ( count < 0 )
+    count = other.getTestCount();
+  else
+    count += countAdjustment;
+
+  int index = indexFirst;
+  while ( count-- > 0  &&  index < other.getTestCount() )
+    add( other.getTestAt( index++ ) );
+}
+
+
+TestPath::TestPath( Test *searchRoot, 
+                    const std::string &pathAsString )
+{
+  PathTestNames testNames;
+
+  Test *parentTest = findActualRoot( searchRoot, pathAsString, testNames );
+  add( parentTest );
+
+  for ( unsigned int index = 1; index < testNames.size(); ++index )
+  {
+    bool childFound = false;
+    for ( int childIndex =0; childIndex < parentTest->getChildTestCount(); ++childIndex )
+    {
+      if ( parentTest->getChildTestAt( childIndex )->getName() == testNames[index] )
+      {
+        childFound = true;
+        parentTest = parentTest->getChildTestAt( childIndex );
+        break;
+      }
+    }
+
+    if ( !childFound )
+      throw std::invalid_argument( "TestPath::TestPath(): failed to resolve test name <"+
+                                   testNames[index] + "> of path <" + pathAsString + ">" );
+
+    add( parentTest );
+  }
+}
+
+
+TestPath::TestPath( const TestPath &other )
+  : m_tests( other.m_tests )
+{
+}
+
+
+TestPath::~TestPath()
+{
+}
+
+
+TestPath &
+TestPath::operator =( const TestPath &other )
+{
+  if ( &other != this )
+    m_tests = other.m_tests;
+  return *this;
+}
+
+
+bool 
+TestPath::isValid() const
+{
+  return getTestCount() > 0;
+}
+
+
+void 
+TestPath::add( Test *test )
+{
+  m_tests.push_back( test );
+}
+
+
+void 
+TestPath::add( const TestPath &path )
+{
+  for ( int index =0; index < path.getTestCount(); ++index )
+    add( path.getTestAt( index ) );
+}
+
+
+void 
+TestPath::insert( Test *test, 
+                  int index )
+{
+  if ( index < 0  ||  index > getTestCount() )
+    throw std::out_of_range( "TestPath::insert(): index out of range" );
+  m_tests.insert( m_tests.begin() + index, test );
+}
+
+void 
+TestPath::insert( const TestPath &path, 
+                  int index )
+{
+  int itemIndex = path.getTestCount() -1;
+  while ( itemIndex >= 0 )
+    insert( path.getTestAt( itemIndex-- ), index );
+}
+
+
+void 
+TestPath::removeTests()
+{
+  while ( isValid() )
+    removeTest( 0 );
+}
+
+
+void 
+TestPath::removeTest( int index )
+{
+  checkIndexValid( index );
+  m_tests.erase( m_tests.begin() + index );
+}
+
+
+void 
+TestPath::up()
+{
+  checkIndexValid( 0 );
+  removeTest( getTestCount() -1 );
+}
+
+
+int 
+TestPath::getTestCount() const
+{
+  return m_tests.size();
+}
+
+
+Test *
+TestPath::getTestAt( int index ) const
+{
+  checkIndexValid( index );
+  return m_tests[index];
+}
+
+
+Test *
+TestPath::getChildTest() const
+{
+  return getTestAt( getTestCount() -1 );
+}
+
+
+void 
+TestPath::checkIndexValid( int index ) const
+{
+  if ( index < 0  ||  index >= getTestCount() )
+    throw std::out_of_range( "TestPath::checkIndexValid(): index out of range" );
+}
+
+
+std::string 
+TestPath::toString() const
+{
+  std::string asString( "/" );
+  for ( int index =0; index < getTestCount(); ++index )
+  {
+    if ( index > 0 )
+      asString += '/';
+    asString += getTestAt(index)->getName();
+  }
+
+  return asString;
+}
+
+
+Test *
+TestPath::findActualRoot( Test *searchRoot,
+                          const std::string &pathAsString,
+                          PathTestNames &testNames )
+{
+  bool isRelative = splitPathString( pathAsString, testNames );
+
+  if ( isRelative  &&  pathAsString.empty() )
+    return searchRoot;
+
+  if ( testNames.empty() )
+    throw std::invalid_argument( "TestPath::TestPath(): invalid root or root name in absolute path" );
+
+  Test *root = isRelative ? searchRoot->findTest( testNames[0] )  // throw if bad test name
+                          : searchRoot;
+  if ( root->getName() != testNames[0] )
+    throw std::invalid_argument( "TestPath::TestPath(): searchRoot does not match path root name" );
+
+  return root;
+}
+
+
+bool
+TestPath::splitPathString( const std::string &pathAsString,
+                           PathTestNames &testNames )
+{
+  if ( pathAsString.empty() )
+    return true;
+
+  bool isRelative = pathAsString[0] != '/';
+
+  int index = (isRelative ? 0 : 1);
+  while ( true )
+  {
+    int separatorIndex = pathAsString.find( '/', index );
+    if ( separatorIndex >= 0 )
+    {
+      testNames.push_back( pathAsString.substr( index, separatorIndex - index ) );
+      index = separatorIndex + 1;
+    }
+    else
+    {
+      testNames.push_back( pathAsString.substr( index ) );
+      break;
+    }
+  }
+
+  return isRelative;
+}
+  
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestPath.h b/src/test/cppunit/TestPath.h
new file mode 100644
index 0000000..c3c851c
--- /dev/null
+++ b/src/test/cppunit/TestPath.h
@@ -0,0 +1,211 @@
+#ifndef CPPUNIT_TESTPATH_H
+#define CPPUNIT_TESTPATH_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<Test *>;
+#endif
+
+
+/*! \brief A List of Test representing a path to access a Test.
+ * \ingroup ExecutingTest
+ *
+ * The path can be converted to a string and resolved from a string with toString()
+ * and TestPath( Test *root, const std::string &pathAsString ).
+ *
+ * Pointed tests are not owned by the class.
+ *
+ * \see Test::resolvedTestPath()
+ */
+class CPPUNIT_API TestPath
+{
+public:
+  /*! \brief Constructs an invalid path.
+   * 
+   * The path is invalid until a test is added with add().
+   */
+  TestPath();
+
+  /*! \brief Constructs a valid path.
+   *
+   * \param root Test to add.
+   */
+  TestPath( Test *root );
+
+  /*! \brief Constructs a path using a slice of another path.
+   * \param otherPath Path the test are copied from.
+   * \param indexFirst Zero based index of the first test to copy. Adjusted to be in valid
+   *                   range. \a count is adjusted with \a indexFirst.
+   * \param count Number of tests to copy. If < 0 then all test starting from index
+   *              \a indexFirst are copied.
+   */
+  TestPath( const TestPath &otherPath, 
+            int indexFirst, 
+            int count = -1 );
+
+  /*! \brief Resolves a path from a string returned by toString().
+   *
+   * If \a pathAsString is an absolute path (begins with '/'), then the first test name
+   * of the path must be the name of \a searchRoot. Otherwise, \a pathAsString is a 
+   * relative path, and the first test found using Test::findTest() matching the first
+   * test name is used as root. An empty string resolve to a path containing 
+   * \a searchRoot.
+   *
+   * The resolved path is always valid.
+   *
+   * \param searchRoot Test used to resolve the path.
+   * \param pathAsString String that contains the path as a string created by toString().
+   * \exception std::invalid_argument if one of the test names can not be resolved.
+   * \see toString().
+   */
+  TestPath( Test *searchRoot, 
+            const std::string &pathAsString );
+
+  /*! \brief Copy constructor.
+   * \param other Object to copy.
+   */
+  TestPath( const TestPath &other );
+
+  virtual ~TestPath();
+
+  /*! \brief Tests if the path contains at least one test.
+   * \return \c true if the path contains at least one test, otherwise returns \c false.
+   */
+  virtual bool isValid() const;
+
+  /*! \brief Adds a test to the path.
+   * \param test Pointer on the test to add. Must not be \c NULL.
+   */
+  virtual void add( Test *test );
+
+  /*! \brief Adds all the tests of the specified path.
+   * \param path Path that contains the test to add.
+   */
+  virtual void add( const TestPath &path );
+
+  /*! \brief Inserts a test at the specified index.
+   * \param test Pointer on the test to insert. Must not be \c NULL.
+   * \param index Zero based index indicating where the test is inserted.
+   * \exception std::out_of_range is \a index < 0 or \a index > getTestCount().
+   */
+  virtual void insert( Test *test, int index );
+
+  /*! \brief Inserts all the tests at the specified path at a given index.
+   * \param path Path that contains the test to insert.
+   * \param index Zero based index indicating where the tests are inserted.
+   * \exception std::out_of_range is \a index < 0 or \a index > getTestCount(), and
+   *            \a path is valid.
+   */
+  virtual void insert( const TestPath &path, int index );
+
+  /*! \brief Removes all the test from the path.
+   *
+   * The path becomes invalid after this call.
+   */
+  virtual void removeTests();
+
+  /*! \brief Removes the test at the specified index of the path.
+   * \param index Zero based index of the test to remove.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  virtual void removeTest( int index );
+
+  /*! \brief Removes the last test.
+   * \exception std::out_of_range is the path is invalid.
+   * \see isValid().
+   */
+  virtual void up();
+
+  /*! \brief Returns the number of tests in the path.
+   * \return Number of tests in the path.
+   */
+  virtual int getTestCount() const;
+
+  /*! \brief Returns the test of the specified index.
+   * \param index Zero based index of the test to return.
+   * \return Pointer on the test at index \a index. Never \c NULL.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  virtual Test *getTestAt( int index ) const;
+
+  /*! \brief Get the last test of the path.
+   * \return Pointer on the last test (test at the bottom of the hierarchy). Never \c NULL.
+   * \exception std::out_of_range if the path is not valid ( isValid() returns \c false ).
+   */
+  virtual Test *getChildTest() const;
+
+  /*! \brief Returns the path as a string.
+   *
+   * For example, if a path is composed of three tests named "All Tests", "Math" and
+   * "Math::testAdd", toString() will return:
+   *
+   * "All Tests/Math/Math::testAdd".
+   * 
+   * \return A string composed of the test names separated with a '/'. It is a relative
+   *         path.
+   */
+  virtual std::string toString() const;
+
+  /*! \brief Assignment operator.
+   * \param other Object to copy.
+   * \return This object.
+   */
+  TestPath &operator =( const TestPath &other );
+
+protected:
+  /*! \brief Checks that the specified test index is within valid range.
+   * \param index Zero based index to check.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  void checkIndexValid( int index ) const;
+
+  /// A list of test names.
+  typedef CppUnitDeque<std::string> PathTestNames;
+
+  /*! \brief Splits a path string into its test name components.
+   * \param pathAsString Path string created with toString().
+   * \param testNames Test name components are added to that container.
+   * \return \c true if the path is relative (does not begin with '/'), \c false
+   *         if it is absolute (begin with '/').
+   */
+  bool splitPathString( const std::string &pathAsString,
+                        PathTestNames &testNames );
+
+  /*! \brief Finds the actual root of a path string and get the path string name components.
+   * \param searchRoot Test used as root if the path string is absolute, or to search
+   *                   the root test if the path string is relative.
+   * \param pathAsString Path string. May be absolute or relative.
+   * \param testNames Test name components are added to that container.
+   * \return Pointer on the resolved root test. Never \c NULL.
+   * \exception std::invalid_argument if either the root name can not be resolved or if
+   *            pathAsString contains no name components.
+   */
+  Test *findActualRoot( Test *searchRoot,
+                        const std::string &pathAsString,
+                        PathTestNames &testNames );
+
+protected:
+  typedef CppUnitDeque<Test *> Tests;
+  Tests m_tests;
+
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTPATH_H
+
diff --git a/src/test/cppunit/TestPlugInDefaultImpl.cpp b/src/test/cppunit/TestPlugInDefaultImpl.cpp
new file mode 100644
index 0000000..1e39825
--- /dev/null
+++ b/src/test/cppunit/TestPlugInDefaultImpl.cpp
@@ -0,0 +1,63 @@
+#include <cppunit/config/SourcePrefix.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/TestSuite.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/plugin/TestPlugInDefaultImpl.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestPlugInDefaultImpl::TestPlugInDefaultImpl() 
+{
+}
+
+
+TestPlugInDefaultImpl::~TestPlugInDefaultImpl()
+{
+}
+
+
+void 
+TestPlugInDefaultImpl::initialize( TestFactoryRegistry *registry,
+                                   const PlugInParameters &parameters )
+{
+}
+
+
+void 
+TestPlugInDefaultImpl::addListener( TestResult *eventManager )
+{
+}
+
+
+void 
+TestPlugInDefaultImpl::removeListener( TestResult *eventManager )
+{
+}
+
+
+void 
+TestPlugInDefaultImpl::addXmlOutputterHooks( XmlOutputter *outputter )
+{
+}
+
+
+void 
+TestPlugInDefaultImpl::removeXmlOutputterHooks()
+{
+}
+
+
+void 
+TestPlugInDefaultImpl::uninitialize( TestFactoryRegistry *registry )
+{
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/TestResult.cpp b/src/test/cppunit/TestResult.cpp
new file mode 100644
index 0000000..6be19f1
--- /dev/null
+++ b/src/test/cppunit/TestResult.cpp
@@ -0,0 +1,196 @@
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestListener.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/tools/Algorithm.h>
+#include <algorithm>
+#include "DefaultProtector.h"
+#include "ProtectorChain.h"
+#include "ProtectorContext.h"
+
+CPPUNIT_NS_BEGIN
+
+
+TestResult::TestResult( SynchronizationObject *syncObject )
+    : SynchronizedObject( syncObject )
+    , m_protectorChain( new ProtectorChain() )
+    , m_stop( false )
+{ 
+  m_protectorChain->push( new DefaultProtector() );
+}
+
+
+TestResult::~TestResult()
+{
+  delete m_protectorChain;
+}
+
+
+void 
+TestResult::reset()
+{
+  ExclusiveZone zone( m_syncObject ); 
+  m_stop = false;
+}
+
+
+void 
+TestResult::addError( Test *test, 
+                      Exception *e )
+{ 
+  TestFailure failure( test, e, true );
+  addFailure( failure );
+}
+
+
+void 
+TestResult::addFailure( Test *test, Exception *e )
+{ 
+  TestFailure failure( test, e, false );
+  addFailure( failure );
+}
+
+
+void 
+TestResult::addFailure( const TestFailure &failure )
+{
+  ExclusiveZone zone( m_syncObject ); 
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+    (*it)->addFailure( failure );
+}
+
+
+void 
+TestResult::startTest( Test *test )
+{ 
+  ExclusiveZone zone( m_syncObject ); 
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+    (*it)->startTest( test );
+}
+
+  
+void 
+TestResult::endTest( Test *test )
+{ 
+  ExclusiveZone zone( m_syncObject ); 
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+    (*it)->endTest( test );
+}
+
+
+void 
+TestResult::startSuite( Test *test )
+{
+  ExclusiveZone zone( m_syncObject ); 
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+    (*it)->startSuite( test );
+}
+
+
+void 
+TestResult::endSuite( Test *test )
+{
+  ExclusiveZone zone( m_syncObject ); 
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+    (*it)->endSuite( test );
+}
+
+
+bool 
+TestResult::shouldStop() const
+{ 
+  ExclusiveZone zone( m_syncObject );
+  return m_stop; 
+}
+
+
+void 
+TestResult::stop()
+{ 
+  ExclusiveZone zone( m_syncObject );
+  m_stop = true; 
+}
+
+
+void 
+TestResult::addListener( TestListener *listener )
+{
+  ExclusiveZone zone( m_syncObject ); 
+  m_listeners.push_back( listener );
+}
+
+
+void 
+TestResult::removeListener ( TestListener *listener )
+{
+  ExclusiveZone zone( m_syncObject ); 
+  removeFromSequence( m_listeners, listener );
+}
+
+
+void 
+TestResult::runTest( Test *test )
+{
+  startTestRun( test );
+  test->run( this );
+  endTestRun( test );
+}
+
+
+void 
+TestResult::startTestRun( Test *test )
+{
+  ExclusiveZone zone( m_syncObject ); 
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+    (*it)->startTestRun( test, this );
+}
+
+
+void 
+TestResult::endTestRun( Test *test )
+{
+  ExclusiveZone zone( m_syncObject ); 
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+    (*it)->endTestRun( test, this );
+}
+
+
+bool 
+TestResult::protect( const Functor &functor,
+                     Test *test,
+                     const std::string &shortDescription )
+{
+  ProtectorContext context( test, this, shortDescription );
+  return m_protectorChain->protect( functor, context );
+}
+
+
+void 
+TestResult::pushProtector( Protector *protector )
+{
+  m_protectorChain->push( protector );
+}
+
+
+void 
+TestResult::popProtector()
+{
+  m_protectorChain->pop();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestResult.h b/src/test/cppunit/TestResult.h
new file mode 100644
index 0000000..e7e1050
--- /dev/null
+++ b/src/test/cppunit/TestResult.h
@@ -0,0 +1,156 @@
+#ifndef CPPUNIT_TESTRESULT_H
+#define CPPUNIT_TESTRESULT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/SynchronizedObject.h>
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class Functor;
+class Protector;
+class ProtectorChain;
+class Test;
+class TestFailure;
+class TestListener;
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<TestListener *>;
+#endif
+
+/*! \brief Manages TestListener.
+ * \ingroup TrackingTestExecution
+ *
+ * A single instance of this class is used when running the test. It is usually
+ * created by the test runner (TestRunner).
+ *
+ * This class shouldn't have to be inherited from. Use a TestListener
+ * or one of its subclasses to be informed of the ongoing tests.
+ * Use a Outputter to receive a test summary once it has finished
+ *
+ * TestResult supplies a template method 'setSynchronizationObject()'
+ * so that subclasses can provide mutual exclusion in the face of multiple
+ * threads.  This can be useful when tests execute in one thread and
+ * they fill a subclass of TestResult which effects change in another 
+ * thread.  To have mutual exclusion, override setSynchronizationObject()
+ * and make sure that you create an instance of ExclusiveZone at the 
+ * beginning of each method.
+ *
+ * \see Test, TestListener, TestResultCollector, Outputter.
+ */
+class CPPUNIT_API TestResult : protected SynchronizedObject
+{
+public:
+  /// Construct a TestResult
+  TestResult( SynchronizationObject *syncObject = 0 );
+
+  /// Destroys a test result
+  virtual ~TestResult();
+
+  virtual void addListener( TestListener *listener );
+
+  virtual void removeListener( TestListener *listener );
+
+  /// Resets the stop flag.
+  virtual void reset();
+  
+  /// Stop testing
+  virtual void stop();
+
+  /// Returns whether testing should be stopped
+  virtual bool shouldStop() const;
+
+  /// Informs TestListener that a test will be started.
+  virtual void startTest( Test *test );
+
+  /*! \brief Adds an error to the list of errors. 
+   *  The passed in exception
+   *  caused the error
+   */
+  virtual void addError( Test *test, Exception *e );
+
+  /*! \brief Adds a failure to the list of failures. The passed in exception
+   * caused the failure.
+   */
+  virtual void addFailure( Test *test, Exception *e );
+
+  /// Informs TestListener that a test was completed.
+  virtual void endTest( Test *test );
+
+  /// Informs TestListener that a test suite will be started.
+  virtual void startSuite( Test *test );
+
+  /// Informs TestListener that a test suite was completed.
+  virtual void endSuite( Test *test );
+
+  /*! \brief Run the specified test.
+   * 
+   * Calls startTestRun(), test->run(this), and finally endTestRun().
+   */
+  virtual void runTest( Test *test );
+
+  /*! \brief Protects a call to the specified functor.
+   *
+   * See Protector to understand how protector works. A default protector is
+   * always present. It captures CppUnit::Exception, std::exception and
+   * any other exceptions, retrieving as much as possible information about
+   * the exception as possible.
+   *
+   * Additional Protector can be added to the chain to support other exception
+   * types using pushProtector() and popProtector().
+   *
+   * \param functor Functor to call (typically a call to setUp(), runTest() or
+   *                tearDown().
+   * \param test Test the functor is associated to (used for failure reporting).
+   * \param shortDescription Short description override for the failure message.
+   */
+  virtual bool protect( const Functor &functor,
+                        Test *test,
+                        const std::string &shortDescription = std::string("") );
+
+  /// Adds the specified protector to the protector chain.
+  virtual void pushProtector( Protector *protector );
+
+  /// Removes the last protector from the protector chain.
+  virtual void popProtector();
+
+protected:
+  /*! \brief Called to add a failure to the list of failures.
+   */
+  void addFailure( const TestFailure &failure );
+
+  virtual void startTestRun( Test *test );
+  virtual void endTestRun( Test *test );
+  
+protected:
+  typedef CppUnitDeque<TestListener *> TestListeners;
+  TestListeners m_listeners;
+  ProtectorChain *m_protectorChain;
+  bool m_stop;
+
+private: 
+  TestResult( const TestResult &other );
+  TestResult &operator =( const TestResult &other );
+};
+
+
+CPPUNIT_NS_END
+
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_TESTRESULT_H
+
+
diff --git a/src/test/cppunit/TestResultCollector.cpp b/src/test/cppunit/TestResultCollector.cpp
new file mode 100644
index 0000000..4371c50
--- /dev/null
+++ b/src/test/cppunit/TestResultCollector.cpp
@@ -0,0 +1,117 @@
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestResultCollector.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestResultCollector::TestResultCollector( SynchronizationObject *syncObject )
+    : TestSuccessListener( syncObject )
+{
+  reset();
+}
+
+
+TestResultCollector::~TestResultCollector()
+{
+  freeFailures();
+}
+
+
+void 
+TestResultCollector::freeFailures()
+{
+  TestFailures::iterator itFailure = m_failures.begin();
+  while ( itFailure != m_failures.end() )
+    delete *itFailure++;
+  m_failures.clear();
+}
+
+
+void 
+TestResultCollector::reset()
+{
+  TestSuccessListener::reset();
+
+  ExclusiveZone zone( m_syncObject ); 
+  freeFailures();
+  m_testErrors = 0;
+  m_tests.clear();
+}
+
+
+void 
+TestResultCollector::startTest( Test *test )
+{
+  ExclusiveZone zone (m_syncObject); 
+  m_tests.push_back( test );
+}
+
+
+void 
+TestResultCollector::addFailure( const TestFailure &failure )
+{
+  TestSuccessListener::addFailure( failure );
+
+  ExclusiveZone zone( m_syncObject ); 
+  if ( failure.isError() )
+    ++m_testErrors;
+  m_failures.push_back( failure.clone() );
+}
+
+
+/// Gets the number of run tests.
+int 
+TestResultCollector::runTests() const
+{ 
+  ExclusiveZone zone( m_syncObject ); 
+  return m_tests.size(); 
+}
+
+
+/// Gets the number of detected errors (uncaught exception).
+int 
+TestResultCollector::testErrors() const
+{ 
+  ExclusiveZone zone( m_syncObject );
+  return m_testErrors;
+}
+
+
+/// Gets the number of detected failures (failed assertion).
+int 
+TestResultCollector::testFailures() const
+{ 
+  ExclusiveZone zone( m_syncObject ); 
+  return m_failures.size() - m_testErrors;
+}
+
+
+/// Gets the total number of detected failures.
+int 
+TestResultCollector::testFailuresTotal() const
+{
+  ExclusiveZone zone( m_syncObject ); 
+  return m_failures.size();
+}
+
+
+/// Returns a the list failures (random access collection).
+const TestResultCollector::TestFailures & 
+TestResultCollector::failures() const
+{ 
+  ExclusiveZone zone( m_syncObject );
+  return m_failures; 
+}
+
+
+const TestResultCollector::Tests &
+TestResultCollector::tests() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_tests;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestResultCollector.h b/src/test/cppunit/TestResultCollector.h
new file mode 100644
index 0000000..01b0a54
--- /dev/null
+++ b/src/test/cppunit/TestResultCollector.h
@@ -0,0 +1,87 @@
+#ifndef CPPUNIT_TESTRESULTCOLLECTOR_H
+#define CPPUNIT_TESTRESULTCOLLECTOR_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 4660 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/TestSuccessListener.h>
+#include <cppunit/portability/CppUnitDeque.h>
+
+
+CPPUNIT_NS_BEGIN
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<TestFailure *>;
+//  template class CPPUNIT_API std::deque<Test *>;
+#endif
+
+
+/*! \brief Collects test result.
+ * \ingroup WritingTestResult
+ * \ingroup BrowsingCollectedTestResult
+ * 
+ * A TestResultCollector is a TestListener which collects the results of executing 
+ * a test case. It is an instance of the Collecting Parameter pattern.
+ *
+ * The test framework distinguishes between failures and errors.
+ * A failure is anticipated and checked for with assertions. Errors are
+ * unanticipated problems signified by exceptions that are not generated
+ * by the framework.
+ * \see TestListener, TestFailure.
+ */
+class CPPUNIT_API TestResultCollector : public TestSuccessListener
+{
+public:
+  typedef CppUnitDeque<TestFailure *> TestFailures;
+  typedef CppUnitDeque<Test *> Tests;
+
+
+  /*! Constructs a TestResultCollector object.
+   */
+  TestResultCollector( SynchronizationObject *syncObject = 0 );
+
+  /// Destructor.
+  virtual ~TestResultCollector();
+
+  void startTest( Test *test );
+  void addFailure( const TestFailure &failure );
+
+  virtual void reset();
+
+  virtual int runTests() const;
+  virtual int testErrors() const;
+  virtual int testFailures() const;
+  virtual int testFailuresTotal() const;
+
+  virtual const TestFailures& failures() const;
+  virtual const Tests &tests() const;
+
+protected:
+  void freeFailures();
+
+  Tests m_tests;
+  TestFailures m_failures;
+  int m_testErrors;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TestResultCollector( const TestResultCollector &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TestResultCollector &copy );
+};
+
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_TESTRESULTCOLLECTOR_H
diff --git a/src/test/cppunit/TestRunner.cpp b/src/test/cppunit/TestRunner.cpp
new file mode 100644
index 0000000..8d95a63
--- /dev/null
+++ b/src/test/cppunit/TestRunner.cpp
@@ -0,0 +1,101 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/TestRunner.h>
+#include <cppunit/TestPath.h>
+#include <cppunit/TestResult.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestRunner::WrappingSuite::WrappingSuite( const std::string &name ) 
+    : TestSuite( name )
+{
+}
+
+
+int 
+TestRunner::WrappingSuite::getChildTestCount() const
+{
+  if ( hasOnlyOneTest() )
+    return getUniqueChildTest()->getChildTestCount();
+  return TestSuite::getChildTestCount();
+}
+
+
+std::string 
+TestRunner::WrappingSuite::getName() const
+{
+  if ( hasOnlyOneTest() )
+    return getUniqueChildTest()->getName();
+  return TestSuite::getName();
+}
+
+
+Test *
+TestRunner::WrappingSuite::doGetChildTestAt( int index ) const
+{
+  if ( hasOnlyOneTest() )
+    return getUniqueChildTest()->getChildTestAt( index );
+  return TestSuite::doGetChildTestAt( index );
+}
+
+
+void 
+TestRunner::WrappingSuite::run( TestResult *result )
+{
+  if ( hasOnlyOneTest() )
+    getUniqueChildTest()->run( result );
+  else
+    TestSuite::run( result );
+}
+
+
+bool 
+TestRunner::WrappingSuite::hasOnlyOneTest() const
+{
+  return TestSuite::getChildTestCount() == 1;
+}
+
+
+Test *
+TestRunner::WrappingSuite::getUniqueChildTest() const
+{
+  return TestSuite::doGetChildTestAt( 0 );
+}
+
+
+
+
+
+TestRunner::TestRunner()
+    : m_suite( new WrappingSuite() )
+{
+}
+
+
+TestRunner::~TestRunner()
+{
+  delete m_suite;
+}
+
+
+void 
+TestRunner::addTest( Test *test )
+{
+  m_suite->addTest( test ); 
+}
+
+
+void 
+TestRunner::run( TestResult &controller,
+                 const std::string &testPath )
+{
+  TestPath path = m_suite->resolveTestPath( testPath );
+  Test *testToRun = path.getChildTest();
+
+  controller.runTest( testToRun );
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestRunner.h b/src/test/cppunit/TestRunner.h
new file mode 100644
index 0000000..930370a
--- /dev/null
+++ b/src/test/cppunit/TestRunner.h
@@ -0,0 +1,135 @@
+#ifndef CPPUNIT_TESTRUNNER_H
+#define CPPUNIT_TESTRUNNER_H
+
+#include <cppunit/TestSuite.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+
+/*! \brief Generic test runner.
+ * \ingroup ExecutingTest
+ *
+ * The TestRunner assumes ownership of all added tests: you can not add test
+ * or suite that are local variable since they can't be deleted.
+ *
+ * Example of usage:
+ * \code
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ * #include <cppunit/CompilerOutputter.h>
+ * #include <cppunit/TestResult.h>
+ * #include <cppunit/TestResultCollector.h>
+ * #include <cppunit/TestRunner.h>
+ * #include <cppunit/TextTestProgressListener.h>
+ * 
+ * 
+ * int 
+ * main( int argc, char* argv[] )
+ * {
+ *   std::string testPath = (argc > 1) ? std::string(argv[1]) : "";
+ * 
+ *   // Create the event manager and test controller
+ *   CppUnit::TestResult controller;
+ * 
+ *   // Add a listener that colllects test result
+ *   CppUnit::TestResultCollector result;
+ *   controller.addListener( &result );        
+ * 
+ *   // Add a listener that print dots as test run.
+ *   CppUnit::TextTestProgressListener progress;
+ *   controller.addListener( &progress );      
+ * 
+ *   // Add the top suite to the test runner
+ *   CppUnit::TestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );   
+ *   try
+ *   {
+ *     std::cout << "Running "  <<  testPath;
+ *     runner.run( controller, testPath );
+ * 
+ *     std::cerr << std::endl;
+ * 
+ *     // Print test in a compiler compatible format.
+ *     CppUnit::CompilerOutputter outputter( &result, std::cerr );
+ *     outputter.write();                      
+ *   }
+ *   catch ( std::invalid_argument &e )  // Test path not resolved
+ *   {
+ *     std::cerr  <<  std::endl  
+ *                <<  "ERROR: "  <<  e.what()
+ *                << std::endl;
+ *     return 0;
+ *   }
+ * 
+ *   return result.wasSuccessful() ? 0 : 1;
+ * }
+ * \endcode
+ */
+class CPPUNIT_API TestRunner
+{
+public:
+  /*! \brief Constructs a TestRunner object.
+   */
+  TestRunner(  );
+
+  /// Destructor.
+  virtual ~TestRunner();
+
+  /*! \brief Adds the specified test.
+   * \param test Test to add. The TestRunner takes ownership of the test.
+   */
+  virtual void addTest( Test *test );
+
+  /*! \brief Runs a test using the specified controller.
+   * \param controller Event manager and controller used for testing
+   * \param testPath Test path string. See Test::resolveTestPath() for detail.
+   * \exception std::invalid_argument if no test matching \a testPath is found.
+   *                                  see TestPath::TestPath( Test*, const std::string &)
+   *                                  for detail.
+   */
+  virtual void run( TestResult &controller,
+                    const std::string &testPath = "" );
+
+protected:
+  /*! \brief (INTERNAL) Mutating test suite.
+   */
+  class CPPUNIT_API WrappingSuite : public TestSuite
+  {
+  public:
+    WrappingSuite( const std::string &name = "All Tests" );
+
+    int getChildTestCount() const;
+
+    std::string getName() const;
+
+    void run( TestResult *result );
+
+  protected:
+    Test *doGetChildTestAt( int index ) const;
+
+    bool hasOnlyOneTest() const;
+
+    Test *getUniqueChildTest() const;
+  };
+
+protected:
+  WrappingSuite *m_suite;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TestRunner( const TestRunner &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TestRunner &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTRUNNER_H
diff --git a/src/test/cppunit/TestSetUp.cpp b/src/test/cppunit/TestSetUp.cpp
new file mode 100644
index 0000000..d4d8530
--- /dev/null
+++ b/src/test/cppunit/TestSetUp.cpp
@@ -0,0 +1,32 @@
+#include <cppunit/extensions/TestSetUp.h>
+
+CPPUNIT_NS_BEGIN
+
+
+TestSetUp::TestSetUp( Test *test ) : TestDecorator( test ) 
+{
+}
+
+
+void 
+TestSetUp::setUp()
+{
+}
+
+
+void 
+TestSetUp::tearDown() 
+{
+}
+
+
+void
+TestSetUp::run( TestResult *result )
+{ 
+  setUp();
+  TestDecorator::run(result);
+  tearDown();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestSuccessListener.cpp b/src/test/cppunit/TestSuccessListener.cpp
new file mode 100644
index 0000000..3c9c821
--- /dev/null
+++ b/src/test/cppunit/TestSuccessListener.cpp
@@ -0,0 +1,44 @@
+#include <cppunit/TestSuccessListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestSuccessListener::TestSuccessListener( SynchronizationObject *syncObject )
+    : SynchronizedObject( syncObject )
+    , m_success( true )
+{
+}
+
+
+TestSuccessListener::~TestSuccessListener()
+{
+}
+
+
+void 
+TestSuccessListener::reset()
+{
+  ExclusiveZone zone( m_syncObject );
+  m_success = true;
+}
+
+
+void 
+TestSuccessListener::addFailure( const TestFailure &failure )
+{
+  ExclusiveZone zone( m_syncObject );
+  m_success = false;
+}
+
+
+bool 
+TestSuccessListener::wasSuccessful() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_success;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestSuccessListener.h b/src/test/cppunit/TestSuccessListener.h
new file mode 100644
index 0000000..60c5ff5
--- /dev/null
+++ b/src/test/cppunit/TestSuccessListener.h
@@ -0,0 +1,39 @@
+#ifndef CPPUNIT_TESTSUCCESSLISTENER_H
+#define CPPUNIT_TESTSUCCESSLISTENER_H
+
+#include <cppunit/SynchronizedObject.h>
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief TestListener that checks if any test case failed.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API TestSuccessListener : public TestListener,
+                                        public SynchronizedObject
+{
+public:
+  /*! Constructs a TestSuccessListener object.
+   */
+  TestSuccessListener( SynchronizationObject *syncObject = 0 );
+
+  /// Destructor.
+  virtual ~TestSuccessListener();
+
+  virtual void reset();
+
+  void addFailure( const TestFailure &failure );
+
+  /// Returns whether the entire test was successful or not.
+  virtual bool wasSuccessful() const;
+
+private:
+  bool m_success;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTSUCCESSLISTENER_H
diff --git a/src/test/cppunit/TestSuite.cpp b/src/test/cppunit/TestSuite.cpp
new file mode 100644
index 0000000..8dd2ea6
--- /dev/null
+++ b/src/test/cppunit/TestSuite.cpp
@@ -0,0 +1,64 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/TestResult.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/// Default constructor
+TestSuite::TestSuite( std::string name )
+    : TestComposite( name )
+{
+}
+
+
+/// Destructor
+TestSuite::~TestSuite()
+{ 
+  deleteContents(); 
+}
+
+
+/// Deletes all tests in the suite.
+void 
+TestSuite::deleteContents()
+{
+  int childCount = getChildTestCount();
+  for ( int index =0; index < childCount; ++index )
+    delete getChildTestAt( index );
+
+  m_tests.clear();
+}
+
+
+/// Adds a test to the suite. 
+void 
+TestSuite::addTest( Test *test )
+{ 
+  m_tests.push_back( test ); 
+}
+
+
+const CppUnitVector<Test *> &
+TestSuite::getTests() const
+{
+  return m_tests;
+}
+
+
+int 
+TestSuite::getChildTestCount() const
+{
+  return m_tests.size();
+}
+
+
+Test *
+TestSuite::doGetChildTestAt( int index ) const
+{
+  return m_tests[index];
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestSuite.h b/src/test/cppunit/TestSuite.h
new file mode 100644
index 0000000..2b9cd8d
--- /dev/null
+++ b/src/test/cppunit/TestSuite.h
@@ -0,0 +1,80 @@
+#ifndef CPPUNIT_TESTSUITE_H    // -*- C++ -*-
+#define CPPUNIT_TESTSUITE_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/TestComposite.h>
+#include <cppunit/portability/CppUnitVector.h>
+
+CPPUNIT_NS_BEGIN
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::vector<Test *>;
+#endif
+
+
+/*! \brief A Composite of Tests.
+ * \ingroup CreatingTestSuite
+ *
+ * It runs a collection of test cases. Here is an example.
+ * \code
+ * CppUnit::TestSuite *suite= new CppUnit::TestSuite();
+ * suite->addTest(new CppUnit::TestCaller<MathTest> (
+ *                  "testAdd", testAdd));
+ * suite->addTest(new CppUnit::TestCaller<MathTest> (
+ *                  "testDivideByZero", testDivideByZero));
+ * \endcode
+ * Note that \link TestSuite TestSuites \endlink assume lifetime
+ * control for any tests added to them.
+ *
+ * TestSuites do not register themselves in the TestRegistry.
+ * \see Test 
+ * \see TestCaller
+ */
+class CPPUNIT_API TestSuite : public TestComposite
+{
+public:
+  /*! Constructs a test suite with the specified name.
+   */
+  TestSuite( std::string name = "" );
+
+  ~TestSuite();
+
+  /*! Adds the specified test to the suite.
+   * \param test Test to add. Must not be \c NULL.
+    */
+  void addTest( Test *test );
+
+  /*! Returns the list of the tests (DEPRECATED).
+   * \deprecated Use getChildTestCount() & getChildTestAt() of the 
+   *             TestComposite interface instead.
+   * \return Reference on a vector that contains the tests of the suite.
+   */
+  const CppUnitVector<Test *> &getTests() const;
+
+  /*! Destroys all the tests of the suite.
+   */
+  virtual void deleteContents();
+
+  int getChildTestCount() const;
+
+  Test *doGetChildTestAt( int index ) const;
+
+private:
+  CppUnitVector<Test *> m_tests;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_TESTSUITE_H
diff --git a/src/test/cppunit/TestSuiteBuilderContext.cpp b/src/test/cppunit/TestSuiteBuilderContext.cpp
new file mode 100644
index 0000000..ff71b52
--- /dev/null
+++ b/src/test/cppunit/TestSuiteBuilderContext.cpp
@@ -0,0 +1,85 @@
+#include <cppunit/TestSuite.h>
+#include <cppunit/extensions/TestFixtureFactory.h>
+#include <cppunit/extensions/TestNamer.h>
+#include <cppunit/extensions/TestSuiteBuilderContext.h>
+
+
+CPPUNIT_NS_BEGIN
+
+TestSuiteBuilderContextBase::TestSuiteBuilderContextBase( 
+                                 TestSuite &suite,
+                                 const TestNamer &namer,
+                                 TestFixtureFactory &factory )
+  : m_suite( suite )
+  , m_namer( namer )
+  , m_factory( factory )
+{
+}
+
+
+TestSuiteBuilderContextBase::~TestSuiteBuilderContextBase()
+{
+}
+
+
+void 
+TestSuiteBuilderContextBase::addTest( Test *test )
+{
+  m_suite.addTest( test );
+}
+
+
+std::string 
+TestSuiteBuilderContextBase::getFixtureName() const
+{
+  return m_namer.getFixtureName();
+}
+
+
+std::string 
+TestSuiteBuilderContextBase::getTestNameFor( 
+                                 const std::string &testMethodName ) const
+{
+  return m_namer.getTestNameFor( testMethodName );
+}
+
+
+TestFixture *
+TestSuiteBuilderContextBase::makeTestFixture() const
+{
+  return m_factory.makeFixture();
+}
+
+
+void 
+TestSuiteBuilderContextBase::addProperty( const std::string &key, 
+                                          const std::string &value )
+{
+  Properties::iterator it = m_properties.begin();
+  for ( ; it != m_properties.end(); ++it )
+  {
+    if ( (*it).first == key )
+    {
+      (*it).second = value;
+      return;
+    }
+  }
+
+  Property property( key, value );
+  m_properties.push_back( property );
+}
+
+const std::string 
+TestSuiteBuilderContextBase::getStringProperty( const std::string &key ) const
+{
+  Properties::const_iterator it = m_properties.begin();
+  for ( ; it != m_properties.end(); ++it )
+  {
+    if ( (*it).first == key )
+      return (*it).second;
+  }
+  return "";
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TextOutputter.cpp b/src/test/cppunit/TextOutputter.cpp
new file mode 100644
index 0000000..f74214f
--- /dev/null
+++ b/src/test/cppunit/TextOutputter.cpp
@@ -0,0 +1,140 @@
+#include <cppunit/Exception.h>
+#include <cppunit/SourceLine.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TextOutputter.h>
+#include <cppunit/TestResultCollector.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TextOutputter::TextOutputter( TestResultCollector *result,
+                              OStream &stream )
+    : m_result( result )
+    , m_stream( stream )
+{
+}
+
+
+TextOutputter::~TextOutputter()
+{
+}
+
+
+void 
+TextOutputter::write() 
+{
+  printHeader();
+  m_stream << "\n";
+  printFailures();
+  m_stream << "\n";
+}
+
+
+void 
+TextOutputter::printFailures()
+{
+  TestResultCollector::TestFailures::const_iterator itFailure = m_result->failures().begin();
+  int failureNumber = 1;
+  while ( itFailure != m_result->failures().end() ) 
+  {
+    m_stream  <<  "\n";
+    printFailure( *itFailure++, failureNumber++ );
+  }
+}
+
+
+void 
+TextOutputter::printFailure( TestFailure *failure,
+                             int failureNumber )
+{
+  printFailureListMark( failureNumber );
+  m_stream << ' ';
+  printFailureTestName( failure );
+  m_stream << ' ';
+  printFailureType( failure );
+  m_stream << ' ';
+  printFailureLocation( failure->sourceLine() );
+  m_stream << "\n";
+  printFailureDetail( failure->thrownException() );
+  m_stream << "\n";
+}
+
+
+void 
+TextOutputter::printFailureListMark( int failureNumber )
+{
+  m_stream << failureNumber << ")";
+}
+
+
+void 
+TextOutputter::printFailureTestName( TestFailure *failure )
+{
+  m_stream << "test: " << failure->failedTestName();
+}
+
+
+void 
+TextOutputter::printFailureType( TestFailure *failure )
+{
+  m_stream << "("
+           << (failure->isError() ? "E" : "F")
+           << ")";
+}
+
+
+void 
+TextOutputter::printFailureLocation( SourceLine sourceLine )
+{
+  if ( !sourceLine.isValid() )
+    return;
+
+  m_stream << "line: " << sourceLine.lineNumber()
+           << ' ' << sourceLine.fileName();
+}
+
+
+void 
+TextOutputter::printFailureDetail( Exception *thrownException )
+{
+  m_stream  <<  thrownException->message().shortDescription()  <<  "\n";
+  m_stream  <<  thrownException->message().details();
+}
+
+
+void 
+TextOutputter::printHeader()
+{
+  if ( m_result->wasSuccessful() )
+    m_stream << "\nOK (" << m_result->runTests () << " tests)\n" ;
+  else
+  {
+    m_stream << "\n";
+    printFailureWarning();
+    printStatistics();
+  }
+}
+
+
+void 
+TextOutputter::printFailureWarning()
+{
+  m_stream  << "!!!FAILURES!!!\n";
+}
+
+
+void 
+TextOutputter::printStatistics()
+{
+  m_stream  << "Test Results:\n";
+
+  m_stream  <<  "Run:  "  <<  m_result->runTests()
+            <<  "   Failures: "  <<  m_result->testFailures()
+            <<  "   Errors: "  <<  m_result->testErrors()
+            <<  "\n";
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TextOutputter.h b/src/test/cppunit/TextOutputter.h
new file mode 100644
index 0000000..6bd9cea
--- /dev/null
+++ b/src/test/cppunit/TextOutputter.h
@@ -0,0 +1,59 @@
+#ifndef CPPUNIT_TEXTOUTPUTTER_H
+#define CPPUNIT_TEXTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Outputter.h>
+#include <cppunit/portability/Stream.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class TestResultCollector;
+class TestFailure;
+
+
+/*! \brief Prints a TestResultCollector to a text stream.
+ * \ingroup WritingTestResult
+ */
+class CPPUNIT_API TextOutputter : public Outputter
+{
+public:
+  TextOutputter( TestResultCollector *result,
+                 OStream &stream );
+
+  /// Destructor.
+  virtual ~TextOutputter();
+
+  void write();
+  virtual void printFailures();
+  virtual void printHeader();
+
+  virtual void printFailure( TestFailure *failure,
+                             int failureNumber );
+  virtual void printFailureListMark( int failureNumber );
+  virtual void printFailureTestName( TestFailure *failure );
+  virtual void printFailureType( TestFailure *failure );
+  virtual void printFailureLocation( SourceLine sourceLine );
+  virtual void printFailureDetail( Exception *thrownException );
+  virtual void printFailureWarning();
+  virtual void printStatistics();
+
+protected:
+  TestResultCollector *m_result;
+  OStream &m_stream;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TextOutputter( const TextOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TextOutputter &copy );
+};
+
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TEXTOUTPUTTER_H
diff --git a/src/test/cppunit/TextTestProgressListener.cpp b/src/test/cppunit/TextTestProgressListener.cpp
new file mode 100644
index 0000000..7fa92ce
--- /dev/null
+++ b/src/test/cppunit/TextTestProgressListener.cpp
@@ -0,0 +1,43 @@
+#include <cppunit/TestFailure.h>
+#include <cppunit/TextTestProgressListener.h>
+#include <cppunit/portability/Stream.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TextTestProgressListener::TextTestProgressListener()
+{
+}
+
+
+TextTestProgressListener::~TextTestProgressListener()
+{
+}
+
+
+void 
+TextTestProgressListener::startTest( Test *test )
+{
+  stdCOut() << ".";
+}
+
+
+void 
+TextTestProgressListener::addFailure( const TestFailure &failure )
+{
+  stdCOut() << ( failure.isError() ? "E" : "F" );
+}
+
+
+void 
+TextTestProgressListener::endTestRun( Test *test, 
+                                      TestResult *eventManager )
+{
+  stdCOut()  <<  "\n";
+  stdCOut().flush();
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TextTestProgressListener.h b/src/test/cppunit/TextTestProgressListener.h
new file mode 100644
index 0000000..7521c40
--- /dev/null
+++ b/src/test/cppunit/TextTestProgressListener.h
@@ -0,0 +1,44 @@
+#ifndef CPPUNIT_TEXTTESTPROGRESSLISTENER_H
+#define CPPUNIT_TEXTTESTPROGRESSLISTENER_H
+
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! 
+ * \brief TestListener that show the status of each TestCase test result.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API TextTestProgressListener : public TestListener
+{
+public:
+  /*! Constructs a TextTestProgressListener object.
+   */
+  TextTestProgressListener();
+
+  /// Destructor.
+  virtual ~TextTestProgressListener();
+
+  void startTest( Test *test );
+
+  void addFailure( const TestFailure &failure );
+
+  void endTestRun( Test *test, 
+                   TestResult *eventManager );
+
+private:
+  /// Prevents the use of the copy constructor.
+  TextTestProgressListener( const TextTestProgressListener &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TextTestProgressListener &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TEXTTESTPROGRESSLISTENER_H
diff --git a/src/test/cppunit/TextTestResult.cpp b/src/test/cppunit/TextTestResult.cpp
new file mode 100644
index 0000000..871eb6d
--- /dev/null
+++ b/src/test/cppunit/TextTestResult.cpp
@@ -0,0 +1,50 @@
+#include <cppunit/Exception.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TextTestResult.h>
+#include <cppunit/TextOutputter.h>
+#include <cppunit/portability/Stream.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TextTestResult::TextTestResult()
+{
+  addListener( this );
+}
+
+
+void 
+TextTestResult::addFailure( const TestFailure &failure )
+{
+  TestResultCollector::addFailure( failure );
+  stdCOut() << ( failure.isError() ? "E" : "F" );
+}
+
+
+void 
+TextTestResult::startTest( Test *test )
+{
+  TestResultCollector::startTest (test);
+  stdCOut() << ".";
+}
+
+
+void 
+TextTestResult::print( OStream &stream ) 
+{
+  TextOutputter outputter( this, stream );
+  outputter.write();
+}
+
+
+OStream &
+operator <<( OStream &stream, 
+             TextTestResult &result )
+{ 
+  result.print (stream); return stream; 
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TextTestResult.h b/src/test/cppunit/TextTestResult.h
new file mode 100644
index 0000000..e7b1fa3
--- /dev/null
+++ b/src/test/cppunit/TextTestResult.h
@@ -0,0 +1,39 @@
+#ifndef CPPUNIT_TEXTTESTRESULT_H
+#define CPPUNIT_TEXTTESTRESULT_H
+
+#include <cppunit/TestResult.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/portability/Stream.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class SourceLine;
+class Exception;
+class Test;
+
+/*! \brief Holds printable test result (DEPRECATED).
+ * \ingroup TrackingTestExecution
+ * 
+ * deprecated Use class TextTestProgressListener and TextOutputter instead.
+ */
+class CPPUNIT_API TextTestResult : public TestResult,
+                                   public TestResultCollector
+{
+public:
+  TextTestResult();
+
+  virtual void addFailure( const TestFailure &failure );
+  virtual void startTest( Test *test );
+  virtual void print( OStream &stream );
+};
+
+/** insertion operator for easy output */
+CPPUNIT_API OStream &operator <<( OStream &stream, 
+                                  TextTestResult &result );
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TEXTTESTRESULT_H
+
+
diff --git a/src/test/cppunit/TextTestRunner.cpp b/src/test/cppunit/TextTestRunner.cpp
new file mode 100644
index 0000000..1534ec0
--- /dev/null
+++ b/src/test/cppunit/TextTestRunner.cpp
@@ -0,0 +1,144 @@
+// ==> Implementation of cppunit/ui/text/TestRunner.h
+
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/TextTestResult.h>
+#include <cppunit/TextOutputter.h>
+#include <cppunit/TextTestProgressListener.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/ui/text/TextTestRunner.h>
+#include <cppunit/portability/Stream.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! Constructs a new text runner.
+ * \param outputter used to print text result. Owned by the runner.
+ */
+TextTestRunner::TextTestRunner( Outputter *outputter ) 
+    : m_result( new TestResultCollector() )
+    , m_eventManager( new TestResult() )
+    , m_outputter( outputter )
+{
+  if ( !m_outputter )
+    m_outputter = new TextOutputter( m_result, stdCOut() );
+  m_eventManager->addListener( m_result );
+}
+
+
+TextTestRunner::~TextTestRunner()
+{
+  delete m_eventManager;
+  delete m_outputter;
+  delete m_result;
+}
+
+
+/*! Runs the named test case.
+ *
+ * \param testName Name of the test case to run. If an empty is given, then
+ *                 all added tests are run. The name can be the name of any
+ *                 test in the hierarchy.
+ * \param doWait if \c true then the user must press the RETURN key 
+ *               before the run() method exit.
+ * \param doPrintResult if \c true (default) then the test result are printed
+ *                      on the standard output.
+ * \param doPrintProgress if \c true (default) then TextTestProgressListener is
+ *                        used to show the progress.
+ * \return \c true is the test was successful, \c false if the test
+ *         failed or was not found.
+ */
+bool
+TextTestRunner::run( std::string testName,
+                       bool doWait,
+                       bool doPrintResult,
+                       bool doPrintProgress )
+{
+  TextTestProgressListener progress;
+  if ( doPrintProgress )
+    m_eventManager->addListener( &progress );
+
+  TestRunner *pThis = this;
+  pThis->run( *m_eventManager, testName );
+
+  if ( doPrintProgress )
+    m_eventManager->removeListener( &progress );
+
+  printResult( doPrintResult );
+  wait( doWait );
+
+  return m_result->wasSuccessful();
+}
+
+
+void 
+TextTestRunner::wait( bool doWait )
+{
+#if !defined( CPPUNIT_NO_STREAM )
+  if ( doWait ) 
+  {
+    stdCOut() << "<RETURN> to continue\n";
+    stdCOut().flush();
+    std::cin.get ();
+  }
+#endif
+}
+
+
+void 
+TextTestRunner::printResult( bool doPrintResult )
+{
+  stdCOut() << "\n";
+  if ( doPrintResult )
+    m_outputter->write();
+}
+
+
+/*! Returns the result of the test run.
+ * Use this after calling run() to access the result of the test run.
+ */
+TestResultCollector &
+TextTestRunner::result() const
+{
+  return *m_result;
+}
+
+
+/*! Returns the event manager.
+ * The instance of TestResult results returned is the one that is used to run the
+ * test. Use this to register additional TestListener before running the tests.
+ */
+TestResult &
+TextTestRunner::eventManager() const
+{
+  return *m_eventManager;
+}
+
+
+/*! Specifies an alternate outputter.
+ *
+ * Notes that the outputter will be use after the test run only if \a printResult was
+ * \c true.
+ * \param outputter New outputter to use. The previous outputter is destroyed. 
+ *                  The TextTestRunner assumes ownership of the outputter.
+ * \see CompilerOutputter, XmlOutputter, TextOutputter.
+ */
+void 
+TextTestRunner::setOutputter( Outputter *outputter )
+{
+  delete m_outputter;
+  m_outputter = outputter;
+}
+
+
+void 
+TextTestRunner::run( TestResult &controller,
+                     const std::string &testPath )
+{
+  TestRunner::run( controller, testPath );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TextTestRunner.h b/src/test/cppunit/TextTestRunner.h
new file mode 100644
index 0000000..23890e0
--- /dev/null
+++ b/src/test/cppunit/TextTestRunner.h
@@ -0,0 +1,6 @@
+#ifndef CPPUNIT_TEXTTESTRUNNER_H
+#define CPPUNIT_TEXTTESTRUNNER_H
+
+#include <cppunit/ui/text/TextTestRunner.h>
+
+#endif  // CPPUNIT_TEXTTESTRUNNER_H
diff --git a/src/test/cppunit/TypeInfoHelper.cpp b/src/test/cppunit/TypeInfoHelper.cpp
new file mode 100644
index 0000000..bd01001
--- /dev/null
+++ b/src/test/cppunit/TypeInfoHelper.cpp
@@ -0,0 +1,53 @@
+#include <cppunit/Portability.h>
+#include <cppunit/extensions/TypeInfoHelper.h>
+
+#if CPPUNIT_HAVE_RTTI
+
+#include <string>
+
+#if CPPUNIT_HAVE_GCC_ABI_DEMANGLE
+#include <cxxabi.h>
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+
+std::string 
+TypeInfoHelper::getClassName( const std::type_info &info )
+{
+#if defined(CPPUNIT_HAVE_GCC_ABI_DEMANGLE)  &&  CPPUNIT_HAVE_GCC_ABI_DEMANGLE
+
+  int status = 0;
+  char* c_name = 0;
+
+  c_name = abi::__cxa_demangle( info.name(), 0, 0, &status );
+  
+  std::string name( c_name );
+  free( c_name );  
+
+#else   // CPPUNIT_HAVE_GCC_ABI_DEMANGLE
+
+  static std::string classPrefix( "class " );
+  std::string name( info.name() );
+
+  // Work around gcc 3.0 bug: strip number before type name.
+  unsigned int firstNotDigitIndex = 0;
+  while ( firstNotDigitIndex < name.length()  &&
+          name[firstNotDigitIndex] >= '0'  &&
+          name[firstNotDigitIndex] <= '9' )
+    ++firstNotDigitIndex;
+  name = name.substr( firstNotDigitIndex );
+
+  if ( name.substr( 0, classPrefix.length() ) == classPrefix )
+    return name.substr( classPrefix.length() );
+
+#endif  // CPPUNIT_HAVE_GCC_ABI_DEMANGLE
+
+  return name;
+}
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_HAVE_RTTI
diff --git a/src/test/cppunit/UnixDynamicLibraryManager.cpp b/src/test/cppunit/UnixDynamicLibraryManager.cpp
new file mode 100644
index 0000000..f235cce
--- /dev/null
+++ b/src/test/cppunit/UnixDynamicLibraryManager.cpp
@@ -0,0 +1,44 @@
+#include <cppunit/Portability.h>
+
+#if defined(CPPUNIT_HAVE_UNIX_DLL_LOADER)
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#include <dlfcn.h>
+#include <unistd.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::LibraryHandle 
+DynamicLibraryManager::doLoadLibrary( const std::string &libraryName )
+{
+  return ::dlopen( libraryName.c_str(), RTLD_NOW | RTLD_GLOBAL );
+}
+
+
+void 
+DynamicLibraryManager::doReleaseLibrary()
+{
+  ::dlclose( m_libraryHandle);
+}
+
+
+DynamicLibraryManager::Symbol 
+DynamicLibraryManager::doFindSymbol( const std::string &symbol )
+{
+  return ::dlsym ( m_libraryHandle, symbol.c_str() );
+}
+
+
+std::string 
+DynamicLibraryManager::getLastErrorDetail() const
+{
+  return "";
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // defined(CPPUNIT_HAVE_UNIX_DLL_LOADER)
diff --git a/src/test/cppunit/Win32DynamicLibraryManager.cpp b/src/test/cppunit/Win32DynamicLibraryManager.cpp
new file mode 100644
index 0000000..acadf46
--- /dev/null
+++ b/src/test/cppunit/Win32DynamicLibraryManager.cpp
@@ -0,0 +1,73 @@
+#include <cppunit/Portability.h>
+
+#if defined(CPPUNIT_HAVE_WIN32_DLL_LOADER)
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#define WIN32_LEAN_AND_MEAN 
+#define NOGDI
+#define NOUSER
+#define NOKERNEL
+#define NOSOUND
+#define NOMINMAX
+#define BLENDFUNCTION void    // for mingw & gcc  
+#include <windows.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::LibraryHandle 
+DynamicLibraryManager::doLoadLibrary( const std::string &libraryName )
+{
+  return ::LoadLibraryA( libraryName.c_str() );
+}
+
+
+void 
+DynamicLibraryManager::doReleaseLibrary()
+{
+  ::FreeLibrary( (HINSTANCE)m_libraryHandle );
+}
+
+
+DynamicLibraryManager::Symbol 
+DynamicLibraryManager::doFindSymbol( const std::string &symbol )
+{
+  return (DynamicLibraryManager::Symbol)::GetProcAddress( 
+     (HINSTANCE)m_libraryHandle, 
+     symbol.c_str() );
+}
+
+
+std::string 
+DynamicLibraryManager::getLastErrorDetail() const
+{
+  LPVOID lpMsgBuf;
+  ::FormatMessageA( 
+      FORMAT_MESSAGE_ALLOCATE_BUFFER | 
+      FORMAT_MESSAGE_FROM_SYSTEM | 
+      FORMAT_MESSAGE_IGNORE_INSERTS,
+      NULL,
+      GetLastError(),
+      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
+      (LPSTR) &lpMsgBuf,
+      0,
+      NULL 
+  );
+
+  std::string message = (LPCSTR)lpMsgBuf;
+
+  // Display the string.
+//  ::MessageBoxA( NULL, (LPCSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );
+
+  // Free the buffer.
+  ::LocalFree( lpMsgBuf );
+
+  return message;
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // defined(CPPUNIT_HAVE_WIN32_DLL_LOADER)
diff --git a/src/test/cppunit/XmlDocument.cpp b/src/test/cppunit/XmlDocument.cpp
new file mode 100644
index 0000000..31f9115
--- /dev/null
+++ b/src/test/cppunit/XmlDocument.cpp
@@ -0,0 +1,106 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/tools/XmlDocument.h>
+#include <cppunit/tools/XmlElement.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+XmlDocument::XmlDocument( const std::string &encoding,
+                          const std::string &styleSheet )
+  : m_styleSheet( styleSheet )
+  , m_rootElement( new XmlElement( "DummyRoot" ) )
+  , m_standalone( true )
+{
+  setEncoding( encoding );
+}
+
+
+XmlDocument::~XmlDocument()
+{
+  delete m_rootElement;
+}
+
+
+
+std::string 
+XmlDocument::encoding() const
+{
+  return m_encoding;
+}
+
+
+void 
+XmlDocument::setEncoding( const std::string &encoding )
+{
+  m_encoding = encoding.empty() ? std::string("ISO-8859-1") : encoding;
+}
+
+
+std::string 
+XmlDocument::styleSheet() const
+{
+  return m_styleSheet;
+}
+
+
+void 
+XmlDocument::setStyleSheet( const std::string &styleSheet )
+{
+  m_styleSheet = styleSheet;
+}
+
+
+bool
+XmlDocument::standalone() const
+{
+  return m_standalone;
+}
+
+
+void
+XmlDocument::setStandalone( bool standalone )
+{
+  m_standalone = standalone;
+}
+
+
+void 
+XmlDocument::setRootElement( XmlElement *rootElement )
+{
+  if ( rootElement == m_rootElement )
+    return;
+
+  delete m_rootElement;
+  m_rootElement = rootElement;
+}
+
+
+XmlElement &
+XmlDocument::rootElement() const
+{
+  return *m_rootElement;
+}
+
+
+std::string 
+XmlDocument::toString() const
+{
+  std::string asString = "<?xml version=\"1.0\" "
+                         "encoding='" + m_encoding + "'";
+  if ( m_standalone )
+      asString += " standalone='yes'";
+
+  asString += " ?>\n"; 
+
+  if ( !m_styleSheet.empty() )
+    asString += "<?xml-stylesheet type=\"text/xsl\" href=\"" + m_styleSheet + "\"?>\n";
+
+  asString += m_rootElement->toString();
+
+  return asString;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/XmlElement.cpp b/src/test/cppunit/XmlElement.cpp
new file mode 100644
index 0000000..f930ad4
--- /dev/null
+++ b/src/test/cppunit/XmlElement.cpp
@@ -0,0 +1,226 @@
+#include <cppunit/tools/StringTools.h>
+#include <cppunit/tools/XmlElement.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+  
+XmlElement::XmlElement( std::string elementName,
+                        std::string content ) 
+  : m_name( elementName )
+  , m_content( content )
+{
+}
+
+    
+XmlElement::XmlElement( std::string elementName,
+                        int numericContent )
+  : m_name( elementName )
+{
+  setContent( numericContent );
+}
+
+
+XmlElement::~XmlElement()
+{
+  Elements::iterator itNode = m_elements.begin();
+  while ( itNode != m_elements.end() )
+  {
+    XmlElement *element = *itNode++;
+    delete element;
+  }
+}
+
+
+std::string 
+XmlElement::name() const
+{
+  return m_name;
+}
+
+
+std::string 
+XmlElement::content() const
+{
+  return m_content;
+}
+
+
+void 
+XmlElement::setName( const std::string &name )
+{
+  m_name = name;
+}
+
+
+void 
+XmlElement::setContent( const std::string &content )
+{
+  m_content = content;
+}
+
+
+void 
+XmlElement::setContent( int numericContent )
+{
+  m_content = StringTools::toString( numericContent );
+}
+
+
+void 
+XmlElement::addAttribute( std::string attributeName,
+                          std::string value  )
+{
+  m_attributes.push_back( Attribute( attributeName, value ) );
+}
+
+
+void 
+XmlElement::addAttribute( std::string attributeName,
+                          int numericValue )
+{
+  addAttribute( attributeName, StringTools::toString( numericValue ) );
+}
+
+
+void 
+XmlElement::addElement( XmlElement *node )
+{
+  m_elements.push_back( node );
+}
+
+
+int 
+XmlElement::elementCount() const
+{
+  return m_elements.size();
+}
+
+
+XmlElement *
+XmlElement::elementAt( int index ) const
+{
+  if ( index < 0  ||  index >= elementCount() )
+    throw std::invalid_argument( "XmlElement::elementAt(), out of range index" );
+
+  return m_elements[ index ];
+}
+
+
+XmlElement *
+XmlElement::elementFor( const std::string &name ) const
+{
+  Elements::const_iterator itElement = m_elements.begin();
+  for ( ; itElement != m_elements.end(); ++itElement )
+  {
+    if ( (*itElement)->name() == name )
+      return *itElement;
+  }
+
+  throw std::invalid_argument( "XmlElement::elementFor(), not matching child element found" );
+  return NULL;  // make some compilers happy.
+}
+
+
+std::string 
+XmlElement::toString( const std::string &indent ) const
+{
+  std::string element( indent );
+  element += "<";
+  element += m_name;
+  if ( !m_attributes.empty() )
+  {
+    element += " ";
+    element += attributesAsString();
+  }
+  element += ">";
+
+  if ( !m_elements.empty() )
+  {
+    element += "\n";
+
+    std::string subNodeIndent( indent + "  " );
+    Elements::const_iterator itNode = m_elements.begin();
+    while ( itNode != m_elements.end() )
+    {
+      const XmlElement *node = *itNode++;
+      element += node->toString( subNodeIndent );
+    }
+
+    element += indent;
+  }
+
+  if ( !m_content.empty() )
+  {
+    element += escape( m_content );
+    if ( !m_elements.empty() )
+    {
+      element += "\n";
+      element += indent;
+    }
+  }
+
+  element += "</";
+  element += m_name;
+  element += ">\n";
+
+  return element;
+}
+
+
+std::string 
+XmlElement::attributesAsString() const
+{
+  std::string attributes;
+  Attributes::const_iterator itAttribute = m_attributes.begin();
+  while ( itAttribute != m_attributes.end() )
+  {
+    if ( !attributes.empty() )
+       attributes += " ";
+
+    const Attribute &attribute = *itAttribute++;
+    attributes += attribute.first;
+    attributes += "=\"";
+    attributes += escape( attribute.second );
+    attributes += "\"";
+  }
+  return attributes;
+}
+
+
+std::string 
+XmlElement::escape( std::string value ) const
+{
+  std::string escaped;
+  for ( unsigned int index =0; index < value.length(); ++index )
+  {
+    char c = value[index ];
+    switch ( c )    // escape all predefined XML entity (safe?)
+    {
+    case '<': 
+      escaped += "&lt;";
+      break;
+    case '>': 
+      escaped += "&gt;";
+      break;
+    case '&': 
+      escaped += "&amp;";
+      break;
+    case '\'': 
+      escaped += "&apos;";
+      break;
+    case '"': 
+      escaped += "&quot;";
+      break;
+    default:
+      escaped += c;
+    }
+  }
+  
+  return escaped;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/XmlOutputter.cpp b/src/test/cppunit/XmlOutputter.cpp
new file mode 100644
index 0000000..c605e33
--- /dev/null
+++ b/src/test/cppunit/XmlOutputter.cpp
@@ -0,0 +1,205 @@
+#include <cppunit/Exception.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/XmlOutputter.h>
+#include <cppunit/XmlOutputterHook.h>
+#include <cppunit/tools/XmlDocument.h>
+#include <cppunit/tools/XmlElement.h>
+#include <stdlib.h>
+#include <algorithm>
+
+
+CPPUNIT_NS_BEGIN
+
+
+XmlOutputter::XmlOutputter( TestResultCollector *result,
+                            OStream &stream,
+                            std::string encoding )
+  : m_result( result )
+  , m_stream( stream )
+  , m_xml( new XmlDocument( encoding ) )
+{
+}
+
+
+XmlOutputter::~XmlOutputter()
+{
+  delete m_xml;
+}
+
+
+void 
+XmlOutputter::addHook( XmlOutputterHook *hook )
+{
+  m_hooks.push_back( hook );
+}
+
+
+void 
+XmlOutputter::removeHook( XmlOutputterHook *hook )
+{
+  m_hooks.erase( std::find( m_hooks.begin(), m_hooks.end(), hook ) );
+}
+
+
+void 
+XmlOutputter::write()
+{
+  setRootNode();
+  m_stream  <<  m_xml->toString();
+}
+
+
+void 
+XmlOutputter::setStyleSheet( const std::string &styleSheet )
+{
+  m_xml->setStyleSheet( styleSheet );
+}
+
+
+void
+XmlOutputter::setStandalone( bool standalone )
+{
+  m_xml->setStandalone( standalone );
+}
+ 
+
+void
+XmlOutputter::setRootNode()
+{
+  XmlElement *rootNode = new XmlElement( "TestRun" );
+  m_xml->setRootElement( rootNode );
+
+  for ( Hooks::iterator it = m_hooks.begin(); it != m_hooks.end(); ++it )
+    (*it)->beginDocument( m_xml );
+
+  FailedTests failedTests;
+  fillFailedTestsMap( failedTests );
+
+  addFailedTests( failedTests, rootNode );
+  addSuccessfulTests( failedTests, rootNode );
+  addStatistics( rootNode );
+
+  for ( Hooks::iterator itEnd = m_hooks.begin(); itEnd != m_hooks.end(); ++itEnd )
+    (*itEnd)->endDocument( m_xml );
+}
+
+
+void 
+XmlOutputter::fillFailedTestsMap( FailedTests &failedTests )
+{
+  const TestResultCollector::TestFailures &failures = m_result->failures();
+  TestResultCollector::TestFailures::const_iterator itFailure = failures.begin();
+  while ( itFailure != failures.end() )
+  {
+    TestFailure *failure = *itFailure++;
+    failedTests.insert( std::pair<Test* const, TestFailure*>(failure->failedTest(), failure ) );
+  }
+}
+
+
+void
+XmlOutputter::addFailedTests( FailedTests &failedTests,
+                              XmlElement *rootNode )
+{
+  XmlElement *testsNode = new XmlElement( "FailedTests" );
+  rootNode->addElement( testsNode );
+
+  const TestResultCollector::Tests &tests = m_result->tests();
+  for ( unsigned int testNumber = 0; testNumber < tests.size(); ++testNumber )
+  {
+    Test *test = tests[testNumber];
+    if ( failedTests.find( test ) != failedTests.end() )
+      addFailedTest( test, failedTests[test], testNumber+1, testsNode );
+  }
+}
+
+
+void
+XmlOutputter::addSuccessfulTests( FailedTests &failedTests,
+                                           XmlElement *rootNode )
+{
+  XmlElement *testsNode = new XmlElement( "SuccessfulTests" );
+  rootNode->addElement( testsNode );
+
+  const TestResultCollector::Tests &tests = m_result->tests();
+  for ( unsigned int testNumber = 0; testNumber < tests.size(); ++testNumber )
+  {
+    Test *test = tests[testNumber];
+    if ( failedTests.find( test ) == failedTests.end() )
+      addSuccessfulTest( test, testNumber+1, testsNode );
+  }
+}
+
+
+void
+XmlOutputter::addStatistics( XmlElement *rootNode )
+{
+  XmlElement *statisticsElement = new XmlElement( "Statistics" );
+  rootNode->addElement( statisticsElement );
+  statisticsElement->addElement( new XmlElement( "Tests", m_result->runTests() ) );
+  statisticsElement->addElement( new XmlElement( "FailuresTotal", 
+                                                 m_result->testFailuresTotal() ) );
+  statisticsElement->addElement( new XmlElement( "Errors", m_result->testErrors() ) );
+  statisticsElement->addElement( new XmlElement( "Failures", m_result->testFailures() ) );
+
+  for ( Hooks::iterator it = m_hooks.begin(); it != m_hooks.end(); ++it )
+    (*it)->statisticsAdded( m_xml, statisticsElement );
+}
+
+
+void
+XmlOutputter::addFailedTest( Test *test,
+                             TestFailure *failure,
+                             int testNumber,
+                             XmlElement *testsNode )
+{
+  Exception *thrownException = failure->thrownException();
+  
+  XmlElement *testElement = new XmlElement( "FailedTest" );
+  testsNode->addElement( testElement );
+  testElement->addAttribute( "id", testNumber );
+  testElement->addElement( new XmlElement( "Name", test->getName() ) );
+  testElement->addElement( new XmlElement( "FailureType", 
+                                           failure->isError() ? "Error" : 
+                                                                "Assertion" ) );
+
+  if ( failure->sourceLine().isValid() )
+    addFailureLocation( failure, testElement );
+
+  testElement->addElement( new XmlElement( "Message", thrownException->what() ) );
+
+  for ( Hooks::iterator it = m_hooks.begin(); it != m_hooks.end(); ++it )
+    (*it)->failTestAdded( m_xml, testElement, test, failure );
+}
+
+
+void
+XmlOutputter::addFailureLocation( TestFailure *failure,
+                                  XmlElement *testElement )
+{
+  XmlElement *locationNode = new XmlElement( "Location" );
+  testElement->addElement( locationNode );
+  SourceLine sourceLine = failure->sourceLine();
+  locationNode->addElement( new XmlElement( "File", sourceLine.fileName() ) );
+  locationNode->addElement( new XmlElement( "Line", sourceLine.lineNumber() ) );
+}
+
+
+void
+XmlOutputter::addSuccessfulTest( Test *test, 
+                                 int testNumber,
+                                 XmlElement *testsNode )
+{
+  XmlElement *testElement = new XmlElement( "Test" );
+  testsNode->addElement( testElement );
+  testElement->addAttribute( "id", testNumber );
+  testElement->addElement( new XmlElement( "Name", test->getName() ) );
+
+  for ( Hooks::iterator it = m_hooks.begin(); it != m_hooks.end(); ++it )
+    (*it)->successfulTestAdded( m_xml, testElement, test );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/XmlOutputter.h b/src/test/cppunit/XmlOutputter.h
new file mode 100644
index 0000000..0de9676
--- /dev/null
+++ b/src/test/cppunit/XmlOutputter.h
@@ -0,0 +1,167 @@
+#ifndef CPPUNIT_XMLTESTRESULTOUTPUTTER_H
+#define CPPUNIT_XMLTESTRESULTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/Outputter.h>
+#include <cppunit/portability/CppUnitDeque.h>
+#include <cppunit/portability/CppUnitMap.h>
+#include <cppunit/portability/Stream.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFailure;
+class TestResultCollector;
+class XmlDocument;
+class XmlElement;
+class XmlOutputterHook;
+
+
+/*! \brief Outputs a TestResultCollector in XML format.
+ * \ingroup WritingTestResult
+ *
+ * Save the test result as a XML stream. 
+ *
+ * Additional datas can be added to the XML document using XmlOutputterHook. 
+ * Hook are not owned by the XmlOutputter. They should be valid until 
+ * destruction of the XmlOutputter. They can be removed with removeHook().
+ *
+ * \see XmlDocument, XmlElement, XmlOutputterHook.
+ */
+class CPPUNIT_API XmlOutputter : public Outputter
+{
+public:
+  /*! \brief Constructs a XmlOutputter object.
+   * \param result Result of the test run.
+   * \param stream Stream used to output the XML output.
+   * \param encoding Encoding used in the XML file (default is Latin-1). 
+   */
+  XmlOutputter( TestResultCollector *result,
+                OStream &stream,
+                std::string encoding = std::string("ISO-8859-1") );
+
+  /// Destructor.
+  virtual ~XmlOutputter();
+
+  /*! \brief Adds the specified hook to the outputter.
+   * \param hook Hook to add. Must not be \c NULL.
+   */
+  virtual void addHook( XmlOutputterHook *hook );
+
+  /*! \brief Removes the specified hook from the outputter.
+   * \param hook Hook to remove.
+   */
+  virtual void removeHook( XmlOutputterHook *hook );
+
+  /*! \brief Writes the specified result as an XML document to the stream.
+   *
+   * Refer to examples/cppunittest/XmlOutputterTest.cpp for example
+   * of use and XML document structure.
+   */
+  virtual void write();
+
+  /*! \brief Sets the XSL style sheet used.
+   *
+   * \param styleSheet Name of the style sheet used. If empty, then no style sheet
+   *                   is used (default).
+   */
+  virtual void setStyleSheet( const std::string &styleSheet );
+
+  /*! \brief set the output document as standalone or not.
+   *
+   *  For the output document, specify wether it's a standalone XML
+   *  document, or not.
+   *
+   *  \param standalone if true, the output will be specified as standalone.
+   *         if false, it will be not.
+   */
+  virtual void setStandalone( bool standalone );
+
+  typedef CppUnitMap<Test *,TestFailure*, std::less<Test*> > FailedTests;
+
+  /*! \brief Sets the root element and adds its children.
+   *
+   * Set the root element of the XML Document and add its child elements.
+   *
+   * For all hooks, call beginDocument() just after creating the root element (it
+   * is empty at this time), and endDocument() once all the datas have been added
+   * to the root element.
+   */
+  virtual void setRootNode();
+
+  virtual void addFailedTests( FailedTests &failedTests,
+                               XmlElement *rootNode );
+
+  virtual void addSuccessfulTests( FailedTests &failedTests,
+                                   XmlElement *rootNode );
+
+  /*! \brief Adds the statics element to the root node.
+   * 
+   * Creates a new element containing statistics data and adds it to the root element.
+   * Then, for all hooks, call statisticsAdded().
+   * \param rootNode Root element.
+   */
+  virtual void addStatistics( XmlElement *rootNode );
+
+  /*! \brief Adds a failed test to the failed tests node.
+   * Creates a new element containing datas about the failed test, and adds it to 
+   * the failed tests element.
+   * Then, for all hooks, call failTestAdded().
+   */
+  virtual void addFailedTest( Test *test,
+                              TestFailure *failure,
+                              int testNumber,
+                              XmlElement *testsNode );
+
+  virtual void addFailureLocation( TestFailure *failure,
+                                   XmlElement *testElement );
+
+
+  /*! \brief Adds a successful test to the successful tests node.
+   * Creates a new element containing datas about the successful test, and adds it to 
+   * the successful tests element.
+   * Then, for all hooks, call successfulTestAdded().
+   */
+  virtual void addSuccessfulTest( Test *test, 
+                                  int testNumber,
+                                  XmlElement *testsNode );
+protected:
+  virtual void fillFailedTestsMap( FailedTests &failedTests );
+
+protected:
+  typedef CppUnitDeque<XmlOutputterHook *> Hooks;
+
+  TestResultCollector *m_result;
+  OStream &m_stream;
+  std::string m_encoding;
+  std::string m_styleSheet;
+  XmlDocument *m_xml;
+  Hooks m_hooks;
+
+private:
+  /// Prevents the use of the copy constructor.
+  XmlOutputter( const XmlOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const XmlOutputter &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_XMLTESTRESULTOUTPUTTER_H
diff --git a/src/test/cppunit/XmlOutputterHook.cpp b/src/test/cppunit/XmlOutputterHook.cpp
new file mode 100644
index 0000000..4b4e8d8
--- /dev/null
+++ b/src/test/cppunit/XmlOutputterHook.cpp
@@ -0,0 +1,44 @@
+#include <cppunit/XmlOutputterHook.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+void 
+XmlOutputterHook::beginDocument( XmlDocument *document )
+{
+}
+
+
+void 
+XmlOutputterHook::endDocument( XmlDocument *document )
+{
+}
+
+
+void 
+XmlOutputterHook::failTestAdded( XmlDocument *document,
+                                 XmlElement *testElement,
+                                 Test *test,
+                                 TestFailure *failure )
+{
+}
+
+
+void 
+XmlOutputterHook::successfulTestAdded( XmlDocument *document,
+                                       XmlElement *testElement,
+                                       Test *test )
+{
+}
+
+
+void 
+XmlOutputterHook::statisticsAdded( XmlDocument *document,
+                                   XmlElement *statisticsElement )
+{
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/XmlOutputterHook.h b/src/test/cppunit/XmlOutputterHook.h
new file mode 100644
index 0000000..5ded3b1
--- /dev/null
+++ b/src/test/cppunit/XmlOutputterHook.h
@@ -0,0 +1,163 @@
+#ifndef CPPUNIT_XMLOUTPUTTERHOOK_H
+#define CPPUNIT_XMLOUTPUTTERHOOK_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFailure;
+class XmlDocument;
+class XmlElement;
+
+
+
+/*! \brief Hook to customize Xml output.
+ *
+ * XmlOutputterHook can be passed to XmlOutputter to customize the XmlDocument.
+ *
+ * Common customizations are:
+ * - adding some datas to successfull or failed test with
+ *   failTestAdded() and successfulTestAdded(),
+ * - adding some statistics with statisticsAdded(),
+ * - adding other datas with beginDocument() or endDocument().
+ *
+ * See examples/ClockerPlugIn which makes use of most the hook.
+ *
+ * Another simple example of an outputter hook is shown below. It may be  
+ * used to add some meta information to your result files. In the example,
+ * the author name as well as the project name and test creation date is
+ * added to the head of the xml file.
+ *
+ * In order to make this information stored within the xml file, the virtual 
+ * member function beginDocument() is overriden where a new 
+ * XmlElement object is created.
+ *
+ * This element is simply added to the root node of the document which
+ * makes the information automatically being stored when the xml file
+ * is written.
+ *
+ * \code
+ * #include <cppunit/XmlOutputterHook.h>
+ * #include <cppunit/XmlElement.h>
+ * #include <cppunit/tools/StringTools.h>
+ * 
+ * ...
+ * 
+ * class MyXmlOutputterHook : public CppUnit::XmlOutputterHook
+ * {
+ * public:
+ *   MyXmlOutputterHook(const std::string projectName,
+ *                      const std::string author)
+ *   {
+ *      m_projectName = projectName;
+ *      m_author      = author;
+ *   };
+ * 
+ *   virtual ~MyXmlOutputterHook()
+ *   {
+ *   };
+ * 
+ *   void beginDocument(CppUnit::XmlDocument* document)
+ *   {
+ *     if (!document)
+ *       return;
+ *
+ *     // dump current time
+ *     std::string szDate          = CppUnit::StringTools::toString( (int)time(0) );
+ *     CppUnit::XmlElement* metaEl = new CppUnit::XmlElement("SuiteInfo", 
+ *                                                           "");
+ *
+ *     metaEl->addElement( new CppUnit::XmlElement("Author", m_author) );
+ *     metaEl->addElement( new CppUnit::XmlElement("Project", m_projectName) );
+ *     metaEl->addElement( new CppUnit::XmlElement("Date", szDate ) );
+ *    
+ *     document->rootElement().addElement(metaEl);
+ *   };
+ * private:
+ *   std::string m_projectName;
+ *   std::string m_author;
+ * }; 
+ * \endcode
+ *
+ * Within your application's main code, you need to snap the hook 
+ * object into your xml outputter object like shown below:
+ *
+ * \code
+ * CppUnit::TextUi::TestRunner runner;
+ * std::ofstream outputFile("testResults.xml");
+ * 
+ * CppUnit::XmlOutputter* outputter = new CppUnit::XmlOutputter( &runner.result(),
+ *                                                               outputFile );    
+ * MyXmlOutputterHook hook("myProject", "meAuthor");
+ * outputter->addHook(&hook);
+ * runner.setOutputter(outputter);    
+ * runner.addTest( VectorFixture::suite() );   
+ * runner.run();
+ * outputFile.close();
+ * \endcode
+ *
+ * This results into the following output:
+ *
+ * \code
+ * <TestRun>
+ *   <suiteInfo>
+ *     <author>meAuthor</author>
+ *     <project>myProject</project>
+ *     <date>1028143912</date>
+ *   </suiteInfo>
+ *   <FailedTests>
+ *    ...
+ * \endcode
+ *
+ * \see XmlOutputter, CppUnitTestPlugIn.
+ */
+class CPPUNIT_API XmlOutputterHook
+{
+public:
+  /*! Called before any elements is added to the root element.
+   * \param document XML Document being created.
+   */
+  virtual void beginDocument( XmlDocument *document );
+
+  /*! Called after adding all elements to the root element.
+   * \param document XML Document being created.
+   */
+  virtual void endDocument( XmlDocument *document );
+
+  /*! Called after adding a fail test element.
+   * \param document XML Document being created.
+   * \param testElement \<FailedTest\> element.
+   * \param test Test that failed.
+   * \param failure Test failure data.
+   */
+  virtual void failTestAdded( XmlDocument *document,
+                              XmlElement *testElement,
+                              Test *test,
+                              TestFailure *failure );
+
+  /*! Called after adding a successful test element.
+   * \param document XML Document being created.
+   * \param testElement \<Test\> element.
+   * \param test Test that was successful.
+   */
+  virtual void successfulTestAdded( XmlDocument *document,
+                                    XmlElement *testElement,
+                                    Test *test );
+
+  /*! Called after adding the statistic element.
+   * \param document XML Document being created.
+   * \param statisticsElement \<Statistics\> element.
+   */
+  virtual void statisticsAdded( XmlDocument *document,
+                                XmlElement *statisticsElement );
+
+  virtual ~XmlOutputterHook() {}
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_XMLOUTPUTTERHOOK_H
diff --git a/src/test/cppunit/config/CppUnitApi.h b/src/test/cppunit/config/CppUnitApi.h
new file mode 100644
index 0000000..a068bbd
--- /dev/null
+++ b/src/test/cppunit/config/CppUnitApi.h
@@ -0,0 +1,33 @@
+#ifndef CPPUNIT_CONFIG_CPPUNITAPI
+#define CPPUNIT_CONFIG_CPPUNITAPI
+
+#undef CPPUNIT_API
+
+#ifdef WIN32
+
+// define CPPUNIT_DLL_BUILD when building CppUnit dll.
+#ifdef CPPUNIT_BUILD_DLL
+#define CPPUNIT_API __declspec(dllexport)
+#endif
+
+// define CPPUNIT_DLL when linking to CppUnit dll.
+#ifdef CPPUNIT_DLL
+#define CPPUNIT_API __declspec(dllimport)
+#endif
+
+#ifdef CPPUNIT_API
+#undef CPPUNIT_NEED_DLL_DECL
+#define CPPUNIT_NEED_DLL_DECL 1
+#endif
+
+#endif
+
+
+#ifndef CPPUNIT_API
+#define CPPUNIT_API
+#undef CPPUNIT_NEED_DLL_DECL
+#define CPPUNIT_NEED_DLL_DECL 0
+#endif
+
+ 
+#endif  // CPPUNIT_CONFIG_CPPUNITAPI
diff --git a/src/test/cppunit/config/Makefile.am b/src/test/cppunit/config/Makefile.am
new file mode 100644
index 0000000..2f0b1f8
--- /dev/null
+++ b/src/test/cppunit/config/Makefile.am
@@ -0,0 +1,10 @@
+libcppunitincludedir = $(includedir)/cppunit/config
+
+libcppunitinclude_HEADERS = \
+	config-bcb5.h \
+	config-evc4.h \
+	config-mac.h \
+	config-msvc6.h \
+	SelectDllLoader.h \
+	CppUnitApi.h \
+  SourcePrefix.h
diff --git a/src/test/cppunit/config/Makefile.in b/src/test/cppunit/config/Makefile.in
new file mode 100644
index 0000000..4c21edb
--- /dev/null
+++ b/src/test/cppunit/config/Makefile.in
@@ -0,0 +1,438 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/config
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/config
+libcppunitinclude_HEADERS = \
+	config-bcb5.h \
+	config-evc4.h \
+	config-mac.h \
+	config-msvc6.h \
+	SelectDllLoader.h \
+	CppUnitApi.h \
+  SourcePrefix.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/config/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/config/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/config/SelectDllLoader.h b/src/test/cppunit/config/SelectDllLoader.h
new file mode 100644
index 0000000..dc1c011
--- /dev/null
+++ b/src/test/cppunit/config/SelectDllLoader.h
@@ -0,0 +1,76 @@
+#ifndef CPPUNIT_CONFIG_SELECTDLLLOADER_H
+#define CPPUNIT_CONFIG_SELECTDLLLOADER_H
+
+/*! \file
+ * Selects DynamicLibraryManager implementation.
+ *
+ * Don't include this file directly. Include Portability.h instead.
+ */
+
+/*!
+ * \def CPPUNIT_NO_TESTPLUGIN
+ * \brief If defined, then plug-in related classes and functions will not be compiled.
+ * 
+ * \internal
+ * CPPUNIT_HAVE_WIN32_DLL_LOADER
+ * If defined, Win32 implementation of DynamicLibraryManager will be used.
+ * 
+ * CPPUNIT_HAVE_BEOS_DLL_LOADER
+ * If defined, BeOs implementation of DynamicLibraryManager will be used.
+ * 
+ * CPPUNIT_HAVE_UNIX_DLL_LOADER
+ * If defined, Unix implementation (dlfcn.h) of DynamicLibraryManager will be used.
+ */
+
+/*!
+ * \def CPPUNIT_PLUGIN_EXPORT
+ * \ingroup WritingTestPlugIn
+ * \brief A macro to export a function from a dynamic library
+ *
+ * This macro export the C function following it from a dynamic library. 
+ * Exporting the function makes it accessible to the DynamicLibraryManager.
+ *
+ * Example of usage:
+ * \code
+ * #include <cppunit/include/plugin/TestPlugIn.h>
+ *
+ * CPPUNIT_PLUGIN_EXPORT CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void)
+ * {
+ *   ...
+ *   return &myPlugInInterface;
+ * }
+ * \endcode
+ */
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+// Is WIN32 platform ?
+#if defined(WIN32)
+#define CPPUNIT_HAVE_WIN32_DLL_LOADER 1
+#undef CPPUNIT_PLUGIN_EXPORT
+#define CPPUNIT_PLUGIN_EXPORT extern "C" __declspec(dllexport)
+
+// Is BeOS platform ?
+#elif defined(__BEOS__)
+#define CPPUNIT_HAVE_BEOS_DLL_LOADER 1
+
+// Is Unix platform and have shl_load() (hp-ux)
+#elif defined(CPPUNIT_HAVE_SHL_LOAD)
+#define CPPUNIT_HAVE_UNIX_SHL_LOADER 1
+
+// Is Unix platform and have include <dlfcn.h>
+#elif defined(CPPUNIT_HAVE_LIBDL)
+#define CPPUNIT_HAVE_UNIX_DLL_LOADER 1
+
+// Otherwise, disable support for DllLoader
+#else
+#define CPPUNIT_NO_TESTPLUGIN 1
+#endif
+
+#if !defined(CPPUNIT_PLUGIN_EXPORT)
+#define CPPUNIT_PLUGIN_EXPORT extern "C"
+#endif // !defined(CPPUNIT_PLUGIN_EXPORT)
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif // CPPUNIT_CONFIG_SELECTDLLLOADER_H
diff --git a/src/test/cppunit/config/SourcePrefix.h b/src/test/cppunit/config/SourcePrefix.h
new file mode 100644
index 0000000..2334601
--- /dev/null
+++ b/src/test/cppunit/config/SourcePrefix.h
@@ -0,0 +1,14 @@
+#ifndef CPPUNIT_CONFIG_H_INCLUDED
+#define CPPUNIT_CONFIG_H_INCLUDED
+
+#include <cppunit/Portability.h>
+
+#ifdef _MSC_VER
+#pragma warning(disable: 4018 4284 4146)
+#if _MSC_VER >= 1400
+#pragma warning(disable: 4996)		// sprintf is deprecated
+#endif
+#endif
+
+
+#endif // CPPUNIT_CONFIG_H_INCLUDED
diff --git a/src/test/cppunit/config/config-bcb5.h b/src/test/cppunit/config/config-bcb5.h
new file mode 100644
index 0000000..d491452
--- /dev/null
+++ b/src/test/cppunit/config/config-bcb5.h
@@ -0,0 +1,47 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_BCB5_H
+#define _INCLUDE_CPPUNIT_CONFIG_BCB5_H 1
+
+#define HAVE_CMATH 1
+ 
+/* include/cppunit/config-bcb5.h. Manually adapted from 
+   include/cppunit/config-auto.h */
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifndef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#define CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST  0
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  1 
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+#define CPPUNIT_HAVE_SSTREAM 1
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+ 
+/* _INCLUDE_CPPUNIT_CONFIG_BCB5_H */
+#endif
diff --git a/src/test/cppunit/config/config-evc4.h b/src/test/cppunit/config/config-evc4.h
new file mode 100644
index 0000000..a791698
--- /dev/null
+++ b/src/test/cppunit/config/config-evc4.h
@@ -0,0 +1,78 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_EVC4_H
+#define _INCLUDE_CPPUNIT_CONFIG_EVC4_H 1
+
+#if _MSC_VER > 1000     // VC++
+#pragma warning( disable : 4786 )   // disable warning debug symbol > 255...
+#endif // _MSC_VER > 1000
+
+#define HAVE_CMATH 1
+ 
+/* include/cppunit/config-msvc6.h. Manually adapted from 
+   include/cppunit/config-auto.h */
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  0
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+#define CPPUNIT_NO_STREAM 1
+#define CPPUNIT_NO_ASSERT 1
+
+#define CPPUNIT_HAVE_SSTREAM 0
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+
+
+// Compiler error location format for CompilerOutputter
+// See class CompilerOutputter for format.
+#undef CPPUNIT_COMPILER_LOCATION_FORMAT
+#if _MSC_VER >= 1300    // VS 7.0
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l) : error : "
+#else
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l):"
+#endif
+
+/* define to 1 if the compiler has _finite() */
+#ifndef CPPUNIT_HAVE__FINITE
+#define CPPUNIT_HAVE__FINITE 1 
+#endif
+
+// Uncomment to turn on STL wrapping => use this to test compilation. 
+// This will make CppUnit subclass std::vector & co to provide default
+// parameter.
+/*#define CPPUNIT_STD_NEED_ALLOCATOR 1
+#define CPPUNIT_STD_ALLOCATOR std::allocator<T>
+//#define CPPUNIT_NO_NAMESPACE 1
+*/
+
+
+/* _INCLUDE_CPPUNIT_CONFIG_EVC4_H */
+#endif
diff --git a/src/test/cppunit/config/config-mac.h b/src/test/cppunit/config/config-mac.h
new file mode 100644
index 0000000..4ace906
--- /dev/null
+++ b/src/test/cppunit/config/config-mac.h
@@ -0,0 +1,58 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_MAC_H
+#define _INCLUDE_CPPUNIT_CONFIG_MAC_H 1
+
+/* MacOS X should be installed using the configure script.
+   This file is for other macs.
+
+   It is not integrated into <cppunit/Portability.h> because we don't
+   know a suitable preprocessor symbol that will distinguish MacOS X
+   from other MacOS versions.  Email us if you know the answer.
+*/
+ 
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* define if the library defines strstream */
+#ifndef CPPUNIT_HAVE_CLASS_STRSTREAM 
+#define CPPUNIT_HAVE_CLASS_STRSTREAM  1 
+#endif
+
+/* Define if you have the <cmath> header file. */
+#ifdef CPPUNIT_HAVE_CMATH 
+#undef CPPUNIT_HAVE_CMATH
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  1 
+#endif
+
+/* define if the compiler has stringstream */
+#ifndef CPPUNIT_HAVE_SSTREAM 
+#define CPPUNIT_HAVE_SSTREAM  1 
+#endif
+
+/* Define if you have the <strstream> header file. */
+#ifndef CPPUNIT_HAVE_STRSTREAM 
+#define CPPUNIT_HAVE_STRSTREAM  1 
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+/* _INCLUDE_CPPUNIT_CONFIG_MAC_H */
+#endif
diff --git a/src/test/cppunit/config/config-msvc6.h b/src/test/cppunit/config/config-msvc6.h
new file mode 100644
index 0000000..d688171
--- /dev/null
+++ b/src/test/cppunit/config/config-msvc6.h
@@ -0,0 +1,83 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_MSVC6_H
+#define _INCLUDE_CPPUNIT_CONFIG_MSVC6_H 1
+
+#if _MSC_VER > 1000     // VC++
+#pragma warning( disable : 4786 )   // disable warning debug symbol > 255...
+#endif // _MSC_VER > 1000
+
+#define HAVE_CMATH 1
+ 
+/* include/cppunit/config-msvc6.h. Manually adapted from 
+   include/cppunit/config-auto.h */
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI
+# ifdef _CPPRTTI // Defined by the compiler option /GR
+#  define CPPUNIT_HAVE_RTTI 1
+# else
+#  define CPPUNIT_HAVE_RTTI 0
+# endif
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+#define CPPUNIT_HAVE_SSTREAM 1
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+
+
+// Compiler error location format for CompilerOutputter
+// See class CompilerOutputter for format.
+#undef CPPUNIT_COMPILER_LOCATION_FORMAT
+#if _MSC_VER >= 1300    // VS 7.0
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l) : error : "
+#else
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l):"
+#endif
+
+// Define to 1 if the compiler support C++ style cast.
+#define CPPUNIT_HAVE_CPP_CAST 1
+
+/* define to 1 if the compiler has _finite() */
+#ifndef CPPUNIT_HAVE__FINITE
+#define CPPUNIT_HAVE__FINITE 1 
+#endif
+
+
+// Uncomment to turn on STL wrapping => use this to test compilation. 
+// This will make CppUnit subclass std::vector & co to provide default
+// parameter.
+/*#define CPPUNIT_STD_NEED_ALLOCATOR 1
+#define CPPUNIT_STD_ALLOCATOR std::allocator<T>
+//#define CPPUNIT_NO_NAMESPACE 1
+*/
+
+
+/* _INCLUDE_CPPUNIT_CONFIG_MSVC6_H */
+#endif
diff --git a/src/test/cppunit/cppunit.dsp b/src/test/cppunit/cppunit.dsp
new file mode 100644
index 0000000..55f4769
--- /dev/null
+++ b/src/test/cppunit/cppunit.dsp
@@ -0,0 +1,707 @@
+# Microsoft Developer Studio Project File - Name="cppunit" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=CPPUNIT - WIN32 DEBUG
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "cppunit.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "cppunit.mak" CFG="CPPUNIT - WIN32 DEBUG"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "cppunit - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "cppunit - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "cppunit - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GR /GX /Zd /O2 /I "..\..\include" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "WIN32" /YX /FD /c
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo
+# Begin Special Build Tool
+TargetPath=.\Release\cppunit.lib
+TargetName=cppunit
+SOURCE="$(InputPath)"
+PostBuild_Desc=Copying target to lib/
+PostBuild_Cmds=copy "$(TargetPath)" ..\..\lib\$(TargetName).lib
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "cppunit - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GR /GX /Zi /Od /I "..\..\include" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "WIN32" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug\cppunitd.lib"
+# Begin Special Build Tool
+TargetPath=.\Debug\cppunitd.lib
+TargetName=cppunitd
+SOURCE="$(InputPath)"
+PostBuild_Desc=Copying target to lib/
+PostBuild_Cmds=copy "$(TargetPath)" ..\..\lib\$(TargetName).lib
+# End Special Build Tool
+
+!ENDIF 
+
+# Begin Target
+
+# Name "cppunit - Win32 Release"
+# Name "cppunit - Win32 Debug"
+# Begin Group "documentation"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\ChangeLog
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\CodingGuideLines.txt
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\cookbook.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\FAQ
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\INSTALL-unix"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\INSTALL-WIN32.txt"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\Money.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\NEWS
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\other_documentation.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\THANKS
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\TODO
+# End Source File
+# End Group
+# Begin Group "listener"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\BriefTestProgressListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\BriefTestProgressListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestResultCollector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestResultCollector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuccessListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestProgressListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestProgressListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestResult.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestResult.h
+# End Source File
+# End Group
+# Begin Group "textui"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\ui\text\TestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestRunner.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\ui\text\TextTestRunner.h
+# End Source File
+# End Group
+# Begin Group "portability"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-bcb5.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-evc4.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-mac.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-msvc6.h"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\CppUnitApi.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitDeque.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitMap.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitSet.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitStack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitVector.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\FloatingPoint.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Portability.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\SelectDllLoader.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\SourcePrefix.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\Stream.h
+# End Source File
+# End Group
+# Begin Group "output"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\CompilerOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\CompilerOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Outputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlOutputter.cpp
+
+!IF  "$(CFG)" == "cppunit - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "cppunit - Win32 Debug"
+
+# ADD CPP /W3
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\XmlOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlOutputterHook.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\XmlOutputterHook.h
+# End Source File
+# End Group
+# Begin Group "core"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\AdditionalMessage.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\AdditionalMessage.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Asserter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Asserter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Exception.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Exception.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Message.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Message.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\SourceLine.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\SourceLine.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\SynchronizedObject.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\SynchronizedObject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Test.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Test.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestAssert.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestAssert.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestCase.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestCase.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestComposite.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestComposite.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestFailure.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestFailure.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestFixture.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestLeaf.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestLeaf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestPath.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestPath.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestResult.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestResult.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestRunner.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuite.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestSuite.h
+# End Source File
+# End Group
+# Begin Group "helper"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\AutoRegisterSuite.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\HelperMacros.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestCaller.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestFactoryRegistry.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFactoryRegistry.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFixtureFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestNamer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestNamer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteBuilder.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuiteBuilderContext.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteBuilderContext.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TypeInfoHelper.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TypeInfoHelper.h
+# End Source File
+# End Group
+# Begin Group "extension"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\ExceptionTestCaseDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\Orthodox.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\RepeatedTest.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\RepeatedTest.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestCaseDecorator.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestCaseDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestDecorator.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSetUp.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSetUp.h
+# End Source File
+# End Group
+# Begin Group "plugin"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\BeOsDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\DynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\DynamicLibraryManager.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\DynamicLibraryManagerException.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\DynamicLibraryManagerException.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\PlugInManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\PlugInManager.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\PlugInParameters.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\PlugInParameters.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ShlDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\TestPlugIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestPlugInDefaultImpl.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\TestPlugInDefaultImpl.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\UnixDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\Win32DynamicLibraryManager.cpp
+# End Source File
+# End Group
+# Begin Group "tools"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\Algorithm.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\StringTools.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\StringTools.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlDocument.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\XmlDocument.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlElement.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\XmlElement.h
+# End Source File
+# End Group
+# Begin Group "protector"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\DefaultProtector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\DefaultProtector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Protector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Protector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorChain.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorChain.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorContext.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\..\configure.in
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Makefile.am
+# End Source File
+# Begin Source File
+
+SOURCE=.\Makefile.am
+# End Source File
+# End Target
+# End Project
diff --git a/src/test/cppunit/cppunit_dll.dsp b/src/test/cppunit/cppunit_dll.dsp
new file mode 100644
index 0000000..a7a73c7
--- /dev/null
+++ b/src/test/cppunit/cppunit_dll.dsp
@@ -0,0 +1,682 @@
+# Microsoft Developer Studio Project File - Name="cppunit_dll" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=cppunit_dll - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "cppunit_dll.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "cppunit_dll.mak" CFG="cppunit_dll - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "cppunit_dll - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "cppunit_dll - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "cppunit_dll - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "cppunit_dll___Win32_Release"
+# PROP BASE Intermediate_Dir "cppunit_dll___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "ReleaseDll"
+# PROP Intermediate_Dir "ReleaseDll"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CPPUNIT_DLL_EXPORTS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GR /GX /Zd /O2 /I "..\..\include" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CPPUNIT_BUILD_DLL" /YX /FD /c
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /pdb:"..\..\lib\cppunit_dll.pdb" /machine:I386
+# SUBTRACT LINK32 /pdb:none
+# Begin Special Build Tool
+TargetDir=.\ReleaseDll
+TargetPath=.\ReleaseDll\cppunit_dll.dll
+TargetName=cppunit_dll
+SOURCE="$(InputPath)"
+PostBuild_Desc=Copying target to lib/
+PostBuild_Cmds=copy "$(TargetPath)" ..\..\lib\$(TargetName).dll	copy "$(TargetDir)\$(TargetName).lib" ..\..\lib\$(TargetName).lib
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "cppunit_dll - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "cppunit_dll___Win32_Debug"
+# PROP BASE Intermediate_Dir "cppunit_dll___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "DebugDll"
+# PROP Intermediate_Dir "DebugDll"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CPPUNIT_DLL_EXPORTS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GR /GX /Zi /Od /I "..\..\include" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CPPUNIT_BUILD_DLL" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /pdb:"..\..\lib\cppunitd_dll.pdb" /debug /machine:I386 /out:"DebugDll\cppunitd_dll.dll" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none
+# Begin Special Build Tool
+TargetDir=.\DebugDll
+TargetPath=.\DebugDll\cppunitd_dll.dll
+TargetName=cppunitd_dll
+SOURCE="$(InputPath)"
+PostBuild_Desc=Copying target to lib/
+PostBuild_Cmds=copy "$(TargetPath)" ..\..\lib\$(TargetName).dll	copy "$(TargetDir)\$(TargetName).lib" ..\..\lib\$(TargetName).lib
+# End Special Build Tool
+
+!ENDIF 
+
+# Begin Target
+
+# Name "cppunit_dll - Win32 Release"
+# Name "cppunit_dll - Win32 Debug"
+# Begin Group "DllSpecific"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\DllMain.cpp
+# End Source File
+# End Group
+# Begin Group "extension"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\ExceptionTestCaseDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\Orthodox.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\RepeatedTest.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\RepeatedTest.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestCaseDecorator.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestCaseDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestDecorator.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSetUp.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSetUp.h
+# End Source File
+# End Group
+# Begin Group "helper"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\AutoRegisterSuite.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\HelperMacros.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestCaller.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestFactoryRegistry.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFactoryRegistry.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFixtureFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestNamer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestNamer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteBuilder.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuiteBuilderContext.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteBuilderContext.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TypeInfoHelper.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TypeInfoHelper.h
+# End Source File
+# End Group
+# Begin Group "core"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\AdditionalMessage.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\AdditionalMessage.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Asserter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Asserter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Exception.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Exception.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Message.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Message.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\SourceLine.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\SourceLine.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\SynchronizedObject.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\SynchronizedObject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Test.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Test.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestAssert.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestAssert.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestCase.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestCase.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestComposite.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestComposite.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestFailure.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestFailure.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestFixture.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestLeaf.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestLeaf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestPath.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestPath.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestResult.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestResult.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestRunner.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuite.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestSuite.h
+# End Source File
+# End Group
+# Begin Group "output"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\CompilerOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\CompilerOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Outputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestResultCollector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestResultCollector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\XmlOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlOutputterHook.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\XmlOutputterHook.h
+# End Source File
+# End Group
+# Begin Group "portability"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-bcb5.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-mac.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-msvc6.h"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\CppUnitApi.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitDeque.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitMap.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitSet.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitStack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitVector.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Portability.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\SelectDllLoader.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\SourcePrefix.h
+# End Source File
+# End Group
+# Begin Group "textui"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\ui\text\TestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestRunner.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\ui\text\TextTestRunner.h
+# End Source File
+# End Group
+# Begin Group "listener"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\BriefTestProgressListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\BriefTestProgressListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuccessListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestProgressListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestProgressListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestResult.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestResult.h
+# End Source File
+# End Group
+# Begin Group "documentation"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\ChangeLog
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\cookbook.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\FAQ
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\NEWS
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\other_documentation.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\TODO
+# End Source File
+# End Group
+# Begin Group "plugin"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\BeosDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\DynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\DynamicLibraryManager.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\DynamicLibraryManagerException.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\DynamicLibraryManagerException.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\PlugInManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\PlugInManager.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\PlugInParameters.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\PlugInParameters.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\TestPlugIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestPlugInDefaultImpl.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\TestPlugInDefaultImpl.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\UnixDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\Win32DynamicLibraryManager.cpp
+# End Source File
+# End Group
+# Begin Group "tools"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\StringTools.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\StringTools.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlDocument.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\XmlDocument.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlElement.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\XmlElement.h
+# End Source File
+# End Group
+# Begin Group "protector"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\DefaultProtector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\DefaultProtector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Protector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Protector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorChain.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorChain.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorContext.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE="..\..\INSTALL-WIN32.txt"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Makefile.am
+# End Source File
+# Begin Source File
+
+SOURCE=.\Makefile.am
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\XmlInputHelper.h
+# End Source File
+# End Target
+# End Project
diff --git a/src/test/cppunit/extensions/AutoRegisterSuite.h b/src/test/cppunit/extensions/AutoRegisterSuite.h
new file mode 100644
index 0000000..e04adb5
--- /dev/null
+++ b/src/test/cppunit/extensions/AutoRegisterSuite.h
@@ -0,0 +1,83 @@
+#ifndef CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
+#define CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
+
+#include <cppunit/extensions/TestSuiteFactory.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief (Implementation) Automatically register the test suite of the specified type.
+ *
+ * You should not use this class directly. Instead, use the following macros:
+ * - CPPUNIT_TEST_SUITE_REGISTRATION()
+ * - CPPUNIT_TEST_SUITE_NAMED_REGISTRATION()
+ *
+ * This object will register the test returned by TestCaseType::suite()
+ * when constructed to the test registry.
+ *
+ * This object is intented to be used as a static variable.
+ *
+ *
+ * \param TestCaseType Type of the test case which suite is registered.
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ * \see CppUnit::TestFactoryRegistry.
+ */
+template<class TestCaseType>
+class AutoRegisterSuite
+{
+public:
+  /** Auto-register the suite factory in the global registry.
+   */
+  AutoRegisterSuite()
+      : m_registry( &TestFactoryRegistry::getRegistry() )
+  {
+    m_registry->registerFactory( &m_factory );
+  }
+
+  /** Auto-register the suite factory in the specified registry.
+   * \param name Name of the registry.
+   */
+  AutoRegisterSuite( const std::string &name )
+      : m_registry( &TestFactoryRegistry::getRegistry( name ) )
+  {
+    m_registry->registerFactory( &m_factory );
+  }
+
+  ~AutoRegisterSuite()
+  {
+    if ( TestFactoryRegistry::isValid() )
+      m_registry->unregisterFactory( &m_factory );
+  }
+
+private:
+  TestFactoryRegistry *m_registry;
+  TestSuiteFactory<TestCaseType> m_factory;
+};
+
+
+/*! \brief (Implementation) Automatically adds a registry into another registry.
+ *
+ * Don't use this class. Use the macros CPPUNIT_REGISTRY_ADD() and
+ * CPPUNIT_REGISTRY_ADD_TO_DEFAULT() instead.
+ */
+class AutoRegisterRegistry
+{
+public:
+  AutoRegisterRegistry( const std::string &which,
+                        const std::string &to )
+  {
+    TestFactoryRegistry::getRegistry( to ).addRegistry( which );
+  }
+
+  AutoRegisterRegistry( const std::string &which )
+  {
+    TestFactoryRegistry::getRegistry().addRegistry( which );
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
diff --git a/src/test/cppunit/extensions/ExceptionTestCaseDecorator.h b/src/test/cppunit/extensions/ExceptionTestCaseDecorator.h
new file mode 100644
index 0000000..9c816ad
--- /dev/null
+++ b/src/test/cppunit/extensions/ExceptionTestCaseDecorator.h
@@ -0,0 +1,104 @@
+#ifndef CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+#define CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Exception.h>
+#include <cppunit/extensions/TestCaseDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Expected exception test case decorator.
+ *
+ * A decorator used to assert that a specific test case should throw an
+ * exception of a given type.
+ *
+ * You should use this class only if you need to check the exception object
+ * state (that a specific cause is set for example). If you don't need to
+ * do that, you might consider using CPPUNIT_TEST_EXCEPTION() instead.
+ *
+ * Intended use is to subclass and override checkException(). Example:
+ *
+ * \code
+ *
+ * class NetworkErrorTestCaseDecorator : 
+ *           public ExceptionTestCaseDecorator<NetworkError>
+ * {
+ * public:
+ *   NetworkErrorTestCaseDecorator( NetworkError::Cause expectedCause )
+ *       : m_expectedCause( expectedCause )
+ *   {
+ *   }
+ * private:
+ *   void checkException( ExpectedExceptionType &e )
+ *   {
+ *     CPPUNIT_ASSERT_EQUAL( m_expectedCause, e.getCause() );
+ *   }
+ *
+ *   NetworkError::Cause m_expectedCause;
+ * };
+ * \endcode
+ *
+ */ 
+template<class ExpectedException>
+class ExceptionTestCaseDecorator : public TestCaseDecorator
+{
+public:
+  typedef ExpectedException ExpectedExceptionType;
+
+  /*! \brief Decorates the specified test.
+   * \param test TestCase to decorate. Assumes ownership of the test.
+   */
+  ExceptionTestCaseDecorator( TestCase *test )
+      : TestCaseDecorator( test )
+  {
+  }
+
+  /*! \brief Checks that the expected exception is thrown by the decorated test.
+   * is thrown.
+   *
+   * Calls the decorated test runTest() and checks that an exception of
+   * type ExpectedException is thrown. Call checkException() passing the
+   * exception that was caught so that some assertions can be made if
+   * needed.
+   */
+  void runTest()
+  {
+    try
+    {
+      TestCaseDecorator::runTest();
+    }
+    catch ( ExpectedExceptionType &e )
+    {
+      checkException( e );
+      return;
+    }
+
+    // Moved outside the try{} statement to handle the case where the
+    // expected exception type is Exception (expecting assertion failure).
+#if CPPUNIT_USE_TYPEINFO_NAME
+      throw Exception( Message(
+                         "expected exception not thrown",
+                         "Expected exception type: " + 
+                           TypeInfoHelper::getClassName( 
+                               typeid( ExpectedExceptionType ) ) ) );
+#else
+      throw Exception( Message("expected exception not thrown") );
+#endif
+  }
+
+private:
+  /*! \brief Called when the exception is caught.
+   *
+   * Should be overriden to check the exception.
+   */
+  virtual void checkException( ExpectedExceptionType &e )
+  {
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+
diff --git a/src/test/cppunit/extensions/HelperMacros.h b/src/test/cppunit/extensions/HelperMacros.h
new file mode 100644
index 0000000..12431e4
--- /dev/null
+++ b/src/test/cppunit/extensions/HelperMacros.h
@@ -0,0 +1,541 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file HelperMacros.h
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/04/15
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_EXTENSIONS_HELPERMACROS_H
+#define CPPUNIT_EXTENSIONS_HELPERMACROS_H
+
+#include <cppunit/TestCaller.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/extensions/AutoRegisterSuite.h>
+#include <cppunit/extensions/ExceptionTestCaseDecorator.h>
+#include <cppunit/extensions/TestFixtureFactory.h>
+#include <cppunit/extensions/TestNamer.h>
+#include <cppunit/extensions/TestSuiteBuilderContext.h>
+#include <memory>
+
+
+/*! \addtogroup WritingTestFixture Writing test fixture
+ */
+/** @{
+ */
+
+
+/** \file
+ * Macros intended to ease the definition of test suites.
+ *
+ * The macros
+ * CPPUNIT_TEST_SUITE(), CPPUNIT_TEST(), and CPPUNIT_TEST_SUITE_END()
+ * are designed to facilitate easy creation of a test suite.
+ * For example,
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST( testEquality );
+ *   CPPUNIT_TEST( testSetName );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testEquality();
+ *   void testSetName();
+ * };
+ * \endcode
+ * 
+ * The effect of these macros is to define two methods in the
+ * class MyTest.  The first method is an auxiliary function
+ * named registerTests that you will not need to call directly.
+ * The second function
+ * \code static CppUnit::TestSuite *suite()\endcode
+ * returns a pointer to the suite of tests defined by the CPPUNIT_TEST()
+ * macros.  
+ *
+ * Rather than invoking suite() directly,
+ * the macro CPPUNIT_TEST_SUITE_REGISTRATION() is
+ * used to create a static variable that automatically
+ * registers its test suite in a global registry.
+ * The registry yields a Test instance containing all the
+ * registered suites.
+ * \code
+ * CPPUNIT_TEST_SUITE_REGISTRATION( MyTest );
+ * CppUnit::Test* tp =
+ *   CppUnit::TestFactoryRegistry::getRegistry().makeTest();
+ * \endcode
+ * 
+ * The test suite macros can even be used with templated test classes.
+ * For example:
+ *
+ * \code
+ * template<typename CharType>
+ * class StringTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( StringTest );
+ *   CPPUNIT_TEST( testAppend );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:  
+ *   ...
+ * };
+ * \endcode
+ *
+ * You need to add in an implementation file:
+ *
+ * \code
+ * CPPUNIT_TEST_SUITE_REGISTRATION( StringTest<char> );
+ * CPPUNIT_TEST_SUITE_REGISTRATION( StringTest<wchar_t> );
+ * \endcode
+ */
+
+
+/*! \brief Begin test suite
+ *
+ * This macro starts the declaration of a new test suite.
+ * Use CPPUNIT_TEST_SUB_SUITE() instead, if you wish to include the
+ * test suite of the parent class.
+ *
+ * \param ATestFixtureType Type of the test case class. This type \b MUST
+ *                         be derived from TestFixture.
+ * \see CPPUNIT_TEST_SUB_SUITE, CPPUNIT_TEST, CPPUNIT_TEST_SUITE_END, 
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_EXCEPTION, CPPUNIT_TEST_FAIL.
+ */
+#define CPPUNIT_TEST_SUITE( ATestFixtureType )                              \
+  public:                                                                   \
+    typedef ATestFixtureType TestFixtureType;                               \
+                                                                            \
+  private:                                                                  \
+    static const CPPUNIT_NS::TestNamer &getTestNamer__()                    \
+    {                                                                       \
+      static CPPUNIT_TESTNAMER_DECL( testNamer, ATestFixtureType );         \
+      return testNamer;                                                     \
+    }                                                                       \
+                                                                            \
+  public:                                                                   \
+    typedef CPPUNIT_NS::TestSuiteBuilderContext<TestFixtureType>            \
+                TestSuiteBuilderContextType;                                \
+                                                                            \
+    static void                                                             \
+    addTestsToSuite( CPPUNIT_NS::TestSuiteBuilderContextBase &baseContext ) \
+    {                                                                       \
+      TestSuiteBuilderContextType context( baseContext )
+
+
+/*! \brief Begin test suite (includes parent suite)
+ * 
+ * This macro may only be used in a class whose parent class
+ * defines a test suite using CPPUNIT_TEST_SUITE() or CPPUNIT_TEST_SUB_SUITE().
+ *
+ * This macro begins the declaration of a test suite, in the same
+ * manner as CPPUNIT_TEST_SUITE().  In addition, the test suite of the
+ * parent is automatically inserted in the test suite being
+ * defined.
+ * 
+ * Here is an example:
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class MySubTest : public MyTest {
+ *   CPPUNIT_TEST_SUB_SUITE( MySubTest, MyTest );
+ *   CPPUNIT_TEST( testAdd );
+ *   CPPUNIT_TEST( testSub );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testAdd();
+ *   void testSub();
+ * };
+ * \endcode
+ *
+ * \param ATestFixtureType Type of the test case class. This type \b MUST
+ *                         be derived from TestFixture.
+ * \param ASuperClass   Type of the parent class.
+ * \see CPPUNIT_TEST_SUITE.
+ */
+#define CPPUNIT_TEST_SUB_SUITE( ATestFixtureType, ASuperClass )  \
+  public:                                                        \
+    typedef ASuperClass ParentTestFixtureType;                   \
+  private:                                                       \
+    CPPUNIT_TEST_SUITE( ATestFixtureType );                      \
+      ParentTestFixtureType::addTestsToSuite( baseContext )
+
+
+/*! \brief End declaration of the test suite.
+ *
+ * After this macro, member access is set to "private".
+ *
+ * \see  CPPUNIT_TEST_SUITE.
+ * \see  CPPUNIT_TEST_SUITE_REGISTRATION.
+ */
+#define CPPUNIT_TEST_SUITE_END()                                               \
+    }                                                                          \
+                                                                               \
+    static CPPUNIT_NS::TestSuite *suite()                                      \
+    {                                                                          \
+      const CPPUNIT_NS::TestNamer &namer = getTestNamer__();                   \
+      std::auto_ptr<CPPUNIT_NS::TestSuite> suite(                              \
+             new CPPUNIT_NS::TestSuite( namer.getFixtureName() ));             \
+      CPPUNIT_NS::ConcretTestFixtureFactory<TestFixtureType> factory;          \
+      CPPUNIT_NS::TestSuiteBuilderContextBase context( *suite.get(),           \
+                                                       namer,                  \
+                                                       factory );              \
+      TestFixtureType::addTestsToSuite( context );                             \
+      return suite.release();                                                  \
+    }                                                                          \
+  private: /* dummy typedef so that the macro can still end with ';'*/         \
+    typedef int CppUnitDummyTypedefForSemiColonEnding__
+
+/*! \brief End declaration of an abstract test suite.
+ *
+ * Use this macro to indicate that the %TestFixture is abstract. No
+ * static suite() method will be declared. 
+ *
+ * After this macro, member access is set to "private".
+ *
+ * Here is an example of usage:
+ *
+ * The abstract test fixture:
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class AbstractDocument;
+ * class AbstractDocumentTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( AbstractDocumentTest );
+ *   CPPUNIT_TEST( testInsertText );
+ *   CPPUNIT_TEST_SUITE_END_ABSTRACT();
+ * public:
+ *   void testInsertText();
+ * 
+ *   void setUp()
+ *   {
+ *     m_document = makeDocument();
+ *   }
+ *
+ *   void tearDown()
+ *   {
+ *     delete m_document;
+ *   }
+ * protected:
+ *   virtual AbstractDocument *makeDocument() =0;
+ *
+ *   AbstractDocument *m_document;
+ * };\endcode
+ *
+ * The concret test fixture:
+ * \code
+ * class RichTextDocumentTest : public AbstractDocumentTest {
+ *   CPPUNIT_TEST_SUB_SUITE( RichTextDocumentTest, AbstractDocumentTest );
+ *   CPPUNIT_TEST( testInsertFormatedText );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testInsertFormatedText();
+ * protected:
+ *   AbstractDocument *makeDocument()
+ *   {
+ *     return new RichTextDocument();
+ *   }
+ * };\endcode
+ *
+ * \see  CPPUNIT_TEST_SUB_SUITE.
+ * \see  CPPUNIT_TEST_SUITE_REGISTRATION.
+ */
+#define CPPUNIT_TEST_SUITE_END_ABSTRACT()                                      \
+    }                                                                          \
+  private: /* dummy typedef so that the macro can still end with ';'*/         \
+    typedef int CppUnitDummyTypedefForSemiColonEnding__
+
+
+/*! \brief Add a test to the suite (for custom test macro).
+ *
+ * The specified test will be added to the test suite being declared. This macro
+ * is intended for \e advanced usage, to extend %CppUnit by creating new macro such
+ * as CPPUNIT_TEST_EXCEPTION()...
+ *
+ * Between macro CPPUNIT_TEST_SUITE() and CPPUNIT_TEST_SUITE_END(), you can assume
+ * that the following variables can be used:
+ * \code
+ * typedef TestSuiteBuilder<TestFixtureType> TestSuiteBuilderType;
+ * TestSuiteBuilderType &context;
+ * \endcode
+ *
+ * \c context can be used to name test case, create new test fixture instance,
+ * or add test case to the test fixture suite.
+ *
+ * Below is an example that show how to use this macro to create new macro to add
+ * test to the fixture suite. The macro below show how you would add a new type
+ * of test case which fails if the execution last more than a given time limit.
+ * It relies on an imaginary TimeOutTestCaller class which has an interface similar
+ * to TestCaller.
+ * 
+ * \code
+ * #define CPPUNITEX_TEST_TIMELIMIT( testMethod, timeLimit )            \
+ *      CPPUNIT_TEST_SUITE_ADD_TEST( (new TimeOutTestCaller<TestFixtureType>(  \
+ *                  namer.getTestNameFor( #testMethod ),                \
+ *                  &TestFixtureType::testMethod,                   \
+ *                  factory.makeFixture(),                              \
+ *                  timeLimit ) ) )
+ *   
+ * class PerformanceTest : CppUnit::TestFixture
+ * {
+ * public:
+ *   CPPUNIT_TEST_SUITE( PerformanceTest );
+ *   CPPUNITEX_TEST_TIMELIMIT( testSortReverseOrder, 5.0 );
+ *   CPPUNIT_TEST_SUITE_END();
+ *
+ *   void testSortReverseOrder();
+ * };
+ * \endcode
+ *
+ * \param test Test to add to the suite. Must be a subclass of Test. The test name
+ *             should have been obtained using TestNamer::getTestNameFor().
+ */
+#define CPPUNIT_TEST_SUITE_ADD_TEST( test ) \
+      context.addTest( test )
+
+/*! \brief Add a method to the suite.
+ * \param testMethod Name of the method of the test case to add to the
+ *                   suite. The signature of the method must be of
+ *                   type: void testMethod();
+ * \see  CPPUNIT_TEST_SUITE.
+ */
+#define CPPUNIT_TEST( testMethod )                        \
+    CPPUNIT_TEST_SUITE_ADD_TEST(                           \
+        ( new CPPUNIT_NS::TestCaller<TestFixtureType>(    \
+                  context.getTestNameFor( #testMethod),   \
+                  &TestFixtureType::testMethod,           \
+                  context.makeFixture() ) ) )
+
+/*! \brief Add a test which fail if the specified exception is not caught.
+ *
+ * Example:
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * #include <vector>
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST_EXCEPTION( testVectorAtThrow, std::invalid_argument );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testVectorAtThrow()
+ *   {
+ *     std::vector<int> v;
+ *     v.at( 1 );     // must throw exception std::invalid_argument
+ *   }
+ * };
+ * \endcode
+ *
+ * \param testMethod Name of the method of the test case to add to the suite.
+ * \param ExceptionType Type of the exception that must be thrown by the test 
+ *                      method.
+ * \deprecated Use the assertion macro CPPUNIT_ASSERT_THROW instead.
+ */
+#define CPPUNIT_TEST_EXCEPTION( testMethod, ExceptionType )          \
+  CPPUNIT_TEST_SUITE_ADD_TEST(                                        \
+      (new CPPUNIT_NS::ExceptionTestCaseDecorator< ExceptionType >(  \
+          new CPPUNIT_NS::TestCaller< TestFixtureType >(             \
+                               context.getTestNameFor( #testMethod ),  \
+                               &TestFixtureType::testMethod,         \
+                               context.makeFixture() ) ) ) )
+
+/*! \brief Adds a test case which is excepted to fail.
+ *
+ * The added test case expect an assertion to fail. You usually used that type
+ * of test case when testing custom assertion macros.
+ *
+ * \code
+ * CPPUNIT_TEST_FAIL( testAssertFalseFail );
+ * 
+ * void testAssertFalseFail()
+ * {
+ *   CPPUNIT_ASSERT( false );
+ * }
+ * \endcode
+ * \see CreatingNewAssertions.
+ * \deprecated Use the assertion macro CPPUNIT_ASSERT_ASSERTION_FAIL instead.
+ */
+#define CPPUNIT_TEST_FAIL( testMethod ) \
+              CPPUNIT_TEST_EXCEPTION( testMethod, CPPUNIT_NS::Exception )
+
+/*! \brief Adds some custom test cases.
+ *
+ * Use this to add one or more test cases to the fixture suite. The specified
+ * method is called with a context parameter that can be used to name, 
+ * instantiate fixture, and add instantiated test case to the fixture suite.
+ * The specified method must have the following signature:
+ * \code
+ * static void aMethodName( TestSuiteBuilderContextType &context );
+ * \endcode
+ *
+ * \c TestSuiteBuilderContextType is typedef to 
+ * TestSuiteBuilderContext<TestFixtureType> declared by CPPUNIT_TEST_SUITE().
+ *
+ * Here is an example that add two custom tests:
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ *
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS( addTimeOutTests );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   static void addTimeOutTests( TestSuiteBuilderContextType &context )
+ *   {
+ *     context.addTest( new TimeOutTestCaller( context.getTestNameFor( "test1" ) ),
+ *                                             &MyTest::test1,
+ *                                             context.makeFixture(),
+ *                                             5.0 );
+ *     context.addTest( new TimeOutTestCaller( context.getTestNameFor( "test2" ) ),
+ *                                             &MyTest::test2,
+ *                                             context.makeFixture(),
+ *                                             5.0 );
+ *   }
+ *
+ *   void test1()
+ *   {
+ *     // Do some test that may never end...
+ *   }
+ *
+ *   void test2()
+ *   {
+ *     // Do some test that may never end...
+ *   }
+ * };
+ * \endcode
+ * @param testAdderMethod Name of the method called to add the test cases.
+ */
+#define CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS( testAdderMethod ) \
+      testAdderMethod( context )
+
+/*! \brief Adds a property to the test suite builder context.
+ * \param APropertyKey   Key of the property to add.
+ * \param APropertyValue Value for the added property.
+ * Example:
+ * \code
+ * CPPUNIT_TEST_SUITE_PROPERTY("XmlFileName", "paraTest.xml"); \endcode
+ */
+#define CPPUNIT_TEST_SUITE_PROPERTY( APropertyKey, APropertyValue ) \
+    context.addProperty( std::string(APropertyKey),                 \
+                         std::string(APropertyValue) )
+
+/** @}
+ */
+
+
+/*! Adds the specified fixture suite to the unnamed registry.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro declares a static variable whose construction
+ * causes a test suite factory to be inserted in a global registry
+ * of such factories.  The registry is available by calling
+ * the static function CppUnit::TestFactoryRegistry::getRegistry().
+ * 
+ * \param ATestFixtureType Type of the test case class.
+ * \warning This macro should be used only once per line of code (the line
+ *          number is used to name a hidden static variable).
+ * \see CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT
+ * \see CPPUNIT_REGISTRY_ADD
+ * \see CPPUNIT_TEST_SUITE, CppUnit::AutoRegisterSuite, 
+ *      CppUnit::TestFactoryRegistry.
+ */
+#define CPPUNIT_TEST_SUITE_REGISTRATION( ATestFixtureType )      \
+  static CPPUNIT_NS::AutoRegisterSuite< ATestFixtureType >       \
+             CPPUNIT_MAKE_UNIQUE_NAME(autoRegisterRegistry__ )
+
+
+/** Adds the specified fixture suite to the specified registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro declares a static variable whose construction
+ * causes a test suite factory to be inserted in the global registry
+ * suite of the specified name. The registry is available by calling
+ * the static function CppUnit::TestFactoryRegistry::getRegistry().
+ * 
+ * For the suite name, use a string returned by a static function rather
+ * than a hardcoded string. That way, you can know what are the name of
+ * named registry and you don't risk mistyping the registry name.
+ *
+ * \code
+ * // MySuites.h
+ * namespace MySuites {
+ *   std::string math() { 
+ *     return "Math";
+ *   }
+ * }
+ *
+ * // ComplexNumberTest.cpp
+ * #include "MySuites.h"
+ * 
+ * CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ComplexNumberTest, MySuites::math() );
+ * \endcode
+ *
+ * \param ATestFixtureType Type of the test case class.
+ * \param suiteName Name of the global registry suite the test suite is 
+ *                  registered into.
+ * \warning This macro should be used only once per line of code (the line
+ *          number is used to name a hidden static variable).
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT
+ * \see CPPUNIT_REGISTRY_ADD
+ * \see CPPUNIT_TEST_SUITE, CppUnit::AutoRegisterSuite, 
+ *      CppUnit::TestFactoryRegistry..
+ */
+#define CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ATestFixtureType, suiteName ) \
+  static CPPUNIT_NS::AutoRegisterSuite< ATestFixtureType >                   \
+             CPPUNIT_MAKE_UNIQUE_NAME(autoRegisterRegistry__ )(suiteName)
+
+/*! Adds that the specified registry suite to another registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * Use this macros to automatically create test registry suite hierarchy. For example,
+ * if you want to create the following hierarchy:
+ * - Math
+ *   - IntegerMath
+ *   - FloatMath
+ *     - FastFloat
+ *     - StandardFloat
+ * 
+ * You can do this automatically with:
+ * \code
+ * CPPUNIT_REGISTRY_ADD( "FastFloat", "FloatMath" );
+ * CPPUNIT_REGISTRY_ADD( "IntegerMath", "Math" );
+ * CPPUNIT_REGISTRY_ADD( "FloatMath", "Math" );
+ * CPPUNIT_REGISTRY_ADD( "StandardFloat", "FloatMath" );
+ * \endcode
+ *
+ * There is no specific order of declaration. Think of it as declaring links.
+ *
+ * You register the test in each suite using CPPUNIT_TEST_SUITE_NAMED_REGISTRATION.
+ *
+ * \param which Name of the registry suite to add to the registry suite named \a to.
+ * \param to Name of the registry suite \a which is added to.
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION.
+ */
+#define CPPUNIT_REGISTRY_ADD( which, to )                                     \
+  static CPPUNIT_NS::AutoRegisterRegistry                                     \
+             CPPUNIT_MAKE_UNIQUE_NAME( autoRegisterRegistry__ )( which, to )
+
+/*! Adds that the specified registry suite to the default registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro is just like CPPUNIT_REGISTRY_ADD except the specified registry
+ * suite is added to the default suite (root suite).
+ *
+ * \param which Name of the registry suite to add to the default registry suite.
+ * \see CPPUNIT_REGISTRY_ADD.
+ */
+#define CPPUNIT_REGISTRY_ADD_TO_DEFAULT( which )                         \
+  static CPPUNIT_NS::AutoRegisterRegistry                                \
+             CPPUNIT_MAKE_UNIQUE_NAME( autoRegisterRegistry__ )( which )
+
+// Backwards compatibility
+// (Not tested!)
+
+#if CPPUNIT_ENABLE_CU_TEST_MACROS
+
+#define CU_TEST_SUITE(tc) CPPUNIT_TEST_SUITE(tc)
+#define CU_TEST_SUB_SUITE(tc,sc) CPPUNIT_TEST_SUB_SUITE(tc,sc)
+#define CU_TEST(tm) CPPUNIT_TEST(tm)
+#define CU_TEST_SUITE_END() CPPUNIT_TEST_SUITE_END()
+#define CU_TEST_SUITE_REGISTRATION(tc) CPPUNIT_TEST_SUITE_REGISTRATION(tc)
+
+#endif
+
+
+#endif  // CPPUNIT_EXTENSIONS_HELPERMACROS_H
diff --git a/src/test/cppunit/extensions/Makefile.am b/src/test/cppunit/extensions/Makefile.am
new file mode 100644
index 0000000..ff96de3
--- /dev/null
+++ b/src/test/cppunit/extensions/Makefile.am
@@ -0,0 +1,19 @@
+libcppunitincludedir = $(includedir)/cppunit/extensions
+
+libcppunitinclude_HEADERS = \
+	TestFactory.h \
+	AutoRegisterSuite.h \
+	HelperMacros.h \
+	Orthodox.h \
+	RepeatedTest.h \
+	ExceptionTestCaseDecorator.h \
+	TestCaseDecorator.h \
+	TestDecorator.h \
+	TestFactoryRegistry.h \
+	TestFixtureFactory.h \
+	TestNamer.h \
+	TestSetUp.h \
+	TestSuiteBuilderContext.h \
+	TestSuiteFactory.h \
+	TypeInfoHelper.h
+
diff --git a/src/test/cppunit/extensions/Makefile.in b/src/test/cppunit/extensions/Makefile.in
new file mode 100644
index 0000000..c088904
--- /dev/null
+++ b/src/test/cppunit/extensions/Makefile.in
@@ -0,0 +1,446 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/extensions
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/extensions
+libcppunitinclude_HEADERS = \
+	TestFactory.h \
+	AutoRegisterSuite.h \
+	HelperMacros.h \
+	Orthodox.h \
+	RepeatedTest.h \
+	ExceptionTestCaseDecorator.h \
+	TestCaseDecorator.h \
+	TestDecorator.h \
+	TestFactoryRegistry.h \
+	TestFixtureFactory.h \
+	TestNamer.h \
+	TestSetUp.h \
+	TestSuiteBuilderContext.h \
+	TestSuiteFactory.h \
+	TypeInfoHelper.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/extensions/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/extensions/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/extensions/Orthodox.h b/src/test/cppunit/extensions/Orthodox.h
new file mode 100644
index 0000000..7221259
--- /dev/null
+++ b/src/test/cppunit/extensions/Orthodox.h
@@ -0,0 +1,95 @@
+#ifndef CPPUNIT_EXTENSIONS_ORTHODOX_H
+#define CPPUNIT_EXTENSIONS_ORTHODOX_H
+
+#include <cppunit/TestCase.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*
+ * Orthodox performs a simple set of tests on an arbitary
+ * class to make sure that it supports at least the
+ * following operations:
+ *
+ *      default construction    - constructor
+ *      equality/inequality     - operator== && operator!=
+ *      assignment              - operator=
+ *      negation                - operator!
+ *      safe passage            - copy construction
+ *
+ * If operations for each of these are not declared
+ * the template will not instantiate.  If it does 
+ * instantiate, tests are performed to make sure
+ * that the operations have correct semantics.
+ *      
+ * Adding an orthodox test to a suite is very 
+ * easy: 
+ * 
+ * public: Test *suite ()  {
+ *     TestSuite *suiteOfTests = new TestSuite;
+ *     suiteOfTests->addTest (new ComplexNumberTest ("testAdd");
+ *     suiteOfTests->addTest (new TestCaller<Orthodox<Complex> > ());
+ *     return suiteOfTests;
+ *  }
+ *
+ * Templated test cases be very useful when you are want to
+ * make sure that a group of classes have the same form.
+ *
+ * see TestSuite
+ */
+
+
+template <class ClassUnderTest> class Orthodox : public TestCase
+{
+public:
+                    Orthodox () : TestCase ("Orthodox") {}
+
+protected:
+    ClassUnderTest  call (ClassUnderTest object);
+    void            runTest ();
+
+
+};
+
+
+// Run an orthodoxy test
+template <class ClassUnderTest> void Orthodox<ClassUnderTest>::runTest ()
+{
+    // make sure we have a default constructor
+    ClassUnderTest   a, b, c;
+
+    // make sure we have an equality operator
+    CPPUNIT_ASSERT (a == b);
+
+    // check the inverse
+    b.operator= (a.operator! ());
+    CPPUNIT_ASSERT (a != b);
+
+    // double inversion
+    b = !!a;
+    CPPUNIT_ASSERT (a == b);
+
+    // invert again
+    b = !a;
+
+    // check calls
+    c = a;
+    CPPUNIT_ASSERT (c == call (a));
+
+    c = b;
+    CPPUNIT_ASSERT (c == call (b));
+
+}
+
+
+// Exercise a call
+template <class ClassUnderTest> 
+ClassUnderTest Orthodox<ClassUnderTest>::call (ClassUnderTest object)
+{
+    return object;
+}
+
+
+CPPUNIT_NS_END
+
+#endif
diff --git a/src/test/cppunit/extensions/RepeatedTest.h b/src/test/cppunit/extensions/RepeatedTest.h
new file mode 100644
index 0000000..390ce48
--- /dev/null
+++ b/src/test/cppunit/extensions/RepeatedTest.h
@@ -0,0 +1,43 @@
+#ifndef CPPUNIT_EXTENSIONS_REPEATEDTEST_H
+#define CPPUNIT_EXTENSIONS_REPEATEDTEST_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/extensions/TestDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+
+/*! \brief Decorator that runs a test repeatedly.
+ *
+ * Does not assume ownership of the test it decorates
+ */
+class CPPUNIT_API RepeatedTest : public TestDecorator 
+{
+public:
+  RepeatedTest( Test *test, 
+                int timesRepeat ) : 
+      TestDecorator( test ), 
+      m_timesRepeat(timesRepeat) 
+  {
+  }
+
+  void run( TestResult *result );
+
+  int countTestCases() const;
+
+private:
+  RepeatedTest( const RepeatedTest & );
+  void operator=( const RepeatedTest & );
+
+  const int m_timesRepeat;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXTENSIONS_REPEATEDTEST_H
diff --git a/src/test/cppunit/extensions/TestCaseDecorator.h b/src/test/cppunit/extensions/TestCaseDecorator.h
new file mode 100644
index 0000000..3a15ba9
--- /dev/null
+++ b/src/test/cppunit/extensions/TestCaseDecorator.h
@@ -0,0 +1,40 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTCASEDECORATOR_H
+#define CPPUNIT_EXTENSIONS_TESTCASEDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/TestCase.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief  Decorator for Test cases.
+ *
+ * TestCaseDecorator provides an alternate means to extend functionality
+ * of a test class without subclassing the test.  Instead, one can
+ * subclass the decorater and use it to wrap the test class.
+ *
+ * Does not assume ownership of the test it decorates
+ */ 
+class CPPUNIT_API TestCaseDecorator : public TestCase
+{
+public:
+  TestCaseDecorator( TestCase *test );
+  ~TestCaseDecorator();
+
+  std::string getName() const;
+
+  void setUp();
+
+  void tearDown();
+
+  void runTest();
+
+protected:
+  TestCase *m_test;
+};
+
+
+CPPUNIT_NS_END
+
+#endif
+
diff --git a/src/test/cppunit/extensions/TestDecorator.h b/src/test/cppunit/extensions/TestDecorator.h
new file mode 100644
index 0000000..59d9a30
--- /dev/null
+++ b/src/test/cppunit/extensions/TestDecorator.h
@@ -0,0 +1,49 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTDECORATOR_H
+#define CPPUNIT_EXTENSIONS_TESTDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Test.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+
+
+/*! \brief  Decorator for Tests.
+ *
+ * TestDecorator provides an alternate means to extend functionality
+ * of a test class without subclassing the test.  Instead, one can
+ * subclass the decorater and use it to wrap the test class.
+ *
+ * Does not assume ownership of the test it decorates
+ */ 
+class CPPUNIT_API TestDecorator : public Test
+{
+public:
+  TestDecorator( Test *test );
+  ~TestDecorator();
+
+  int countTestCases() const;
+
+  std::string getName() const;
+
+  void run( TestResult *result );
+
+  int getChildTestCount() const;
+
+protected:
+  Test *doGetChildTestAt( int index ) const;
+
+  Test *m_test;
+
+private:
+  TestDecorator( const TestDecorator &);
+  void operator =( const TestDecorator & );
+};
+
+
+CPPUNIT_NS_END
+
+#endif
+
diff --git a/src/test/cppunit/extensions/TestFactory.h b/src/test/cppunit/extensions/TestFactory.h
new file mode 100644
index 0000000..214d353
--- /dev/null
+++ b/src/test/cppunit/extensions/TestFactory.h
@@ -0,0 +1,27 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTFACTORY_H
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+
+/*! \brief Abstract Test factory.
+ */
+class CPPUNIT_API TestFactory 
+{
+public:
+  virtual ~TestFactory() {}
+
+  /*! Makes a new test.
+   * \return A new Test.
+   */
+  virtual Test* makeTest() = 0;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_TESTFACTORY_H
diff --git a/src/test/cppunit/extensions/TestFactoryRegistry.h b/src/test/cppunit/extensions/TestFactoryRegistry.h
new file mode 100644
index 0000000..fc8723e
--- /dev/null
+++ b/src/test/cppunit/extensions/TestFactoryRegistry.h
@@ -0,0 +1,182 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
+#define CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251)  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitSet.h>
+#include <cppunit/extensions/TestFactory.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestSuite;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::set<TestFactory *>;
+#endif
+
+
+/*! \brief Registry for TestFactory.
+ * \ingroup CreatingTestSuite
+ *
+ * Notes that the registry \b DON'T assumes lifetime control for any registered tests
+ * anymore.
+ *
+ * The <em>default</em> registry is the registry returned by getRegistry() with the 
+ * default name parameter value.
+ *
+ * To register tests, use the macros:
+ * - CPPUNIT_TEST_SUITE_REGISTRATION(): to add tests in the default registry.
+ * - CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(): to add tests in a named registry.
+ *
+ * Example 1: retreiving a suite that contains all the test registered with
+ * CPPUNIT_TEST_SUITE_REGISTRATION().
+ * \code
+ * CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
+ * CppUnit::TestSuite *suite = registry.makeTest();
+ * \endcode
+ *
+ * Example 2: retreiving a suite that contains all the test registered with
+ * \link CPPUNIT_TEST_SUITE_NAMED_REGISTRATION() CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Math" )\endlink.
+ * \code
+ * CppUnit::TestFactoryRegistry &mathRegistry = CppUnit::TestFactoryRegistry::getRegistry( "Math" );
+ * CppUnit::TestSuite *mathSuite = mathRegistry.makeTest();
+ * \endcode
+ *
+ * Example 3: creating a test suite hierarchy composed of unnamed registration and
+ * named registration:
+ * - All Tests
+ *   - tests registered with CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Graph" )
+ *   - tests registered with CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Math" )
+ *   - tests registered with CPPUNIT_TEST_SUITE_REGISTRATION
+ *
+ * \code
+ * CppUnit::TestSuite *rootSuite = new CppUnit::TestSuite( "All tests" );
+ * rootSuite->addTest( CppUnit::TestFactoryRegistry::getRegistry( "Graph" ).makeTest() );
+ * rootSuite->addTest( CppUnit::TestFactoryRegistry::getRegistry( "Math" ).makeTest() );
+ * CppUnit::TestFactoryRegistry::getRegistry().addTestToSuite( rootSuite );
+ * \endcode
+ *
+ * The same result can be obtained with:
+ * \code
+ * CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
+ * registry.addRegistry( "Graph" );
+ * registry.addRegistry( "Math" );
+ * CppUnit::TestSuite *suite = registry.makeTest();
+ * \endcode
+ *
+ * Since a TestFactoryRegistry is a TestFactory, the named registries can be 
+ * registered in the unnamed registry, creating the hierarchy links.
+ *
+ * \see TestSuiteFactory, AutoRegisterSuite
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ */
+class CPPUNIT_API TestFactoryRegistry : public TestFactory
+{
+public:
+  /** Constructs the registry with the specified name.
+   * \param name Name of the registry. It is the name of TestSuite returned by
+   *             makeTest().
+   */
+  TestFactoryRegistry( std::string name );
+
+  /// Destructor.
+  virtual ~TestFactoryRegistry();
+
+  /** Returns a new TestSuite that contains the registered test.
+   * \return A new TestSuite which contains all the test added using 
+   * registerFactory(TestFactory *).
+   */
+  virtual Test *makeTest();
+
+  /** Returns a named registry.
+   *
+   * If the \a name is left to its default value, then the registry that is returned is
+   * the one used by CPPUNIT_TEST_SUITE_REGISTRATION(): the 'top' level registry.
+   *
+   * \param name Name of the registry to return.
+   * \return Registry. If the registry does not exist, it is created with the
+   *         specified name.
+   */
+  static TestFactoryRegistry &getRegistry( const std::string &name = "All Tests" );
+
+  /** Adds the registered tests to the specified suite.
+   * \param suite Suite the tests are added to.
+   */
+  void addTestToSuite( TestSuite *suite );
+
+  /** Adds the specified TestFactory to the registry.
+   *
+   * \param factory Factory to register. 
+   */
+  void registerFactory( TestFactory *factory );
+
+  /*! Removes the specified TestFactory from the registry.
+   * 
+   * The specified factory is not destroyed.
+   * \param factory Factory to remove from the registry.
+   * \todo Address case when trying to remove a TestRegistryFactory.
+   */
+  void unregisterFactory( TestFactory *factory );
+
+  /*! Adds a registry to the registry.
+   * 
+   * Convenience method to help create test hierarchy. See TestFactoryRegistry detail
+   * for examples of use. Calling this method is equivalent to:
+   * \code
+   * this->registerFactory( TestFactoryRegistry::getRegistry( name ) );
+   * \endcode
+   *
+   * \param name Name of the registry to add.
+   */
+  void addRegistry( const std::string &name );
+
+  /*! Tests if the registry is valid.
+   *
+   * This method should be used when unregistering test factory on static variable 
+   * destruction to ensure that the registry has not been already destroyed (in 
+   * that case there is no need to unregister the test factory).
+   *
+   * You should not concern yourself with this method unless you are writing a class
+   * like AutoRegisterSuite.
+   *
+   * \return \c true if the specified registry has not been destroyed, 
+   *         otherwise returns \c false.
+   * \see AutoRegisterSuite.
+   */
+  static bool isValid();
+
+  /** Adds the specified TestFactory with a specific name (DEPRECATED).
+   * \param name Name associated to the factory.
+   * \param factory Factory to register. 
+   * \deprecated Use registerFactory( TestFactory *) instead.
+   */
+  void registerFactory( const std::string &name,
+                        TestFactory *factory );
+
+private:
+  TestFactoryRegistry( const TestFactoryRegistry &copy );
+  void operator =( const TestFactoryRegistry &copy );
+
+private:
+  typedef CppUnitSet<TestFactory *, std::less<TestFactory*> > Factories;
+  Factories m_factories;
+
+  std::string m_name;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
diff --git a/src/test/cppunit/extensions/TestFixtureFactory.h b/src/test/cppunit/extensions/TestFixtureFactory.h
new file mode 100644
index 0000000..45354c6
--- /dev/null
+++ b/src/test/cppunit/extensions/TestFixtureFactory.h
@@ -0,0 +1,50 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class TestFixture;
+
+/*! \brief Abstract TestFixture factory (Implementation).
+ *
+ * Implementation detail. Use by HelperMacros to handle TestFixture hierarchy.
+ */
+class TestFixtureFactory
+{
+public:
+  //! Creates a new TestFixture instance.
+  virtual TestFixture *makeFixture() =0;
+
+  virtual ~TestFixtureFactory() {}
+};
+
+
+/*! \brief Concret TestFixture factory (Implementation).
+ *
+ * Implementation detail. Use by HelperMacros to handle TestFixture hierarchy.
+ */
+template<class TestFixtureType>
+class ConcretTestFixtureFactory : public CPPUNIT_NS::TestFixtureFactory
+{
+  /*! \brief Returns a new TestFixture instance.
+   * \return A new fixture instance. The fixture instance is returned by
+   *         the TestFixtureFactory passed on construction. The actual type 
+   *         is that of the fixture on which the static method suite() 
+   *         was called.
+   */
+  TestFixture *makeFixture()
+  {
+    return new TestFixtureType();
+  }
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+
diff --git a/src/test/cppunit/extensions/TestNamer.h b/src/test/cppunit/extensions/TestNamer.h
new file mode 100644
index 0000000..5a6471c
--- /dev/null
+++ b/src/test/cppunit/extensions/TestNamer.h
@@ -0,0 +1,89 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTNAMER_H
+#define CPPUNIT_EXTENSIONS_TESTNAMER_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+#if CPPUNIT_HAVE_RTTI
+#  include <typeinfo>
+#endif
+
+
+
+/*! \def CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )
+ * \brief Declares a TestNamer.
+ *
+ * Declares a TestNamer for the specified type, using RTTI if enabled, otherwise
+ * using macro string expansion.
+ *
+ * RTTI is used if CPPUNIT_USE_TYPEINFO_NAME is defined and not null.
+ *
+ * \code
+ * void someMethod() 
+ * {
+ *   CPPUNIT_TESTNAMER_DECL( namer, AFixtureType );
+ *   std::string fixtureName = namer.getFixtureName();
+ *   ...
+ * \endcode
+ *
+ * \relates TestNamer
+ * \see TestNamer
+ */
+#if CPPUNIT_USE_TYPEINFO_NAME
+#  define CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )       \
+              CPPUNIT_NS::TestNamer variableName( typeid(FixtureType) )
+#else
+#  define CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )       \
+              CPPUNIT_NS::TestNamer variableName( std::string(#FixtureType) )
+#endif
+
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Names a test or a fixture suite.
+ *
+ * TestNamer is usually instantiated using CPPUNIT_TESTNAMER_DECL.
+ *
+ */
+class CPPUNIT_API TestNamer
+{
+public:
+#if CPPUNIT_HAVE_RTTI
+  /*! \brief Constructs a namer using the fixture's type-info.
+   * \param typeInfo Type-info of the fixture type. Use to name the fixture suite.
+   */
+  TestNamer( const std::type_info &typeInfo );
+#endif
+
+  /*! \brief Constructs a namer using the specified fixture name.
+   * \param fixtureName Name of the fixture suite. Usually extracted using a macro.
+   */
+  TestNamer( const std::string &fixtureName );
+
+  virtual ~TestNamer();
+
+  /*! \brief Returns the name of the fixture.
+   * \return Name of the fixture.
+   */
+  virtual std::string getFixtureName() const;
+
+  /*! \brief Returns the name of the test for the specified method.
+   * \param testMethodName Name of the method that implements a test.
+   * \return A string that is the concatenation of the test fixture name 
+   *         (returned by getFixtureName()) and\a testMethodName, 
+   *         separated using '::'. This provides a fairly unique name for a given
+   *         test.
+   */
+  virtual std::string getTestNameFor( const std::string &testMethodName ) const;
+
+protected:
+  std::string m_fixtureName;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_TESTNAMER_H
+
diff --git a/src/test/cppunit/extensions/TestSetUp.h b/src/test/cppunit/extensions/TestSetUp.h
new file mode 100644
index 0000000..f2128ec
--- /dev/null
+++ b/src/test/cppunit/extensions/TestSetUp.h
@@ -0,0 +1,34 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTSETUP_H
+#define CPPUNIT_EXTENSIONS_TESTSETUP_H
+
+#include <cppunit/extensions/TestDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+/*! \brief Decorates a test by providing a specific setUp() and tearDown().
+ */
+class CPPUNIT_API TestSetUp : public TestDecorator 
+{
+public:
+  TestSetUp( Test *test );
+
+  void run( TestResult *result );
+
+protected:
+  virtual void setUp();
+  virtual void tearDown();
+
+private:
+  TestSetUp( const TestSetUp & );
+  void operator =( const TestSetUp & );
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_TESTSETUP_H
+
diff --git a/src/test/cppunit/extensions/TestSuiteBuilderContext.h b/src/test/cppunit/extensions/TestSuiteBuilderContext.h
new file mode 100644
index 0000000..db26926
--- /dev/null
+++ b/src/test/cppunit/extensions/TestSuiteBuilderContext.h
@@ -0,0 +1,131 @@
+#ifndef CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+#define CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/portability/CppUnitMap.h>
+#include <string>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+class TestSuite;
+class TestFixture;
+class TestFixtureFactory;
+class TestNamer;
+
+/*! \brief Context used when creating test suite in HelperMacros.
+ *
+ * Base class for all context used when creating test suite. The
+ * actual context type during test suite creation is TestSuiteBuilderContext.
+ *
+ * \sa CPPUNIT_TEST_SUITE, CPPUNIT_TEST_SUITE_ADD_TEST, 
+ *     CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS.
+ */
+class CPPUNIT_API TestSuiteBuilderContextBase
+{
+public:
+  /*! \brief Constructs a new context.
+   *
+   * You should not use this. The context is created in 
+   * CPPUNIT_TEST_SUITE().
+   */
+  TestSuiteBuilderContextBase( TestSuite &suite,
+                               const TestNamer &namer,
+                               TestFixtureFactory &factory );
+
+  virtual ~TestSuiteBuilderContextBase();
+
+  /*! \brief Adds a test to the fixture suite.
+   *
+   * \param test Test to add to the fixture suite. Must not be \c NULL.
+   */
+  void addTest( Test *test );
+
+  /*! \brief Returns the fixture name.
+   * \return Fixture name. It is the name used to name the fixture
+   *         suite.
+   */
+  std::string getFixtureName() const;
+
+  /*! \brief Returns the name of the test for the specified method.
+   *
+   * \param testMethodName Name of the method that implements a test.
+   * \return A string that is the concatenation of the test fixture name 
+   *         (returned by getFixtureName()) and\a testMethodName, 
+   *         separated using '::'. This provides a fairly unique name for a given
+   *         test.
+   */
+  std::string getTestNameFor( const std::string &testMethodName ) const;
+
+  /*! \brief Adds property pair.
+   * \param key   PropertyKey string to add.
+   * \param value PropertyValue string to add.
+   */
+  void addProperty( const std::string &key, 
+                    const std::string &value );
+  
+  /*! \brief Returns property value assigned to param key.
+   * \param key PropertyKey string.
+   */
+  const std::string getStringProperty( const std::string &key ) const;
+
+protected:
+  TestFixture *makeTestFixture() const;
+
+  // Notes: we use a vector here instead of a map to work-around the
+  // shared std::map in dll bug in VC6.
+  // See http://www.dinkumware.com/vc_fixes.html for detail.
+  typedef std::pair<std::string,std::string> Property;
+  typedef CppUnitVector<Property> Properties;
+
+  TestSuite &m_suite;
+  const TestNamer &m_namer;
+  TestFixtureFactory &m_factory;
+
+private:
+  Properties m_properties;
+};
+
+
+/*! \brief Type-sage context used when creating test suite in HelperMacros.
+ * 
+ * \sa TestSuiteBuilderContextBase.
+ */
+template<class Fixture>
+class TestSuiteBuilderContext : public TestSuiteBuilderContextBase
+{
+public:
+  typedef Fixture FixtureType;
+
+  TestSuiteBuilderContext( TestSuiteBuilderContextBase &contextBase )
+      : TestSuiteBuilderContextBase( contextBase )
+  {
+  }
+
+  /*! \brief Returns a new TestFixture instance.
+   * \return A new fixture instance. The fixture instance is returned by
+   *         the TestFixtureFactory passed on construction. The actual type 
+   *         is that of the fixture on which the static method suite() 
+   *         was called.
+   */
+  FixtureType *makeFixture() const
+  {
+    return CPPUNIT_STATIC_CAST( FixtureType *, 
+                                TestSuiteBuilderContextBase::makeTestFixture() );
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+
diff --git a/src/test/cppunit/extensions/TestSuiteFactory.h b/src/test/cppunit/extensions/TestSuiteFactory.h
new file mode 100644
index 0000000..260b483
--- /dev/null
+++ b/src/test/cppunit/extensions/TestSuiteFactory.h
@@ -0,0 +1,27 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H
+
+#include <cppunit/extensions/TestFactory.h>
+
+CPPUNIT_NS_BEGIN
+
+
+  class Test;
+
+  /*! \brief TestFactory for TestFixture that implements a static suite() method.
+   * \see AutoRegisterSuite.
+   */
+  template<class TestCaseType>
+  class TestSuiteFactory : public TestFactory
+  {
+  public:
+    virtual Test *makeTest()
+    {
+      return TestCaseType::suite();
+    }
+  };
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H
diff --git a/src/test/cppunit/extensions/TypeInfoHelper.h b/src/test/cppunit/extensions/TypeInfoHelper.h
new file mode 100644
index 0000000..c0ecdbc
--- /dev/null
+++ b/src/test/cppunit/extensions/TypeInfoHelper.h
@@ -0,0 +1,33 @@
+#ifndef CPPUNIT_TYPEINFOHELPER_H
+#define CPPUNIT_TYPEINFOHELPER_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_HAVE_RTTI
+
+#include <typeinfo>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+  /**! \brief Helper to use type_info.
+   */
+  class CPPUNIT_API TypeInfoHelper
+  {
+  public:
+    /*! \brief Get the class name of the specified type_info.
+     * \param info Info which the class name is extracted from.
+     * \return The string returned by type_info::name() without
+     *         the "class" prefix. If the name is not prefixed
+     *         by "class", it is returned as this.
+     */
+    static std::string getClassName( const std::type_info &info );
+  };
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_HAVE_RTTI
+
+#endif  // CPPUNIT_TYPEINFOHELPER_H
diff --git a/src/test/cppunit/plugin/DynamicLibraryManager.h b/src/test/cppunit/plugin/DynamicLibraryManager.h
new file mode 100644
index 0000000..d70ccde
--- /dev/null
+++ b/src/test/cppunit/plugin/DynamicLibraryManager.h
@@ -0,0 +1,121 @@
+#ifndef CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H
+#define CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Manages dynamic libraries.
+ *
+ * The Dynamic Library Manager provides a platform independent way to work with
+ * dynamic library. It load a specific dynamic library, and can returns specific
+ * symbol exported by the dynamic library.
+ *
+ * If an error occurs, a DynamicLibraryManagerException is thrown.
+ *
+ * \internal Implementation of the OS independent methods is in 
+ * DynamicLibraryManager.cpp.
+ *
+ * \internal Porting to a new platform:
+ * - Adds platform detection in config/SelectDllLoader.h. Should define a specific
+ *   macro for that platform of the form: CPPUNIT_HAVE_XYZ_DLL_LOADER, where
+ *   XYZ is the platform.
+ * - Makes a copy of UnixDynamicLibraryManager.cpp and named it after the platform.
+ * - Updated the 'guard' in your file (CPPUNIT_HAVE_XYZ_DLL_LOADER) so that it is
+ *   only processed if the matching platform has been detected.
+ * - Change the implementation of methods doLoadLibrary(), doReleaseLibrary(), 
+ *   doFindSymbol() in your copy. Those methods usually maps directly to OS calls.
+ * - Adds the file to the project.
+ */
+class DynamicLibraryManager
+{
+public:
+  typedef void *Symbol;
+  typedef void *LibraryHandle;
+
+  /*! \brief Loads the specified library.
+   * \param libraryFileName Name of the library to load.
+   * \exception DynamicLibraryManagerException if a failure occurs while loading
+   *            the library (fail to found or load the library).
+   */
+  DynamicLibraryManager( const std::string &libraryFileName );
+
+  /// Releases the loaded library..
+  ~DynamicLibraryManager();
+
+  /*! \brief Returns a pointer on the specified symbol exported by the library.
+   * \param symbol Name of the symbol exported by the library.
+   * \return Pointer on the symbol. Should be casted to the actual type. Never \c NULL.
+   * \exception DynamicLibraryManagerException if the symbol is not found.
+   */
+  Symbol findSymbol( const std::string &symbol );
+
+private:
+  /*! Loads the specified library.
+   * \param libraryName Name of the library to load.
+   * \exception DynamicLibraryManagerException if a failure occurs while loading
+   *            the library (fail to found or load the library).
+   */
+  void loadLibrary( const std::string &libraryName );
+
+  /*! Releases the loaded library.
+   * 
+   * \warning Must NOT throw any exceptions (called from destructor).
+   */
+  void releaseLibrary();
+
+  /*! Loads the specified library.
+   * 
+   * May throw any exceptions (indicates failure).
+   * \param libraryName Name of the library to load.
+   * \return Handle of the loaded library. \c NULL indicates failure.
+   */
+  LibraryHandle doLoadLibrary( const std::string &libraryName );
+
+  /*! Releases the loaded library.
+   *
+   * The handle of the library to free is in \c m_libraryHandle. It is never
+   * \c NULL.
+   * \warning Must NOT throw any exceptions (called from destructor).
+   */
+  void doReleaseLibrary();
+
+  /*! Returns a pointer on the specified symbol exported by the library.
+   * 
+   * May throw any exceptions (indicates failure).
+   * \param symbol Name of the symbol exported by the library.
+   * \return Pointer on the symbol. \c NULL indicates failure.
+   */
+  Symbol doFindSymbol( const std::string &symbol );
+
+  /*! Returns detailed information about doLoadLibrary() failure.
+   *
+   * Called just after a failed call to doLoadLibrary() to get extra
+   * error information.
+   *
+   * \return Detailed information about the failure of the call to
+   *         doLoadLibrary() that just failed.
+   */
+  std::string getLastErrorDetail() const;
+
+  /// Prevents the use of the copy constructor.
+  DynamicLibraryManager( const DynamicLibraryManager &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const DynamicLibraryManager &copy );
+
+private:
+  LibraryHandle m_libraryHandle;
+  std::string m_libraryName;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif  // CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H
diff --git a/src/test/cppunit/plugin/DynamicLibraryManagerException.h b/src/test/cppunit/plugin/DynamicLibraryManagerException.h
new file mode 100644
index 0000000..11ebbd9
--- /dev/null
+++ b/src/test/cppunit/plugin/DynamicLibraryManagerException.h
@@ -0,0 +1,53 @@
+#ifndef CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H
+#define CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+#include <stdexcept>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Exception thrown by DynamicLibraryManager when a failure occurs.
+ *
+ * Use getCause() to know what function caused the failure.
+ *
+ */
+class DynamicLibraryManagerException : public std::runtime_error
+{
+public:
+  enum Cause
+  {
+    /// Failed to load the dynamic library
+    loadingFailed =0,
+    /// Symbol not found in the dynamic library
+    symbolNotFound
+  };
+
+  /// Failed to load the dynamic library or Symbol not found in the dynamic library.
+  DynamicLibraryManagerException( const std::string &libraryName,
+                                  const std::string &errorDetail,
+                                  Cause cause );
+
+  ~DynamicLibraryManagerException() throw()
+  {
+  }
+
+  Cause getCause() const;
+
+  const char *what() const throw();
+
+private:
+  std::string m_message;
+  Cause m_cause;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif  // CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H
diff --git a/src/test/cppunit/plugin/Makefile.am b/src/test/cppunit/plugin/Makefile.am
new file mode 100644
index 0000000..5221a66
--- /dev/null
+++ b/src/test/cppunit/plugin/Makefile.am
@@ -0,0 +1,9 @@
+libcppunitincludedir = $(includedir)/cppunit/plugin
+
+libcppunitinclude_HEADERS = \
+	DynamicLibraryManager.h \
+	DynamicLibraryManagerException.h \
+	TestPlugIn.h \
+	TestPlugInDefaultImpl.h \
+	PlugInManager.h \
+	PlugInParameters.h
diff --git a/src/test/cppunit/plugin/Makefile.in b/src/test/cppunit/plugin/Makefile.in
new file mode 100644
index 0000000..c97e6e4
--- /dev/null
+++ b/src/test/cppunit/plugin/Makefile.in
@@ -0,0 +1,437 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/plugin
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/plugin
+libcppunitinclude_HEADERS = \
+	DynamicLibraryManager.h \
+	DynamicLibraryManagerException.h \
+	TestPlugIn.h \
+	TestPlugInDefaultImpl.h \
+	PlugInManager.h \
+	PlugInParameters.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/plugin/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/plugin/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/plugin/PlugInManager.h b/src/test/cppunit/plugin/PlugInManager.h
new file mode 100644
index 0000000..6ecedc8
--- /dev/null
+++ b/src/test/cppunit/plugin/PlugInManager.h
@@ -0,0 +1,113 @@
+#ifndef CPPUNIT_PLUGIN_PLUGINMANAGER_H
+#define CPPUNIT_PLUGIN_PLUGINMANAGER_H
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/plugin/PlugInParameters.h>
+struct CppUnitTestPlugIn;
+
+CPPUNIT_NS_BEGIN
+
+
+class DynamicLibraryManager;
+class TestResult;
+class XmlOutputter;
+
+
+/*! \brief Manges TestPlugIn.
+ */
+class CPPUNIT_API PlugInManager
+{
+public:
+  /*! Constructs a PlugInManager object.
+   */
+  PlugInManager();
+
+  /// Destructor.
+  virtual ~PlugInManager();
+
+  /*! \brief Loads the specified plug-in.
+   *
+   * After being loaded, the CppUnitTestPlugIn::initialize() is called.
+   *
+   * \param libraryFileName Name of the file that contains the TestPlugIn.
+   * \param parameters List of string passed to the plug-in.
+   * \return Pointer on the DynamicLibraryManager associated to the library.
+   *         Valid until the library is unloaded. Never \c NULL.
+   * \exception DynamicLibraryManagerException is thrown if an error occurs during loading.
+   */
+  void load( const std::string &libraryFileName,
+             const PlugInParameters &parameters = PlugInParameters() );
+
+  /*! \brief Unloads the specified plug-in.
+   * \param libraryFileName Name of the file that contains the TestPlugIn passed
+   *                        to a previous call to load().
+   */
+  void unload( const std::string &libraryFileName );
+
+  /*! \brief Gives a chance to each loaded plug-in to register TestListener.
+   *
+   * For each plug-in, call CppUnitTestPlugIn::addListener().
+   */
+  void addListener( TestResult *eventManager );
+
+  /*! \brief Gives a chance to each loaded plug-in to unregister TestListener.
+   * For each plug-in, call CppUnitTestPlugIn::removeListener().
+   */
+  void removeListener( TestResult *eventManager );
+
+  /*! \brief Provides a way for the plug-in to register some XmlOutputterHook.
+   */
+  void addXmlOutputterHooks( XmlOutputter *outputter );
+
+  /*! \brief Called when the XmlOutputter is destroyed.
+   * 
+   * Can be used to free some resources allocated by addXmlOutputterHooks().
+   */
+  void removeXmlOutputterHooks();
+
+protected:
+  /*! \brief (INTERNAL) Information about a specific plug-in.
+   */
+  struct PlugInInfo
+  {
+    std::string m_fileName;
+    DynamicLibraryManager *m_manager;
+    CppUnitTestPlugIn *m_interface;
+  };
+
+  /*! Unloads the specified plug-in.
+   * \param plugIn Information about the plug-in.
+   */
+  void unload( PlugInInfo &plugIn );
+
+private:
+  /// Prevents the use of the copy constructor.
+  PlugInManager( const PlugInManager &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const PlugInManager &copy );
+
+private:
+  typedef CppUnitDeque<PlugInInfo> PlugIns;
+  PlugIns m_plugIns;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif  // CPPUNIT_PLUGIN_PLUGINMANAGER_H
diff --git a/src/test/cppunit/plugin/PlugInParameters.h b/src/test/cppunit/plugin/PlugInParameters.h
new file mode 100644
index 0000000..c67d0f1
--- /dev/null
+++ b/src/test/cppunit/plugin/PlugInParameters.h
@@ -0,0 +1,36 @@
+#ifndef CPPUNIT_PLUGIN_PARAMETERS
+#define CPPUNIT_PLUGIN_PARAMETERS
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Test plug-ins parameters.
+ */
+class CPPUNIT_API PlugInParameters
+{
+public:
+  /// Constructs plug-in parameters from the specified command-line.
+  PlugInParameters( const std::string &commandLine = "" );
+
+  virtual ~PlugInParameters();
+
+  /// Returns the command line that was passed on construction.
+  std::string getCommandLine() const;
+
+private:
+  std::string m_commandLine;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif // CPPUNIT_PLUGIN_PARAMETERS
diff --git a/src/test/cppunit/plugin/TestPlugIn.h b/src/test/cppunit/plugin/TestPlugIn.h
new file mode 100644
index 0000000..1c9b929
--- /dev/null
+++ b/src/test/cppunit/plugin/TestPlugIn.h
@@ -0,0 +1,200 @@
+#ifndef CPPUNIT_PLUGIN_TESTPLUGIN
+#define CPPUNIT_PLUGIN_TESTPLUGIN
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/plugin/PlugInParameters.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFactoryRegistry;
+class TestResult;
+class XmlOutputter;
+
+CPPUNIT_NS_END
+
+/*! \file
+ */
+
+
+/*! \brief Test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * This class define the interface implemented by test plug-in. A pointer to that
+ * interface is returned by the function exported by the test plug-in.
+ *
+ * Plug-in are loaded/unloaded by PlugInManager. When a plug-in is loaded, 
+ * initialize() is called. Before unloading the plug-in, the PlugInManager
+ * call uninitialize().
+ *
+ * addListener() and removeListener() are called respectively before and after
+ * the test run.
+ *
+ * addXmlOutputterHooks() and removeXmlOutputterHooks() are called respectively
+ * before and after writing the XML output using a XmlOutputter.
+ *
+ * \see CPPUNIT_PLUGIN_IMPLEMENT, CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL
+ * \see CppUnit::TestPlugInDefaultImpl, CppUnit::XmlOutputter.
+ */
+struct CppUnitTestPlugIn
+{
+  /*! \brief Called just after loading the dynamic library. 
+   *
+   * Override this method to add additional suite to the registry, though this
+   * is preferably done using the macros (CPPUNIT_TEST_SUITE_REGISTRATION...).
+   * If you are creating a custom listener to extends the plug-in runner,
+   * you can use this to configure the listener using the \a parameters.
+   *
+   * You could also use the parameters to specify some global parameter, such
+   * as test datas location, database name...
+   *
+   * N.B.: Parameters interface is not define yet, and the plug-in runner does
+   * not yet support plug-in parameter.
+   */
+  virtual void initialize( CPPUNIT_NS::TestFactoryRegistry *registry,
+                           const CPPUNIT_NS::PlugInParameters &parameters ) =0;
+
+  /*! \brief Gives a chance to the plug-in to register TestListener.
+   * 
+   * Override this method to add a TestListener for the test run. This is useful
+   * if you are writing a custom TestListener, but also if you need to
+   * setUp some global resource: listen to TestListener::startTestRun(), 
+   * and TestListener::endTestRun().
+   */
+  virtual void addListener( CPPUNIT_NS::TestResult *eventManager ) =0;
+
+  /*! \brief Gives a chance to the plug-in to remove its registered TestListener.
+   *
+   * Override this method to remove a TestListener that has been added.
+   */
+  virtual void removeListener( CPPUNIT_NS::TestResult *eventManager ) =0;
+
+  /*! \brief Provides a way for the plug-in to register some XmlOutputterHook.
+   */
+  virtual void addXmlOutputterHooks( CPPUNIT_NS::XmlOutputter *outputter ) =0;
+
+  /*! \brief Called when the XmlOutputter is destroyed.
+   * 
+   * Can be used to free some resources allocated by addXmlOutputterHooks().
+   */
+  virtual void removeXmlOutputterHooks() = 0;
+
+  /*! \brief Called just before unloading the dynamic library.
+   * 
+   * Override this method to unregister test factory added in initialize().
+   * This is necessary to keep the TestFactoryRegistry 'clean'. When
+   * the plug-in is unloaded from memory, the TestFactoryRegistry will hold
+   * reference on test that are no longer available if they are not 
+   * unregistered.
+   */
+  virtual void uninitialize( CPPUNIT_NS::TestFactoryRegistry *registry ) =0;
+
+  virtual ~CppUnitTestPlugIn() {}
+};
+
+
+
+/*! \brief Name of the function exported by a test plug-in.
+ * \ingroup WritingTestPlugIn
+ *
+ * The signature of the exported function is:
+ * \code
+ * CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void);
+ * \endcode
+ */
+#define CPPUNIT_PLUGIN_EXPORTED_NAME cppunitTestPlugIn
+
+/*! \brief Type of the function exported by a plug-in.
+ * \ingroup WritingTestPlugIn
+ */
+typedef CppUnitTestPlugIn *(*TestPlugInSignature)();
+
+
+/*! \brief Implements the function exported by the test plug-in
+ * \ingroup WritingTestPlugIn
+ */
+#define CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL( TestPlugInInterfaceType )       \
+  CPPUNIT_PLUGIN_EXPORT CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void)  \
+  {                                                                            \
+    static TestPlugInInterfaceType plugIn;                                     \
+    return &plugIn;                                                            \
+  }                                                                            \
+  typedef char __CppUnitPlugInExportFunctionDummyTypeDef  // dummy typedef so it can end with ';'
+
+
+// Note: This include should remain after definition of CppUnitTestPlugIn
+#include <cppunit/plugin/TestPlugInDefaultImpl.h>
+
+
+/*! \def CPPUNIT_PLUGIN_IMPLEMENT_MAIN()
+ * \brief Implements the 'main' function for the plug-in.
+ *
+ * This macros implements the main() function for dynamic library.
+ * For example, WIN32 requires a DllMain function, while some Unix 
+ * requires a main() function. This macros takes care of the implementation.
+ */
+
+// Win32
+#if defined(CPPUNIT_HAVE_WIN32_DLL_LOADER)
+#if !defined(APIENTRY)
+#define WIN32_LEAN_AND_MEAN 
+#define NOGDI
+#define NOUSER
+#define NOKERNEL
+#define NOSOUND
+#define NOMINMAX
+#define BLENDFUNCTION void    // for mingw & gcc
+#include <windows.h>
+#endif
+#define CPPUNIT_PLUGIN_IMPLEMENT_MAIN()               \
+  BOOL APIENTRY DllMain( HANDLE hModule,              \
+                         DWORD  ul_reason_for_call,   \
+                         LPVOID lpReserved )          \
+  {                                                   \
+      return TRUE;                                    \
+  }                                                   \
+  typedef char __CppUnitPlugInImplementMainDummyTypeDef
+
+// Unix
+#elif defined(CPPUNIT_HAVE_UNIX_DLL_LOADER) || defined(CPPUNIT_HAVE_UNIX_SHL_LOADER)
+#define CPPUNIT_PLUGIN_IMPLEMENT_MAIN()               \
+  int main( int argc, char *argv[] )                  \
+  {                                                   \
+    return 0;                                         \
+  }                                                   \
+  typedef char __CppUnitPlugInImplementMainDummyTypeDef
+
+
+// Other
+#else     // other platforms don't require anything specifics
+#endif
+
+
+
+/*! \brief Implements and exports the test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * This macro exports the test plug-in function using the subclass, 
+ * and implements the 'main' function for the plug-in using 
+ * CPPUNIT_PLUGIN_IMPLEMENT_MAIN().
+ *
+ * When using this macro, CppUnit must be linked as a DLL (shared library).
+ * Otherwise, tests registered to the TestFactoryRegistry in the DLL will 
+ * not be visible to the DllPlugInTester.
+ *
+ * \see CppUnitTestPlugIn
+ * \see CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL(), CPPUNIT_PLUGIN_IMPLEMENT_MAIN().
+ */
+#define CPPUNIT_PLUGIN_IMPLEMENT()                                          \
+  CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL( CPPUNIT_NS::TestPlugInDefaultImpl );  \
+  CPPUNIT_PLUGIN_IMPLEMENT_MAIN()
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif // CPPUNIT_PLUGIN_TESTPLUGIN
diff --git a/src/test/cppunit/plugin/TestPlugInDefaultImpl.h b/src/test/cppunit/plugin/TestPlugInDefaultImpl.h
new file mode 100644
index 0000000..fa4b807
--- /dev/null
+++ b/src/test/cppunit/plugin/TestPlugInDefaultImpl.h
@@ -0,0 +1,52 @@
+#ifndef CPPUNIT_PLUGIN_TESTPLUGINADAPTER
+#define CPPUNIT_PLUGIN_TESTPLUGINADAPTER
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/plugin/TestPlugIn.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestSuite;
+
+
+/*! \brief Default implementation of test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * Override getSuiteName() to specify the suite name. Default is "All Tests".
+ *
+ * CppUnitTestPlugIn::getTestSuite() returns a suite that contains
+ * all the test registered to the default test factory registry 
+ * ( TestFactoryRegistry::getRegistry() ).
+ *
+ */
+class CPPUNIT_API TestPlugInDefaultImpl : public CppUnitTestPlugIn
+{
+public:
+  TestPlugInDefaultImpl();
+
+  virtual ~TestPlugInDefaultImpl();
+
+  void initialize( TestFactoryRegistry *registry,
+                   const PlugInParameters &parameters );
+
+  void addListener( TestResult *eventManager );
+
+  void removeListener( TestResult *eventManager );
+
+  void addXmlOutputterHooks( XmlOutputter *outputter );
+
+  void removeXmlOutputterHooks();
+
+  void uninitialize( TestFactoryRegistry *registry );
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif // CPPUNIT_PLUGIN_TESTPLUGINADAPTER
diff --git a/src/test/cppunit/portability/CppUnitDeque.h b/src/test/cppunit/portability/CppUnitDeque.h
new file mode 100644
index 0000000..bbab21f
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitDeque.h
@@ -0,0 +1,25 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+#define CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <deque>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitDeque : public std::deque<T,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitDeque std::deque
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+
diff --git a/src/test/cppunit/portability/CppUnitMap.h b/src/test/cppunit/portability/CppUnitMap.h
new file mode 100644
index 0000000..0cdc723
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitMap.h
@@ -0,0 +1,29 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITMAP_H
+#define CPPUNIT_PORTABILITY_CPPUNITMAP_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <functional>
+#include <map>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class Key, class T>
+class CppUnitMap : public std::map<Key
+                                  ,T
+                                  ,std::less<Key>
+                                  ,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitMap std::map
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITMAP_H
+
diff --git a/src/test/cppunit/portability/CppUnitSet.h b/src/test/cppunit/portability/CppUnitSet.h
new file mode 100644
index 0000000..18b8662
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitSet.h
@@ -0,0 +1,28 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITSET_H
+#define CPPUNIT_PORTABILITY_CPPUNITSET_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <functional>
+#include <set>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitSet : public std::set<T
+                                  ,std::less<T>
+                                  ,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitSet std::set
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITSET_H
+
diff --git a/src/test/cppunit/portability/CppUnitStack.h b/src/test/cppunit/portability/CppUnitStack.h
new file mode 100644
index 0000000..bc7785b
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitStack.h
@@ -0,0 +1,26 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITSTACK_H
+#define CPPUNIT_PORTABILITY_CPPUNITSTACK_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <deque>
+#include <stack>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitStack : public std::stack<T
+                                      ,std::deque<T,CPPUNIT_STD_ALLOCATOR> >
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitStack std::stack
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITSTACK_H
\ No newline at end of file
diff --git a/src/test/cppunit/portability/CppUnitVector.h b/src/test/cppunit/portability/CppUnitVector.h
new file mode 100644
index 0000000..6666a63
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitVector.h
@@ -0,0 +1,25 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+#define CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <vector>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitVector : public std::vector<T,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitVector std::vector
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+
diff --git a/src/test/cppunit/portability/FloatingPoint.h b/src/test/cppunit/portability/FloatingPoint.h
new file mode 100644
index 0000000..e8c91b3
--- /dev/null
+++ b/src/test/cppunit/portability/FloatingPoint.h
@@ -0,0 +1,54 @@
+#ifndef CPPUNIT_PORTABILITY_FLOATINGPOINT_H_INCLUDED
+#define CPPUNIT_PORTABILITY_FLOATINGPOINT_H_INCLUDED
+
+#include <cppunit/Portability.h>
+#include <math.h>
+
+CPPUNIT_NS_BEGIN
+
+/// \brief Tests if a floating-point is a NaN.
+// According to IEEE-754 floating point standard, 
+// (see e.g. page 8 of
+// http://www.cs.berkeley.edu/~wkahan/ieee754status/ieee754.ps) 
+// all comparisons with NaN are false except "x != x", which is true.
+//
+// At least Microsoft Visual Studio 6 is known not to implement this test correctly.
+// It emits the following code to test equality:
+//  fcomp       qword ptr [nan]
+//  fnstsw      ax                        // copie fp (floating-point) status register to ax
+//  test        ah,40h                    // test bit 14 of ax (0x4000) => C3 of fp status register
+// According to the following documentation on the x86 floating point status register,
+// the C2 bit should be tested to test for NaN value. 
+// http://webster.cs.ucr.edu/AoA/Windows/HTML/RealArithmetic.html#1000117
+// In Microsoft Visual Studio 2003 & 2005, the test is implemented with:
+//  test        ah,44h         // Visual Studio 2005 test both C2 & C3...
+//
+// To work around this, a NaN is assumed to be detected if no strict ordering is found.
+inline bool floatingPointIsUnordered( double x )
+{
+   // x != x will detect a NaN on conformant platform
+   // (2.0 < x  &&  x < 1.0) will detect a NaN on non conformant platform:
+   // => no ordering can be found for x.
+   return  (x != x) ||  (2.0 < x  &&  x < 1.0);
+}
+
+
+/// \brief Tests if a floating-point is finite.
+/// @return \c true if x is neither a NaN, nor +inf, nor -inf, \c false otherwise.
+inline int floatingPointIsFinite( double x )
+{
+#if defined(CPPUNIT_HAVE_ISFINITE)
+   return isfinite( x );
+#elif defined(CPPUNIT_HAVE_FINITE)
+   return finite( x );
+#elif defined(CPPUNIT_HAVE__FINITE)
+   return _finite(x);
+#else
+   double testInf = x * 0.0;  // Produce 0.0 if x is finite, a NaN otherwise.
+   return testInf == 0.0  &&  !floatingPointIsUnordered(testInf);
+#endif
+}
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_PORTABILITY_FLOATINGPOINT_H_INCLUDED
diff --git a/src/test/cppunit/portability/Makefile.am b/src/test/cppunit/portability/Makefile.am
new file mode 100644
index 0000000..2caeb32
--- /dev/null
+++ b/src/test/cppunit/portability/Makefile.am
@@ -0,0 +1,10 @@
+libcppunitincludedir = $(includedir)/cppunit/portability
+
+libcppunitinclude_HEADERS = \
+	CppUnitDeque.h  \
+	CppUnitMap.h    \
+	CppUnitSet.h    \
+	CppUnitStack.h  \
+	CppUnitVector.h \
+   FloatingPoint.h \
+   Stream.h
diff --git a/src/test/cppunit/portability/Makefile.in b/src/test/cppunit/portability/Makefile.in
new file mode 100644
index 0000000..80278e9
--- /dev/null
+++ b/src/test/cppunit/portability/Makefile.in
@@ -0,0 +1,438 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/portability
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/portability
+libcppunitinclude_HEADERS = \
+	CppUnitDeque.h  \
+	CppUnitMap.h    \
+	CppUnitSet.h    \
+	CppUnitStack.h  \
+	CppUnitVector.h \
+   FloatingPoint.h \
+   Stream.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/portability/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/portability/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/portability/Stream.h b/src/test/cppunit/portability/Stream.h
new file mode 100644
index 0000000..e9beb8c
--- /dev/null
+++ b/src/test/cppunit/portability/Stream.h
@@ -0,0 +1,347 @@
+#ifndef CPPUNIT_PORTABILITY_STREAM_H_INCLUDED
+#define CPPUNIT_PORTABILITY_STREAM_H_INCLUDED
+
+// This module define:
+// Type CppUT::Stream (either std::stream or a custom type)
+// Type CppUT::OStringStream (eitjer std::ostringstream, older alternate or a custom type)
+// Functions stdCOut() & stdCErr() which returns a reference on cout & cerr stream (or our
+// custom stream).
+
+#include <cppunit/Portability.h>
+
+
+#if defined( CPPUNIT_NO_STREAM )
+
+#include <string>
+#include <stdio.h>
+#include <string.h>
+
+CPPUNIT_NS_BEGIN
+
+class StreamBuffer
+{
+public:
+   virtual ~StreamBuffer() {}
+
+   virtual void write( const char *text, unsigned int length ) = 0;
+
+   virtual void flush() {}
+};
+
+
+class StringStreamBuffer : public StreamBuffer
+{
+public:
+   std::string str() const
+   {
+      return str_;
+   }
+
+public: // overridden from StreamBuffer
+   void write( const char *text, unsigned int length )
+   {
+      str_.append( text, length );
+   }
+
+private:
+   std::string str_;
+};
+
+
+class FileStreamBuffer : public StreamBuffer
+{
+public:
+   FileStreamBuffer( FILE *file )
+      : file_( file )
+   {
+   }
+
+   FILE *file() const
+   {
+      return file_;
+   }
+
+public: // overridden from StreamBuffer
+   void write( const char *text, unsigned int length )
+   {
+      if ( file_ )
+         fwrite( text, sizeof(char), length, file_ );
+   }
+
+   void flush() 
+   {
+      if ( file_ )
+         fflush( file_ );
+   }
+
+private:
+   FILE *file_;
+};
+
+
+class OStream
+{
+public:
+   OStream()
+      : buffer_( 0 )
+   {
+   }
+
+   OStream( StreamBuffer *buffer )
+      : buffer_( buffer )
+   {
+   }
+
+   virtual ~OStream()
+   {
+     flush();
+   }
+
+   OStream &flush()
+   {
+	   if ( buffer_ )
+		    buffer_->flush();
+	   return *this;
+   }
+
+   void setBuffer( StreamBuffer *buffer )
+   {
+      buffer_ = buffer;
+   }
+
+   OStream &write( const char *text, unsigned int length )
+   {
+      if ( buffer_ )
+         buffer_->write( text, length );
+      return *this;
+   }
+
+   OStream &write( const char *text )
+   {
+      return write( text, strlen(text) );
+   }
+
+   OStream &operator <<( bool v )
+   {
+      const char *out = v ? "true" : "false";
+      return write( out );
+   }
+
+   OStream &operator <<( short v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%hd", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( unsigned short v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%hu", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( int v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%d", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( unsigned int v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%u", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( long v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%ld", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( unsigned long v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%lu", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( float v )
+   {
+      char buffer[128];
+      sprintf( buffer, "%.16g", double(v) );
+      return write( buffer );
+   }
+
+   OStream &operator <<( double v )
+   {
+      char buffer[128];
+      sprintf( buffer, "%.16g", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( long double v )
+   {
+      char buffer[128];
+      sprintf( buffer, "%.16g", double(v) );
+      return write( buffer );
+   }
+
+   OStream &operator <<( const void *v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%p", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( const char *v )
+   {
+      return write( v ? v : "NULL" );
+   }
+
+   OStream &operator <<( char c )
+   {
+      char buffer[16];
+      sprintf( buffer, "%c", c );
+      return write( buffer );
+   }
+
+   OStream &operator <<( const std::string &s )
+   {
+      return write( s.c_str(), s.length() );
+   }
+
+private:
+   StreamBuffer *buffer_;
+};
+
+
+class OStringStream : public OStream
+{
+public:
+	OStringStream()
+		: OStream( &buffer_ )
+	{
+	}
+
+	std::string str() const
+	{
+		return buffer_.str();
+	}
+
+private:
+	StringStreamBuffer buffer_;
+};
+
+
+class OFileStream : public OStream
+{
+public:
+   OFileStream( FILE *file )
+      : OStream( &buffer_ )
+      , buffer_( file )
+      , ownFile_( false )
+   {
+   }
+
+   OFileStream( const char *path )
+      : OStream( &buffer_ )
+      , buffer_( fopen( path, "wt" ) )
+      , ownFile_( true )
+   {
+   }
+
+   virtual ~OFileStream()
+   {
+      if ( ownFile_  &&  buffer_.file() )
+         fclose( buffer_.file() );
+   }
+
+private:
+   FileStreamBuffer buffer_;
+   bool ownFile_;
+};
+
+inline OStream &stdCOut() 
+{
+   static OFileStream stream( stdout );
+   return stream;
+}
+
+inline OStream &stdCErr() 
+{
+   static OFileStream stream( stderr );
+   return stream;
+}
+
+CPPUNIT_NS_END
+
+#elif CPPUNIT_HAVE_SSTREAM // #if defined( CPPUNIT_NO_STREAM )
+# include <sstream>
+# include <fstream>
+
+    CPPUNIT_NS_BEGIN
+    typedef std::ostringstream OStringStream;      // The standard C++ way
+    typedef std::ofstream OFileStream;
+    CPPUNIT_NS_END
+
+
+#elif CPPUNIT_HAVE_CLASS_STRSTREAM
+# include <string>
+# if CPPUNIT_HAVE_STRSTREAM
+#   include <strstream>
+# else // CPPUNIT_HAVE_STRSTREAM
+#  include <strstream.h>
+# endif // CPPUNIT_HAVE_CLASS_STRSTREAM
+
+    CPPUNIT_NS_BEGIN
+
+    class OStringStream : public std::ostrstream 
+    {
+    public:
+        std::string str()
+        {
+//            (*this) << '\0';
+//            std::string msg(std::ostrstream::str());
+//            std::ostrstream::freeze(false);
+//            return msg;
+// Alternative implementation that don't rely on freeze which is not
+// available on some platforms:
+            return std::string( std::ostrstream::str(), pcount() );
+        }
+    };
+
+    CPPUNIT_NS_END
+#else // CPPUNIT_HAVE_CLASS_STRSTREAM
+#   error Cannot define CppUnit::OStringStream.
+#endif // #if defined( CPPUNIT_NO_STREAM )
+
+
+
+#if !defined( CPPUNIT_NO_STREAM )
+
+#include <iostream>
+
+    CPPUNIT_NS_BEGIN
+
+    typedef std::ostream OStream;
+
+    inline OStream &stdCOut() 
+    {
+        return std::cout;
+    }
+
+    inline OStream &stdCErr() 
+    {
+       return std::cerr;
+    }
+
+    CPPUNIT_NS_END
+   
+#endif // #if !defined( CPPUNIT_NO_STREAM )
+
+#endif // CPPUNIT_PORTABILITY_STREAM_H_INCLUDED
+
diff --git a/src/test/cppunit/tools/Algorithm.h b/src/test/cppunit/tools/Algorithm.h
new file mode 100644
index 0000000..e5746a2
--- /dev/null
+++ b/src/test/cppunit/tools/Algorithm.h
@@ -0,0 +1,23 @@
+#ifndef CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED
+#define CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+template<class SequenceType, class ValueType>
+void
+removeFromSequence( SequenceType &sequence, 
+                    const ValueType &valueToRemove )
+{
+   for ( unsigned int index =0; index < sequence.size(); ++index )
+   {
+      if ( sequence[ index ] == valueToRemove )
+         sequence.erase( sequence.begin() + index );
+   }
+}
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED
diff --git a/src/test/cppunit/tools/Makefile.am b/src/test/cppunit/tools/Makefile.am
new file mode 100644
index 0000000..8ce08086
--- /dev/null
+++ b/src/test/cppunit/tools/Makefile.am
@@ -0,0 +1,7 @@
+libcppunitincludedir = $(includedir)/cppunit/tools
+
+libcppunitinclude_HEADERS = \
+	Algorithm.h		\
+	StringTools.h \
+	XmlElement.h \
+	XmlDocument.h
\ No newline at end of file
diff --git a/src/test/cppunit/tools/Makefile.in b/src/test/cppunit/tools/Makefile.in
new file mode 100644
index 0000000..5b7d3e6
--- /dev/null
+++ b/src/test/cppunit/tools/Makefile.in
@@ -0,0 +1,435 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/tools
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/tools
+libcppunitinclude_HEADERS = \
+	Algorithm.h		\
+	StringTools.h \
+	XmlElement.h \
+	XmlDocument.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/tools/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/tools/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/tools/StringTools.h b/src/test/cppunit/tools/StringTools.h
new file mode 100644
index 0000000..7a6b6d7
--- /dev/null
+++ b/src/test/cppunit/tools/StringTools.h
@@ -0,0 +1,34 @@
+#ifndef CPPUNIT_TOOLS_STRINGTOOLS_H
+#define CPPUNIT_TOOLS_STRINGTOOLS_H
+
+#include <cppunit/Portability.h>
+#include <string>
+#include <cppunit/portability/CppUnitVector.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Tool functions to manipulate string.
+ */
+struct StringTools
+{
+
+  typedef CppUnitVector<std::string> Strings;
+
+  static std::string CPPUNIT_API toString( int value );
+
+  static std::string CPPUNIT_API toString( double value );
+
+  static Strings CPPUNIT_API split( const std::string &text, 
+                                    char separator );
+
+  static std::string CPPUNIT_API wrap( const std::string &text,
+                                       int wrapColumn = CPPUNIT_WRAP_COLUMN );
+
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TOOLS_STRINGTOOLS_H
diff --git a/src/test/cppunit/tools/XmlDocument.h b/src/test/cppunit/tools/XmlDocument.h
new file mode 100644
index 0000000..4ee7325
--- /dev/null
+++ b/src/test/cppunit/tools/XmlDocument.h
@@ -0,0 +1,86 @@
+#ifndef CPPUNIT_TOOLS_XMLDOCUMENT_H
+#define CPPUNIT_TOOLS_XMLDOCUMENT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class XmlElement;
+
+
+/*! \brief A XML Document.
+ *
+ * A XmlDocument represents a XML file. It holds a pointer on the root XmlElement
+ * of the document. It also holds the encoding and style sheet used.
+ *
+ * By default, the XML document is stand-alone and tagged with enconding "ISO-8859-1".
+ */
+class CPPUNIT_API XmlDocument
+{
+public:
+  /*! \brief Constructs a XmlDocument object.
+   * \param encoding Encoding used in the XML file (default is Latin-1, ISO-8859-1 ). 
+   * \param styleSheet Name of the XSL style sheet file used. If empty then no
+   *                   style sheet will be specified in the output.
+   */
+  XmlDocument( const std::string &encoding = "",
+               const std::string &styleSheet = "" );
+
+  /// Destructor.
+  virtual ~XmlDocument();
+
+  std::string encoding() const;
+  void setEncoding( const std::string &encoding = "" );
+  
+  std::string styleSheet() const;
+  void setStyleSheet( const std::string &styleSheet = "" );
+
+  bool standalone() const;
+
+  /*! \brief set the output document as standalone or not.
+   *
+   *  For the output document, specify wether it's a standalone XML
+   *  document, or not.
+   *
+   *  \param standalone if true, the output will be specified as standalone.
+   *         if false, it will be not.
+   */
+  void setStandalone( bool standalone );
+ 
+  void setRootElement( XmlElement *rootElement );
+  XmlElement &rootElement() const;
+
+  std::string toString() const;
+
+private:
+  /// Prevents the use of the copy constructor.
+  XmlDocument( const XmlDocument &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const XmlDocument &copy );
+
+protected:
+  std::string m_encoding;
+  std::string m_styleSheet;
+  XmlElement *m_rootElement;
+  bool m_standalone;
+};
+
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TOOLS_XMLDOCUMENT_H
diff --git a/src/test/cppunit/tools/XmlElement.h b/src/test/cppunit/tools/XmlElement.h
new file mode 100644
index 0000000..0b36bd2
--- /dev/null
+++ b/src/test/cppunit/tools/XmlElement.h
@@ -0,0 +1,149 @@
+#ifndef CPPUNIT_TOOLS_XMLELEMENT_H
+#define CPPUNIT_TOOLS_XMLELEMENT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class XmlElement;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<XmlElement *>;
+#endif
+
+
+/*! \brief A XML Element.
+ * 
+ * A XML element has:
+ * - a name, specified on construction,
+ * - a content, specified on construction (may be empty),
+ * - zero or more attributes, added with addAttribute(),
+ * - zero or more child elements, added with addElement().
+ */
+class CPPUNIT_API XmlElement
+{
+public:
+  /*! \brief Constructs an element with the specified name and string content.
+   * \param elementName Name of the element. Must not be empty.
+   * \param content Content of the element.
+   */
+  XmlElement( std::string elementName,
+              std::string content ="" );
+
+  /*! \brief Constructs an element with the specified name and numeric content.
+   * \param elementName Name of the element. Must not be empty.
+   * \param numericContent Content of the element.
+   */
+  XmlElement( std::string elementName,
+              int numericContent );
+
+  /*! \brief Destructs the element and its child elements.
+   */
+  virtual ~XmlElement();
+
+  /*! \brief Returns the name of the element.
+   * \return Name of the element.
+   */
+  std::string name() const;
+
+  /*! \brief Returns the content of the element.
+   * \return Content of the element.
+   */
+  std::string content() const;
+
+  /*! \brief Sets the name of the element.
+   * \param name New name for the element.
+   */
+  void setName( const std::string &name );
+
+  /*! \brief Sets the content of the element.
+   * \param content New content for the element.
+   */
+  void setContent( const std::string &content );
+
+  /*! \overload void setContent( const std::string &content )
+   */
+  void setContent( int numericContent );
+
+  /*! \brief Adds an attribute with the specified string value.
+   * \param attributeName Name of the attribute. Must not be an empty.
+   * \param value Value of the attribute.
+   */
+  void addAttribute( std::string attributeName,
+                     std::string value );
+
+  /*! \brief Adds an attribute with the specified numeric value.
+   * \param attributeName Name of the attribute. Must not be empty.
+   * \param numericValue Numeric value of the attribute.
+   */
+  void addAttribute( std::string attributeName,
+                     int numericValue );
+
+  /*! \brief Adds a child element to the element.
+   * \param element Child element to add. Must not be \c NULL.
+   */
+  void addElement( XmlElement *element );
+
+  /*! \brief Returns the number of child elements.
+   * \return Number of child elements (element added with addElement()).
+   */
+  int elementCount() const;
+
+  /*! \brief Returns the child element at the specified index.
+   * \param index Zero based index of the element to return.
+   * \returns Element at the specified index. Never \c NULL.
+   * \exception std::invalid_argument if \a index < 0 or index >= elementCount().
+   */
+  XmlElement *elementAt( int index ) const;
+
+  /*! \brief Returns the first child element with the specified name.
+   * \param name Name of the child element to return.
+   * \return First child element found which is named \a name.
+   * \exception std::invalid_argument if there is no child element with the specified
+   *            name.
+   */
+  XmlElement *elementFor( const std::string &name ) const;
+
+  /*! \brief Returns a XML string that represents the element.
+   * \param indent String of spaces representing the amount of 'indent'.
+   * \return XML string that represents the element, its attributes and its
+   *         child elements.
+   */
+  std::string toString( const std::string &indent = "" ) const;
+
+private:
+  typedef std::pair<std::string,std::string> Attribute;
+
+  std::string attributesAsString() const;
+  std::string escape( std::string value ) const;
+
+private:
+  std::string m_name;
+  std::string m_content;
+
+  typedef CppUnitDeque<Attribute> Attributes;
+  Attributes m_attributes;
+
+  typedef CppUnitDeque<XmlElement *> Elements;
+  Elements m_elements;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_TOOLS_XMLELEMENT_H
diff --git a/src/test/cppunit/ui/Makefile.am b/src/test/cppunit/ui/Makefile.am
new file mode 100644
index 0000000..1b9f08e
--- /dev/null
+++ b/src/test/cppunit/ui/Makefile.am
@@ -0,0 +1 @@
+SUBDIRS = text mfc qt
diff --git a/src/test/cppunit/ui/Makefile.in b/src/test/cppunit/ui/Makefile.in
new file mode 100644
index 0000000..e8a9d59
--- /dev/null
+++ b/src/test/cppunit/ui/Makefile.in
@@ -0,0 +1,511 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/ui
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = text mfc qt
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/ui/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/ui/mfc/Makefile.am b/src/test/cppunit/ui/mfc/Makefile.am
new file mode 100644
index 0000000..1ea8b5e
--- /dev/null
+++ b/src/test/cppunit/ui/mfc/Makefile.am
@@ -0,0 +1,5 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/mfc
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  MfcTestRunner.h
diff --git a/src/test/cppunit/ui/mfc/Makefile.in b/src/test/cppunit/ui/mfc/Makefile.in
new file mode 100644
index 0000000..abe488a
--- /dev/null
+++ b/src/test/cppunit/ui/mfc/Makefile.in
@@ -0,0 +1,433 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/ui/mfc
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/ui/mfc
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  MfcTestRunner.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/ui/mfc/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/mfc/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/ui/mfc/MfcTestRunner.h b/src/test/cppunit/ui/mfc/MfcTestRunner.h
new file mode 100644
index 0000000..6a5f7b7
--- /dev/null
+++ b/src/test/cppunit/ui/mfc/MfcTestRunner.h
@@ -0,0 +1,76 @@
+#ifndef CPPUNITUI_MFC_MFCTESTRUNNER_H
+#define CPPUNITUI_MFC_MFCTESTRUNNER_H
+
+#if _MSC_VER >= 1000
+#pragma once
+#endif // _MSC_VER >= 1000
+
+#include <cppunit/Portability.h>
+#include <cppunit/portability/CppUnitVector.h>
+
+/* Refer to MSDN documentation to know how to write and use MFC extension DLL:
+   mk:@MSITStore:h:\DevStudio\MSDN\98VSa\1036\vcmfc.chm::/html/_mfcnotes_tn033.htm#_mfcnotes_how_to_write_an_mfc_extension_dll
+   
+   This can be found in the index with "mfc extension"
+   The basic:
+   Using:
+   - your application must use MFC DLL
+   - memory allocation is done using the same heap
+   - you must define the symbol _AFX_DLL
+
+   Building:
+   - you must define the symbol _AFX_DLL and _AFX_EXT
+   - export class using AFX_EXT_CLASS
+ */
+
+CPPUNIT_NS_BEGIN
+
+  class Test;
+  class TestSuite;
+
+
+/*! \brief MFC test runner.
+ * \ingroup ExecutingTest
+ *
+ * Use this to launch the MFC TestRunner. Usually called from you CWinApp subclass:
+ *
+ * \code
+ * #include <cppunit/ui/mfc/MfcTestRunner.h>
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ *
+ * void 
+ * CHostAppApp::RunUnitTests()
+ * {
+ *   CppUnit::MfcTestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );
+ *
+ *   runner.run();    
+ * }
+ * \endcode
+ * \see CppUnit::TextTestRunner, CppUnit::TestFactoryRegistry.
+ */
+class AFX_EXT_CLASS MfcTestRunner
+{
+public:
+  MfcTestRunner();
+  virtual ~MfcTestRunner();
+
+  void run();
+
+  void addTest( Test *test );
+
+  void addTests( const CppUnitVector<Test *> &tests );
+
+protected:
+  Test *getRootTest();
+
+  TestSuite *m_suite;
+
+  typedef CppUnitVector<Test *> Tests;
+  Tests m_tests;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNITUI_MFC_MFCTESTRUNNER_H
\ No newline at end of file
diff --git a/src/test/cppunit/ui/mfc/TestRunner.h b/src/test/cppunit/ui/mfc/TestRunner.h
new file mode 100644
index 0000000..c4d6aff
--- /dev/null
+++ b/src/test/cppunit/ui/mfc/TestRunner.h
@@ -0,0 +1,21 @@
+#ifndef CPPUNITUI_MFC_TESTRUNNER_H
+#define CPPUNITUI_MFC_TESTRUNNER_H
+
+#include <cppunit/ui/mfc/MfcTestRunner.h>
+
+CPPUNIT_NS_BEGIN
+
+#if defined(CPPUNIT_HAVE_NAMESPACES)
+namespace MfcUi
+{
+  /*! Mfc TestRunner (DEPRECATED).
+   * \deprecated Use CppUnit::MfcTestRunner instead.
+   */
+  typedef CPPUNIT_NS::MfcTestRunner TestRunner;
+}
+#endif // defined(CPPUNIT_HAVE_NAMESPACES)
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNITUI_MFC_TESTRUNNER_H
diff --git a/src/test/cppunit/ui/qt/Config.h b/src/test/cppunit/ui/qt/Config.h
new file mode 100644
index 0000000..beaf9ad
--- /dev/null
+++ b/src/test/cppunit/ui/qt/Config.h
@@ -0,0 +1,21 @@
+#ifndef CPPUNIT_QTUI_CONFIG_H
+#define CPPUNIT_QTUI_CONFIG_H
+
+/*! Macro to export symbol to DLL with VC++.
+ *
+ * - QTTESTRUNNER_DLL_BUILD must be defined when building the DLL.
+ * - QTTESTRUNNER_DLL must be defined if linking against the DLL.
+ * - If none of the above are defined then you are building or linking against
+ *   the static library.
+ */
+
+#if defined( QTTESTRUNNER_DLL_BUILD )
+#  define QTTESTRUNNER_API __declspec(dllexport)
+#elif defined ( QTTESTRUNNER_DLL )
+#  define QTTESTRUNNER_API __declspec(dllimport)
+#else
+#  define QTTESTRUNNER_API
+#endif
+
+
+#endif // CPPUNIT_QTUI_CONFIG_H
diff --git a/src/test/cppunit/ui/qt/Makefile.am b/src/test/cppunit/ui/qt/Makefile.am
new file mode 100644
index 0000000..7d4fb46
--- /dev/null
+++ b/src/test/cppunit/ui/qt/Makefile.am
@@ -0,0 +1,6 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/qt
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+	QtTestRunner.h \
+	Config.h
diff --git a/src/test/cppunit/ui/qt/Makefile.in b/src/test/cppunit/ui/qt/Makefile.in
new file mode 100644
index 0000000..1154d40
--- /dev/null
+++ b/src/test/cppunit/ui/qt/Makefile.in
@@ -0,0 +1,434 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/ui/qt
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/ui/qt
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+	QtTestRunner.h \
+	Config.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/ui/qt/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/qt/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/ui/qt/QtTestRunner.h b/src/test/cppunit/ui/qt/QtTestRunner.h
new file mode 100644
index 0000000..4b6ab4e
--- /dev/null
+++ b/src/test/cppunit/ui/qt/QtTestRunner.h
@@ -0,0 +1,85 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file TestRunner.h for class TestRunner
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/09/19
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_QTUI_QTTESTRUNNER_H
+#define CPPUNIT_QTUI_QTTESTRUNNER_H
+
+#include <cppunit/portability/CppUnitVector.h>
+#include "Config.h"
+
+CPPUNIT_NS_BEGIN
+
+
+  class Test;
+  class TestSuite;
+
+
+/*! 
+ * \brief QT test runner.
+ * \ingroup ExecutingTest
+ *
+ * Here is an example of usage:
+ * \code
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ * #include <cppunit/ui/qt/TestRunner.h>
+ *
+ * [...]
+ *
+ * void 
+ * QDepWindow::runTests()
+ * {
+ *   CppUnit::QtUi::TestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );
+ *   runner.run( true );
+ * }
+ * \endcode
+ *
+ */
+class QTTESTRUNNER_API QtTestRunner
+{
+public:
+  /*! Constructs a TestRunner object.
+   */
+  QtTestRunner();
+
+  /*! Destructor.
+   */
+  virtual ~QtTestRunner();
+
+  void run( bool autoRun =false );
+
+  void addTest( Test *test );
+
+private:
+  /// Prevents the use of the copy constructor.
+  QtTestRunner( const QtTestRunner &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const QtTestRunner &copy );
+
+  Test *getRootTest();
+
+private:
+  typedef CppUnitVector<Test *> Tests;
+  Tests *_tests;
+
+  TestSuite *_suite;
+};
+
+
+#if CPPUNIT_HAVE_NAMESPACES
+  namespace QtUi
+  {
+    /*! Qt TestRunner (DEPRECATED).
+     * \deprecated Use CppUnit::QtTestRunner instead.
+     */
+    typedef CPPUNIT_NS::QtTestRunner TestRunner;
+  }
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_QTUI_QTTESTRUNNER_H
diff --git a/src/test/cppunit/ui/qt/TestRunner.h b/src/test/cppunit/ui/qt/TestRunner.h
new file mode 100644
index 0000000..9c53e4b
--- /dev/null
+++ b/src/test/cppunit/ui/qt/TestRunner.h
@@ -0,0 +1,11 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file TestRunner.h for class TestRunner
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/09/19
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_QTUI_TESTRUNNER_H
+#define CPPUNIT_QTUI_TESTRUNNER_H
+
+#include <cppunit/ui/qt/QtTestRunner.h>
+
+#endif  // CPPUNIT_QTUI_TESTRUNNER_H
diff --git a/src/test/cppunit/ui/text/Makefile.am b/src/test/cppunit/ui/text/Makefile.am
new file mode 100644
index 0000000..5f01d81
--- /dev/null
+++ b/src/test/cppunit/ui/text/Makefile.am
@@ -0,0 +1,5 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/text
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  TextTestRunner.h
diff --git a/src/test/cppunit/ui/text/Makefile.in b/src/test/cppunit/ui/text/Makefile.in
new file mode 100644
index 0000000..db794f6
--- /dev/null
+++ b/src/test/cppunit/ui/text/Makefile.in
@@ -0,0 +1,433 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/ui/text
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/ui/text
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  TextTestRunner.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/ui/text/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/text/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/ui/text/TestRunner.h b/src/test/cppunit/ui/text/TestRunner.h
new file mode 100644
index 0000000..023eb83
--- /dev/null
+++ b/src/test/cppunit/ui/text/TestRunner.h
@@ -0,0 +1,24 @@
+#ifndef CPPUNIT_UI_TEXT_TESTRUNNER_H
+#define CPPUNIT_UI_TEXT_TESTRUNNER_H
+
+#include <cppunit/ui/text/TextTestRunner.h>
+
+
+#if defined(CPPUNIT_HAVE_NAMESPACES)
+
+CPPUNIT_NS_BEGIN
+namespace TextUi
+{
+
+  /*! Text TestRunner (DEPRECATED).
+   * \deprecated Use TextTestRunner instead.
+   */
+  typedef TextTestRunner TestRunner;
+
+}
+CPPUNIT_NS_END
+
+#endif // defined(CPPUNIT_HAVE_NAMESPACES)
+
+
+#endif  // CPPUNIT_UI_TEXT_TESTRUNNER_H
diff --git a/src/test/cppunit/ui/text/TextTestRunner.h b/src/test/cppunit/ui/text/TextTestRunner.h
new file mode 100644
index 0000000..86da4d4
--- /dev/null
+++ b/src/test/cppunit/ui/text/TextTestRunner.h
@@ -0,0 +1,97 @@
+#ifndef CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H
+#define CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H
+
+
+#include <cppunit/Portability.h>
+#include <string>
+#include <cppunit/TestRunner.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Outputter;
+class Test;
+class TestSuite;
+class TextOutputter;
+class TestResult;
+class TestResultCollector;
+
+
+
+/*!
+ * \brief A text mode test runner.
+ * \ingroup WritingTestResult
+ * \ingroup ExecutingTest
+ *
+ * The test runner manage the life cycle of the added tests.
+ *
+ * The test runner can run only one of the added tests or all the tests. 
+ *
+ * TestRunner prints out a trace as the tests are executed followed by a
+ * summary at the end. The trace and summary print are optional.
+ *
+ * Here is an example of use:
+ *
+ * \code
+ * CppUnit::TextTestRunner runner;
+ * runner.addTest( ExampleTestCase::suite() );
+ * runner.run( "", true );    // Run all tests and wait
+ * \endcode
+ *
+ * The trace is printed using a TextTestProgressListener. The summary is printed
+ * using a TextOutputter. 
+ *
+ * You can specify an alternate Outputter at construction
+ * or later with setOutputter(). 
+ *
+ * After construction, you can register additional TestListener to eventManager(),
+ * for a custom progress trace, for example.
+ *
+ * \code
+ * CppUnit::TextTestRunner runner;
+ * runner.addTest( ExampleTestCase::suite() );
+ * runner.setOutputter( CppUnit::CompilerOutputter::defaultOutputter( 
+ *                          &runner.result(),
+ *                          std::cerr ) );
+ * MyCustomProgressTestListener progress;
+ * runner.eventManager().addListener( &progress );
+ * runner.run( "", true );    // Run all tests and wait
+ * \endcode
+ *
+ * \see CompilerOutputter, XmlOutputter, TextOutputter.
+ */
+class CPPUNIT_API TextTestRunner : public CPPUNIT_NS::TestRunner
+{
+public:
+  TextTestRunner( Outputter *outputter =NULL );
+
+  virtual ~TextTestRunner();
+
+  bool run( std::string testPath ="",
+            bool doWait = false,
+            bool doPrintResult = true,
+            bool doPrintProgress = true );
+
+  void setOutputter( Outputter *outputter );
+
+  TestResultCollector &result() const;
+
+  TestResult &eventManager() const;
+
+public: // overridden from TestRunner (to avoid hidden virtual function warning)
+  virtual void run( TestResult &controller,
+                    const std::string &testPath = "" );
+
+protected:
+  virtual void wait( bool doWait );
+  virtual void printResult( bool doPrintResult );
+
+  TestResultCollector *m_result;
+  TestResult *m_eventManager;
+  Outputter *m_outputter;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H
diff --git a/src/test/efficiency/AbstractEfficiencyTestCase.h b/src/test/efficiency/AbstractEfficiencyTestCase.h
new file mode 100644
index 0000000..b1554d3
--- /dev/null
+++ b/src/test/efficiency/AbstractEfficiencyTestCase.h
@@ -0,0 +1,40 @@
+#pragma once
+
+#include "../EngineTestBase.h"
+#include "EfficiencyActionExecutionListener.h"
+
+using namespace std;
+
+namespace ai
+{
+    class AbstractEfficiencyTestCase : public EngineTestBase
+    {
+    public:
+        void setUp()
+        {
+            EngineTestBase::setUp();
+        }
+
+    protected:
+        void refresh(map<string, SpellInfo> spellInfo)
+        {
+            for (map<string, SpellInfo>::iterator i = spellInfo.begin(); i != spellInfo.end(); ++i)
+            {
+                spellAvailable(i->first);
+            }
+        }
+
+        void run(map<string, SpellInfo> spellInfo, double mana)
+        {
+            EfficiencyActionExecutionListener* listener = new EfficiencyActionExecutionListener(ai, spellInfo, mana);
+            engine->AddActionExecutionListener(listener);
+            while (listener->CanContinue())
+            {
+                tick();
+                refresh(spellInfo);
+            }
+            listener->Report();
+        }
+    };
+
+}
diff --git a/src/test/efficiency/DruidEfficiencyTestCase.cpp b/src/test/efficiency/DruidEfficiencyTestCase.cpp
new file mode 100644
index 0000000..9a096f0
--- /dev/null
+++ b/src/test/efficiency/DruidEfficiencyTestCase.cpp
@@ -0,0 +1,39 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/Druid/DruidAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class DruidEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+
+CPPUNIT_TEST_SUITE( DruidEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_caster );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["entangling roots"] = SpellInfo(23, 1.5, 15, 50);
+        spellInfo["faerie fire"] = SpellInfo(26, 0, 0, 0);
+        spellInfo["hibernate"] = SpellInfo(23, 1.5, 0, 0);
+        spellInfo["moonfire"] = SpellInfo(69, 0, 12, 28 + 52);
+        spellInfo["wrath"] = SpellInfo(36, 2, 0, 53);
+        return spellInfo;
+    }
+
+ 	void lvl19_caster()
+	{
+        setupEngine(new DruidAiObjectContext(ai), "caster", "aoe", NULL);
+        addTargetAura("faerie fire");
+        run(lvl19(), 600);
+	}
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DruidEfficiencyTestCase );
diff --git a/src/test/efficiency/EfficiencyActionExecutionListener.cpp b/src/test/efficiency/EfficiencyActionExecutionListener.cpp
new file mode 100644
index 0000000..9b3c3f2
--- /dev/null
+++ b/src/test/efficiency/EfficiencyActionExecutionListener.cpp
@@ -0,0 +1,88 @@
+#include "pch.h"
+#include "../aitest.h"
+#include "../EngineTestBase.h"
+#include "../MockedTargets.h"
+#include "../AiObjectContextWrapper.h"
+#include "EfficiencyActionExecutionListener.h"
+
+
+EfficiencyActionExecutionListener::EfficiencyActionExecutionListener(MockPlayerbotAIBase *ai, map<string, SpellInfo> spellInfo, double mana) :
+    ai(ai), spellInfo(spellInfo), mana(mana), castTime(0), damage(0), fullMana(mana), log("")
+{
+}
+
+bool EfficiencyActionExecutionListener::Before(Action* action, Event event)
+{
+    return true;
+}
+
+bool EfficiencyActionExecutionListener::AllowExecution(Action* action, Event event)
+{
+    return false;
+}
+
+bool EfficiencyActionExecutionListener::OverrideResult(Action* action, bool executed, Event event)
+{
+    if (!executed)
+        return false;
+
+    string name = action->getName();
+    if (!spellInfo.count(name))
+        return false;
+
+    SpellInfo spell = spellInfo[name];
+
+    string sharedCooldown = spell.sharedCooldown.empty() ? name : spell.sharedCooldown;
+    if (cooldown.count(sharedCooldown) && cooldown[sharedCooldown] > 0)
+        return false;
+
+    if (mana < spell.mana)
+        return false;
+
+    return true;
+}
+
+void EfficiencyActionExecutionListener::After(Action* action, bool executed, Event event)
+{
+    string name = action->getName();
+    if (!spellInfo.count(name))
+        return;
+
+    SpellInfo spell = spellInfo[name];
+
+    double elapsed = max(executed ? 1.5 : 0.1, spell.castTime);
+    for (map<string, double>::iterator i = cooldown.begin(); i != cooldown.end(); ++i)
+    {
+        int value = i->second - elapsed;
+        string sharedCooldown = spell.sharedCooldown.empty() ? i->first : spell.sharedCooldown;
+        cooldown[sharedCooldown] = value > 0 ? value : 0;
+    }
+
+    castTime += elapsed;
+
+    if (!executed)
+        return;
+
+    mana -= spell.mana;
+    string sharedCooldown = spell.sharedCooldown.empty() ? name : spell.sharedCooldown;
+    cooldown[sharedCooldown] = spell.cooldown;
+    damage += spell.damage;
+    if (!log.empty())
+        log += ",";
+    log += name;
+}
+
+void EfficiencyActionExecutionListener::Report()
+{
+    cout << endl << log << endl <<
+            "Time: " << castTime << endl <<
+            "Damage: " << damage << endl <<
+            "Mana: " << mana << endl;
+    if (damage > 0 && castTime > 0)
+        cout << "DPS: " << damage / castTime << endl;
+}
+
+bool EfficiencyActionExecutionListener::CanContinue()
+{
+    return castTime < 60 && mana > fullMana / 10;
+}
diff --git a/src/test/efficiency/EfficiencyActionExecutionListener.h b/src/test/efficiency/EfficiencyActionExecutionListener.h
new file mode 100644
index 0000000..f4076d8
--- /dev/null
+++ b/src/test/efficiency/EfficiencyActionExecutionListener.h
@@ -0,0 +1,52 @@
+#pragma once
+
+#include "../../plugins/playerbot/strategy/Action.h"
+#include "../../plugins/playerbot/strategy/ActionBasket.h"
+#include "../../plugins/playerbot/strategy/Queue.h"
+#include "../../plugins/playerbot/strategy/Trigger.h"
+#include "../../plugins/playerbot/strategy/Engine.h"
+
+#include "../MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class SpellInfo
+{
+public:
+    SpellInfo() : mana(0), castTime(0), cooldown(0), damage(0) {}
+    SpellInfo(double mana, double castTime, double cooldown, double damage, string sharedCooldown = "") :
+        mana(mana), castTime(castTime), cooldown(cooldown), damage(damage), sharedCooldown(sharedCooldown) {}
+    SpellInfo(SpellInfo const& other)
+    {
+        mana = other.mana;
+        castTime = other.castTime;
+        cooldown = other.cooldown;
+        damage = other.damage;
+        sharedCooldown = other.sharedCooldown;
+    }
+    virtual ~SpellInfo() {}
+
+    double mana, castTime, cooldown, damage;
+    string sharedCooldown;
+};
+
+class EfficiencyActionExecutionListener : public ActionExecutionListener
+{
+public:
+    EfficiencyActionExecutionListener(MockPlayerbotAIBase *ai, map<string, SpellInfo> spellInfo, double mana);
+
+    virtual bool Before(Action* action, Event event);
+    virtual bool AllowExecution(Action* action, Event event);
+    virtual bool OverrideResult(Action* action, bool executed, Event event);
+    virtual void After(Action* action, bool executed, Event event);
+    void Report();
+    bool CanContinue();
+
+private:
+    map<string, SpellInfo> spellInfo;
+    map<string, double> cooldown;
+    double mana, castTime, damage, fullMana;
+    MockPlayerbotAIBase *ai;
+    string log;
+};
+
diff --git a/src/test/efficiency/MageEfficiencyTestCase.cpp b/src/test/efficiency/MageEfficiencyTestCase.cpp
new file mode 100644
index 0000000..7de662d
--- /dev/null
+++ b/src/test/efficiency/MageEfficiencyTestCase.cpp
@@ -0,0 +1,55 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class MageEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+  CPPUNIT_TEST_SUITE( MageEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_frost );
+  CPPUNIT_TEST( lvl19_fire );
+  CPPUNIT_TEST( lvl19_arcane );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["frostbolt"] = SpellInfo(27, 2, 0, 54);
+        spellInfo["frost nova"] = SpellInfo(24, 0, 25, 20);
+        spellInfo["arcane explosion"] = SpellInfo(67, 0, 0, 33);
+        spellInfo["arcane missiles"] = SpellInfo(106, 4, 0, 36 * 4);
+        spellInfo["polymorph"] = SpellInfo(24, 1.5, 0, 0);
+        spellInfo["remove curse"] = SpellInfo(27, 0, 0, 0);
+        spellInfo["fire blast"] = SpellInfo(72, 0, 8, 64);
+        spellInfo["fireball"] = SpellInfo(54, 3, 0, 100);
+        spellInfo["flamestrike"] = SpellInfo(120, 2, 0, 60);
+        return spellInfo;
+    }
+
+ 	void lvl19_frost()
+	{
+        setupEngine(new MageAiObjectContext(ai), "frost", NULL);
+        run(lvl19(), 888);
+	}
+
+ 	void lvl19_fire()
+	{
+        setupEngine(new MageAiObjectContext(ai), "fire", NULL);
+        run(lvl19(), 888);
+	}
+
+ 	void lvl19_arcane()
+	{
+        setupEngine(new MageAiObjectContext(ai), "arcane", NULL);
+        run(lvl19(), 888);
+	}
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( MageEfficiencyTestCase );
diff --git a/src/test/efficiency/PriestEfficiencyTestCase.cpp b/src/test/efficiency/PriestEfficiencyTestCase.cpp
new file mode 100644
index 0000000..5331b28
--- /dev/null
+++ b/src/test/efficiency/PriestEfficiencyTestCase.cpp
@@ -0,0 +1,43 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/Priest/PriestAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class PriestEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+
+CPPUNIT_TEST_SUITE( PriestEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_shadow );
+  CPPUNIT_TEST( lvl19_holy );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["mind blast"] = SpellInfo(62, 1.5, 8, 74);
+        spellInfo["shadow word: pain"] = SpellInfo(80, 0, 18, 120);
+        spellInfo["smite"] = SpellInfo(54, 2.5, 0, 58);
+        spellInfo["shoot"] = SpellInfo(0, 0, 1, 15);
+        return spellInfo;
+    }
+
+ 	void lvl19_shadow()
+	{
+        setupEngine(new PriestAiObjectContext(ai), "shadow", "aoe", NULL);
+        run(lvl19(), 777);
+	}
+
+ 	void lvl19_holy()
+	{
+        setupEngine(new PriestAiObjectContext(ai), "holy", "aoe", NULL);
+        run(lvl19(), 777);
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( PriestEfficiencyTestCase );
diff --git a/src/test/efficiency/ShamanEfficiencyTestCase.cpp b/src/test/efficiency/ShamanEfficiencyTestCase.cpp
new file mode 100644
index 0000000..b9a8ff1
--- /dev/null
+++ b/src/test/efficiency/ShamanEfficiencyTestCase.cpp
@@ -0,0 +1,46 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class ShamanEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+  CPPUNIT_TEST_SUITE( ShamanEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_melee );
+  CPPUNIT_TEST( lvl19_caster );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["earth shock"] = SpellInfo(62, 0, 6, 62, "shock");
+        spellInfo["flame shock"] = SpellInfo(58, 0, 18, 45 + 72, "shock");
+        spellInfo["lightning bolt"] = SpellInfo(34, 2.5, 0, 49);
+        spellInfo["lightning shield"] = SpellInfo(0, 0, 0, 0);
+        spellInfo["searing totem"] = SpellInfo(24, 0, 30, 10 * 30 / 1.5);
+        spellInfo["fire nova"] = SpellInfo(75, 0, 6, 52);
+        spellInfo["melee"] = SpellInfo(0, 0, 1, 15 + 6);
+        return spellInfo;
+    }
+
+ 	void lvl19_melee()
+	{
+        setupEngine(new ShamanAiObjectContext(ai), "melee", "melee aoe", NULL);
+        run(lvl19(), 600);
+	}
+
+ 	void lvl19_caster()
+	{
+        setupEngine(new ShamanAiObjectContext(ai), "caster", "caster aoe", NULL);
+        run(lvl19(), 600);
+	}
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ShamanEfficiencyTestCase );
diff --git a/src/test/efficiency/WarlockEfficiencyTestCase.cpp b/src/test/efficiency/WarlockEfficiencyTestCase.cpp
new file mode 100644
index 0000000..790e249
--- /dev/null
+++ b/src/test/efficiency/WarlockEfficiencyTestCase.cpp
@@ -0,0 +1,43 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/Warlock/WarlockAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class WarlockEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+  CPPUNIT_TEST_SUITE( WarlockEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_dps );
+  CPPUNIT_TEST( lvl19_tank );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["corruption"] = SpellInfo(42, 0, 15, 90);
+        spellInfo["immolate"] = SpellInfo(60, 0, 15, 19 + 40);
+        spellInfo["shadow bolt"] = SpellInfo(58, 2.8, 0, 52);
+        spellInfo["curse of agony"] = SpellInfo(35, 0, 24, 180);
+        spellInfo["shoot"] = SpellInfo(0, 0, 1, 15);
+        return spellInfo;
+    }
+
+ 	void lvl19_dps()
+	{
+        setupEngine(new WarlockAiObjectContext(ai), "dps", "aoe", NULL);
+        run(lvl19(), 888);
+	}
+
+ 	void lvl19_tank()
+	{
+        setupEngine(new WarlockAiObjectContext(ai), "tank", "aoe", NULL);
+        run(lvl19(), 888);
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( WarlockEfficiencyTestCase );
diff --git a/src/test/main.cpp b/src/test/main.cpp
new file mode 100644
index 0000000..5450142
--- /dev/null
+++ b/src/test/main.cpp
@@ -0,0 +1,98 @@
+#include "pch.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
+#include "../../plugins/ahbot/AhBot.h"
+
+WorldDatabaseWorkerPool WorldDatabase;                      ///< Accessor to the world database
+CharacterDatabaseWorkerPool CharacterDatabase;              ///< Accessor to the character database
+LoginDatabaseWorkerPool LoginDatabase;                      ///< Accessor to the realm/login database
+uint32 realmID;                                             ///< Id of the realm
+
+int main(int argc, char* argv[])
+{
+
+    /*std::string configError;
+    if (!sConfigMgr->LoadInitial("worldserver.conf", configError))
+    {
+        printf("Error in config file: %s\n", configError.c_str());
+        return 1;
+    }
+
+    MySQL::Library_Init();
+
+    WorldDatabase.SetConnectionInfo(sConfigMgr->GetStringDefault("WorldDatabaseInfo", ""), 1, 1);
+    if (!WorldDatabase.Open())
+    {
+        printf("Cannot connect to world database");
+        return false;
+    }
+    CharacterDatabase.SetConnectionInfo(sConfigMgr->GetStringDefault("CharacterDatabaseInfo", ""), 1, 1);
+    if (!CharacterDatabase.Open())
+    {
+        printf("Cannot connect to Character database");
+        return false;
+    }
+    LoginDatabase.SetConnectionInfo(sConfigMgr->GetStringDefault("LoginDatabaseInfo", ""), 1, 1);
+    if (!LoginDatabase.Open())
+    {
+        printf("Cannot connect to Login database");
+        return false;
+    }
+
+    //sWorld->SetInitialWorldSettings();
+    std::string dataPath = sConfigMgr->GetStringDefault("DataDir", "./");
+    if (dataPath.empty() || (dataPath.at(dataPath.length()-1) != '/' && dataPath.at(dataPath.length()-1) != '\\'))
+        dataPath.push_back('/');
+
+    ///- Load the DBC files
+     TC_LOG_INFO("server.loading", "Initialize data stores...");
+     LoadDBCStores(dataPath);
+
+     auctionbot.Init();
+*/
+
+    //sPlayerbotAIConfig.Initialize();
+    sPlayerbotAIConfig.enabled = true;
+    sPlayerbotAIConfig.globalCoolDown = 1000;
+    sPlayerbotAIConfig.reactDelay = 100;
+    sPlayerbotAIConfig.sightDistance = 40.0f;
+    sPlayerbotAIConfig.spellDistance = 25.0f;
+    sPlayerbotAIConfig.reactDistance = 100.0f;
+    sPlayerbotAIConfig.grindDistance = 50.0f;
+    sPlayerbotAIConfig.meleeDistance = ATTACK_DISTANCE;
+    sPlayerbotAIConfig.followDistance = ATTACK_DISTANCE;
+    sPlayerbotAIConfig.tooCloseDistance = ATTACK_DISTANCE;
+    sPlayerbotAIConfig.contactDistance = CONTACT_DISTANCE;
+    sPlayerbotAIConfig.lootDistance = 20.0f;
+    sPlayerbotAIConfig.criticalHealth = 25;
+    sPlayerbotAIConfig.lowHealth = 40;
+    sPlayerbotAIConfig.mediumHealth = 60;
+    sPlayerbotAIConfig.almostFullHealth = 80;
+    sPlayerbotAIConfig.lowMana = 40;
+    sPlayerbotAIConfig.mediumMana = 60;
+    sPlayerbotAIConfig.iterationsPerTick = 10;
+    sPlayerbotAIConfig.randomChangeMultiplier = 1;
+
+    // Create the event manager and test controller
+    CPPUNIT_NS::TestResult controller;
+
+    // Add a listener that colllects test result
+    CPPUNIT_NS::TestResultCollector result;
+    controller.addListener( &result );
+
+    // Add a listener that print dots as test run.
+    CPPUNIT_NS::BriefTestProgressListener progress;
+    controller.addListener( &progress );
+
+    // Add the top suite to the test runner
+    CPPUNIT_NS::TestRunner runner;
+
+    runner.addTest( CPPUNIT_NS::TestFactoryRegistry::getRegistry().makeTest() );
+    runner.run( controller, argc > 1 ? argv[1] : "" );
+
+    // Print test in a compiler compatible format.
+    CPPUNIT_NS::CompilerOutputter outputter( &result, CPPUNIT_NS::stdCOut() );
+    outputter.write();
+
+    cout.flush();
+    return result.wasSuccessful() ? 0 : 1;
+}
diff --git a/src/test/pch.cpp b/src/test/pch.cpp
new file mode 100644
index 0000000..1d9f38c
--- /dev/null
+++ b/src/test/pch.cpp
@@ -0,0 +1 @@
+#include "pch.h"
diff --git a/src/test/pch.h b/src/test/pch.h
new file mode 100644
index 0000000..dff60eb
--- /dev/null
+++ b/src/test/pch.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../server/game/Miscellaneous/Language.h"
+#include "../common/Logging/Log.h"
+#include "../server/game/World/World.h"
+#include "../server/game/Globals/ObjectMgr.h"
+#include "../server/game/Server/WorldSession.h"
+#include "../common/Configuration/Config.h"
+#include "../common/Utilities/Util.h"
+#include "../server/game/Accounts/AccountMgr.h"
+#include "../server/worldserver/CommandLine/CliRunnable.h"
+#include "../server/game/Maps/MapManager.h"
+#include "../server/game/Entities/Player/Player.h"
+#include "../server/game/Chat/Chat.h"
+#include "../server/database/Database/DatabaseEnv.h"
+#include <openssl/opensslv.h>
+#include <openssl/crypto.h>
+
+#include <cppunit/BriefTestProgressListener.h>
+#include <cppunit/CompilerOutputter.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/TestRunner.h>
+#include <cppunit/extensions/HelperMacros.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/TestPath.h>
+#include <stdexcept>
+
+#include <stdio.h>
+#include <iostream>
+
+#include <list>
+#include "../common/Define.h"
+
+#include <stdexcept>
+
+#include "../../plugins/playerbot/playerbotDefs.h"
-- 
2.1.4

